import { r as registerInstance, h, H as Host, g as getElement } from './index-04c470ea.js';
import { a as assert } from './assert-7fc7463a.js';
import { D as DateUtils } from './date.utils-73541332.js';
import { E as ElementIdGenerator } from './element-id-handling-bb37154e.js';
import { a as isActiveElement } from './misc-util-d3b69f2c.js';
import { o as onNextFrame } from './render-util-1dee6655.js';
import { S as SlotObserver } from './slot-observer-9196738e.js';
import { D as DateErrorType } from './date-daafccec.js';
import { e as extractDateRange } from './date-range.util-c742055e.js';
import './value-store-f4663db1.js';
import './query-util-02753b43.js';

const dxDateRangeCss = ":host{display:block}:host:host([hidden]){display:none !important}:host .date-container{display:flex;align-items:baseline;gap:24px;flex-direction:column;align-items:stretch}@media (min-width: 476px){:host .date-container{flex-direction:row}}:host .date-container .date-input-container{flex:1}:host .date-container .date-input-container:first-child{position:relative}@media (min-width: 476px){:host .date-container .date-input-container ::slotted(*[slot=from]):after{font-family:DVAG-Type, sans-serif;content:\"-\";display:flex;top:0;right:-24px;width:24px;height:100%;align-items:center;justify-content:center;position:absolute}}:host .date-container .date-input-container ::slotted(*[label]):after{top:12px}";

const DxDateRange = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.errors = {
      from: DateErrorType.NO_ERROR,
      to: DateErrorType.NO_ERROR,
    };
    this.currentlyFocused = false;
    this.internalErrorMessage = "";
    /**
     * Defines how a date range can be selected or edited.
     *
     * @value "day-month-year": The user can select a specific date range.
     * The calendar shows all three views (month, year and decade) for selecting a date range.
     * @value "month-year": The user can select a month range.
     * The calendar shows two views (year and decade) for selecting a month range.
     * @value "day-month": The user can select two possible dates within a year.
     * The calendar shows two views (month and year) for selecting a date range.
     */
    this.mode = "day-month-year";
    /**
     * The current displayed date range.
     *
     * @important
     * @value string: Two comma seperated dates in following format: YYYY-MM-dd (e.g.: 2021-01-01,2021-12-31)
     * @example value
     */
    this.value = null;
    this.onFocus = () => (this.currentlyFocused = true);
    this.onBlur = () => this.handleBlur();
    this.onError = (e) => this.handleError(e);
    this.onDateValueChange = (e) => this.handleDateValueChange(e);
  }
  onValueChange() {
    const range = extractDateRange(this.value);
    this.selectRange(range);
  }
  connectedCallback() {
    this.slotObserver = new SlotObserver(this.self, "dx-date-input", (dateInputs) => {
      assert(dateInputs.length === 2, () => "You have to define exactly two dx-date-inputs within this component");
      const rangeFromDateInputs = {
        from: null,
        to: null,
      };
      dateInputs.forEach((dateInput) => {
        dateInput.removeEventListener("focus", this.onFocus);
        dateInput.addEventListener("focus", this.onFocus);
        dateInput.removeEventListener("blur", this.onBlur);
        dateInput.addEventListener("blur", this.onBlur);
        dateInput.removeEventListener("errorFound", this.onError);
        dateInput.addEventListener("errorFound", this.onError);
        dateInput.removeEventListener("valueChange", this.onDateValueChange);
        dateInput.addEventListener("valueChange", this.onDateValueChange);
        // Override date-input properties
        dateInput.min = this.min;
        dateInput.max = this.max;
        dateInput.mode = this.mode;
        // Show custom calendar for date-range and disable calendars of inner date inputs
        dateInput.calendarenabled = false;
        rangeFromDateInputs[dateInput.slot] = DateUtils.stringToDate(dateInput.value);
      });
      if (this.value != null) {
        this.selectRange(extractDateRange(this.value));
      }
      else {
        this.selectRange(rangeFromDateInputs);
      }
    });
  }
  componentDidLoad() {
    this.updateCalendarValue();
  }
  disconnectedCallback() {
    this.slotObserver.disconnect();
  }
  onSegmentBlurred() {
    this.updateCalendarValue();
  }
  /**
   * Sets the focus on the first date input element.
   */
  async focusControl() {
    var _a;
    (_a = this.self.querySelector("dx-date-input")) === null || _a === void 0 ? void 0 : _a.focusControl();
  }
  handleBlur() {
    onNextFrame(() => {
      const loseFocus = !isActiveElement(this.self) &&
        // Check if any inner dx-date-input elements have focus
        !Array.from(this.self.querySelectorAll("dx-date-input[slot]")).some((elem) => isActiveElement(elem));
      if (loseFocus) {
        this.currentlyFocused = false;
      }
    });
  }
  handleError(e) {
    const error = e.detail;
    const slot = e.target.slot;
    this.errors[slot] = error.type;
    const errorType = this.errors.from !== DateErrorType.NO_ERROR
      ? this.errors.from
      : this.errors.to;
    // Record makes this type-safe. If a new DateError appears, the compiler will complain here.
    const errorToMessageMap = {
      [DateErrorType.INVALID_DATE]: () => "Invalides Datum gefunden!",
      [DateErrorType.UNDER_MIN]: () => `Die eingegeben Daten müssen nach dem ${DateUtils.getFormattedDisplayDate(this.min)} liegen.`,
      [DateErrorType.OVER_MAX]: () => `Die eingegeben Daten müssen vor dem ${DateUtils.getFormattedDisplayDate(this.max)} liegen.`,
      [DateErrorType.NO_ERROR]: () => "",
    };
    this.internalErrorMessage = errorToMessageMap[errorType]();
  }
  handleDateValueChange(e) {
    const dateInput = e.target;
    if (!dateInput.slot) {
      return;
    }
    const range = extractDateRange(this.value);
    // Slot == from or to. So we set from or to property dependant of slot
    range[dateInput.slot] = e.detail ? new Date(e.detail) : null;
    this.selectRange(range);
  }
  getDateInputs() {
    return Array.from(this.self.querySelectorAll("dx-date-input"));
  }
  selectRange(range, source = "other") {
    // TODO: ... Check for range validity with min and max
    var _a, _b;
    this.value = `${(_a = DateUtils.dateToString(range.from)) !== null && _a !== void 0 ? _a : ""},${(_b = DateUtils.dateToString(range.to)) !== null && _b !== void 0 ? _b : ""}`;
    const dateInputs = this.getDateInputs();
    if (dateInputs[0]) {
      dateInputs[0].value = DateUtils.dateToString(range.from);
      if (source === "calendar-widget") {
        dateInputs[0].internalForceEmitChangeEvent();
      }
    }
    if (dateInputs[1]) {
      dateInputs[1].value = DateUtils.dateToString(range.to);
      if (source === "calendar-widget") {
        dateInputs[1].internalForceEmitChangeEvent();
      }
    }
  }
  updateCalendarValue() {
    if (this.calendar != null) {
      this.calendar.value = this.value;
    }
  }
  setCalendar(calendar) {
    if (this.calendar !== calendar) {
      this.calendar = calendar;
      this.updateCalendarValue();
    }
  }
  renderCalendar() {
    return (h("dx-calendar", { slot: "overlay", id: ElementIdGenerator.createId(this.self, "calendar"), ref: (ref) => this.setCalendar(ref), tabindex: -1, errormessage: this.internalErrorMessage, rangeenabled: true, onBlur: () => {
        this.onBlur();
      }, min: this.min, max: this.max, onRangeSelected: (e) => {
        this.selectRange(e.detail, "calendar-widget");
      }, mode: this.mode }));
  }
  render() {
    return (h(Host, null, h("dx-flyout", { open: this.currentlyFocused, offsety: 4 }, h("div", { class: "date-container" }, h("div", { class: "date-input-container" }, h("slot", { name: "from" })), h("div", { class: "date-input-container" }, h("slot", { name: "to" }))), this.renderCalendar())));
  }
  get self() { return getElement(this); }
  static get watchers() { return {
    "value": ["onValueChange"]
  }; }
};
DxDateRange.style = dxDateRangeCss;

export { DxDateRange as dx_date_range };
