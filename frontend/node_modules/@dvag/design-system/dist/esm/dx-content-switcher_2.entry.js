import { r as registerInstance, c as createEvent, w as writeTask, h, H as Host, g as getElement } from './index-04c470ea.js';
import { S as SlotObserver } from './slot-observer-9196738e.js';
import { c as sameArrayInOrder } from './misc-util-d3b69f2c.js';
import { o as onNextFrame } from './render-util-1dee6655.js';
import './query-util-02753b43.js';

const dxContentSwitcherCss = ":host{display:flex;position:relative;height:100%;max-width:100%;overflow:hidden}:host:host([hidden]){display:none !important}";

const DxContentSwitcher = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.valueChange = createEvent(this, "valueChange", 7);
    this.skipAnimation = false;
  }
  onValueChange() {
    var _a, _b;
    const currentVisibleItemIndex = this.getCurrentVisibleItemIndex();
    const lastVisibleItemIndex = (_a = this.contentChildren) === null || _a === void 0 ? void 0 : _a.findIndex((child) => child.visible);
    (_b = this.contentChildren) === null || _b === void 0 ? void 0 : _b.forEach((element, index) => {
      element.animatable = !this.skipAnimation;
      if (index === currentVisibleItemIndex) {
        this.setVisible(element, index, lastVisibleItemIndex);
      }
      else {
        this.setInvisible(element, index, currentVisibleItemIndex);
      }
    });
    this.skipAnimation = false;
  }
  connectedCallback() {
    this.slotObserver = new SlotObserver(this.self, ":scope > dx-content-switcher-item", (nodes) => {
      if (sameArrayInOrder(nodes, this.contentChildren)) {
        return;
      }
      this.contentChildren = nodes;
      this.initializeValue();
      this.prepareContentChildren();
    });
    this.resizeObserver = new ResizeObserver((entries) => {
      this.currentWidth = entries[0].contentRect.width;
    });
    this.resizeObserver.observe(this.self);
  }
  disconnectedCallback() {
    var _a;
    (_a = this.slotObserver) === null || _a === void 0 ? void 0 : _a.disconnect();
    this.resizeObserver.disconnect();
  }
  getCurrentVisibleItemIndex() {
    var _a;
    return (_a = this.contentChildren) === null || _a === void 0 ? void 0 : _a.findIndex((child) => child.value === this.value);
  }
  initializeValue() {
    var _a, _b;
    const contentWithCurrentValue = (_a = this.contentChildren) === null || _a === void 0 ? void 0 : _a.find((child) => child.value === this.value);
    if (contentWithCurrentValue != null) {
      this.value = (_b = this.contentChildren[0]) === null || _b === void 0 ? void 0 : _b.value;
    }
  }
  prepareContentChildren() {
    var _a;
    const currentVisibleItemIndex = (_a = this.contentChildren) === null || _a === void 0 ? void 0 : _a.findIndex((child) => child.value === this.value);
    writeTask(() => {
      this.contentChildren.forEach((element, index) => {
        element.animatable = false;
        if (index === currentVisibleItemIndex) {
          this.setVisible(element, index, -1);
        }
        else {
          element.style.setProperty("visibility", "hidden");
          this.setInvisible(element, index, currentVisibleItemIndex);
        }
      });
    });
  }
  async showValue(value, animate = true) {
    if (value != null && this.value !== value) {
      this.skipAnimation = !animate;
      this.value = value;
      this.valueChange.emit(this.value);
    }
  }
  render() {
    var _a;
    return (h(Host, { style: {
        "--dx-content-switcher-width": `${(_a = this.currentWidth) !== null && _a !== void 0 ? _a : 0}px`,
      } }, h("slot", null)));
  }
  setVisible(element, index, currentVisibleIndex) {
    if (index === this.contentChildren.length - 1) {
      element.visible = true;
    }
    else if (index === 0) {
      element.visible = true;
      element.reverse = true;
    }
    else {
      element.visible = true;
      element.reverse = index < currentVisibleIndex;
    }
  }
  setInvisible(element, index, currentVisibleIndex) {
    if (index === this.contentChildren.length - 1) {
      element.visible = false;
    }
    else if (index === 0) {
      element.visible = false;
      element.reverse = true;
    }
    else {
      element.visible = false;
      element.reverse = index < currentVisibleIndex;
    }
  }
  get self() { return getElement(this); }
  static get watchers() { return {
    "value": ["onValueChange"]
  }; }
};
DxContentSwitcher.style = dxContentSwitcherCss;

const dxContentSwitcherItemCss = ".sc-dx-content-switcher-item-h{display:flex;flex:0 0 0;opacity:0;overflow:hidden}.sc-dx-content-switcher-item-h([hidden]).sc-dx-content-switcher-item-h{display:none !important}.animatable.sc-dx-content-switcher-item-h{transition:flex-basis, opacity;transition-timing-function:var(--dx-content-switcher-transition-timing-function, ease-in-out);transition-duration:var(--dx-content-switcher-transition-duration, 300ms), calc(var(--dx-content-switcher-transition-duration, 300ms) * 0.5);will-change:flex-basis, opacity}@media screen and (prefers-reduced-motion: reduce){.animatable.sc-dx-content-switcher-item-h{transition-duration:1ms !important;transition-delay:0ms !important}}.animatable.visible.sc-dx-content-switcher-item-h{transition-duration:var(--dx-content-switcher-transition-duration, 300ms);transition-delay:0ms, calc(var(--dx-content-switcher-transition-duration, 300ms) * 0.5)}.visible.sc-dx-content-switcher-item-h{opacity:1;flex:0 0 100%}.reverse.sc-dx-content-switcher-item-h{flex-direction:row-reverse}.sc-dx-content-switcher-item-h .slot-wrapper.sc-dx-content-switcher-item{flex:0 0 var(--dx-content-switcher-width)}";

const DxContentSwitcherItem = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.reverse = false;
    this.animatable = true;
  }
  onReverseChange() {
    // Prevents wobbling while initializing the content-switcher-items.
    this.reverse = this.reverse && this.animatable;
  }
  onStateChanged() {
    if (this.visible) {
      this.self.hidden = false;
      this.self.style.removeProperty("visibility");
    }
    onNextFrame(() => {
      this.internalVisible = this.visible;
    });
  }
  connectedCallback() {
    this.internalVisible = this.visible;
  }
  handleTransitionEnd(e) {
    if (e.target === this.self && e.propertyName === "flex-basis") {
      if (this.internalVisible) {
        // This is important to prevent the content from wobbling when the size of the window changes.
        this.reverse = false;
      }
      else {
        this.self.style.setProperty("visibility", "hidden");
      }
    }
  }
  render() {
    return (h(Host, { onTransitionEnd: (e) => this.handleTransitionEnd(e), class: {
        visible: this.internalVisible,
        animatable: this.animatable,
        reverse: this.reverse,
      } }, h("div", { class: "slot-wrapper" }, h("slot", null))));
  }
  get self() { return getElement(this); }
  static get watchers() { return {
    "reverse": ["onReverseChange"],
    "visible": ["onStateChanged"]
  }; }
};
DxContentSwitcherItem.style = dxContentSwitcherItemCss;

export { DxContentSwitcher as dx_content_switcher, DxContentSwitcherItem as dx_content_switcher_item };
