import { r as registerInstance, c as createEvent, w as writeTask, h, H as Host, g as getElement } from './index-04c470ea.js';
import { o as onNextFrame } from './render-util-1dee6655.js';

const dxSimpleGrowBoxCss = ".sc-dx-simple-grow-box-h{display:block;box-sizing:border-box;will-change:height}.sc-dx-simple-grow-box-h([hidden]).sc-dx-simple-grow-box-h{display:none !important}.animate-with-content.sc-dx-simple-grow-box-h{transition:height var(--dx-simple-grow-box-animation-duration, 300ms) ease-in-out}.overflow-hidden.sc-dx-simple-grow-box-h{overflow:hidden}.overflow-hidden.sc-dx-simple-grow-box-h .animation-container.sc-dx-simple-grow-box{overflow:hidden}.sc-dx-simple-grow-box-h .animation-container.sc-dx-simple-grow-box{width:100%;box-sizing:border-box;border-color:var(--dx-simple-grow-box-border-color);border-top-width:var(--dx-simple-grow-box-border-top-width, 0);border-right-width:var(--dx-simple-grow-box-border-right-width, 0);border-bottom-width:var(--dx-simple-grow-box-border-bottom-width, 0);border-left-width:var(--dx-simple-grow-box-border-left-width, 0);border-style:solid}.sc-dx-simple-grow-box-h .animation-container.animatable.sc-dx-simple-grow-box{transition:transform var(--dx-simple-grow-box-animation-duration, 300ms) ease-in-out}.sc-dx-simple-grow-box-h .animation-container.top-to-bottom.sc-dx-simple-grow-box{transform:translateY(-100%)}.sc-dx-simple-grow-box-h .animation-container.bottom-to-top.sc-dx-simple-grow-box{transform:translateY(100%)}.sc-dx-simple-grow-box-h .animation-container.open.sc-dx-simple-grow-box{transform:translateY(0)}.sc-dx-simple-grow-box-h .animation-container.ignore-transform.sc-dx-simple-grow-box{transform:none}";

const DxSimpleGrowBox = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.growBoxStateChange = createEvent(this, "growBoxStateChange", 7);
    this.initialized = false;
    /**
     * Defines whether the content is visible or not.
     *
     * @value true: The content under the header is visible.
     * @value false: The content under the header is not displayed.
     */
    this.open = false;
    /**
     * Reserves space before opening the grow-box.
     * The reserved space equals the final height of the animated content.
     */
    this.reservespaceonopen = false;
    this.animationmode = "top-to-bottom";
    this.slidecontent = true;
    this.height = 0;
    this.isFullyOpened = false;
  }
  onOpenChanged() {
    var _a, _b, _c, _d;
    this.animationContainer.classList.add("animatable");
    if (!this.open) {
      // Remove now because these styles should be set before next render step.
      (_b = (_a = this.animationContainer) === null || _a === void 0 ? void 0 : _a.classList) === null || _b === void 0 ? void 0 : _b.remove("ignore-transform");
      (_d = (_c = this.self) === null || _c === void 0 ? void 0 : _c.style) === null || _d === void 0 ? void 0 : _d.setProperty("height", `${this.height}px`);
      this.isFullyOpened = false;
    }
  }
  componentWillLoad() {
    this.setVisibility(this.open);
  }
  connectedCallback() {
    this.resizeObserver = new ResizeObserver((entries) => {
      const element = entries[0].target;
      // If element is currently not displayed, we don't want to set the height
      if (element.offsetParent == null) {
        return;
      }
      this.height = entries[0].target.offsetHeight;
    });
    this.isFullyOpened = this.open;
  }
  disconnectedCallback() {
    this.resizeObserver.disconnect();
  }
  setVisibility(visible) {
    writeTask(() => {
      this.self.style.setProperty("visibility", visible ? "visible" : "hidden");
    });
  }
  isValidTransitionTarget(target) {
    return target !== this.self && target !== this.animationContainer;
  }
  onTransitionStart(e) {
    if (this.isValidTransitionTarget(e.target) ||
      e.propertyName !== "transform") {
      return;
    }
    else if (this.open && this.isFullyOpened) {
      // This will be called after setting transform to "none" or undefined and would lead to an invalid state.
      // Therefor we return here.
      return;
    }
    this.growBoxStateChange.emit(this.open ? "opening" : "closing");
    this.setVisibility(true);
  }
  onTransitionEnd(e) {
    if (this.isValidTransitionTarget(e.target) ||
      e.propertyName !== "transform") {
      return;
    }
    else if (this.open && this.isFullyOpened) {
      // This will be called after setting transform to "none" or undefined and would lead to an invalid state.
      // Therefor we return here.
      return;
    }
    const state = this.open ? "opened" : "closed";
    this.growBoxStateChange.emit(state);
    this.setVisibility(this.open);
  }
  onStateChanged(e) {
    if (e.target !== this.self) {
      return;
    }
    if (e.detail === "closed") {
      writeTask(() => {
        var _a, _b;
        (_b = (_a = this.animationContainer) === null || _a === void 0 ? void 0 : _a.classList) === null || _b === void 0 ? void 0 : _b.remove("animatable");
      });
    }
    this.isFullyOpened = e.detail === "opened";
  }
  componentDidLoad() {
    this.initialized = true;
  }
  componentWillUpdate() {
    // Render should wait at least one frame before being called because the styles applied in `onOpenChanged`
    // need to be applied in one frame while the new styles in render should be applied in the next frame.
    return new Promise((resolve) => {
      onNextFrame(resolve);
    });
  }
  render() {
    const hostHeight = !this.reservespaceonopen
      ? this.open
        ? this.height
        : 0
      : null;
    return (h(Host, { style: {
        height: hostHeight == null || !this.initialized || this.isFullyOpened
          ? "unset"
          : `${hostHeight}px`,
      }, class: {
        "animate-with-content": !this.reservespaceonopen,
        "slide-content": this.slidecontent,
        "overflow-hidden": !this.isFullyOpened,
      } }, h("div", { class: {
        "animation-container": true,
        "top-to-bottom": this.animationmode === "top-to-bottom",
        "bottom-to-top": this.animationmode === "bottom-to-top",
        "ignore-transform": this.isFullyOpened,
        open: this.open,
      }, ref: (ref) => {
        this.animationContainer = ref;
      } }, h("div", { ref: (ref) => this.resizeObserver.observe(ref) }, h("slot", null)))));
  }
  get self() { return getElement(this); }
  static get watchers() { return {
    "open": ["onOpenChanged"]
  }; }
};
DxSimpleGrowBox.style = dxSimpleGrowBoxCss;

export { DxSimpleGrowBox as dx_simple_grow_box };
