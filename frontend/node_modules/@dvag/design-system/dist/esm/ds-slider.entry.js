import { r as registerInstance, c as createEvent, h, H as Host, g as getElement, f as forceUpdate } from './index-04c470ea.js';
import { a as assert } from './assert-7fc7463a.js';
import { o as onNextFrame } from './render-util-1dee6655.js';
import { D as DragController } from './drag-controller-3573133f.js';
import { R as ReadonlyTextElement } from './base-elements-20abac26.js';
import { c as clamp } from './math-util-3928f6c7.js';

const dsSliderCss = ":host{display:block}:host:host([hidden]){display:none !important}:host:host(.is-dragging){cursor:grab !important}:host .form-control{height:76px;position:relative;top:0;left:0}:host .form-control .knob{position:absolute;top:36px;left:0;background-color:#ffffff;border:1px solid #a7893d;width:32px;height:32px;border-radius:50%;box-sizing:border-box;box-shadow:0px 4px 12px 0px rgba(0, 0, 0, 0.12)}:host .form-control .outer-bar{position:absolute;top:52px;width:100%;height:2px;background-color:#dedede}:host .form-control .outer-bar .inner-bar{width:100%;height:100%;background-color:#a7893d;transform-origin:left}:host .form-control .value{display:inline-block;opacity:0;white-space:nowrap}:host .form-control .value.visible{opacity:1}:host .label{padding-left:8px}";

const DsSlider = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.valueChange = createEvent(this, "valueChange", 7);
    this.isDragging = false;
    /**
     * Size of the Steps, the values can be selected.
     * @value number: Minimal possible change.
     * @example step
     */
    this.step = 0.01;
    /**
     * Text on top of the slider, that displays the current value.
     * A dollarsign followed by a number represents the value of the slider.
     * The amount of numbers determines the amount of decimal numbers.
     *
     * @value string: Formatting of the slider value, e.g. `$1 %` or `$2 €`
     * @example formattedvalue
     */
    this.formattedvalue = "$0";
    /**
     * Switches the input to the read-only mode.
     * The value of the element is shown in a simple way. The element is not usable anymore.
     * @value false: Formfield
     * @value true: Value as text
     * @example readonly
     */
    this.readonly = false;
  }
  valueChanged() {
    if (this.value != null && isNaN(this.value)) {
      console.error(`<ds-slider> hat einen ungültigen Zahlenwert für das Attribut 'value' gesetzt.`);
      this.value = null;
    }
  }
  componentWillLoad() {
    this.dragController = new DragController(() => this.value, (e) => {
      var _a;
      const boundingBox = this.self.getBoundingClientRect();
      const leftLimit = boundingBox.left;
      const rightLimit = boundingBox.right;
      const position = Math.max(0, Math.min((e.x - leftLimit) / (rightLimit - leftLimit), 1));
      const computedValue = Math.round((this.min + position * (this.max - this.min)) / this.step) * this.step;
      const fractionDigits = ((_a = this.step.toString().split(".")[1]) === null || _a === void 0 ? void 0 : _a.length) || 0;
      this.value = parseFloat(computedValue.toFixed(fractionDigits));
      this.valueChange.emit(this.value);
    }, () => (this.isDragging = true), () => (this.isDragging = false));
  }
  format(value) {
    if (this.formattedvalue) {
      if (this.formattedvalue.includes("$")) {
        try {
          const match = this.formattedvalue.match(/(.*)(\$\d)(.*)/); // capture 3 groups: before, digits indicator, after
          const digits = parseInt(match[2].substring(1));
          const formattedNumber = value.toFixed(digits).replace(".", ",");
          return match[1] + formattedNumber + match[3];
        }
        catch (e) {
          console.error("Fehler beim Interpretieren der Eigenschaft 'formattedvalue'");
        }
      }
      else {
        return this.formattedvalue;
      }
    }
    return value.toString();
  }
  valueTranslationX(position) {
    if (this.valueElement != null) {
      const valueWidth = this.valueElement.offsetWidth;
      let translateX = SLIDER_KNOB_SIZE / 2 + position * this.getHostWidth() - valueWidth / 2;
      translateX = clamp(translateX, 0, SLIDER_KNOB_SIZE + this.getHostWidth() - valueWidth);
      return translateX;
    }
    return 0;
  }
  getHostWidth() {
    return this.self.clientWidth - SLIDER_KNOB_SIZE;
  }
  render() {
    assert(this.min != null, () => "Für <ds-slider> ist die Angabe eines Min-Wertes erforderlich");
    assert(this.max != null, () => "Für <ds-slider> ist die Angabe eines Max-Wertes erforderlich");
    assert(this.min < this.max, () => "Für <ds-slider> muss der Min-Wert kleiner sein als der Max-Wert");
    assert(this.value >= this.min && this.value <= this.max, () => "Für <ds-slider> muss der Value zwischen Min-Wert und Max-Wert liegen");
    const usedValue = clamp(this.value, this.min, this.max);
    const position = (usedValue - this.min) / (this.max - this.min);
    const sliderWidth = this.getHostWidth(); // slider area - slider knob width
    if (!this.valueElement) {
      onNextFrame(() => forceUpdate(this)); // wait for label to be measurable
    }
    if (this.readonly) {
      return h(ReadonlyTextElement, { text: this.format(usedValue) });
    }
    return (h(Host, { class: {
        "is-dragging": this.isDragging,
      } }, h("div", { class: "form-control" }, h("div", { class: "outer-bar" }, h("div", { class: "inner-bar", style: {
        transform: `scaleX(${position})`,
      } })), h("div", { class: "knob", onPointerDown: (e) => this.dragController.onPointerDown(e), onTouchStart: (e) => this.dragController.onTouchStart(e), style: {
        transform: `translateX(${position * sliderWidth}px)`,
      } }), h("div", { class: {
        value: true,
        visible: this.valueElement != null,
      }, style: {
        transform: `translateX(${this.valueTranslationX(position)}px)`,
      }, ref: (el) => (this.valueElement = el) }, h("ds-text", { type: "fliesstext-fett", screensize: "small" }, this.format(usedValue)))), this.renderLabel()));
  }
  renderLabel() {
    if (this.label) {
      return (h("div", { class: "label" }, h("ds-text", { type: "infotext-klein", screensize: "small" }, this.label)));
    }
  }
  get self() { return getElement(this); }
  static get watchers() { return {
    "value": ["valueChanged"]
  }; }
};
const SLIDER_KNOB_SIZE = 32;
DsSlider.style = dsSliderCss;

export { DsSlider as ds_slider };
