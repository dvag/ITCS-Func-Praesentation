import { r as registerInstance, h, H as Host } from './index-04c470ea.js';
import { g as getPointOnCircle } from './math-util-3928f6c7.js';

const dsSpinnerCss = ":host{display:inline-block;position:relative}:host:host([hidden]){display:none !important}@keyframes fade-out{0%{opacity:1}100%{opacity:0}}:host svg{position:absolute;left:0;top:0;opacity:0;animation-name:fade-out;animation-timing-function:linear;animation-iteration-count:infinite}";

const DsSpinner = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.lines = [];
    this.counter = 0;
    this.circleWalker = 0;
    /**
     * @internal
     *
     * Specifies the duration in milliseconds the spinner needs to spin one turn.
     *
     * @value number: The duration of one spin.
     */
    this.animationduration = 1500;
    /**
     * @internal
     *
     * The number of segments in the circle.
     *
     * @value number: Number of segments.
     */
    this.segments = 12;
    /**
     * Displays the spinner in a light or dark theme.
     *
     * @value light: The segments have a dark tone to contrast a light background.
     * @value dark: The segments have a light tone to contrast a dark background.
     *
     * @example theme
     */
    this.theme = "light";
    /**
     * Specififes the size of the spinner.
     *
     * @value small: Spinner has a size of 16px.
     * @value medium: Spinner has a size of 32px.
     * @value large: Spinner has a size of 72px.
     *
     * @example size
     */
    this.size = "small";
  }
  onAnimationDurationChanged() {
    this.internalAnimationDuration = this.animationduration;
  }
  onSegmentCountChange() {
    this.computeLines();
  }
  onSizeChanged() {
    this.updateStates();
  }
  componentWillLoad() {
    this.internalAnimationDuration = this.animationduration;
    this.updateStates();
    this.computeLines();
  }
  connectedCallback() {
    this.internalAnimationDuration = this.animationduration;
  }
  disconnectedCallback() {
    this.internalAnimationDuration = 0;
  }
  updateStates() {
    this.sizeInPx = this.computeSizeInPx();
    this.strokeWidth = this.computeStrokeWidth();
  }
  computeSizeInPx() {
    if (this.size === "small") {
      return 16;
    }
    else if (this.size === "medium") {
      return 32;
    }
    else {
      return 72;
    }
  }
  computeStrokeWidth() {
    if (this.size === "small") {
      return 1;
    }
    else if (this.size === "medium") {
      return 3;
    }
    else {
      return 6;
    }
  }
  computeLines() {
    this.lines = [];
    const halfSizeInPx = this.sizeInPx * 0.5;
    for (let i = 0; i < this.segments; ++i) {
      const angle = (360 / this.segments) * i - 90;
      const innerPoint = getPointOnCircle(halfSizeInPx * 0.5 + this.strokeWidth * 0.5, angle);
      const outerPoint = getPointOnCircle(halfSizeInPx - this.strokeWidth * 0.5, angle);
      innerPoint.x += halfSizeInPx;
      innerPoint.y += halfSizeInPx;
      outerPoint.x += halfSizeInPx;
      outerPoint.y += halfSizeInPx;
      this.lines.push(createLine(innerPoint.x, innerPoint.y, outerPoint.x, outerPoint.y));
    }
  }
  renderSVGLine(line, index) {
    const delay = (this.internalAnimationDuration / this.segments) *
      (this.segments - index);
    const opacity = ((index - 1 + this.segments) % this.segments) / this.segments;
    return (h("svg", { width: this.sizeInPx, height: this.sizeInPx, style: {
        "animation-delay": -delay + "ms",
        "animation-duration": this.internalAnimationDuration + "ms",
        opacity: opacity + "",
      } }, h("line", { x1: line.x1, x2: line.x2, y1: line.y1, y2: line.y2, "stroke-linecap": "round", style: {
        stroke: this.theme === "light" ? "#4c4c4c" : "white",
        "stroke-width": this.strokeWidth + "px",
      } })));
  }
  render() {
    return (h(Host, { style: {
        width: this.sizeInPx + "px",
        height: this.sizeInPx + "px",
      } }, this.lines.map((line, index) => {
      return this.renderSVGLine(line, index);
    })));
  }
  static get watchers() { return {
    "animationduration": ["onAnimationDurationChanged"],
    "segments": ["onSegmentCountChange"],
    "size": ["onSizeChanged"]
  }; }
};
function createLine(x1, y1, x2, y2) {
  return {
    x1,
    y1,
    x2,
    y2,
  };
}
DsSpinner.style = dsSpinnerCss;

export { DsSpinner as ds_spinner };
