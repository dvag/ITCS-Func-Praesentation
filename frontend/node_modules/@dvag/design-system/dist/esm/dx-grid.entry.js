import { r as registerInstance, h, H as Host, g as getElement } from './index-04c470ea.js';
import { G as GridBreakpoint, g as getBreakpointMinWidth } from './grid-models-f7973aae.js';
import { B as BreakpointAware } from './breakpoint-aware-0017fabb.js';
import { S as SlotObserver } from './slot-observer-9196738e.js';
import { a as assert } from './assert-7fc7463a.js';
import { a as assertIsPossibleSize } from './sizes.util-0576b947.js';
import './query-util-02753b43.js';

class GridSyntaxParser {
  parse(expression, breakpoint) {
    const splitByRows = expression.split('/');
    const result = {
      rows: splitByRows.map(row => this.parseRow(row)),
      breakpoint,
      expression,
      error: ''
    };
    const naNColumns = result.rows.filter(row => row.type === 'columns').flatMap(row => row.columns).filter(column => isNaN(column.size));
    if (naNColumns.length > 0) {
      result.error += `Fehler beim Parsen von ${breakpoint}="${expression}". Syntaxfehler.`;
    }
    return result;
  }
  parseRow(rowExpression) {
    if (rowExpression === '*') {
      return { type: 'repeat' };
    }
    const splitByMinusChar = rowExpression.split('-');
    const columns = splitByMinusChar.map(char => {
      if (WHITESPACE_MATCHER.test(char)) {
        const size = parseInt(char.match(WHITESPACE_MATCHER)[1]);
        return { type: 'whitespace', size };
      }
      else {
        return { type: 'slotelement', size: parseInt(char) };
      }
    });
    return {
      type: 'columns',
      columns,
    };
  }
}
const WHITESPACE_MATCHER = /^\((.+)\)$/i;

class GridValidator {
  constructor(base) {
    this.base = base;
  }
  validate(grid) {
    grid.rows.forEach((row, index) => {
      if (row.type === "columns") {
        const usedColumns = row.columns.reduce((prev, row) => prev + row.size, 0);
        const breakPointColumns = this.base.columns[grid.breakpoint];
        if (usedColumns > breakPointColumns) {
          grid.error += `Error parsing ${grid.breakpoint}="${grid.expression}". Line ${index + 1} uses ${usedColumns} columns. Only ${breakPointColumns} columns are allowed.`;
        }
      }
    });
  }
}

const PAGE_GRID = {
  gapSizes: {
    mq1: 16,
    mq2: 16,
    mq3: 24,
    mq4: 24,
    mq5: 24,
  },
  columns: {
    mq1: 12,
    mq2: 12,
    mq3: 12,
    mq4: 12,
    mq5: 12,
  }
};

class GridCssBuilder {
  build(base, grid, currentBreakpoint, numberOfChildNodes, rowGap) {
    const builder = new CssBuilder();
    const columnGap = base.gapSizes[currentBreakpoint];
    const columns = base.columns[currentBreakpoint];
    builder.writeCss(`:host {
        column-gap: ${columnGap}px;
        row-gap: ${rowGap}px;
        grid-template-columns: repeat\(${columns}, 1fr\);
      }
    `);
    let childRuleNumber = 0;
    let rowNumber = 0;
    grid.rows.forEach((row, rowIndex) => {
      var _a;
      if (row.type === "columns") {
        rowNumber++;
        childRuleNumber = this.processRow(row.columns, childRuleNumber, builder, rowNumber);
      }
      if (row.type === "repeat") {
        const columns = (_a = grid.rows[rowIndex - 1]) === null || _a === void 0 ? void 0 : _a.columns;
        while (childRuleNumber < numberOfChildNodes) {
          rowNumber++;
          childRuleNumber = this.processRow(columns, childRuleNumber, builder, rowNumber);
        }
      }
    });
    if (numberOfChildNodes > childRuleNumber) {
      builder.writeError(`There are ${numberOfChildNodes} child elements within the grid, although it is only layed out for ${childRuleNumber} child elements.`);
    }
    return {
      css: builder.css,
      error: builder.error,
    };
  }
  processRow(columns, childRuleNumber, builder, rowNumber) {
    let currentColumn = 1;
    columns.forEach((column) => {
      if (column.type === "slotelement") {
        childRuleNumber++;
        if (column.size > 0) {
          builder.writeCss(`
:host ::slotted(*:nth-child(${childRuleNumber})) {
  grid-column-start: ${currentColumn};
  grid-column-end: span ${column.size};
  grid-row-start: ${rowNumber};
  grid-row-end: span 1;
}`);
        }
        else {
          builder.writeCss(`
:host ::slotted(*:nth-child(${childRuleNumber})) {
  display: none !important;
}`);
        }
      }
      currentColumn += column.size;
    });
    return childRuleNumber;
  }
}
class CssBuilder {
  constructor() {
    this.css = "";
    this.error = "";
  }
  writeCss(code) {
    this.css += code;
  }
  writeError(msg) {
    this.error += msg;
  }
}

const dxGridCss = ":host{display:grid}:host:host([hidden]){display:none !important}";

const DxGrid = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    /**
     * The grid's base. Different bases can define a custom amount of columns for every breakpoint.
     *
     * @value page: Default page grid.
     * @example page-1
     * @example page-2
     */
    this.base = "page";
    /**
     * The gap between the rows of the grid.
     *
     * @value 0, 4, 8, 16, 24, 32, 40, 48, 56, 64, 80, 120: The gap between the rows.
     * @example row-gap
     */
    this.rowgap = "16";
    this.updateGridPoolBeforeRender = false;
    this.gridPool = [];
  }
  updateGridPool() {
    assert((this.mq1 || this.mq2 || this.mq3 || this.mq4 || this.mq5) != null, () => '<dx-grid> There has to be at least one breakpoint defined: "mq1", "mq2", "mq3", "mq4" or "mq5".');
    this.gridPool = [];
    const gridBase = PAGE_GRID;
    if (this.mq1) {
      this.gridPool.push(new GridSyntaxParser().parse(this.mq1, GridBreakpoint.MQ1));
    }
    if (this.mq2) {
      this.gridPool.push(new GridSyntaxParser().parse(this.mq2, GridBreakpoint.MQ2));
    }
    if (this.mq3) {
      this.gridPool.push(new GridSyntaxParser().parse(this.mq3, GridBreakpoint.MQ3));
    }
    if (this.mq4) {
      this.gridPool.push(new GridSyntaxParser().parse(this.mq4, GridBreakpoint.MQ4));
    }
    if (this.mq5) {
      this.gridPool.push(new GridSyntaxParser().parse(this.mq5, GridBreakpoint.MQ5));
    }
    const validator = new GridValidator(gridBase);
    this.gridPool.forEach((grid) => validator.validate(grid));
    this.updateChosenGrid();
  }
  componentWillLoad() {
    this.updateGridPool();
  }
  connectedCallback() {
    this.slotObserver = new SlotObserver(this.self, "*", (nodes) => {
      this.numberOfChildNodes = nodes.filter((node) => node.parentElement === this.self).length;
    });
    this.breakpointAware = new BreakpointAware(() => this.updateChosenGrid(), true);
  }
  disconnectedCallback() {
    var _a, _b;
    (_a = this.breakpointAware) === null || _a === void 0 ? void 0 : _a.disconnect();
    (_b = this.slotObserver) === null || _b === void 0 ? void 0 : _b.disconnect();
  }
  componentShouldUpdate(_, __, propName) {
    if (propName.startsWith("mq")) {
      this.updateGridPoolBeforeRender = true;
    }
  }
  componentWillRender() {
    var _a;
    assertIsPossibleSize((_a = this.rowgap) !== null && _a !== void 0 ? _a : "16", this.self);
    if (this.updateGridPoolBeforeRender) {
      this.updateGridPool();
      this.updateGridPoolBeforeRender = false;
    }
  }
  gridBase() {
    if (this.base == "page") {
      return PAGE_GRID;
    }
    throw Error("<dx-grid> Invalid 'base' value");
  }
  getBreakpointFromBreakpointAware() {
    if (this.breakpointAware.mq1) {
      return GridBreakpoint.MQ1;
    }
    else if (this.breakpointAware.mq2) {
      return GridBreakpoint.MQ2;
    }
    else if (this.breakpointAware.mq3) {
      return GridBreakpoint.MQ3;
    }
    else if (this.breakpointAware.mq4) {
      return GridBreakpoint.MQ4;
    }
    else {
      return GridBreakpoint.MQ5;
    }
  }
  updateChosenGrid() {
    this.breakpoint = this.getBreakpointFromBreakpointAware();
    // 1. use direct matches
    this.usedGrid = this.gridPool.find((grid) => grid.breakpoint === this.breakpoint);
    // 2. else: find next smallest breakpoint
    if (!this.usedGrid) {
      const currentBreakpointMinWidth = getBreakpointMinWidth(this.breakpoint);
      this.usedGrid = this.gridPool.reduce((prev, next) => {
        const nextMinWidth = getBreakpointMinWidth(next.breakpoint);
        const prevMinWidth = getBreakpointMinWidth(prev.breakpoint);
        return nextMinWidth > prevMinWidth &&
          nextMinWidth < currentBreakpointMinWidth
          ? next
          : prev;
      });
    }
    // 3. else: use any
    if (!this.usedGrid) {
      this.usedGrid = this.gridPool[0];
    }
  }
  render() {
    let gridErrors = this.gridPool
      .map((grid) => grid.error)
      .reduce((a, b) => a + b, "");
    const rowGap = parseInt(this.rowgap);
    const result = new GridCssBuilder().build(this.gridBase(), this.usedGrid, this.getBreakpointFromBreakpointAware(), this.numberOfChildNodes, isNaN(rowGap) ? 16 : rowGap);
    gridErrors += result.error;
    if (gridErrors.length > 0) {
      console.error(`<dx-grid> ${gridErrors}`);
      return `Grid-Error: ${gridErrors}`;
    }
    return (h(Host, null, h("style", null, result.css), h("slot", null)));
  }
  get self() { return getElement(this); }
};
DxGrid.style = dxGridCss;

export { DxGrid as dx_grid };
