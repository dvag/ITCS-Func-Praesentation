import { r as registerInstance, c as createEvent, f as forceUpdate, a as readTask, w as writeTask, h, H as Host, g as getElement } from './index-04c470ea.js';
import { u as unawaited, s as sleep } from './async-0c539b38.js';
import { B as BreakpointAware } from './breakpoint-aware-0017fabb.js';
import { E as ElementIdGenerator } from './element-id-handling-bb37154e.js';
import { n as notHidden } from './query-util-02753b43.js';
import { o as onNextFrame, i as isSlotDefined } from './render-util-1dee6655.js';
import { c as createMetaComponentsSlotObserver } from './slot-observer-9196738e.js';
import { s as subscribeToHeaderHeight, H as HeaderService } from './header-service-d157d41e.js';
import { S as SITE_NAVIGATION_STATE_ARRAY } from './states-a9f9fe25.js';
import './value-store-f4663db1.js';
import './multicast-observable-f2e53ec0.js';

// Create an array with all child states state including own.
// Then sort it by priority.
function obtainChildState(items) {
  return items.map((item) => {
    // Start with own state
    const allStates = [item.state];
    // Add all child states
    item.children.forEach((child) => allStates.push(child.state));
    // Compute highest priority
    const highestPriority = allStates.reduce((a, b) => {
      return SITE_NAVIGATION_STATE_ARRAY.indexOf(b) <=
        SITE_NAVIGATION_STATE_ARRAY.indexOf(a)
        ? b
        : a;
    });
    return Object.assign(Object.assign({}, item), { state: highestPriority });
  });
}

const dxSiteNavigationMenuCss = ":host{display:block}:host:host([hidden]){display:none !important}:host:host(.large-screen){position:sticky;transition:top 300ms ease-in-out}:host .large-screen-frame{border:1px solid #d6d6d6;background-color:#ffffff}:host .large-screen-frame .scroll-container{min-height:240px;max-height:calc(100vh - 200px);overflow-y:auto}:host .large-screen-frame .separator{height:1px;position:relative;top:0;left:0}:host .large-screen-frame .separator .shadow{position:absolute;bottom:1px;height:4px;width:100%;background-color:rgba(0, 0, 0, 0.03)}:host .large-screen-frame .separator .border{height:1px;background-color:#d6d6d6}:host .large-screen-frame .action{padding:17px}:host .small-screen-header{display:flex;align-items:center;height:48px;box-sizing:border-box;background-color:#ffffff;border:1px solid #d6d6d6;padding-left:16px;padding-right:8px;cursor:pointer}:host .small-screen-header.static{position:relative;top:0;left:0;margin-bottom:32px}:host .small-screen-header .trigger{position:absolute;left:0;width:100%;top:-8px;height:64px;pointer-events:none}:host .small-screen-header .state{flex-shrink:0;width:24px}:host .small-screen-header .state.hidden{display:none}:host .small-screen-header .label{flex-grow:1;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}:host .small-screen-header .open-menu{flex-shrink:0;width:40px;height:40px;display:flex;justify-content:center;align-items:center}:host .small-screen-header .open-menu button{width:var(--dx-button-width, fit-content);width:var(--dx-button-width, -moz-fit-content);cursor:pointer;display:inline-flex;justify-content:center;align-items:center;box-sizing:border-box;white-space:nowrap;user-select:none;-webkit-user-select:none;border:none;margin:0;background-color:transparent;transition:background-color 150ms ease-in-out, border-color 150ms ease-in-out;outline-offset:2px;width:40px;height:40px;display:flex;justify-content:center;align-items:center}:host .small-screen-header .open-menu button[disabled]{cursor:unset}:host .small-screen-header .open-menu button.icon-right{flex-direction:row-reverse}:host .small-screen-header .open-menu button:focus-visible{outline:2px solid #004763}:host .floating-wrapper{position:fixed;z-index:899;height:48px;background-color:#f7f7f7;padding-top:24px;padding-bottom:8px;transition:top 300ms ease-in-out, opacity 200ms ease-in;display:none}:host .floating-wrapper.visible{display:block}:host .floating-wrapper.visible.fade-out{opacity:0}:host .item{display:flex;align-items:stretch;user-select:none;cursor:pointer}:host .item .indicator{width:4px;flex-shrink:0}:host .item .indent{flex-shrink:0}:host .item .state{display:flex;align-items:center;flex-shrink:0;box-sizing:border-box;width:24px;padding-right:6px}:host .item .state.hidden{display:none}:host .item .label{flex-grow:1;display:flex;align-items:center;min-height:40px;padding:4px 0;box-sizing:border-box}:host .item .label button{width:var(--dx-button-width, fit-content);width:var(--dx-button-width, -moz-fit-content);cursor:pointer;display:inline-flex;justify-content:center;align-items:center;box-sizing:border-box;white-space:nowrap;user-select:none;-webkit-user-select:none;border:none;margin:0;background-color:transparent;transition:background-color 150ms ease-in-out, border-color 150ms ease-in-out;outline-offset:2px;width:auto;white-space:pre-wrap;text-align:left}:host .item .label button[disabled]{cursor:unset}:host .item .label button.icon-right{flex-direction:row-reverse}:host .item .label button:focus-visible{outline:2px solid #004763}:host .item .arrow{flex-shrink:0;display:flex;width:40px;justify-content:center;align-items:center}:host .item .arrow button{width:var(--dx-button-width, fit-content);width:var(--dx-button-width, -moz-fit-content);cursor:pointer;display:inline-flex;justify-content:center;align-items:center;box-sizing:border-box;white-space:nowrap;user-select:none;-webkit-user-select:none;border:none;margin:0;background-color:transparent;transition:background-color 150ms ease-in-out, border-color 150ms ease-in-out;outline-offset:2px;width:40px;height:40px;outline-offset:-4px;display:flex;justify-content:center;align-items:center}:host .item .arrow button[disabled]{cursor:unset}:host .item .arrow button.icon-right{flex-direction:row-reverse}:host .item .arrow button:focus-visible{outline:2px solid #004763}:host .item:hover{background-color:#f7f7f7}:host .item.selected{background-color:#f7f7f7}:host .item.selected .indicator{background-color:#c8aa22}:host .item:active{background-color:#ededed}:host .item.level-1 .indent{width:12px}:host .item.level-2 .indent{width:24px}";

const DxSiteNavigationMenu = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.navigate = createEvent(this, "navigate", 7);
    this.scopes = [];
    this.enableScrollSelection = true;
    this.menuItems = [];
    this.openedMenuItemValue = null;
    this.headerState = { isVisible: true, height: 0 };
    this.usesStates = false;
    this.smallScreenModalVisible = false;
    /**
     * If activated, the menu looks out for dx-site-navigation-section elements with the same value
     * as the menu items, to automatically scroll into view.
     * @value true: Automatic navigation is enabled (default)
     * @value false: No automatic navigation
     */
    this.autonavigation = true;
    /**
     * Title of the page. The text is display in the modal view on the small screen modals.
     * @value string: Page title.
     */
    this.titlestring = "";
    /**
     * @internal
     */
    this.expandedlayoutat = "mq4";
  }
  onExpandedLayoutAtChanges() {
    this.updateLayoutDependentOnCurrentBreakpoint();
  }
  connectedCallback() {
    this.registerMenuItemObserver();
    this.breakpointAware = new BreakpointAware(() => forceUpdate(this), true);
    this.headerHeightSubscription = subscribeToHeaderHeight((height, isVisible) => {
      this.headerState = { height, isVisible };
      this.updateSmallScreenFloatingWrapperPosition();
    });
  }
  disconnectedCallback() {
    var _a, _b, _c, _d, _e;
    (_a = this.menuItemObserver) === null || _a === void 0 ? void 0 : _a.disconnect();
    (_b = this.breakpointAware) === null || _b === void 0 ? void 0 : _b.disconnect();
    (_c = this.headerHeightSubscription) === null || _c === void 0 ? void 0 : _c.unsubscribe();
    (_d = this.scopeIntersectionObserver) === null || _d === void 0 ? void 0 : _d.disconnect();
    (_e = this.smallScreenHeaderIntersectionObserver) === null || _e === void 0 ? void 0 : _e.disconnect();
  }
  onWindowChange() {
    this.updateLayoutDependentOnCurrentBreakpoint();
  }
  updateLayoutDependentOnCurrentBreakpoint() {
    if (this.isLargeScreen) {
      this.updateScrollabilityOfScrollContainer();
    }
    else {
      this.updateSmallScreenFloatingWrapperPosition();
    }
  }
  /**
   * Registers a new dx-site-navigation-scope element for tracking
   * @internal
   */
  async addScope(scope) {
    this.scopes = [...this.scopes, scope];
    this.configureIntersectionObserver();
  }
  /**
   * Removes a previously registered dx-site-navigation-scope element from tracking
   * @internal
   */
  async removeScope(scope) {
    this.scopes = this.scopes.filter((item) => item !== scope);
    this.configureIntersectionObserver();
  }
  updateScrollabilityOfScrollContainer() {
    onNextFrame(() => {
      readTask(() => {
        this.scrollContainerIsScrollable =
          this.scrollContainerElement != null &&
            this.scrollContainerElement.scrollHeight >
              this.scrollContainerElement.offsetHeight;
      });
    });
  }
  configureIntersectionObserver() {
    var _a;
    (_a = this.scopeIntersectionObserver) === null || _a === void 0 ? void 0 : _a.disconnect();
    // this structure keep track of known intersection data
    const data = {};
    // observer callback fires when some element passes a threshold
    this.scopeIntersectionObserver = new IntersectionObserver((entries) => {
      // update intersection data based on new incoming entries
      for (const entry of entries) {
        const value = entry.target.getAttribute("value");
        data[value] = {
          isIntersecting: entry.isIntersecting,
          target: entry.target,
          value: value,
          boundingRect: null,
        };
      }
      // filter for intersecting elements
      const visibleEntries = Object.values(data).filter((item) => {
        if (!item.isIntersecting) {
          return false;
        }
        // update bounding box
        item.boundingRect = item.target.getBoundingClientRect();
        // filter out intersecting items that are barely visible
        const headerBottom = this.headerState.isVisible
          ? this.headerState.height
          : 0;
        return item.boundingRect.bottom >= headerBottom;
      });
      if (visibleEntries.length === 0) {
        // Stop here if no visible elements available
        return;
      }
      visibleEntries.forEach((item) => (item.boundingRect = item.target.getBoundingClientRect()));
      // pick entry with lowest (on top of viewport) center
      const mostVisibleEntry = visibleEntries.reduce((a, b) => {
        const centerOfA = a.boundingRect.y + a.boundingRect.height / 2;
        const centerOfB = b.boundingRect.y + b.boundingRect.height / 2;
        return centerOfA < centerOfB ? a : b;
      });
      // if we have a candidate: select it!
      if (mostVisibleEntry) {
        this.selectValueWhileScrolling(visibleEntries[0].value);
      }
    }, intersectionObserverOptions([0]));
    this.scopes.forEach((scope) => this.scopeIntersectionObserver.observe(scope));
  }
  configureSmallScreenIntersectionObserver() {
    var _a;
    if (this.smallScreenTriggerElement == null) {
      return;
    }
    (_a = this.smallScreenHeaderIntersectionObserver) === null || _a === void 0 ? void 0 : _a.disconnect();
    // observer callback fires when some element passes a threshold
    this.smallScreenHeaderIntersectionObserver = new IntersectionObserver((entries) => {
      if (this.isLargeScreen || this.floatingWrapperElement == null) {
        return;
      }
      // Clear any remaining fade-out timeouts
      clearTimeout(this.fadeOutFloatingWrapperElementTimeout);
      const showFloatingHeader = entries[0].intersectionRatio < 1;
      if (showFloatingHeader) {
        this.floatingWrapperElement.classList.remove("fade-out");
        this.floatingWrapperElement.classList.add("visible");
        this.updateSmallScreenFloatingWrapperPosition();
      }
      else if (!showFloatingHeader) {
        this.floatingWrapperElement.classList.add("fade-out");
        this.fadeOutFloatingWrapperElementTimeout = setTimeout(() => {
          if (this.floatingWrapperElement == undefined) {
            //FloatingWrapper already removed from DOM
            return;
          }
          this.floatingWrapperElement.classList.remove("fade-out");
          this.floatingWrapperElement.classList.remove("visible");
        }, 200);
      }
    }, intersectionObserverOptions([0, 1]));
    this.smallScreenHeaderIntersectionObserver.observe(this.smallScreenTriggerElement);
  }
  updateSmallScreenFloatingWrapperPosition() {
    if (!this.floatingWrapperElement || !this.smallScreenTriggerElement) {
      return;
    }
    readTask(() => {
      const smallScreenTriggerElementWidth = this.smallScreenTriggerElement.offsetWidth + 2;
      writeTask(() => {
        var _a;
        // Asking again because floatingWrapperElement could be null again
        if (!this.floatingWrapperElement || !this.smallScreenTriggerElement) {
          return;
        }
        this.floatingWrapperElement.style.width = `${smallScreenTriggerElementWidth}px`;
        this.floatingWrapperElement.style.top = `${((_a = this.headerState) === null || _a === void 0 ? void 0 : _a.isVisible) ? this.headerState.height : 0}px`;
      });
    });
  }
  selectValueWhileScrolling(value) {
    this.lastRequestedSelectionValue = value;
    if (this.enableScrollSelection && this.selectedvalue !== value) {
      // scan level 1
      for (const item of this.menuItems) {
        if (item.value === value) {
          this.openedMenuItemValue = item.value;
          this.selectedvalue = item.value;
          return;
        }
        // scan level 2
        for (const subItem of item === null || item === void 0 ? void 0 : item.children) {
          if (subItem.value === value) {
            this.selectedvalue = subItem.value;
            this.openedMenuItemValue = item.value;
            return;
          }
        }
      }
    }
  }
  registerMenuItemObserver() {
    this.menuItemObserver =
      createMetaComponentsSlotObserver(this.self, ":scope > dx-site-navigation-menu-item.hydrated", async (nodes) => {
        // Receive menu item structure from DOM (level 1 items)
        this.menuItems = await Promise.all(nodes.map(async (node) => {
          return Object.assign(Object.assign({}, (await node.toMenuItemModel())), {
            // enrich with child nodes (level 2 items)
            children: await Promise.all(Array.from(
            // scan for child nodes within menu item element
            node.querySelectorAll(notHidden("dx-site-navigation-menu-item"))).map((child) => child.toMenuItemModel()))
          });
        }));
        // Obtain child states
        this.menuItems = obtainChildState(this.menuItems);
        this.usesStates = this.menuItems.some((item) => item.state !== "none");
        this.configureIntersectionObserver();
      });
  }
  get isLargeScreen() {
    return ((this.expandedlayoutat === "mq3" && this.breakpointAware.mq3) ||
      this.breakpointAware.mq4 ||
      this.breakpointAware.mq5);
  }
  openCloseItem(item) {
    if (this.openedMenuItemValue !== item.value) {
      this.openedMenuItemValue = item.value;
    }
    else {
      this.openedMenuItemValue = null;
    }
  }
  clickOnItem(item) {
    var _a;
    this.selectedvalue = item.value;
    const isLevel1Item = typeof item.children !== "undefined";
    if (isLevel1Item) {
      const hasChildren = ((_a = item.children) === null || _a === void 0 ? void 0 : _a.length) > 0;
      this.openedMenuItemValue = hasChildren ? item.value : null;
    }
    if (this.autonavigation) {
      // we don't want scroll/scope-based selection for a while.
      // but we track those selection, and if we re-enable scroll selection, we will pick the last tracked value.
      this.enableScrollSelection = false;
      this.smallScreenModalVisible = false;
      unawaited(this.waitAndScrollToScopeWithValue(item.value));
    }
    this.lastRequestedSelectionValue = item.value;
    this.navigate.emit({
      value: this.selectedvalue,
      complete: () => {
        this.reEnableScrollSelection();
        this.smallScreenModalVisible = false;
      },
    });
  }
  async waitAndScrollToScopeWithValue(value) {
    const siteNavigation = this.self.closest("dx-site-navigation");
    // Try to find element for a 5secs
    for (let i = 0; i < 8 * 5; i++) {
      if (this.selectedvalue !== value) {
        // cancel if not selected element anymore
        return;
      }
      const element = siteNavigation === null || siteNavigation === void 0 ? void 0 : siteNavigation.querySelector(`dx-site-navigation-scope[value='${value}']`);
      if (element) {
        // Stop loop if element is found
        await this.scrollToElement(element, "smooth");
        break;
      }
      else if (i == 0) {
        // if dont find the element on first try, temporary scroll to top to allow more overview
        unawaited(this.scrollToElement(siteNavigation));
      }
      await sleep(125); // wait between tries
    }
    this.reEnableScrollSelection();
  }
  reEnableScrollSelection() {
    this.enableScrollSelection = true;
    this.selectValueWhileScrolling(this.lastRequestedSelectionValue);
  }
  async scrollToElement(element, behavior = undefined) {
    if (!element) {
      return;
    }
    const relativePosY = element.getBoundingClientRect().top;
    // If we need to scroll upwards, the header will fade in and occupy space.
    // So we need to allocate some extra space.
    let additionalSpaceForHeaderElement = this.headerState.isVisible
      ? this.headerState.height
      : 0;
    if (!this.isLargeScreen) {
      // extra space for sticky small screen header
      additionalSpaceForHeaderElement +=
        SPACE_BETWEEN_FLOATING_AND_HEADER + SMALL_HEADER_ADDITIONAL_SPACE;
    }
    const scrollAmount = relativePosY - additionalSpaceForHeaderElement - HEADER_MARGIN;
    // don't scroll if it's just a little bit to bottom
    if (scrollAmount > 0 && scrollAmount < window.innerHeight / 4) {
      return;
    }
    unawaited(HeaderService.instance().disableScrollInteractionForMs(SCROLL_DURATION));
    window.scrollBy({ top: scrollAmount, behavior });
    await sleep(SCROLL_DURATION); // scroll duration
  }
  getParentOf(value) {
    return this.menuItems.find((item) => {
      var _a;
      return item.value === value ||
        ((_a = item.children) === null || _a === void 0 ? void 0 : _a.some((child) => child.value === value));
    });
  }
  renderItem(item, level = 1) {
    const children = level === 1 ? item === null || item === void 0 ? void 0 : item.children : [];
    const hasChildren = children.length > 0;
    const hasSelectedChild = children.some((child) => child.value === this.selectedvalue);
    const hasSelectedChildButItsHidden = hasSelectedChild && this.openedMenuItemValue !== item.value;
    return [
      h("div", { class: {
          item: true,
          selected: hasSelectedChildButItsHidden || item.value === this.selectedvalue,
          "level-1": level === 1,
          "level-2": level === 2,
        }, onClick: () => this.clickOnItem(item) }, h("div", { class: "indicator" }), h("div", { class: "indent" }), h("div", { class: { state: true, hidden: !this.usesStates } }, h("dx-icon", { icon: STATE_ICONS[item.state], color: STATE_COLORS[item.state], size: 16 })), h("div", { class: "label" }, h("button", { onClick: (e) => {
          e.stopPropagation();
          this.clickOnItem(item);
        }, id: ElementIdGenerator.createId(this.self, "button-" + item.value) }, h("dx-text", { type: "it", color: "headline" }, item.label))), h("div", { class: {
          arrow: true,
        } }, hasChildren ? (h("button", { onClick: hasChildren
          ? (e) => {
            e.stopPropagation();
            this.openCloseItem(item);
          }
          : undefined, id: ElementIdGenerator.createId(this.self, "open-close-control-" + item.value) }, h("dx-chevron", { directiontop: item.value === this.openedMenuItemValue, size: 16, active: item.value === this.selectedvalue }))) : undefined)),
      h("dx-simple-grow-box", { slidecontent: true, open: item.value === this.openedMenuItemValue }, children.map((child) => this.renderItem(child, level + 1))),
    ];
  }
  renderLargeScreenMenu() {
    const hasActionSlotItem = isSlotDefined(this.self, "action");
    // check if we need to hide show the separator after grow box (depends on number of visible items)
    onNextFrame(() => setTimeout(() => this.updateScrollabilityOfScrollContainer(), GROWBOX_ANIMATION_TIME));
    return (h("div", { class: "large-screen-frame" }, h("div", { class: "scroll-container", ref: (el) => {
        this.scrollContainerElement = el;
        this.updateScrollabilityOfScrollContainer();
      } }, this.menuItems.map((item) => this.renderItem(item))), this.scrollContainerIsScrollable ? (h("div", { class: "separator" }, h("div", { class: "shadow" }), h("div", { class: "border" }))) : null, hasActionSlotItem ? (h("div", { class: "action" }, h("slot", { name: "action" }))) : null));
  }
  renderSmallScreenHeader(position) {
    var _a;
    const selectedItem = (_a = this.getParentOf(this.selectedvalue)) !== null && _a !== void 0 ? _a : this.menuItems[0];
    if (!selectedItem) {
      return;
    }
    return (h("div", { class: {
        "small-screen-header": true,
        static: position === "static",
      }, onClick: () => (this.smallScreenModalVisible = true) }, position === "static" ? (h("div", { class: "trigger", ref: (el) => {
        this.smallScreenTriggerElement = el;
        this.configureSmallScreenIntersectionObserver();
      } })) : null, h("div", { class: { state: true, hidden: !this.usesStates } }, h("dx-icon", { icon: STATE_ICONS[selectedItem.state], color: STATE_COLORS[selectedItem.state], size: 16 })), h("div", { class: "label" }, h("dx-text", { type: "ps", color: "headline" }, selectedItem.label)), h("div", { class: "open-menu" }, h("button", { id: ElementIdGenerator.createId(this.self, "open-menu") }, h("dx-icon", { icon: "ueberlauf-menue", color: "default", size: 24 })))));
  }
  renderSmallScreenMenu() {
    const hasActionSlotItem = isSlotDefined(this.self, "action");
    return [
      this.renderSmallScreenHeader("static"),
      h("div", { class: "floating-wrapper", ref: (el) => {
          this.floatingWrapperElement = el;
          this.configureSmallScreenIntersectionObserver();
        } }, this.renderSmallScreenHeader("floating")),
      h("dx-modal", { height: "internal-site-navigation-menu", label: this.titlestring, visible: this.smallScreenModalVisible, onModalClosed: () => (this.smallScreenModalVisible = false) }, h("div", { slot: "content" }, this.menuItems.map((item) => this.renderItem(item))), hasActionSlotItem ? (h("slot", { name: "action", slot: "primary-actions" })) : null),
    ];
  }
  render() {
    const additionalSpaceForHeaderElement = this.headerState.isVisible
      ? this.headerState.height
      : 0;
    return (h(Host, { class: { "large-screen": this.isLargeScreen }, style: {
        top: `${HEADER_MARGIN + additionalSpaceForHeaderElement}px`,
      } }, this.isLargeScreen
      ? this.renderLargeScreenMenu()
      : this.renderSmallScreenMenu(), h("slot", null)));
  }
  get self() { return getElement(this); }
  static get watchers() { return {
    "expandedlayoutat": ["onExpandedLayoutAtChanges"]
  }; }
};
const STATE_COLORS = {
  error: "red-100",
  required: "gold",
  success: "green-100",
  none: "transparent",
};
const STATE_ICONS = {
  error: "state-error",
  required: "state-required",
  success: "state-success",
  none: "state-error", // intended because invisible
};
const HEADER_MARGIN = 24;
const GROWBOX_ANIMATION_TIME = 300;
const SCROLL_DURATION = 1000;
const SPACE_BETWEEN_FLOATING_AND_HEADER = 16;
const SMALL_HEADER_ADDITIONAL_SPACE = 48 + 8;
function intersectionObserverOptions(threshold) {
  return {
    root: null,
    rootMargin: "0px",
    threshold, // intersectionRatios in which the handler will fire
  };
}
DxSiteNavigationMenu.style = dxSiteNavigationMenuCss;

export { DxSiteNavigationMenu as dx_site_navigation_menu };
