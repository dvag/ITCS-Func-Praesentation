import { r as registerInstance, h, H as Host, g as getElement } from './index-04c470ea.js';
import { a as assert } from './assert-7fc7463a.js';
import { B as BreakpointAware } from './breakpoint-aware-0017fabb.js';
import { S as SlotObserver } from './slot-observer-9196738e.js';
import './query-util-02753b43.js';

class GridSyntaxParser {
  parse(expression, breakpoint) {
    const splitByRows = expression.split('/');
    const result = {
      rows: splitByRows.map(row => this.parseRow(row)),
      breakpoint,
      expression,
      error: ''
    };
    const naNColumns = result.rows.filter(row => row.type === 'columns').flatMap(row => row.columns).filter(column => isNaN(column.size));
    if (naNColumns.length > 0) {
      result.error += `Fehler beim Parsen von ${breakpoint}="${expression}". Syntaxfehler.`;
    }
    return result;
  }
  parseRow(rowExpression) {
    if (rowExpression === '*') {
      return { type: 'repeat' };
    }
    const splitByMinusChar = rowExpression.split('-');
    const columns = splitByMinusChar.map(char => {
      if (WHITESPACE_MATCHER.test(char)) {
        const size = parseInt(char.match(WHITESPACE_MATCHER)[1]);
        return { type: 'whitespace', size };
      }
      else {
        return { type: 'slotelement', size: parseInt(char) };
      }
    });
    return {
      type: 'columns',
      columns,
    };
  }
}
const WHITESPACE_MATCHER = /^\((.+)\)$/i;

class GridValidator {
  constructor(base) {
    this.base = base;
  }
  validate(grid) {
    grid.rows.forEach((row, index) => {
      if (row.type === "columns") {
        const usedColumns = row.columns.reduce((prev, row) => prev + row.size, 0);
        const breakPointColumns = this.base[grid.breakpoint + "Columns"];
        if (usedColumns > breakPointColumns) {
          grid.error += `Fehler beim Parsen von ${grid.breakpoint}="${grid.expression}". Zeile ${index + 1} benutzt ${usedColumns} Spalten von maximal erlaubten ${breakPointColumns}.`;
        }
      }
    });
  }
}

const PAGE_GRID = {
  gapSizePx: 24,
  xlColumns: 12,
  lColumns: 8,
  mColumns: 6,
  sColumns: 4
};

var GridBreakpoint;
(function (GridBreakpoint) {
  GridBreakpoint["XL"] = "xl";
  GridBreakpoint["L"] = "l";
  GridBreakpoint["M"] = "m";
  GridBreakpoint["S"] = "s";
})(GridBreakpoint || (GridBreakpoint = {}));
function ordinalOfGridBreakpoint(breakpoint) {
  if (breakpoint === GridBreakpoint.XL) {
    return 4;
  }
  else if (breakpoint === GridBreakpoint.L) {
    return 3;
  }
  else if (breakpoint === GridBreakpoint.M) {
    return 2;
  }
  else if (breakpoint === GridBreakpoint.S) {
    return 1;
  }
}

class GridCssBuilder {
  build(base, grid, numberOfChildNodes) {
    const builder = new CssBuilder();
    const columnsUsed = base[grid.breakpoint + "Columns"];
    builder.writeCss(`
:host {
  column-gap: ${base.gapSizePx}px;
  row-gap: ${base.gapSizePx}px;
  grid-template-columns: repeat(${columnsUsed}, 1fr);
}`);
    let childRuleNumber = 0;
    let rowNumber = 0;
    grid.rows.forEach((row, rowIndex) => {
      var _a;
      if (row.type === "columns") {
        rowNumber++;
        childRuleNumber = this.processRow(row.columns, childRuleNumber, builder, rowNumber);
      }
      if (row.type === "repeat") {
        const columns = (_a = grid.rows[rowIndex - 1]) === null || _a === void 0 ? void 0 : _a.columns;
        while (childRuleNumber < numberOfChildNodes) {
          rowNumber++;
          childRuleNumber = this.processRow(columns, childRuleNumber, builder, rowNumber);
        }
      }
    });
    if (numberOfChildNodes > childRuleNumber) {
      builder.writeError(`Das Grid ist für ${childRuleNumber} Child-Element(e) definiert, jedoch befinden sich dort aktuell ${numberOfChildNodes} Child-Element(e).`);
    }
    return {
      css: builder.css,
      error: builder.error,
    };
  }
  processRow(columns, childRuleNumber, builder, rowNumber) {
    let currentColumn = 1;
    columns.forEach((column) => {
      if (column.type === "slotelement") {
        childRuleNumber++;
        if (column.size > 0) {
          builder.writeCss(`
:host ::slotted(*:nth-child(${childRuleNumber})) {
  grid-column-start: ${currentColumn};
  grid-column-end: span ${column.size};
  grid-row-start: ${rowNumber};
  grid-row-end: span 1;
}`);
        }
        else {
          builder.writeCss(`
:host ::slotted(*:nth-child(${childRuleNumber})) {
  display: none !important;
}`);
        }
      }
      currentColumn += column.size;
    });
    return childRuleNumber;
  }
}
class CssBuilder {
  constructor() {
    this.css = "";
    this.error = "";
  }
  writeCss(code) {
    this.css += code;
  }
  writeError(msg) {
    this.error += msg;
  }
}

const dsGridCss = ":host{display:grid}:host:host([hidden]){display:none !important}";

const DsGrid = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    /**
     * Art des Grids (Grad-Basis) die für dieses Grid verwendet wird.
     * @value page: Standard-Seiten-Grid
     * @example page-1
     * @example page-2
     */
    this.base = "page";
    this.gridPool = [];
  }
  componentWillLoad() {
    assert((this.s || this.m || this.l || this.xl) != null, () => '<ds-grid> Es muss mindestens eine Größenangabe für die Properties "xl", "l", "m" oder "s" getätigt werden');
    const gridBase = PAGE_GRID;
    if (this.s) {
      this.gridPool.push(new GridSyntaxParser().parse(this.s, GridBreakpoint.S));
    }
    if (this.m) {
      this.gridPool.push(new GridSyntaxParser().parse(this.m, GridBreakpoint.M));
    }
    if (this.l) {
      this.gridPool.push(new GridSyntaxParser().parse(this.l, GridBreakpoint.L));
    }
    if (this.xl) {
      this.gridPool.push(new GridSyntaxParser().parse(this.xl, GridBreakpoint.XL));
    }
    const validator = new GridValidator(gridBase);
    this.gridPool.forEach((grid) => validator.validate(grid));
    this.updateChosenGrid();
  }
  connectedCallback() {
    this.breakpointAware = new BreakpointAware(() => this.updateChosenGrid());
    this.slotObserver = new SlotObserver(this.self, "*", (nodes) => {
      this.numberOfChildNodes = nodes.filter((node) => node.parentElement === this.self).length;
    });
  }
  disconnectedCallback() {
    var _a, _b;
    (_a = this.breakpointAware) === null || _a === void 0 ? void 0 : _a.disconnect();
    (_b = this.slotObserver) === null || _b === void 0 ? void 0 : _b.disconnect();
  }
  gridBase() {
    if (this.base == "page") {
      return PAGE_GRID;
    }
    throw Error("<ds-grid> Ungültige 'base'");
  }
  getBreakpointFromBreakpointAware() {
    if (this.breakpointAware.xs) {
      return GridBreakpoint.S;
    }
    else if (this.breakpointAware.md) {
      return GridBreakpoint.M;
    }
    else if (this.breakpointAware.lg) {
      return GridBreakpoint.L;
    }
    else {
      return GridBreakpoint.XL;
    }
  }
  updateChosenGrid() {
    this.breakpoint = this.getBreakpointFromBreakpointAware();
    // 1. use direct matches
    this.usedGrid = this.gridPool.find((grid) => grid.breakpoint === this.breakpoint);
    // 2. else: find next smallest breakpoint
    if (!this.usedGrid) {
      this.usedGrid = this.gridPool.reduce((prev, next) => {
        return ordinalOfGridBreakpoint(next.breakpoint) >
          ordinalOfGridBreakpoint(prev.breakpoint) &&
          ordinalOfGridBreakpoint(next.breakpoint) <
            ordinalOfGridBreakpoint(this.breakpoint)
          ? next
          : prev;
      });
    }
    // 3. else: use any
    if (!this.usedGrid) {
      this.usedGrid = this.gridPool[0];
    }
  }
  render() {
    let gridErrors = this.gridPool
      .map((grid) => grid.error)
      .reduce((a, b) => a + b, "");
    const result = new GridCssBuilder().build(this.gridBase(), this.usedGrid, this.numberOfChildNodes);
    gridErrors += result.error;
    if (gridErrors.length > 0) {
      console.error(`<ds-grid> ${gridErrors}`);
      return `Grid-Fehler: ${gridErrors}`;
    }
    return (h(Host, null, h("style", null, result.css), h("slot", null)));
  }
  get self() { return getElement(this); }
};
DsGrid.style = dsGridCss;

export { DsGrid as ds_grid };
