import { r as registerInstance, c as createEvent, w as writeTask, a as readTask, h, H as Host, g as getElement, f as forceUpdate } from './index-04c470ea.js';
import { i as isSlotDefined, o as onNextFrame } from './render-util-1dee6655.js';
import { f as findUpperElementByPredicate, o as getNamedSlottedContent } from './misc-util-d3b69f2c.js';

const dxOverlayCss = ":host{display:block}:host:host([hidden]){display:none !important}:host .popup{position:absolute;z-index:1000;min-width:var(--dx-overlay-popup-min-width, min-content);max-width:var(--dx-overlay-popup-max-width, unset)}:host .popup.fixate{position:fixed}:host .popup.is-hidden{pointer-events:none;opacity:0}:host .popup.not-interactive{pointer-events:none}";

const DxOverlay = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.fixedAlignmentChange = createEvent(this, "fixedAlignmentChange", 7);
    this.hidePopup = true;
    this.internalAnchorPosition = "left";
    /**
     * Position, where to place the popup
     */
    this.position = "bottom";
    /**
     * The position to anchor ("right" or "left" to the content width) the popup to.
     */
    this.anchorposition = "left";
    /**
     * CSS display mode of the content area.
     */
    this.contentdisplay = "block";
    /**
     * Additional pixels between content and popup when using horizontal placement.
     */
    this.offsetx = 0;
    /**
     * Additional pixels between content and popup when using vertical placement.
     */
    this.offsety = 0;
    /**
     * Pointer events are delegated to the popup element if true.
     */
    this.popupinteractable = true;
    /**
     * Whether the overlay's position and bounding can be changed over time.
     */
    this.fixate = false;
    /**
     * When the overlay is disabled the width and position is not updated anymore.
     */
    this.disabled = false;
  }
  onDisabledChanged() {
    if (!this.disabled) {
      this.initializeResizeObserver();
    }
    else {
      this.resizeObserver.disconnect();
      writeTask(() => {
        this.popupElement.style.setProperty("width", "0");
      });
    }
  }
  onWindowChange() {
    this.updatePosition();
  }
  connectedCallback() {
    this.initializeResizeObserver();
  }
  disconnectedCallback() {
    var _a, _b;
    (_a = this.slotObserver) === null || _a === void 0 ? void 0 : _a.disconnect();
    (_b = this.resizeObserver) === null || _b === void 0 ? void 0 : _b.disconnect();
  }
  componentWillUpdate() {
    return this.updatePosition();
  }
  async updateFixedPosition() {
    return new Promise((resolve) => {
      readTask(() => {
        // TODO: Implement also for right and top alignment.
        var _a;
        const bounding = this.contentElement.getBoundingClientRect();
        const viewportWidth = document.documentElement.offsetWidth;
        const width = (_a = this.fixatewidth) !== null && _a !== void 0 ? _a : bounding.width;
        const maxLeft = viewportWidth - width;
        const minLeft = Math.max(0, Math.min(bounding.left, maxLeft));
        const anchorPosition = minLeft < bounding.left ? "right" : "left";
        if (anchorPosition !== this.internalAnchorPosition) {
          this.internalAnchorPosition = anchorPosition;
          this.fixedAlignmentChange.emit(this.internalAnchorPosition);
        }
        const withPixels = (num) => `${num}px`;
        // Apply position values to popup
        this.applyValues({
          top: withPixels(bounding.bottom),
          left: withPixels(minLeft),
          bottom: undefined,
          width: withPixels(bounding.width),
          height: undefined,
        }).then(resolve);
      });
    });
  }
  initializeResizeObserver() {
    if (!this.contentElement || this.disabled) {
      return;
    }
    if (this.resizeObserver == null) {
      this.resizeObserver = new ResizeObserver(() => {
        this.updatePosition();
      });
    }
    this.resizeObserver.observe(this.contentElement);
  }
  async updatePosition() {
    if (this.disabled) {
      return;
    }
    return this.internalUpdatePosition();
  }
  internalUpdatePosition() {
    return new Promise((resolve) => {
      if (!this.contentElement ||
        !this.popupElement ||
        !isSlotDefined(this.self, "overlay")) {
        resolve();
        return;
      }
      if (this.fixate) {
        return this.updateFixedPosition().then(resolve);
      }
      readTask(() => {
        // Find element that defines the point of origin for our "position: absolute"
        const offsetParent = closestAnchor(this.contentElement);
        if (offsetParent == null) {
          // When the offsetParent is null this component is currently not visible (display: none)
          resolve();
          return;
        }
        const anchor = offsetParent === document.body
          ? document.documentElement
          : offsetParent; // If anchor is document.body it needs special treatment
        // Get bounding boxes of relevant elements
        const anchorBox = anchor.getBoundingClientRect();
        const popupBox = this.popupElement.getBoundingClientRect();
        const contentBox = this.contentElement.getBoundingClientRect();
        const position = this.position;
        const positionValues = this.computePosition(
        // Determine the final position
        position, contentBox, popupBox, anchorBox, anchor);
        // Apply position values to popup
        this.applyValues(positionValues).then(resolve);
      });
    });
  }
  computeWidth(position, anchorBox, contentBox) {
    const isContentDefined = getNamedSlottedContent(this.self);
    if ((isContentDefined === null || isContentDefined === void 0 ? void 0 : isContentDefined.length) > 0) {
      return contentBox.width;
    }
    if (position === "top" || position === "bottom") {
      const anchorPosition = this.anchorposition;
      if (anchorPosition === "left") {
        return (anchorBox.width - (contentBox.left - anchorBox.left) - OFFSET_BORDER_X);
      }
      else if (anchorPosition === "right") {
        return contentBox.right - anchorBox.left - OFFSET_BORDER_X;
      }
    }
  }
  computePosition(position, contentBox, popupBox, anchorBox, anchor) {
    if (position === "top" || position === "bottom") {
      const left = contentBox.left -
        anchorBox.left +
        anchor.scrollLeft +
        (this.anchorposition === "left"
          ? 0
          : contentBox.width - popupBox.width);
      const width = this.computeWidth(position, anchorBox, contentBox);
      let top;
      let bottom;
      if (position === "top") {
        const relativeValue = anchor === document.documentElement
          ? anchor.clientHeight
          : anchorBox.bottom;
        bottom =
          relativeValue - contentBox.top - anchor.scrollTop + this.offsety;
      }
      else {
        const relativeValue = anchor === document.documentElement ? 0 : anchorBox.top;
        top =
          contentBox.bottom - relativeValue + anchor.scrollTop + this.offsety;
      }
      return {
        left: `${left}px`,
        top: top != null ? `${top}px` : null,
        bottom: bottom != null ? `${bottom}px` : null,
        width: `${width}px`,
        height: `auto`,
      };
    }
    if (position === "left" || position === "right") {
      const top = contentBox.top - anchorBox.top + anchor.scrollTop;
      const height = contentBox.height;
      let left;
      if (position === "left") {
        left =
          contentBox.left -
            anchorBox.left +
            anchor.scrollLeft -
            popupBox.width -
            this.offsetx;
      }
      else {
        left =
          contentBox.right -
            anchorBox.left +
            anchor.scrollLeft +
            this.offsetx +
            anchorBox.width;
      }
      return {
        top: `${top}px`,
        bottom: null,
        left: `${left}px`,
        width: `auto`,
        height: `${height}px`,
      };
    }
  }
  applyValues(values) {
    return new Promise((resolve) => {
      writeTask(() => {
        var _a, _b, _c, _d, _e;
        if (this.hidePopup) {
          onNextFrame(() => {
            this.hidePopup = false;
            forceUpdate(this);
          });
        }
        this.popupElement.style.setProperty("top", (_a = values.top) !== null && _a !== void 0 ? _a : null);
        this.popupElement.style.setProperty("left", (_b = values.left) !== null && _b !== void 0 ? _b : null);
        this.popupElement.style.setProperty("bottom", (_c = values.bottom) !== null && _c !== void 0 ? _c : null);
        this.popupElement.style.setProperty("width", (_d = (this.disabled ? "0" : values.width)) !== null && _d !== void 0 ? _d : null);
        this.popupElement.style.setProperty("height", (_e = values.height) !== null && _e !== void 0 ? _e : null);
        resolve();
      });
    });
  }
  obtainContentRef(element) {
    this.contentElement = element;
    if (!this.resizeObserver && this.disabled) {
      this.internalUpdatePosition();
    }
    this.initializeResizeObserver();
  }
  obtainPopupRef(element) {
    this.popupElement = element;
    this.updatePosition();
  }
  render() {
    const isHidden = this.hidePopup || !isSlotDefined(this.self, "overlay");
    return (h(Host, null, h("div", { style: {
        display: this.contentdisplay,
      }, ref: (el) => this.obtainContentRef(el) }, h("slot", null)), h("div", { class: {
        popup: true,
        disabled: this.disabled,
        fixate: this.fixate,
        "is-hidden": isHidden,
        "not-interactive": !this.popupinteractable,
      }, ref: (el) => this.obtainPopupRef(el) }, h("slot", { name: "overlay" }))));
  }
  get self() { return getElement(this); }
  static get watchers() { return {
    "disabled": ["onDisabledChanged"]
  }; }
};
function closestAnchor(element) {
  return (findUpperElementByPredicate(element, (elem) => {
    if (!(elem instanceof HTMLElement || elem instanceof SVGElement)) {
      return false;
    }
    const computedStyle = getComputedStyle(elem, null);
    const positionValue = computedStyle.getPropertyValue("position");
    const transformValue = computedStyle.getPropertyValue("transform");
    /**
     * positionValue !== "static": When the CSS-position of the element is not "static" it defines a relative positioning for it's children.
     * transformValue !== "none": When the CSS-transform of the element is defined (e.g. translateX(0px)) it also defines a relative positioning for it's children.
     *
     * So both conditions are independently valid for an element to be an anchor.
     */
    return positionValue !== "static" || transformValue !== "none";
  }) || document.body);
}
const OFFSET_BORDER_X = 24;
DxOverlay.style = dxOverlayCss;

const dxPopupCss = ":host{position:absolute;bottom:0;left:0;width:100%;z-index:100;display:block}:host:host([hidden]){display:none !important}:host .base{position:absolute;top:var(--dx-popup-offset-top, 1px);left:var(--dx-popup-offset-left, initial);right:var(--dx-popup-offset-right, initial);z-index:100}:host .base.invisible{opacity:0}:host .base .popup{padding-bottom:16px}:host .base .popup .arrow-up{width:0;height:0;border-left:5px solid transparent;border-right:5px solid transparent;border-bottom:6px solid #ffffff;position:relative;left:8px}:host .base .popup.right .arrow-up{left:15px}:host .base .popup .bubble{width:max-content;max-width:100%;display:block;background-color:#ffffff;box-shadow:0 4px 12px 0 rgba(0, 0, 0, 0.32)}:host .base .popup .bubble .content{white-space:break-spaces;text-align:left;padding:4px 8px}:host:host(:not(.error)) .base{max-width:min(344px, 100%)}:host:host(.error){--dx-text-color:#ffffff}:host:host(.error) .base{width:100%}:host:host(.error) .base .popup .arrow-up{border-bottom-color:var(--dx-popup-color, #9d2235)}:host:host(.error) .base .popup .bubble{background-color:var(--dx-popup-color, #9d2235)}:host:host(.ds-theme) .base{top:var(--dx-popup-offset-top, 1px);left:var(--dx-popup-offset-left, initial);right:var(--dx-popup-offset-right, initial)}:host:host(.ds-theme) .base .popup .arrow-up{border-bottom:6px solid #ffffff}:host:host(.ds-theme) .base .popup .bubble{background-color:#ffffff;border-radius:var(--dx-popup-border-radius, 4px)}:host:host(.ds-theme) .base .popup .bubble .content{--ds-text-font-size:14px;--ds-text-letter-spacing:0.02px;--ds-text-line-height:20px}:host:host(.ds-theme):host(.error){--ds-text-color:#ffffff}:host:host(.ds-theme):host(.error) .base .popup .arrow-up{border-bottom-color:var(--dx-popup-color, #be1413)}:host:host(.ds-theme):host(.error) .base .popup .bubble{background-color:var(--dx-popup-color, #be1413)}:host .right{-moz-transform:scale(-1, 1);-webkit-transform:scale(-1, 1);-o-transform:scale(-1, 1);-ms-transform:scale(-1, 1);transform:scale(-1, 1)}";

const DxPopup = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.iconWidth = 34;
    this.internalArrowPosition = "left";
    this.internalDirection = "left";
    /**
     * Show info or error popup
     */
    this.type = "info";
    /**
     * Is popup displayed?
     */
    this.show = false;
    /**
     * Uses old theme from <ds-popup>
     */
    this.dstheme = false;
    /**
     * Specifies the position of the arrow.
     */
    this.arrowposition = "left";
    /**
     * Specifies the width behavior of the popup bubble.
     * @value parent: width will increases until it matches the parent size
     * @value unconstrained: width will increase unconstrained
     */
    this.contentwidth = "parent";
  }
  onDirectionChange() {
    this.internalDirection = this.arrowposition;
    this.internalArrowPosition = this.arrowposition;
  }
  onResize() {
    this.updatePopupDirection();
  }
  componentWillLoad() {
    this.internalDirection = this.arrowposition;
    this.internalArrowPosition = this.arrowposition;
  }
  componentDidRender() {
    this.updatePopupDirection();
  }
  updatePopupDirection() {
    writeTask(() => {
      if (this.base) {
        this.base.classList.add("invisible");
        if (this.contentwidth === "unconstrained") {
          this.bubble.style.maxWidth = "inherit";
        }
        else if (this.contentwidth === "parent") {
          this.bubble.style.maxWidth = "100%";
        }
        onNextFrame(() => {
          var _a, _b, _c;
          if (this.arrowposition === "left" &&
            this.contentwidth === "unconstrained") {
            const popUpOffsetLeft = (_a = getComputedStyle(this.self).getPropertyValue("--dx-popup-offset-left")) !== null && _a !== void 0 ? _a : null;
            readTask(() => {
              const space = this.availableSpace();
              writeTask(() => {
                var _a, _b, _c, _d, _e, _f, _g, _h;
                if (space.right > 100) {
                  this.internalDirection = "left";
                  (_b = (_a = this.bubble) === null || _a === void 0 ? void 0 : _a.style) === null || _b === void 0 ? void 0 : _b.setProperty("max-width", `${space.right}px`);
                  (_d = (_c = this.base) === null || _c === void 0 ? void 0 : _c.style) === null || _d === void 0 ? void 0 : _d.setProperty("left", popUpOffsetLeft);
                }
                else {
                  this.internalDirection = "right";
                  (_f = (_e = this.bubble) === null || _e === void 0 ? void 0 : _e.style) === null || _f === void 0 ? void 0 : _f.setProperty("max-width", `${space.left}px`);
                  (_h = (_g = this.base) === null || _g === void 0 ? void 0 : _g.style) === null || _h === void 0 ? void 0 : _h.setProperty("left", `${this.calculateOffset(popUpOffsetLeft)}px`);
                }
              });
            });
          }
          (_c = (_b = this.base) === null || _b === void 0 ? void 0 : _b.classList) === null || _c === void 0 ? void 0 : _c.remove("invisible");
        });
      }
    });
  }
  availableSpace() {
    const docRect = document.body.getBoundingClientRect();
    const selfRect = this.self.getBoundingClientRect();
    return {
      left: selfRect.x,
      right: docRect.width - selfRect.x,
    };
  }
  calculateOffset(popUpOffsetLeft) {
    const popupOffsetLeft = isNaN(parseInt(popUpOffsetLeft))
      ? 0
      : parseInt(popUpOffsetLeft);
    const offset = -this.base.offsetWidth + this.iconWidth + popupOffsetLeft;
    return offset;
  }
  renderPopup() {
    if (this.show) {
      return (h("dx-overlay", { position: "bottom", fixate: true, fixatewidth: this.type === "error" ? undefined : 344, onFixedAlignmentChange: (e) => {
          this.internalArrowPosition = e.detail;
        } }, 
      // We insert a div which orients on the parent width because the overlay needs a content to compute the correct width
      h("div", null), h("div", { slot: "overlay", class: "base invisible", ref: (el) => (this.base = el) }, h("div", { class: {
          popup: true,
          right: this.internalArrowPosition === "right" ||
            this.internalDirection === "right",
        } }, h("div", { class: "arrow-up" }), h("div", { class: "bubble", ref: (r) => (this.bubble = r) }, h("div", { class: {
          content: true,
          right: this.internalArrowPosition === "right" ||
            this.internalDirection === "right",
        } }, h("slot", null)))))));
    }
  }
  render() {
    return (h(Host, { class: {
        error: this.type === "error",
        "ds-theme": this.dstheme,
      } }, this.renderPopup()));
  }
  get self() { return getElement(this); }
  static get watchers() { return {
    "arrowposition": ["onDirectionChange"]
  }; }
};
DxPopup.style = dxPopupCss;

export { DxOverlay as dx_overlay, DxPopup as dx_popup };
