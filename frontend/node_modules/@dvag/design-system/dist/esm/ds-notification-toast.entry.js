import { r as registerInstance, c as createEvent, h, H as Host, g as getElement } from './index-04c470ea.js';
import { E as ElementIdGenerator } from './element-id-handling-bb37154e.js';
import { w as waitAnimationFrames } from './misc-util-d3b69f2c.js';
import { H as HeaderService } from './header-service-3e7097ef.js';
import { V as ValueStore } from './value-store-f4663db1.js';
import { B as BreakpointAware } from './breakpoint-aware-0017fabb.js';
import './multicast-observable-f2e53ec0.js';

const NOTIFICATION_SERVICE_KEY = "ds-notification-service";
class NotificationService {
  constructor() {
    this.currentNotificationToasts = [];
    this.notificationCloseHandle = (e) => this.internalCloseNotification(e.target);
  }
  static instance() {
    return ValueStore.instance().getOrPut(NOTIFICATION_SERVICE_KEY, () => new NotificationService());
  }
  connect() {
    this.resizeObserver = new ResizeObserver(() => {
      this.updatePositions();
    });
    this.breakpointAware = new BreakpointAware(() => {
      this.updatePositions();
    });
    this.subscribeToHeaderChanges();
  }
  disconnect() {
    var _a, _b;
    (_a = this.resizeObserver) === null || _a === void 0 ? void 0 : _a.disconnect();
    (_b = this.breakpointAware) === null || _b === void 0 ? void 0 : _b.disconnect();
    this.headerHeightSubscription.unsubscribe();
    this.headerHeightSubscription = null;
  }
  addNotificationToast(notification) {
    if (this.currentNotificationToasts.includes(notification)) {
      return;
    }
    if (this.resizeObserver == null || this.breakpointAware == null) {
      this.connect();
    }
    this.currentNotificationToasts.push(notification);
    notification.addEventListener("closeNotification", this.notificationCloseHandle);
    this.resizeObserver.observe(notification);
    this.updatePositions();
  }
  internalCloseNotification(notificationToClose) {
    this.currentNotificationToasts = this.currentNotificationToasts.filter((notification) => {
      return notificationToClose !== notification;
    });
    notificationToClose.removeEventListener("closeNotification", this.notificationCloseHandle);
    this.resizeObserver.unobserve(notificationToClose);
    if (this.currentNotificationToasts.length === 0) {
      this.disconnect();
    }
    else {
      this.updatePositions();
    }
  }
  getMargin() {
    return this.breakpointAware.xs ? 16 : 24;
  }
  updatePositions() {
    const currentMargin = this.getMargin();
    let referencePositionY = this.currentHeaderHeight + currentMargin;
    this.currentNotificationToasts.forEach((notification) => {
      notification.style.top = referencePositionY + "px";
      referencePositionY += notification.offsetHeight + currentMargin;
    });
  }
  setNotificationsTransition(transitionValue) {
    this.currentNotificationToasts.forEach((notification) => {
      notification.style.transition = transitionValue;
    });
  }
  subscribeToHeaderChanges() {
    const headerService = HeaderService.instance();
    this.headerHeightSubscription = headerService.headerHeight$.subscribe((value) => {
      this.currentHeaderHeight = value;
      // While header moves we dont want to allow any 'top' transitions for notifications
      this.setNotificationsTransition("none");
      this.updatePositions();
      // Reset transition
      this.setNotificationsTransition("top 500ms ease-in-out");
    });
    this.currentHeaderHeight = headerService.headerHeight;
  }
}

const dsNotificationToastCss = ":host{padding:0 16px;display:none;pointer-events:none;position:fixed;left:0;z-index:1002;width:100%;box-sizing:border-box;transition:top 500ms ease-in-out}:host:host([hidden]){display:none !important}@media (min-width: 768px){:host{padding:0 24px}}@media (min-width: 1200px){:host{padding:0 32px}}:host .page-wrapped-content{max-width:1200px;margin:0 auto}:host:host(.visible){display:block}:host .flyout{pointer-events:initial;display:flex;background-color:white;border-radius:6px;box-sizing:border-box;padding:24px;box-shadow:0 4px 12px 0 rgba(0, 0, 0, 0.16);opacity:0;transform:translateY(-100px);transition:opacity 500ms ease-in-out, transform 500ms ease-in-out;will-change:opacity, transform}:host .flyout.show{opacity:1;transform:translateY(0px)}:host .flyout .content-container{display:flex;width:100%}@media (min-width: 0px){:host .flyout .content-container{flex-direction:column}}@media (min-width: 768px){:host .flyout .content-container{flex-direction:row}}:host .flyout .icon-container{display:flex;align-items:center;justify-content:center}@media (min-width: 768px){:host .flyout .icon-container{margin-right:24px}}:host .flyout .text-container{flex:1}:host .flyout .text-container .title{display:block;margin-bottom:8px}:host .flyout .text-container .subcontent{display:block;margin-top:8px}:host .flyout .close-icon-container{margin-left:24px;position:absolute;right:24px}:host ds-text{display:block}";

const DsNotificationToast = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.closeNotification = createEvent(this, "closeNotification", 7);
    this.show = false;
  }
  onVisibleChanged() {
    if (this.visible) {
      clearTimeout(this.closeHandle);
      NotificationService.instance().addNotificationToast(this.self);
      waitAnimationFrames(2).then(() => {
        this.show = this.visible;
      });
    }
  }
  connectedCallback() {
    if (this.visible) {
      NotificationService.instance().addNotificationToast(this.self);
    }
  }
  componentDidLoad() {
    requestAnimationFrame(() => {
      this.show = this.visible;
    });
  }
  closeImmediately() {
    this.closeNotification.emit();
    this.visible = false;
  }
  handleTransitionEnd(e) {
    // handleTransitionEnd is called twice because two different properties transition (opacity and transform)
    if (e.propertyName === "opacity") {
      return;
    }
    if (this.show) {
      if (Number.isInteger(this.closeafter) && this.closeafter > 0) {
        clearTimeout(this.closeHandle);
        this.closeHandle = setTimeout(() => {
          this.show = false;
        }, this.closeafter * 1000);
      }
    }
    else {
      clearTimeout(this.closeHandle);
      this.closeImmediately();
    }
  }
  renderTitle() {
    return (h("ds-text", { class: "title", type: "ftf" }, this.titlestring));
  }
  renderSubContent() {
    if (!this.subcontent) {
      return;
    }
    return (h("ds-text", { class: "subcontent", type: "itk" }, this.subcontent));
  }
  renderIcon() {
    if (!this.icon) {
      return;
    }
    return (h("div", { class: "icon-container" }, h("ds-icon", { size: 72, icon: this.icon, color: this.iconcolor })));
  }
  renderCloseButton() {
    return (h("div", { class: "close-icon-container" }, h("ds-function-icon-button", { id: ElementIdGenerator.createId(this.self, "close-button"), onClick: () => (this.show = false) }, h("ds-icon", { icon: "schliessen-dialog", size: 16 }))));
  }
  render() {
    return (h(Host, { class: { visible: this.visible } }, h("div", { class: {
        flyout: true,
        show: this.show,
        "page-wrapped-content": true,
      }, onTransitionEnd: (e) => this.handleTransitionEnd(e) }, h("div", { class: "content-container" }, this.renderIcon(), h("div", { class: "text-container" }, this.renderTitle(), h("slot", null), this.renderSubContent())), this.renderCloseButton())));
  }
  get self() { return getElement(this); }
  static get watchers() { return {
    "visible": ["onVisibleChanged"]
  }; }
};
DsNotificationToast.style = dsNotificationToastCss;

export { DsNotificationToast as ds_notification_toast };
