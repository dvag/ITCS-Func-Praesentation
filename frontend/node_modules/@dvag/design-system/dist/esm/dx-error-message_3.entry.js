import { r as registerInstance, c as createEvent, f as forceUpdate, h, H as Host, g as getElement } from './index-04c470ea.js';
import { c as clamp } from './math-util-3928f6c7.js';
import { a as assert } from './assert-7fc7463a.js';
import { n as isOverflown } from './misc-util-d3b69f2c.js';
import { E as ElementIdGenerator, v as verifyElementId } from './element-id-handling-bb37154e.js';
import { o as onNextFrame } from './render-util-1dee6655.js';
import { h as hasError, E as ErrorMessage } from './error-076bca5b.js';
import './value-store-f4663db1.js';

const dxErrorMessageCss = ":host{display:block}:host:host([hidden]){display:none !important}:host .error-container{margin-top:4px;display:flex;align-items:flex-start}:host .error-container .error-icon{flex:0 0 16px;margin-right:4px}@media (min-width: 1280px){:host .error-container .error-icon{margin-top:2px}}:host .error-container .error-message.ellipse{display:-webkit-box;-webkit-line-clamp:var(--dx-error-message-lines);-webkit-box-orient:vertical;overflow:hidden}:host .link{display:block;margin-top:4px;margin-left:20px;white-space:nowrap}";

const DxErrorMessage = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.forceUpdateOnChange = createEvent(this, "forceUpdateOnChange", 7);
    /**
     * The number of lines the error message should display.
     *
     * @value 1, 2, 3: The number of lines the text can display simultaneously.
     * @value all: The error message will not be clipped. This mode should only be used in important cases.
     *
     * @example lines
     */
    this.lines = 1;
    this.showCompleteMessage = false;
    this.showLink = false;
  }
  onLinesChanged() {
    this.checkLines();
  }
  connectedCallback() {
    this.initializeMutationObserver();
    this.resizeObserver = new ResizeObserver(() => {
      this.updateView();
    });
    // connectedCallback does not trigger a re-render (which updates the resizeObserver)
    // when the element is deattached and attached again so we have to explicitly observe the
    // textElement if it is not null
    if (this.textElement) {
      this.resizeObserver.observe(this.textElement);
    }
    this.forceUpdateOnChange.emit((ref) => {
      this.forceUpdateReference = ref;
      if (ref) {
        forceUpdate(ref);
      }
    });
  }
  disconnectedCallback() {
    var _a, _b;
    (_a = this.resizeObserver) === null || _a === void 0 ? void 0 : _a.disconnect();
    (_b = this.mutationObserver) === null || _b === void 0 ? void 0 : _b.disconnect();
    if (this.forceUpdateReference) {
      forceUpdate(this.forceUpdateReference);
      this.forceUpdateReference = null;
    }
  }
  initializeMutationObserver() {
    this.mutationObserver = new MutationObserver(() => {
      // We want to reset the showCompleteMessage state because we want to check if the current text is ellipsed.
      const tmpShowCompleteMessage = this.showCompleteMessage;
      this.showCompleteMessage = false;
      forceUpdate(this);
      if (this.forceUpdateReference) {
        forceUpdate(this.forceUpdateReference);
      }
      onNextFrame(() => {
        this.updateView();
        // If the text is ellipsed (showLink => true) we want to reset the showCompleteMessage property to it's former state.
        // Otherwise there is no link and showCompleteMessage has to be false.
        this.showCompleteMessage = tmpShowCompleteMessage && this.showLink;
      });
    });
    this.mutationObserver.observe(this.self, {
      subtree: true,
      characterData: true,
      childList: true,
    });
  }
  updateView() {
    // When the text is cut we want to show the "more"-link
    this.showLink =
      this.lines !== "all" &&
        (this.showCompleteMessage ||
          (this.self.textContent && isOverflown(this.textElement)));
  }
  checkLines() {
    var _a;
    if (this.lines === "all") {
      return;
    }
    const clampedLines = clamp((_a = this.lines) !== null && _a !== void 0 ? _a : 1, 1, 3);
    assert(clampedLines === this.lines, () => `The 'lines' has to be 1, 2 or 3. Current value: ${this.lines}`, this.self);
    this.lines = clampedLines;
  }
  setTextElement(element) {
    this.textElement = element;
    if (this.textElement) {
      this.resizeObserver.observe(this.textElement);
    }
  }
  renderLink() {
    if (!this.showLink) {
      return;
    }
    const linkText = this.showCompleteMessage
      ? "Weniger anzeigen"
      : "Mehr anzeigen";
    return (h("dx-link", { id: ElementIdGenerator.createId(this.self, "show-more"), class: "link", onClick: () => {
        this.showCompleteMessage = !this.showCompleteMessage;
      } }, h("dx-text", { type: "its" }, linkText)));
  }
  render() {
    if (this.self.textContent.length <= 0) {
      return;
    }
    return (h(Host, { style: {
        "--dx-error-message-lines": this.lines.toString(),
      } }, h("div", { class: "error-container" }, h("dx-icon", { class: "error-icon", icon: "state-error", color: "error", size: 16 }), h("dx-text", { type: "its-bold", color: "error", class: {
        "error-message": true,
        ellipse: !this.showCompleteMessage && this.lines !== "all",
      }, ref: (ref) => this.setTextElement(ref) }, h("slot", null))), this.renderLink()));
  }
  get self() { return getElement(this); }
  static get watchers() { return {
    "lines": ["onLinesChanged"]
  }; }
};
DxErrorMessage.style = dxErrorMessageCss;

const dxFormWrapperCss = ":host{display:block}:host:host([hidden]){display:none !important}:host .form-container .slot-container{padding:0;box-sizing:border-box;transition:padding 250ms ease-in-out}:host .form-container .slot-container.error{padding:8px 16px;background-color:#f5e9eb;border:1px solid #9d2235;--dx-list-item-background-color-active:#d8a7ae;--dx-list-item-background-color-hover:#ebd3d7;--dx-list-item-background-color-default:#f5e9eb}";

const DxFormWrapper = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    /**
     * Indicates that the form is synced with KI.
     * @value true: Synchronized.
     * @value false: Not synchronized.
     * @example kisynced
     */
    this.kisynced = false;
  }
  componentDidLoad() {
    verifyElementId(this.self);
  }
  onForceUpdateOnChange(e) {
    e.stopPropagation();
    e.detail(this.self);
  }
  render() {
    return (h(Host, null, h("div", { class: {
        "form-container": true,
      } }, h("dx-input-label", { type: "ps", class: "input-label", label: this.label, required: this.required, kisynced: this.kisynced, condensedlayout: true }), h("div", { class: {
        "slot-container": true,
        error: hasError(this.self),
      } }, h("slot", null)), h(ErrorMessage, { self: this.self, message: this.errormessage, forceUpdateOnChange: (e) => {
        e.detail(this.self);
      } }))));
  }
  get self() { return getElement(this); }
};
DxFormWrapper.style = dxFormWrapperCss;

const dxLinkCss = ":host:host([hidden]){display:none !important}:host a{cursor:pointer;text-decoration:none;--dx-text-internal-text-decoration:underline;--dx-text-internal-color:#337a96;--dx-icon-internal-color:#337a96;--dx-text-text-decoration:underline;--dx-text-color:#337a96;--dx-icon-color:#337a96}:host a:hover{--dx-text-color:#00587c;--dx-icon-color:#00587c}:host a:active{--dx-text-color:#004763;--dx-icon-color:#004763}:host a:focus-visible{outline-offset:2px;outline:2px solid #004763}";

const DxLink = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
  }
  render() {
    return (h("a", { href: this.url, target: this.target, rel: "noreferrer noopener", tabIndex: 0 }, h("slot", null)));
  }
  get self() { return getElement(this); }
};
DxLink.style = dxLinkCss;

export { DxErrorMessage as dx_error_message, DxFormWrapper as dx_form_wrapper, DxLink as dx_link };
