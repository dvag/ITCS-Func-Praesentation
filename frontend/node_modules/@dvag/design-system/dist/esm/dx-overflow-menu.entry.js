import { r as registerInstance, c as createEvent, h, f as forceUpdate, H as Host, g as getElement } from './index-04c470ea.js';
import { E as ElementIdGenerator } from './element-id-handling-bb37154e.js';
import { c as createMetaComponentsSlotObserver } from './slot-observer-9196738e.js';
import { a as assert, c as assertPropertyValue } from './assert-7fc7463a.js';
import { i as isPositiveInteger } from './math-util-3928f6c7.js';
import './value-store-f4663db1.js';
import './query-util-02753b43.js';

const dxOverflowMenuCss = ":host{display:block;--dx-flyout-simple-grow-box-width:fit-content;--dx-flyout-simple-grow-box-min-width:192px;--dx-overlay-popup-max-width:max-content;--dx-overlay-offset:40px;text-align:left}:host:host([hidden]){display:none !important}:host:host(.align-right){text-align:right;display:flex;flex-direction:column;align-items:flex-end}:host:host(.mock-list-item-width){--dx-list-mock-icon-container-width:40px}:host .list-flyout{min-width:192px}";

const DxOverflowMenu = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.selection = createEvent(this, "selection", 7);
    this.listOpenChange = createEvent(this, "listOpenChange", 7);
    /**
     * The alignment defines in which direction the menu button aligns.
     *
     * @value left: The menu button is displayed on the left and the list anchors on the left of the button.
     * @value right: The menu button is displayed on the right and the list anchors on the right of the button.
     *
     * @example align
     */
    this.align = "left";
    /**
     * Defines whether the user is able to select only one or multiple menu items.
     *
     * @value single: The user can select only one menu-item which immediately closes the flyout.
     * @value multi: The user is able to select multiple menu items.
     *
     * @example selection-mode
     */
    this.selectionmode = "single";
    /**
     * Defines the maximum number of selected menu-item labels the menu displays.
     * This property only has an effect if the `selectionmode` is `multi`.
     *
     * @value number: A number greater than zero which defines the upper limit of labels being displayed in the menu.
     * @value undefined: All selected labels are displayed in the menu.
     * @example max-labels
     */
    this.maxlabels = 1;
    this.listOpen = false;
  }
  onListOpenChanged() {
    this.listOpenChange.emit({
      isOpen: this.listOpen,
    });
  }
  connectedCallback() {
    this.menuItemsObserver =
      createMetaComponentsSlotObserver(this.self, "dx-overflow-menu-item", async (nodes) => {
        await this.collectMenuItems(nodes);
        this.updateInternalLabel();
      });
  }
  disconnectedCallback() {
    this.menuItemsObserver.disconnect();
  }
  componentWillRender() {
    assert(this.maxselections == null || isPositiveInteger(this.maxselections), () => "The `maxselections` property has to be a natural number greater than zero ([1,2,3,...]) or undefined.", this.self);
    assert(this.maxlabels == null || isPositiveInteger(this.maxlabels), () => "The `maxlabels` property has to be a natural number greater than zero ([1,2,3,...]) or undefined.", this.self);
    assertPropertyValue("dx-overflow-menu", "selectionmode", this.selectionmode, ["single", "multi"], this.self);
  }
  onItemSelectionChange(e) {
    var _a;
    e.stopPropagation();
    const selectedValues = (_a = e.detail) === null || _a === void 0 ? void 0 : _a.selectedItems;
    this.emitSelection(selectedValues);
    if (this.selectionmode === "single") {
      this.listOpen = false;
    }
    this.updateMenuItems(selectedValues);
    this.updateInternalLabel();
  }
  updateMenuItems(selectedValues) {
    this.menuItems.forEach((menuItem) => {
      menuItem.setSelected(selectedValues.find((value) => value === menuItem.value) != null);
    });
  }
  // Computes the internalLabel dependent on the provided selected values
  updateInternalLabel() {
    if (this.selectionmode === "single") {
      this.internalLabel = ""; // Reset internalLabel just in case
    }
    else if (this.selectionmode === "multi") {
      this.internalLabel = this.computeInternalLabel();
    }
  }
  computeInternalLabel() {
    const selectedMenuItemValues = this.menuItems
      .filter((menuItem) => menuItem.selected)
      .map((menuItem) => menuItem.value);
    const currentLabels = selectedMenuItemValues
      .map((value) => {
      return this.menuItems.find((menuItem) => menuItem.value === value);
    })
      .map((menuItem) => menuItem.label);
    const displayValues = currentLabels.slice(0, this.maxlabels);
    const diff = selectedMenuItemValues.length - displayValues.length;
    const joinSeparator = ", ";
    if (diff === 0) {
      return displayValues.join(joinSeparator);
    }
    return displayValues.join(joinSeparator) + ` (+${diff})`;
  }
  emitSelection(values) {
    const emittedValue = this.selectionmode === "single" ? values[0] : values;
    this.selection.emit({
      value: emittedValue,
    });
  }
  async collectMenuItems(menuItems) {
    this.menuItems = await Promise.all(menuItems.map((menuItem) => menuItem.toOverflowMenuItem()));
  }
  onInputKeyDown(event) {
    const listFlyoutElement = this.self.shadowRoot.querySelector("dx-list-flyout");
    if (event.target === listFlyoutElement) {
      return;
    }
    if ((listFlyoutElement === null || listFlyoutElement === void 0 ? void 0 : listFlyoutElement.open) && event.code !== "Tab") {
      // If the flyout is open we want to prevent all keyboard inputs and delegate it to the list flyout.
      event.preventDefault();
      listFlyoutElement === null || listFlyoutElement === void 0 ? void 0 : listFlyoutElement.dispatchEvent(new event.constructor(event.type, event));
    }
    else if (event.code === "ArrowDown") {
      this.listOpen = true;
    }
  }
  renderButtonIconSlot() {
    var _a, _b;
    if (((_a = this.internalLabel) === null || _a === void 0 ? void 0 : _a.length) > 0 || ((_b = this.label) === null || _b === void 0 ? void 0 : _b.length) > 0) {
      return (h("dx-chevron", { size: 24, slot: "icon", directiontop: this.listOpen }));
    }
    else {
      return (h("dx-element-swapper", { active: this.listOpen ? "second" : "first", slot: "icon" }, h("dx-icon", { icon: "ueberlauf-menue", slot: "first", size: 24 }), h("dx-icon", { icon: "schliessen", slot: "second", size: 24 })));
    }
  }
  renderTextButton() {
    return (h("dx-button", { id: ElementIdGenerator.createId(this.self, "menu-button"), class: {
        "simulate-active": this.listOpen,
      }, onKeyDown: (e) => this.onInputKeyDown(e), type: "text", slot: "base", label: this.internalLabel || this.label, onClick: () => (this.listOpen = !this.listOpen), iconposition: "right" }, this.renderButtonIconSlot()));
  }
  render() {
    var _a, _b;
    return (h(Host, { onBlur: () => {
        this.listOpen = false;
      }, class: {
        "align-right": this.align === "right",
        "mock-list-item-width": (_a = this.menuItems) === null || _a === void 0 ? void 0 : _a.some((menuItem) => { var _a; return ((_a = menuItem.icon) === null || _a === void 0 ? void 0 : _a.length) > 0; }),
      } }, this.renderTextButton(), h("dx-list-flyout", { class: "list-flyout", open: this.listOpen, direction: this.align === "left" ? "right" : "left", itemsvisible: 5.5, size: "m", selectionmode: this.selectionmode, selectonhighlight: false, clearselectiononclose: this.selectionmode === "single", maxselections: this.maxselections, ref: (ref) => forceUpdate(ref) }, (_b = this.menuItems) === null || _b === void 0 ? void 0 : _b.map((item, index) => {
      var _a;
      return (h("dx-list-item", { id: (_a = ElementIdGenerator.createIdFromString(item.id, "list-item")) !== null && _a !== void 0 ? _a : ElementIdGenerator.createId(this.self, `list-item-${index}`), label: item.label, value: item.value, icon: item.icon, selected: item.selected, type: this.selectionmode === "single" ? "clickable" : "checkbox" }));
    }))));
  }
  get self() { return getElement(this); }
  static get watchers() { return {
    "listOpen": ["onListOpenChanged"]
  }; }
};
DxOverflowMenu.style = dxOverflowMenuCss;

export { DxOverflowMenu as dx_overflow_menu };
