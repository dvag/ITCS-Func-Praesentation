import { r as registerInstance, c as createEvent, h, H as Host, g as getElement } from './index-04c470ea.js';
import { E as ElementIdGenerator } from './element-id-handling-bb37154e.js';
import { o as onNextFrame } from './render-util-1dee6655.js';
import { c as clamp } from './math-util-3928f6c7.js';
import { D as DateUtils, f as formatToYear } from './date.utils-73541332.js';
import { R as ReadonlyTextElement } from './base-elements-20abac26.js';
import { D as DateErrorType } from './date-8e39cc7d.js';
import { I as InputContainer } from './input-container-97f842b4.js';
import { a as isActiveElement } from './misc-util-d3b69f2c.js';
import './value-store-f4663db1.js';

class InputController {
  constructor(minValue, maxValue, disabled, formatter, maxCharacters) {
    this.minValue = minValue;
    this.maxValue = maxValue;
    this.disabled = disabled;
    this.formatter = formatter;
    this.maxCharacters = maxCharacters;
    this.inputElement = null;
    this.lastValue = "";
    this.valueBeforeFocus = "";
  }
  focus() {
    var _a, _b;
    this.lastValue = (_a = this.inputElement) === null || _a === void 0 ? void 0 : _a.value;
    this.valueBeforeFocus = this.lastValue;
    (_b = this.inputElement) === null || _b === void 0 ? void 0 : _b.focus();
  }
  setValue(value) {
    if (this.disabled) {
      value = DateUtils.withMultipleLeadingZeros(this.minValue, 4);
    }
    this.internalSetValue(value == null || isNaN(+value) ? "" : value.toString());
    this.format();
  }
  setInputElementValue(value) {
    if (this.inputElement != null) {
      this.inputElement.value = value;
    }
  }
  internalSetValue(value) {
    this.setInputElementValue(value);
    this.lastValue = value;
  }
  sendInput(input) {
    var _a;
    // Does not set lastValue because input event is dispatched
    this.setInputElementValue(input);
    const evt = new Event("input", {
      bubbles: true,
      cancelable: true,
    });
    evt["data"] = input;
    evt["insertType"] = "insertText";
    (_a = this.inputElement) === null || _a === void 0 ? void 0 : _a.dispatchEvent(evt);
  }
  preventInput(input, inputType) {
    if (/delete|history/.test(inputType)) {
      return false;
    }
    // "." doesn't do anything before the user didn't make his first input
    if (input === ".") {
      if (this.lastValue !== this.valueBeforeFocus) {
        this.finish();
      }
      return true;
    }
    const inputNumber = Number(input);
    if (isNaN(inputNumber)) {
      return true;
    }
  }
  onInput(e) {
    e.preventDefault();
    const currentValue = this.inputElement.value;
    if (this.preventInput(e.data, e.inputType)) {
      // In case there was no input we want to keep the previous selection
      if (this.lastValue === this.valueBeforeFocus) {
        requestAnimationFrame(() => {
          this.inputElement.select();
        });
      }
      this.internalSetValue(this.lastValue);
      return;
    }
    const newValue = currentValue.substr(0, this.maxCharacters);
    this.internalSetValue(newValue);
    if (newValue.length === this.maxCharacters) {
      this.finish();
    }
  }
  get formattedValue() {
    var _a, _b;
    return (_b = this.formatter((_a = this.inputElement) === null || _a === void 0 ? void 0 : _a.value)) !== null && _b !== void 0 ? _b : "";
  }
  getDisabled() {
    return this.disabled;
  }
  setDisabled(disabled) {
    this.disabled = !!disabled;
  }
  finish() {
    var _a;
    (_a = this.onFinished) === null || _a === void 0 ? void 0 : _a.call(this);
    this.format();
  }
  format() {
    var _a, _b, _c, _d, _e;
    const currentValue = parseInt((_a = this.inputElement) === null || _a === void 0 ? void 0 : _a.value);
    if (isNaN(currentValue)) {
      this.internalSetValue("");
      return;
    }
    const newValue = clamp(currentValue, this.minValue, this.maxValue);
    if (newValue === currentValue) {
      this.internalSetValue((_b = this.formatter) === null || _b === void 0 ? void 0 : _b.call(this, (_c = this.inputElement) === null || _c === void 0 ? void 0 : _c.value));
    }
    else {
      this.internalSetValue((_e = (_d = this.formatter) === null || _d === void 0 ? void 0 : _d.call(this, newValue.toString())) !== null && _e !== void 0 ? _e : "");
    }
  }
  isEmpty() {
    var _a, _b, _c;
    return this.disabled || ((_c = (_b = (_a = this.inputElement) === null || _a === void 0 ? void 0 : _a.value) === null || _b === void 0 ? void 0 : _b.length) !== null && _c !== void 0 ? _c : 0) === 0;
  }
  clearInput() {
    if (!this.disabled && this.inputElement != null) {
      this.internalSetValue(null);
    }
  }
  onFocus() {
    if (this.inputElement.value.length > 0) {
      this.focus();
      this.inputElement.select();
    }
  }
  onBlur() {
    this.valueBeforeFocus = this.lastValue;
    this.format();
  }
  setInputElement(el) {
    if (this.inputElement !== el) {
      this.inputElement = el;
      onNextFrame(() => {
        this.format();
      });
    }
  }
  incrementValue() {
    const currentValue = this.inputElement.value;
    const newValue = currentValue === ""
      ? this.minValue
      : parseInt(this.inputElement.value) + 1;
    this.setValue(newValue % (this.maxValue + 1));
    requestAnimationFrame(() => {
      this.inputElement.select();
    });
  }
  decrementValue() {
    const currentValue = this.inputElement.value;
    const newValue = currentValue === ""
      ? this.maxValue
      : parseInt(this.inputElement.value) - 1;
    const lessThanMin = newValue - this.minValue < 0;
    const newComputedValue = lessThanMin
      ? this.maxValue + (newValue - this.minValue) + 1
      : newValue % (this.maxValue + 1);
    this.setValue(newComputedValue);
    requestAnimationFrame(() => {
      this.inputElement.select();
    });
  }
}

const dsDateInputCss = ":host{display:block}:host:host([hidden]){display:none !important}:host:host([label]:not([label=\"\"])){--ds-info-button-offset-y:24px}:host:host(.disabled){pointer-events:none;--ds-text-color:#dedede;--ds-icon-color:#dedede}:host label{display:flex;flex-direction:column-reverse}:host label div .container{position:relative;top:0;left:0;display:flex;height:38px;border-radius:4px;border:1px solid #c1c1c1;background-color:#ffffff;box-sizing:border-box;align-items:center;outline:none;justify-content:flex-end}:host label div .container.required-outline{border-color:#e8b50e}:host label div .container.requirement-fulfilled{border-color:#c1c1c1}:host label div .container.red-outline{border-color:#be1413}:host label div .container.disabled-outline{border-color:#ebebeb}:host label div .container.active{border-color:#4c4c4c}:host label div .container input{height:22px;margin:8px 0 8px 8px;border:none;outline:none;font-family:\"Helvetica Neue\", \"Helvetica Neue LT W01\";font-size:16px;line-height:24px;letter-spacing:0.02px;color:#4c4c4c;width:1px;flex-grow:1;flex:none;text-align:right;margin:0}:host label div .container input::placeholder{color:#c1c1c1}:host label div .container input:disabled{background-color:#ffffff;color:#c1c1c1}:host label div .container input.day{width:2.1ch}:host label div .container input.month{width:2ch}:host label div .container input.month.empty{width:3.2ch}:host label div .container input.year{width:4ch}:host label div .container input.year.empty{width:3.6ch}:host label div .container .dot.disabled{--ds-text-color:#c1c1c1}:host label div .container .right-side{display:flex;width:28px;height:28px;justify-content:center;align-items:center}:host .read-only{text-align:right}";

const DsDateInput = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.valueChange = createEvent(this, "valueChange", 7);
    this.valueComplete = createEvent(this, "valueComplete", 7);
    this.errorFound = createEvent(this, "errorFound", 7);
    this.segmentBlur = createEvent(this, "segmentBlur", 7);
    this.dayEmpty = true;
    this.monthEmpty = true;
    this.yearEmpty = true;
    this.currentlyEditing = false;
    this.inputFocused = false;
    this.internalValue = null;
    /**
     * The current displayed date.
     *
     * @important
     * @value string: A date in following format: YYYY-MM-dd
     * @example value
     */
    this.value = null;
    /**
     * Displays the border of the input with a red color.
     * @value true: red border
     * @value false: default border
     * @example error
     */
    this.error = false;
    /**
     * Whether the input is interactable or not.
     * The label and border are grey to indicate the disabled state.
     * @value false: Input is not disabled.
     * @value true: Input is disabled.
     *
     * @example disabled
     */
    this.disabled = false;
    /**
     * Whether the input is readonly or editable.
     * If true the value of this component will be visualized as a normal text.
     * @value false: Input is editable.
     * @value true: Input is read-only.
     *
     * @example readonly
     */
    this.readonly = false;
    /**
     * Marks this input as required.
     * @value false: Input is not required
     * @value true: Input is required
     *
     * @example required
     */
    this.required = false;
    /**
     * Indicates that the form is synced with the KI.
     * @value true: Synchronized.
     * @value false: Not synchronized.
     * @example kisynced
     */
    this.kisynced = false;
    /**
     * Defines how a date can be selected or edited.
     *
     * @value "day-month-year": The user can edit three input fields: day (TT), month (MM) and year (JJJJ).
     * The calendar shows all three views (month, year and decade) for selecting a date.
     * @value "month-year": The user can edit two input fields: month (MM) and year (JJJJ).
     * The calendar shows two views (year and decade) for selecting a month.
     * @value "day-month": The user can edit two input fields: day(TT) and month (MM).
     * The calendar shows two views (month and year) for selecting a date.
     * @example mode
     */
    this.mode = "day-month-year";
    /**
     * Indicates whether a calendar is shown when focusing this component.
     *
     * @value true: The calendar is displayed when the date input is focused.
     * @value false: There is no calendar displayed when the date input is focused.
     *
     * @internal
     */
    this.calendarenabled = true;
    this.dayInputController = null;
    this.monthInputController = null;
    this.yearInputController = null;
    this.currentFocusedIndex = null;
  }
  valueChanged() {
    this.obtainValueChangesFromOutside();
  }
  readonlyChanged() {
    onNextFrame(() => {
      this.updateInputSegments();
      this.checkInputs();
    });
  }
  onModeChange() {
    this.updateInputControllerDisableStates();
  }
  /**
   * Sets the focus on the day-input element.
   * @example focus
   */
  async focusControl() {
    this.getInputController(0).focus();
  }
  /**
   * Remotely triggered by parent date range component
   * @internal
   */
  async internalForceEmitChangeEvent() {
    this.valueChange.emit(this.value);
    this.valueComplete.emit(this.value);
    this.lastEmittedChangeValue = this.value;
    this.lastEmittedCompleteValue = this.value;
  }
  connectedCallback() {
    this.initalizeInputController();
  }
  componentWillLoad() {
    const focusNextHandle = () => {
      this.focusNext();
    };
    this.dayInputController.onFinished = focusNextHandle;
    this.monthInputController.onFinished = this.isYearEnabled
      ? focusNextHandle
      : null;
    this.yearInputController.onFinished = null;
    this.checkInputs();
  }
  componentDidLoad() {
    this.updateInputSegments();
    this.updateCalendarValue();
    requestAnimationFrame(() => {
      this.checkInputs();
    });
  }
  componentWillRender() {
    this.value = DateUtils.dateToString(this.adjustDateDependantOnCurrentMode(DateUtils.newDateFromString(this.value)));
  }
  initalizeInputController() {
    this.yearInputController = new InputController(0, 9999, !this.isYearEnabled(), formatToYear, 4);
    this.monthInputController = new InputController(1, 12, !this.isMonthEnabled(), formatWithLeadingZero, 2);
    this.dayInputController = new InputController(1, 31, !this.isDateEnabled(), formatWithLeadingZero, 2);
  }
  updateInputControllerDisableStates() {
    this.dayInputController.setDisabled(!this.isDateEnabled());
    this.monthInputController.setDisabled(!this.isMonthEnabled());
    this.yearInputController.setDisabled(!this.isYearEnabled());
  }
  /**
   * Sets the date dependant on the current mode
   * E.g: If the current mode is "day-month" we have to set every date's year in this context to 0
   */
  adjustDateDependantOnCurrentMode(date) {
    if (DateUtils.isValidDate(date) && !this.isYearEnabled()) {
      const result = new Date(date);
      result.setFullYear(0);
      return result;
    }
    return date;
  }
  checkInputs() {
    this.dayEmpty = !this.isDateEnabled() || this.dayInputController.isEmpty();
    this.monthEmpty =
      !this.isMonthEnabled() || this.monthInputController.isEmpty();
    this.yearEmpty =
      !this.isYearEnabled() || this.yearInputController.isEmpty();
    this.checkValueValidity();
  }
  isDateEnabled() {
    return this.mode !== "month-year";
  }
  isMonthEnabled() {
    return true;
  }
  isYearEnabled() {
    return this.mode !== "day-month";
  }
  updateInputSegments() {
    this.dayInputController.setValue(this.day);
    this.monthInputController.setValue(this.month);
    this.yearInputController.setValue(this.year);
  }
  focusNext() {
    var _a;
    const newFocusedIndex = (((_a = this.currentFocusedIndex) !== null && _a !== void 0 ? _a : -1) + 1) % 3;
    this.focus(newFocusedIndex);
  }
  focusPrevious() {
    var _a;
    const newFocusedIndex = (((_a = this.currentFocusedIndex) !== null && _a !== void 0 ? _a : 0) + 3 - 1) % 3;
    this.focus(
    // If newFocusedIndex is 0 and we dont have a date selection we want to focus the last segment
    !this.isDateEnabled() && newFocusedIndex === 0 ? 2 : newFocusedIndex);
  }
  focus(index) {
    var _a;
    (_a = this.getInputController(index)) === null || _a === void 0 ? void 0 : _a.focus();
  }
  obtainValueChangesFromOutside() {
    var _a;
    const newValue = (_a = this.formatToDateString(this.value)) !== null && _a !== void 0 ? _a : "";
    if (this.value !== this.internalValue) {
      this.internalValue = newValue;
      this.lastEmittedChangeValue = this.value;
      this.lastEmittedCompleteValue = this.value;
      this.updateInputSegments();
      this.checkInputs();
    }
    this.checkValueValidity();
  }
  checkValueValidity() {
    let errorType = DateErrorType.NO_ERROR;
    if (this.value == null) {
      if (this.isInputValid()) {
        errorType = DateErrorType.INVALID_DATE;
      }
    }
    else if (this.min &&
      DateUtils.isBeforeDate(new Date(this.value), new Date(this.min))) {
      errorType = DateErrorType.UNDER_MIN;
    }
    else if (this.max &&
      DateUtils.isAfterDate(new Date(this.value), new Date(this.max))) {
      errorType = DateErrorType.OVER_MAX;
    }
    const newErrorMessage = this.getErrorMessage(errorType);
    if (errorType !== this.lastErrorType ||
      newErrorMessage !== this.internalErrorMessage) {
      this.internalErrorMessage = newErrorMessage;
      this.errorFound.emit({
        type: errorType,
        message: this.internalErrorMessage,
      });
      this.lastErrorType = errorType;
    }
  }
  getErrorMessage(errorType) {
    const errorToMessageMap = {
      [DateErrorType.INVALID_DATE]: () => {
        const day = this.dayInputController.formattedValue;
        const month = this.monthInputController.formattedValue;
        const year = this.yearInputController.formattedValue;
        return `Das eingegebene Datum ${day}.${month}.${year} ist nicht valide.`;
      },
      [DateErrorType.UNDER_MIN]: () => `Das eingegebene Datum muss nach dem ${this.getFormattedDisplayDate(this.min)} liegen.`,
      [DateErrorType.OVER_MAX]: () => `Das eingegebene Datum muss vor dem ${this.getFormattedDisplayDate(this.max)} liegen.`,
      [DateErrorType.NO_ERROR]: () => "",
    };
    return errorToMessageMap[errorType]();
  }
  getFormattedDisplayDate(date) {
    const formattedDate = DateUtils.getFormattedDisplayDate(date);
    if (this.mode === "day-month-year") {
      return formattedDate;
    }
    const result = formattedDate.split(".");
    if (this.mode === "day-month") {
      return `${result[0]}.${result[1]}`;
    }
    else if (this.mode === "month-year") {
      return `${result[1]}.${result[2]}`;
    }
  }
  emitValueChange() {
    if (this.lastEmittedChangeValue !== this.internalValue) {
      this.value = this.internalValue;
      this.valueChange.emit(this.value);
      this.lastEmittedChangeValue = this.value;
      this.checkInputs();
    }
  }
  emitValueComplete() {
    if (this.lastEmittedCompleteValue !== this.value) {
      this.updateCalendarValue();
      this.valueComplete.emit(this.value);
      this.lastEmittedCompleteValue = this.value;
      this.checkInputs();
    }
  }
  updateCalendarValue() {
    if (this.calendar != null) {
      this.calendar.value = this.value;
    }
  }
  isValueValid() {
    if (this.value == null) {
      return false;
    }
    const date = new Date(this.value);
    return !isNaN(date.getTime());
  }
  isInputValid() {
    const day = parseFloat(this.dayInputController.formattedValue);
    const month = parseFloat(this.monthInputController.formattedValue);
    const year = parseFloat(this.yearInputController.formattedValue);
    return day * month * year > 0;
  }
  formatToDateString(value) {
    if (value == null) {
      return null;
    }
    const date = new Date(value);
    if (isNaN(date.getTime())) {
      return null;
    }
    else {
      // Chrome translates "2021-31-02 into 02.03.2021 instead of returning an "Invalid Date"
      const splittedValue = value.split("-").map((val) => parseFloat(val));
      if (splittedValue[2] !== date.getDate() ||
        splittedValue[1] !== date.getMonth() + 1 ||
        splittedValue[0] !== date.getFullYear()) {
        return null;
      }
      return DateUtils.dateToString(date);
    }
  }
  onFocusInput() {
    this.inputFocused = true;
  }
  handleKeyInput(e) {
    if (e.code === "Enter") {
      e.target.blur();
    }
    else if (!e.code.startsWith("Arrow")) {
      if (e.code !== "Tab" &&
        !e.code.startsWith("Shift") &&
        !this.currentlyEditing) {
        this.currentlyEditing = true;
        this.currentFocusedIndex = 0;
        const inputController = this.getInputController(this.currentFocusedIndex);
        inputController.focus();
        inputController.sendInput(e.key);
        e.preventDefault();
      }
      return;
    }
    if (e.code.includes("Arrow")) {
      e.preventDefault();
      if (e.code === "ArrowLeft") {
        this.focusPrevious();
      }
      else if (e.code === "ArrowRight") {
        this.focusNext();
      }
      else if (e.code === "ArrowUp") {
        this.incrementCurrentSegment();
      }
      else if (e.code === "ArrowDown") {
        this.decrementCurrentSegment();
      }
    }
  }
  incrementCurrentSegment() {
    var _a;
    (_a = this.getInputController(this.currentFocusedIndex)) === null || _a === void 0 ? void 0 : _a.incrementValue();
    this.updateInternalValue();
  }
  decrementCurrentSegment() {
    var _a;
    (_a = this.getInputController(this.currentFocusedIndex)) === null || _a === void 0 ? void 0 : _a.decrementValue();
    this.updateInternalValue();
  }
  getInputController(index) {
    index += index === 0 && !this.isDateEnabled() ? 1 : 0;
    if (index === 0) {
      return this.dayInputController;
    }
    if (index === 1) {
      return this.monthInputController;
    }
    if (index === 2) {
      return this.yearInputController;
    }
  }
  clearInput() {
    this.dayInputController.clearInput();
    this.monthInputController.clearInput();
    this.yearInputController.clearInput();
    this.dayEmpty = true;
    this.monthEmpty = true;
    this.yearEmpty = true;
    this.updateInternalValue();
  }
  onBlur() {
    this.updateInternalValue();
    this.updateCalendarValue();
    this.segmentBlur.emit();
    onNextFrame(() => {
      if (!isActiveElement(this.self)) {
        this.currentlyEditing = false;
        this.currentFocusedIndex = null;
        this.inputFocused = false;
        this.emitValueComplete();
      }
    });
  }
  setFocusedIndex(index) {
    this.currentFocusedIndex = index;
    this.currentlyEditing = true;
  }
  get day() {
    if (this.value == null) {
      return null;
    }
    const day = new Date(this.value).getDate();
    return DateUtils.withMultipleLeadingZeros(day, 2);
  }
  get month() {
    if (this.value == null) {
      return null;
    }
    const month = new Date(this.value).getMonth() + 1;
    return DateUtils.withMultipleLeadingZeros(month, 2);
  }
  get year() {
    if (this.value == null) {
      return null;
    }
    const year = new Date(this.value).getFullYear();
    return DateUtils.withMultipleLeadingZeros(year, 4);
  }
  handleInput(e, inputController) {
    inputController.onInput(e);
    this.updateInternalValue();
  }
  updateInternalValue() {
    const newDay = !this.dayInputController.getDisabled()
      ? this.dayInputController.formattedValue
      : "01";
    const newMonth = !this.monthInputController.getDisabled()
      ? this.monthInputController.formattedValue
      : "01";
    const newYear = !this.yearInputController.getDisabled()
      ? this.yearInputController.formattedValue
      : "0000";
    // We have to check every input because 'YYYY-MM-' is a valid date for chrome. Firefox is invalid in this case.
    const newValue = newDay !== "" && newMonth !== "" && newYear !== ""
      ? this.formatToDateString(`${newYear}-${newMonth}-${newDay}`)
      : null;
    if (newValue !== this.value) {
      this.internalValue = newValue;
      this.emitValueChange();
    }
    this.checkInputs();
  }
  selectDate(date) {
    var _a;
    this.internalValue = DateUtils.dateToString(date);
    this.emitValueChange();
    const splittedValue = (_a = this.value) === null || _a === void 0 ? void 0 : _a.split("-");
    if (splittedValue != null) {
      this.dayInputController.setValue(splittedValue === null || splittedValue === void 0 ? void 0 : splittedValue[2]);
      this.monthInputController.setValue(splittedValue === null || splittedValue === void 0 ? void 0 : splittedValue[1]);
      this.yearInputController.setValue(splittedValue === null || splittedValue === void 0 ? void 0 : splittedValue[0]);
    }
    else {
      this.clearInput();
    }
    this.checkInputs();
    this.dayInputController.focus();
  }
  setCalendar(calendar) {
    if (calendar !== this.calendar) {
      this.calendar = calendar;
      this.updateCalendarValue();
    }
  }
  renderHiddenFallbackInput(inputController) {
    return (h("input", { hidden: true, tabIndex: -1, ref: (el) => {
        inputController.setInputElement(el);
      }, type: "text", disabled: true }));
  }
  renderDayInput() {
    if (this.isDateEnabled()) {
      return [
        h("input", { id: ElementIdGenerator.createId(this.self, "day-control"), tabIndex: this.currentlyEditing ? 0 : -1, ref: (el) => {
            this.dayInputController.setInputElement(el);
          }, type: "text", class: {
            day: true,
          }, onFocus: () => {
            this.setFocusedIndex(0);
            this.dayInputController.onFocus();
            this.onFocusInput();
          }, onBlur: () => {
            this.dayInputController.onBlur();
            this.onBlur();
          }, placeholder: "TT", maxLength: 2, onChange: () => this.updateInternalValue(), onInput: (event) => this.handleInput(event, this.dayInputController), disabled: this.disabled }),
        h("ds-text", { class: {
            dot: true,
            disabled: this.dayInputController.isEmpty(),
          } }, "."),
      ];
    }
    else {
      return this.renderHiddenFallbackInput(this.dayInputController);
    }
  }
  renderMonthInput() {
    if (this.isMonthEnabled()) {
      return [
        h("input", { id: ElementIdGenerator.createId(this.self, "month-control"), tabIndex: this.currentlyEditing ? 0 : -1, ref: (el) => {
            this.monthInputController.setInputElement(el);
          }, type: "text", class: {
            month: true,
            empty: this.monthEmpty,
          }, onFocus: () => {
            this.setFocusedIndex(1);
            this.monthInputController.onFocus();
            this.onFocusInput();
          }, onBlur: () => {
            this.monthInputController.onBlur();
            this.onBlur();
          }, placeholder: "MM", maxLength: 2, onChange: () => this.updateInternalValue(), onInput: (event) => this.handleInput(event, this.monthInputController), disabled: this.disabled }),
        h("ds-text", { class: {
            dot: true,
            disabled: this.monthInputController.isEmpty(),
          } }, "."),
      ];
    }
    else {
      return this.renderHiddenFallbackInput(this.monthInputController);
    }
  }
  renderYearInput() {
    if (this.isYearEnabled()) {
      return (h("input", { id: ElementIdGenerator.createId(this.self, "year-control"), tabIndex: this.currentlyEditing ? 0 : -1, class: {
          year: true,
          empty: this.yearEmpty,
        }, ref: (el) => {
          this.yearInputController.setInputElement(el);
        }, type: "text", onFocus: () => {
          this.setFocusedIndex(2);
          this.yearInputController.onFocus();
          this.onFocusInput();
        }, onBlur: () => {
          this.onBlur();
          this.yearInputController.onBlur();
        }, placeholder: "JJJJ", maxLength: 4, onChange: () => this.updateInternalValue(), onInput: (event) => this.handleInput(event, this.yearInputController), disabled: this.disabled }));
    }
    else {
      return this.renderHiddenFallbackInput(this.yearInputController);
    }
  }
  renderInput() {
    const errorMessage = this.errormessage || this.internalErrorMessage;
    const isErrorOutline = (errorMessage === null || errorMessage === void 0 ? void 0 : errorMessage.length) > 0 || this.error;
    return (h("label", { id: ElementIdGenerator.createId(this.self, "control") }, h("div", null, h("dx-overlay", { position: "bottom", offsety: 8, disabled: !this.inputFocused }, h(InputContainer, { active: this.inputFocused, error: isErrorOutline, required: this.required, requirementFulfilled: this.isValueValid(), disabled: this.disabled, custom: {
        tabIndex: this.currentlyEditing || this.disabled ? -1 : 0,
        onFocus: () => this.onFocusInput(),
        onBlur: () => this.onBlur(),
        onInput: () => this.checkInputs(),
        onKeyDown: (e) => this.handleKeyInput(e),
      }, title: this.getFormattedDisplayDate(this.value) }, this.renderDayInput(), this.renderMonthInput(), this.renderYearInput(), this.renderIconOrClearButton()), this.renderCalendar(), h("ds-required-hint", { required: this.required, fulfilled: this.isValueValid() }))), h("ds-input-label", { label: this.label, kisynced: this.kisynced })));
  }
  renderClearButton() {
    return (h("ds-function-icon-button", { id: ElementIdGenerator.createId(this.self, "clear-button"), unfocusable: true, onBlur: () => {
        this.onBlur();
        this.dayInputController.onBlur();
      }, class: {
        "clear-button": true,
        visible: true,
      }, onPointerDown: () => this.clearInput() }, h("ds-icon", { icon: "schliessen-input", size: 16 })));
  }
  renderIconOrClearButton() {
    const anyInputContainsCharacter = !(this.dayEmpty &&
      this.monthEmpty &&
      this.yearEmpty);
    const isClearButtonVisible = this.inputFocused && anyInputContainsCharacter;
    return (h("div", { class: "right-side" }, isClearButtonVisible ? (this.renderClearButton()) : (h("ds-icon", { icon: "kalender", size: 16 }))));
  }
  renderCalendar() {
    var _a, _b;
    if (!this.inputFocused || !this.calendarenabled) {
      return;
    }
    return (h("ds-calendar", { slot: "overlay", id: ElementIdGenerator.createId(this.self, "calendar"), ref: (ref) => {
        this.setCalendar(ref);
      }, mode: this.mode, tabindex: -1, min: (_a = this.min) !== null && _a !== void 0 ? _a : "", max: (_b = this.max) !== null && _b !== void 0 ? _b : "", errormessage: this.internalErrorMessage || this.errormessage, onBlur: () => {
        this.onBlur();
        this.dayInputController.onBlur();
      }, onRangeSelected: (e) => {
        this.selectDate(e.detail.from);
      } }));
  }
  render() {
    var _a;
    if (this.readonly) {
      const date = new Date(this.value);
      return (h("div", { class: "read-only" }, h(ReadonlyTextElement, { text: ((_a = this.value) === null || _a === void 0 ? void 0 : _a.length) > 0
          ? this.getFormattedDisplayDate(date)
          : "n.a.", label: this.label, alignRight: true, kisynced: this.kisynced })));
    }
    return (h(Host, { class: { disabled: this.disabled } }, this.renderInput()));
  }
  get self() { return getElement(this); }
  static get watchers() { return {
    "value": ["valueChanged"],
    "readonly": ["readonlyChanged"],
    "mode": ["onModeChange"]
  }; }
};
function formatWithLeadingZero(value) {
  if (!value) {
    return value;
  }
  return DateUtils.withLeadingZero(parseInt(value));
}
DsDateInput.style = dsDateInputCss;

export { DsDateInput as ds_date_input };
