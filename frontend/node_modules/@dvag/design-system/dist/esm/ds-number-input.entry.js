import { r as registerInstance, c as createEvent, h, H as Host, g as getElement } from './index-04c470ea.js';
import { v as verifyElementId, E as ElementIdGenerator } from './element-id-handling-bb37154e.js';
import { c as clamp } from './math-util-3928f6c7.js';
import { d as displayNumberAsCurrency } from './currency-util-a17990de.js';
import { a as ReadonlyIconElement, R as ReadonlyTextElement } from './base-elements-20abac26.js';
import { I as InputContainer } from './input-container-97f842b4.js';
import { E as ErrorPopup } from './error-popup-5aa6e69c.js';
import './value-store-f4663db1.js';

const dsNumberInputCss = ":host{display:block}:host:host([hidden]){display:none !important}:host:host([label]:not([label=\"\"])){--ds-info-button-offset-y:24px}:host label{display:block}:host label>.container{position:relative;top:0;left:0;display:flex;height:38px;border-radius:4px;border:1px solid #c1c1c1;background-color:#ffffff;box-sizing:border-box;align-items:center}:host label>.container.required-outline{border-color:#e8b50e}:host label>.container.requirement-fulfilled{border-color:#c1c1c1}:host label>.container.red-outline{border-color:#be1413}:host label>.container.disabled-outline{border-color:#ebebeb}:host label>.container.active{border-color:#4c4c4c}:host label>.container .input-container{display:flex;width:100%;align-items:center;overflow:hidden}:host label>.container .input-container input{height:22px;margin:8px 0 8px 8px;border:none;outline:none;font-family:\"Helvetica Neue\", \"Helvetica Neue LT W01\";font-size:16px;line-height:24px;letter-spacing:0.02px;color:#4c4c4c;width:1px;flex-grow:1}:host label>.container .input-container input::placeholder{color:#c1c1c1}:host label>.container .input-container input:disabled{background-color:#ffffff;color:#c1c1c1}:host label>.container .input-container input.animatable{transform:translateX(20px);transition:transform 300ms ease-in-out}:host label>.container .input-container input.animatable.clear-button-visible{transform:translateX(0px)}:host label>.container .input-container .clear-button{visibility:hidden}:host label>.container .input-container .clear-button.visible{visibility:visible}:host label>.container .input-container .clear-button.animatable{width:28px;transform:translateX(28px);transition:transform 300ms ease-in-out}:host label>.container .input-container .clear-button.animatable.transition-show{transform:translateX(0px)}:host input{height:22px;margin:8px 0 8px 8px;border:none;outline:none;font-family:\"Helvetica Neue\", \"Helvetica Neue LT W01\";font-size:16px;line-height:24px;letter-spacing:0.02px;color:#4c4c4c;width:1px;flex-grow:1;text-align:right}:host input::placeholder{color:#c1c1c1}:host input:disabled{background-color:#ffffff;color:#c1c1c1}:host input::-webkit-outer-spin-button,:host input::-webkit-inner-spin-button{-webkit-appearance:none;margin:0}:host input[type=number]{-moz-appearance:textfield}.right-icon{width:28px;display:flex;align-items:center}.right-icon .clear-button{visibility:hidden}.right-icon .clear-button.visible{visibility:visible}.right-icon .type-icon{padding:6px}";

const DsNumberInput = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.valueChange = createEvent(this, "valueChange", 7);
    this.valueComplete = createEvent(this, "valueComplete", 7);
    this.formattedValue = undefined;
    this.preventObtainValueChanges = false;
    this.lastUnpreventedInputElementValue = null;
    this.inputFocused = false;
    this.active = false;
    /**
     * Colors the border of the element red.
     * @value true: red border.
     * @value false: grey border.
     * @example error
     */
    this.error = false;
    /**
     * Value of the input field.
     * @important
     * @value string: Value of the input.
     * @example value
     */
    this.value = null;
    /**
     * Determines the amount of pre-decimal numbers.
     * The element prevents all inputs higher than this value.
     *
     * @value number: Maximum amount of pre-decimal numbers.
     * @example limit-length
     */
    this.limitlength = null;
    /**
     * Determines the minimal value. The minimal value is **within** the possible input.
     * @value number: The minimal value the input field can have.
     */
    this.min = Number.MIN_SAFE_INTEGER;
    /**
     * Determines the maximum value. The maximum value is **within** the possible input.
     * @value number: The maximum value the input field can have.
     */
    this.max = Number.MAX_SAFE_INTEGER;
    /**
     * Input is not interactable.
     * Label and border are grey.
     * @value true: Input is disabled.
     * @value false: Input is not disabled.
     * @example disabled
     */
    this.disabled = false;
    /**
     * Input is in read only mode.
     * The content of the input is displayed in a simple way. The input is not interactable.
     * @value false: Formfield.
     * @value true: Text of the value.
     * @example readonly
     */
    this.readonly = false;
    /**
     * Marks the formfield as mandatory.
     * @value false: Not mandatory (default).
     * @value true: Mandatory.
     * @example required
     */
    this.required = false;
    /**
     * Indicates that the form is synced with the KI.
     * @value true: Synchronized.
     * @value false: Not synchronized.
     * @example kisynced
     */
    this.kisynced = false;
  }
  valueChanged() {
    this.obtainValueChangesFromOutside();
  }
  /**
   * Sets the tab-focus to the form element.
   */
  async focusControl() {
    this.inputElement.focus();
  }
  componentWillLoad() {
    verifyElementId(this.self);
    this.obtainValueChangesFromOutside(true);
  }
  // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
  componentShouldUpdate(_, __, propName) {
    if (["min", "max"].includes(propName)) {
      this.obtainValueChangesFromOutside();
    }
  }
  getUnformattedValue() {
    return this.formattedValue
      ? parseFloat(this.formattedValue.replace(/\./g, "").replace(",", "."))
      : null;
  }
  obtainValueChangesFromOutside(force = false) {
    if (!this.preventObtainValueChanges) {
      this.value = this.sanitizeValue(this.value);
      if (force || this.value !== this.getUnformattedValue()) {
        this.formattedValue = this.getDisplayValue();
        this.lastEmittedChangeValue = this.value;
        this.lastEmittedCompleteValue = this.value;
      }
    }
    this.preventObtainValueChanges = false;
  }
  sanitizeValue(value) {
    if (isNaN(value) || value == null) {
      return null;
    }
    const scale = Math.pow(10, this.inputTypeDefinition.decimalDigits);
    const bias = 1 / (scale * 100);
    value = Math.floor((value + bias) * scale) / scale;
    return clamp(value, this.min, this.max);
  }
  onInputFocused() {
    this.inputFocused = true;
  }
  onInputBlurred() {
    this.inputFocused = false;
    this.setValueInternal(this.sanitizeValue(this.value));
    this.emitValueChange();
    this.emitValueComplete();
  }
  clearInput() {
    this.inputElement.value = "";
    this.setValueInternal(null);
    this.formattedValue = null;
    this.lastUnpreventedInputElementValue = "";
    this.emitValueChange();
  }
  setValueInternal(newValue) {
    if (isNaN(newValue)) {
      newValue = null;
    }
    if (this.value !== newValue) {
      this.preventObtainValueChanges = true;
      this.formattedValue = this.getDisplayValue(newValue);
      this.value = newValue;
    }
  }
  onInputKeyUp(event) {
    if (event.key === "Enter") {
      this.inputElement.blur();
    }
  }
  preventInput() {
    var _a;
    if (!this.inputElement.value || this.inputElement.value === "-") {
      return false;
    }
    const inputTypeDefinition = this.inputTypeDefinition;
    const zeroPrecision = inputTypeDefinition.decimalDigits === 0;
    const stripTooManyDigits = new RegExp(zeroPrecision
      ? `^-?[\\d]+$`
      : `^-?[\\d]+[\,|\.]?[\\d]{0,${inputTypeDefinition.decimalDigits}}$`);
    if (!stripTooManyDigits.test(this.inputElement.value)) {
      return true;
    }
    if (this.limitlength > 0) {
      const stripPreCommaDigits = new RegExp(`^-?([\\d]+)([,.][\\d]*)?$`);
      const preCommaDigits = (_a = this.inputElement.value) === null || _a === void 0 ? void 0 : _a.match(stripPreCommaDigits)[1];
      if (preCommaDigits.length > this.limitlength) {
        return true;
      }
    }
    return false;
  }
  onInput() {
    if (this.preventInput()) {
      const cursorPosition = this.inputElement.selectionStart - 1;
      this.inputElement.value = this.lastUnpreventedInputElementValue;
      this.inputElement.selectionStart = cursorPosition;
      this.inputElement.selectionEnd = cursorPosition;
      return;
    }
    this.lastUnpreventedInputElementValue = this.inputElement.value;
    this.setValueInternal(parseFloat(this.inputElement.value.replace(",", ".")));
    this.formattedValue = this.getDisplayValue();
    this.emitValueChange();
  }
  emitValueChange() {
    if (this.value !== this.lastEmittedChangeValue) {
      this.setValueInternal(this.getUnformattedValue());
      this.lastEmittedChangeValue = this.value;
      this.valueChange.emit(this.value);
    }
  }
  emitValueComplete() {
    if (this.lastEmittedCompleteValue !== this.value) {
      this.valueComplete.emit(this.value);
      this.lastEmittedCompleteValue = this.value;
    }
  }
  get inputTypeDefinition() {
    let icon = null;
    let decimalDigits = 0;
    let placeholder = "0";
    let thousandsSeparator = true;
    if (this.profile === "currency-euro") {
      icon = "eurozeichen";
      decimalDigits = 2;
    }
    else if (this.profile === "percent") {
      icon = "prozent";
      decimalDigits = 0;
    }
    if (this.precision != null) {
      decimalDigits = this.precision;
    }
    if (decimalDigits > 0) {
      placeholder += ",";
      for (let i = 0; i < decimalDigits; i++) {
        placeholder += "0";
      }
    }
    if (this.placeholder != null) {
      placeholder = this.placeholder;
    }
    if (this.uniticon != null) {
      icon = this.uniticon;
    }
    if (this.thousandseparator != null) {
      thousandsSeparator = this.thousandseparator;
    }
    return { icon, placeholder, decimalDigits, thousandsSeparator };
  }
  getDisplayValue(value = null) {
    return displayNumberAsCurrency(value !== null && value !== void 0 ? value : this.value, this.inputTypeDefinition.decimalDigits, this.inputTypeDefinition.thousandsSeparator);
  }
  isClearButtonVisible() {
    return this.inputFocused && this.formattedValue != null;
  }
  render() {
    if (this.readonly) {
      return (h("div", null, h(ReadonlyTextElement, { text: this.formattedValue, label: this.label, kisynced: this.kisynced }), h(ReadonlyIconElement, { icon: this.inputTypeDefinition.icon })));
    }
    return h(Host, null, this.renderInput());
  }
  renderInput() {
    var _a, _b, _c, _d;
    const isErrorOutline = ((_a = this.errormessage) === null || _a === void 0 ? void 0 : _a.length) > 0 || this.error;
    const inputTypeDefinition = this.inputTypeDefinition;
    const requirementFulfilled = this.value != null && !isNaN(this.value);
    return (h("label", null, h("ds-input-label", { disabled: this.disabled, label: this.label, kisynced: this.kisynced }), h(InputContainer, { active: this.inputFocused, error: isErrorOutline, required: this.required, requirementFulfilled: requirementFulfilled, disabled: this.disabled, title: (_b = this.value) === null || _b === void 0 ? void 0 : _b.toString() }, h("div", { class: "input-container" }, h("input", { id: ElementIdGenerator.createId(this.self, "control"), ref: (el) => (this.inputElement = el), onKeyUp: (event) => this.onInputKeyUp(event), onInput: () => this.onInput(), onFocus: () => this.onInputFocused(), onBlur: () => this.onInputBlurred(), type: "text", inputMode: "numeric", pattern: "[0-9]*", value: this.inputFocused
        ? (_d = (_c = this.value) === null || _c === void 0 ? void 0 : _c.toString()) === null || _d === void 0 ? void 0 : _d.replace(".", ",")
        : this.formattedValue, placeholder: inputTypeDefinition.placeholder, class: {
        animatable: inputTypeDefinition.icon == null,
        "clear-button-visible": this.isClearButtonVisible(),
      }, lang: "de-DE", disabled: this.disabled }), this.renderIcon()), h(ErrorPopup, { text: this.errormessage, show: this.inputFocused, rightAligned: true })), h("ds-required-hint", { required: this.required, fulfilled: requirementFulfilled })));
  }
  renderNoIconSpecified() {
    return (h("ds-function-icon-button", { id: ElementIdGenerator.createId(this.self, "clear-button"), unfocusable: true, class: {
        "clear-button": true,
        animatable: true,
        visible: true,
        "transition-show": this.isClearButtonVisible(),
      }, onPointerDown: () => this.clearInput() }, h("ds-icon", { icon: "schliessen-input", size: 16 })));
  }
  renderIconSpecified() {
    const icon = this.inputTypeDefinition.icon;
    return (h("div", { class: "right-icon" }, this.isClearButtonVisible() ? (h("ds-function-icon-button", { id: ElementIdGenerator.createId(this.self, "clear-button"), unfocusable: true, class: {
        "clear-button": true,
        visible: true,
      }, onPointerDown: () => this.clearInput() }, h("ds-icon", { icon: "schliessen-input", size: 16 }))) : icon != "" ? (h("ds-icon", { class: { "type-icon": true }, icon: icon, color: "gold", size: 16 })) : null));
  }
  renderIcon() {
    return this.inputTypeDefinition.icon == null
      ? this.renderNoIconSpecified()
      : this.renderIconSpecified();
  }
  get self() { return getElement(this); }
  static get watchers() { return {
    "value": ["valueChanged"]
  }; }
};
DsNumberInput.style = dsNumberInputCss;

export { DsNumberInput as ds_number_input };
