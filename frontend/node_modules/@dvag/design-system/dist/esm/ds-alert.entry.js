import { r as registerInstance, c as createEvent, w as writeTask, h, H as Host, g as getElement } from './index-04c470ea.js';
import { c as createMetaComponentsSlotObserver } from './slot-observer-9196738e.js';
import { i as isSlotDefined } from './render-util-1dee6655.js';
import { D as DsSubject } from './multicast-observable-f2e53ec0.js';
import { v as verifyElementId, E as ElementIdGenerator } from './element-id-handling-bb37154e.js';
import { a as assert } from './assert-7fc7463a.js';
import { M as ModalScrollHelper } from './modal-scroll-helper-ad3b2dc1.js';
import { T as TransitionStartHelper } from './event.util-241bc731.js';
import { i as isInnerElement } from './misc-util-d3b69f2c.js';
import './query-util-02753b43.js';
import './value-store-f4663db1.js';

const dsAlertCss = ":host{display:block;outline:none}:host:host([hidden]){display:none !important}:host .overlay{position:fixed;z-index:1010;left:0;top:0;right:0;bottom:0;background-color:#666666;transition:opacity 300ms ease-in-out;opacity:0.6}:host .modal-layout{position:fixed;z-index:1011;left:0;top:0;right:0;bottom:0;display:flex;justify-content:center;align-items:center}:host .modal-layout .modal-element{width:327px;overflow:hidden;transition:transform 300ms ease-in-out, opacity 300ms ease-in-out}:host .modal-layout .modal-element .icon-container{padding-top:24px;display:flex;justify-content:center;--ds-icon-attr-size:32}:host .modal-layout .modal-element .content{display:flex;padding:24px 16px 24px;flex-direction:column}:host .modal-layout .modal-element .content .title{margin:auto auto 8px;text-align:center;--ds-text-font-weight:700;--ds-text-letter-spacing:0.04px;--ds-text-color:#4c4c4c;--ds-text-font-size-small:18px;--ds-text-line-height-small:24px;--ds-text-font-size-large:20px;--ds-text-line-height-large:28px}:host .modal-layout .modal-element .content .body{margin:auto;text-align:center}:host .modal-layout .modal-element .buttons-container{border-top:0.5px solid #c1c1c1;display:flex}:host .modal-layout .modal-element .buttons-container.direction-right{flex-direction:row}:host .modal-layout .modal-element .buttons-container.direction-right .button{position:relative;border-right:0.5px solid #c1c1c1}:host .modal-layout .modal-element .buttons-container.direction-down{flex-direction:column}:host .modal-layout .modal-element .buttons-container.direction-down .button{position:relative;border-bottom:0.5px solid #c1c1c1}:host .modal-layout .modal-element .buttons-container .button{position:relative;flex:1;box-sizing:border-box;padding-top:16px;padding-bottom:16px;text-align:center;cursor:pointer;border-color:#c1c1c1}:host .modal-layout .modal-element .buttons-container .button.color-gold{--ds-text-color:#a7893d;--ds-icon-color:#a7893d}:host .modal-layout .modal-element .buttons-container .button.color-gold:hover{--ds-text-color:#957b36;--ds-icon-color:#957b36}:host .modal-layout .modal-element .buttons-container .button.color-gold:active{--ds-text-color:#856d30;--ds-icon-color:#856d30}:host .modal-layout .modal-element .buttons-container .button.color-gold.disabled{--ds-text-color:#e3dac4;--ds-icon-color:#e3dac4}:host .modal-layout .modal-element .buttons-container .button.color-rot{--ds-text-color:#be1413;--ds-icon-color:#be1413}:host .modal-layout .modal-element .buttons-container .button.color-rot:hover{--ds-text-color:#99100f;--ds-icon-color:#99100f}:host .modal-layout .modal-element .buttons-container .button.color-rot:active{--ds-text-color:#7d0d0d;--ds-icon-color:#7d0d0d}:host .modal-layout .modal-element .buttons-container .button.color-rot.disabled{--ds-text-color:#f2d0cf;--ds-icon-color:#f2d0cf}:host .modal-layout .modal-element .buttons-container .button:last-child{border:none}:host .modal-layout .modal-element .buttons-container .button:hover{background-color:#f5f5f5}:host .modal-layout .modal-element .buttons-container .button:active{background-color:#ebebeb}:host .modal-layout .modal-element .buttons-container .button.disabled{pointer-events:none}:host .modal-layout .modal-element .buttons-container .button ds-text-button.color-gold{--ds-text-color:#a7893d;--ds-icon-color:#a7893d}:host .modal-layout .modal-element .buttons-container .button ds-text-button.color-gold:hover{--ds-text-color:#957b36;--ds-icon-color:#957b36}:host .modal-layout .modal-element .buttons-container .button ds-text-button.color-gold:active{--ds-text-color:#856d30;--ds-icon-color:#856d30}:host .modal-layout .modal-element .buttons-container .button ds-text-button.color-gold.disabled{--ds-text-color:#e3dac4;--ds-icon-color:#e3dac4}:host .modal-layout .modal-element .buttons-container .button ds-text-button.color-rot{--ds-text-color:#be1413;--ds-icon-color:#be1413}:host .modal-layout .modal-element .buttons-container .button ds-text-button.color-rot:hover{--ds-text-color:#99100f;--ds-icon-color:#99100f}:host .modal-layout .modal-element .buttons-container .button ds-text-button.color-rot:active{--ds-text-color:#7d0d0d;--ds-icon-color:#7d0d0d}:host .modal-layout .modal-element .buttons-container .button ds-text-button.color-rot.disabled{--ds-text-color:#f2d0cf;--ds-icon-color:#f2d0cf}:host .modal-layout .modal-element .buttons-container .button ds-text{white-space:nowrap}:host(:not(.visible)){pointer-events:none}:host(:not(.visible)) .overlay{opacity:0}:host(:not(.visible)) .modal-layout .modal-element{transform:scale(0.6);opacity:0}:host(:not(.visible)) .modal-layout .modal-element *{display:none}:host(.no-overlay) .overlay{display:none}:host(.no-overlay) .modal-layout{position:inherit}";

const DsAlert = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.buttonClick = createEvent(this, "buttonClick", 7);
    this.minButtonSpaceOnSides = 16;
    this.submitResult = new DsSubject();
    this.customShowCalled = false;
    this.transitionStartHelper = new TransitionStartHelper(this, this.handleTransitionStart);
    this.direction = "column";
    this.ignoreSlots = false;
    this.nooverlay = false;
    /**
     * Defines if the alert is visible or not.
     * @value true: Alert is visible.
     * @value false: Alert is not visible.
     *
     * @example visible
     */
    this.visible = false;
    /**
     * Defines in which direction the buttons should be displayed.
     *
     * @value column: The buttons will be displayed from left to right.
     * @value row: The buttons will be displayed from top to bottom.
     * @value auto: The direction is computed dependant on the label size of the buttons.
     * @example actions-direction-row
     * @example actions-direction-column
     * @example actions-direction-auto-s
     * @example actions-direction-auto-l
     */
    this.actionsdirection = "auto";
  }
  componentWillLoad() {
    verifyElementId(this.self);
    this.submitResultSubscription = this.submitResult.subscribe((newValue) => {
      this.buttonClick.emit(newValue);
    });
    this.nooverlay =
      getComputedStyle(this.self).getPropertyValue("--nooverlay").trim() ===
        "true";
  }
  connectedCallback() {
    this.slotObserver =
      createMetaComponentsSlotObserver(this.self, "ds-alert-button", async (nodes) => {
        this.buttonsData = await Promise.all(nodes.map((node) => node.toAlertButtonData()));
      });
  }
  componentDidRender() {
    const scrollHelper = ModalScrollHelper.instance();
    if (this.visible) {
      scrollHelper.block(this.modalDialog);
    }
    else {
      scrollHelper.unblock(this.modalDialog);
    }
    if (this.actionsdirection === "auto") {
      const texts = Array.from(this.self.shadowRoot.querySelectorAll(".button ds-text"));
      const textAlreadyRendered = texts.some((text) => text.offsetWidth !== 0);
      if (textAlreadyRendered) {
        writeTask(() => {
          this.direction = this.calculateDirection(texts);
        });
      }
      else {
        const mutationObserver = new MutationObserver(() => {
          this.direction = this.calculateDirection(texts);
          mutationObserver.disconnect();
        });
        const firstButtonText = this.self.shadowRoot.querySelector(".button ds-text");
        if (firstButtonText != null) {
          mutationObserver.observe(firstButtonText, {
            attributes: true,
            childList: true,
            characterData: true,
            subtree: true,
          });
        }
      }
    }
    else {
      writeTask(() => {
        this.direction = this.actionsdirection;
      });
    }
  }
  disconnectedCallback() {
    var _a, _b, _c;
    (_a = this.slotObserver) === null || _a === void 0 ? void 0 : _a.disconnect();
    (_b = this.submitResultSubscription) === null || _b === void 0 ? void 0 : _b.unsubscribe();
    (_c = this.transitionStartHelper) === null || _c === void 0 ? void 0 : _c.disconnect();
    ModalScrollHelper.instance().unblock(this.self);
  }
  onKeyDown(e) {
    if (this.visible && e.key === "Enter") {
      const explicitTargetElement = e.composedPath()[0];
      if (explicitTargetElement !== this.self) {
        const isTargetElementWithinSelf = isInnerElement(explicitTargetElement, this.self);
        // If the target element is one of the inner alert buttons we dont want to interfere
        if (isTargetElementWithinSelf) {
          return;
        }
        // If the target element is outside the alert we cancel the propagation and handle the input.
        e.preventDefault();
        e.stopPropagation();
      }
      const confirmButtonData = this.buttonsData.find((buttonData) => buttonData.confirm);
      if (confirmButtonData != null) {
        this.handleButtonClick(confirmButtonData);
      }
    }
  }
  calculateDirection(texts) {
    const maxTextWidth = 327 / texts.length - 2 * this.minButtonSpaceOnSides;
    const containsLargeText = texts.some((elem) => {
      return elem.offsetWidth > maxTextWidth;
    });
    return !containsLargeText ? "row" : "column";
  }
  async prepareShowAlert(body) {
    return new Promise((resolve) => {
      body(resolve);
      this.ignoreSlots = true;
      this.visible = true;
    }).then((result) => {
      this.ignoreSlots = false;
      return result;
    });
  }
  /**
   * Shows the alert and returns a promise with the users choice.
   * *Important*: This method should not be called with the `showAlert` or `showConfirm` method in an alert's lifecycle.
   *
   * @example method-show
   */
  async show() {
    assert(this.customShowCalled != true, () => `<ds-alert> show() sollte nicht benutzt werden, wenn vorher einer der vordefinierten showAlert() || showConfirm() Methoden benutzt wurde.`);
    return new Promise((resolve) => {
      const subscription = this.submitResult.subscribe((newValue) => {
        resolve(newValue);
        subscription === null || subscription === void 0 ? void 0 : subscription.unsubscribe();
      });
      const elementComment = document.createComment("cpIf " + "comment");
      elementComment.replaceWith(this.self);
      this.visible = true;
    });
  }
  /**
   * Shows a predefined alert with one confirmation button.
   *
   * *Important*: This method should not be called with the `show` method in an alert's lifecycle.
   *
   * @param title Title text.
   * @param body The content text below the title.
   * @param icon An icon name which is displayed over the title.
   * @param iconColor The icon color.
   * @param okLabel The label text of the confirmation button.
   * @example method-show-alert
   */
  async showAlert(title, body, okLabel = "Ok", icon = undefined, iconColor = undefined) {
    this.customShowCalled = true;
    return await this.prepareShowAlert((resolve) => {
      const confirmButtons = [
        createAlertButton(okLabel, undefined, true, "gold", false, false, () => resolve(true)),
      ];
      this.customRenderFunction = () => {
        return [
          this.renderIcon(icon, iconColor),
          this.renderContent(title, body),
          this.renderButtons(confirmButtons),
        ];
      };
    });
  }
  /**
   * Shows a predefined alert with two buttons.
   * The right button confirms and the left button cancels the alert.
   * The method returns a promise which resolves when the user interacts with one of the two options.
   * The resolved promise contains `true` when the user confirms the alert and `false` when the user cancels the alert.
   *
   * *Important*: This method should not be called with the `show` method in an alert's lifecycle.
   *
   * @param title Title text.
   * @param body The content text below the title.
   * @param cancelLabel The label text of the left button (cancel).
   * @param confirmLabel The label text of the right button (confirm).
   * @param icon An icon name which is displayed over the title.
   * @param iconColor The icon color.
   * @param destructive Indicates whether the alert implies a destructive action when confirming (e.g. deletion of a resource).
   * @example method-show-confirm1
   * @example method-show-confirm2
   */
  async showConfirm(title, body, cancelLabel, confirmLabel, icon = undefined, iconColor = undefined, destructive = false) {
    this.customShowCalled = true;
    return await this.prepareShowAlert((resolve) => {
      const confirmButtons = [
        createAlertButton(cancelLabel, "false", false, "gold", false, false, () => resolve(false)),
        createAlertButton(confirmLabel, "true", true, destructive ? "rot" : "gold", !destructive, false, () => resolve(true)),
      ];
      this.customRenderFunction = () => {
        return [
          this.renderIcon(icon, iconColor),
          this.renderContent(title, body),
          this.renderButtons(confirmButtons),
        ];
      };
    });
  }
  handleButtonClick(button) {
    this.submitResult.next(button.value);
    this.visible = false;
  }
  handleTransitionStart(e) {
    if (e.propertyName === "transform" && this.visible) {
      this.self.style["visibility"] = "visible";
      // We want to take the focus from the button which triggered this alert and start listen to keyboard events.
      this.self.focus();
    }
  }
  handleTransitionEnd(e) {
    if (e.propertyName === "transform" && !this.visible) {
      this.self.style["visibility"] = "hidden";
      // We have to blur this alert because it will stay on focus although visibility is hidden.
      this.self.blur();
    }
  }
  render() {
    return (h(Host, { class: {
        visible: this.visible,
        "no-overlay": this.nooverlay,
      }, tabIndex: 0 }, h("div", { class: "overlay" }), h("div", { class: "modal-layout", ref: (ref) => this.transitionStartHelper.on(ref), onTransitionEnd: (e) => this.handleTransitionEnd(e) }, h("ds-card", { class: "modal-element", ref: (el) => (this.modalDialog = el) }, this.ignoreSlots && this.customRenderFunction !== undefined
      ? this.customRenderFunction()
      : this.renderDefault()))));
  }
  renderDefault() {
    return [
      this.renderIconSlot(),
      this.renderDefaultContent(),
      this.renderButtons(this.buttonsData),
    ];
  }
  renderIcon(icon, iconColor) {
    if (icon != null) {
      return (h("div", { class: "icon-container" }, h("ds-icon", { size: 32, icon: icon, color: iconColor })));
    }
  }
  renderIconSlot() {
    if (isSlotDefined(this.self, "icon")) {
      return (h("div", { class: "icon-container" }, h("div", null, h("div", null, h("div", null, h("slot", { name: "icon" }))))));
    }
  }
  renderDefaultContent() {
    const titleSlotDefined = isSlotDefined(this.self, "title");
    const bodySlotDefined = isSlotDefined(this.self, "body");
    return [
      titleSlotDefined || bodySlotDefined ? (h("div", { class: { content: true } }, titleSlotDefined ? (h("div", { class: "title" }, h("div", null, h("slot", { name: "title" })))) : null, bodySlotDefined ? (h("div", { class: "body" }, h("div", null, h("slot", { name: "body" })))) : null)) : null,
      h("slot", null),
    ];
  }
  renderContent(title, body) {
    return (h("div", { class: { content: true } }, h("div", { class: "title" }, h("ds-text", { type: "u5" }, title)), h("div", { class: "body" }, h("ds-text", { type: "ft" }, body))));
  }
  renderButtons(buttonDataArray) {
    if ((buttonDataArray === null || buttonDataArray === void 0 ? void 0 : buttonDataArray.length) > 0) {
      const directionRight = this.direction === "row";
      return (h("div", { class: {
          "buttons-container": true,
          "direction-right": directionRight,
          "direction-down": !directionRight,
        } }, buttonDataArray.map((buttonData, buttonIndex) => this.renderButton(buttonData, buttonIndex))));
    }
  }
  renderButton(buttonData, buttonIndex) {
    const predefinedClickFunction = buttonData.onClick;
    return (h("div", { class: {
        button: true,
        disabled: buttonData.disabled,
      }, onClick: (e) => {
        if (predefinedClickFunction != null) {
          predefinedClickFunction(e);
        }
        this.handleButtonClick(buttonData);
      } }, h("ds-text-button", { id: ElementIdGenerator.createId(this.self, "button-" + buttonIndex), color: buttonData.color, disabled: buttonData.disabled }, h("ds-text", { type: buttonData.highlight ? "ftf" : undefined }, buttonData.label))));
  }
  get self() { return getElement(this); }
};
function createAlertButton(label, value, confirm, color, highlight, disabled, onClick) {
  return {
    label,
    value,
    confirm,
    color,
    highlight,
    disabled,
    onClick,
  };
}
DsAlert.style = dsAlertCss;

export { DsAlert as ds_alert };
