import { r as registerInstance, h, w as writeTask, H as Host, g as getElement } from './index-04c470ea.js';
import { a as assert } from './assert-7fc7463a.js';
import { a as isSlotUndefined, i as isSlotDefined } from './render-util-1dee6655.js';
import { S as SlotObserver } from './slot-observer-9196738e.js';
import { M as ModalScrollHelper } from './modal-scroll-helper-ad3b2dc1.js';
import './query-util-02753b43.js';
import './misc-util-d3b69f2c.js';
import './value-store-f4663db1.js';

const dxAlertCss = ":host{display:block}:host:host([hidden]){display:none !important}:host .alert-container{position:fixed;z-index:1011;left:0;top:0;bottom:0;right:0;background-color:rgba(87, 87, 87, 0.6);transition:background-color 300ms ease-in-out}:host:host(.state-closed){pointer-events:none}:host:host(.state-closed) .alert-container{background-color:rgba(87, 87, 87, 0)}:host:host(.state-closed) .alert-container .alert-card{opacity:0;transform:scale(0.98)}:host:host(.state-opened){pointer-events:all}:host:host(.state-opened) .alert-container .alert-card{opacity:1;transform:scale(1)}:host .icon{--dx-icon-attr-size:24px}@media (min-width: 1280px){:host .icon{--dx-icon-attr-size:32px}}:host .alert-container{display:flex;align-items:center;justify-content:center;padding:16px;box-sizing:border-box}:host .alert-container .alert-card{transition:opacity 150ms ease-in-out, transform 150ms ease-in-out;max-height:100%}@media (min-width: 0px){:host .alert-container .alert-card{width:100%}}@media (min-width: 476px){:host .alert-container .alert-card{width:384px}}@media (min-width: 1280px){:host .alert-container .alert-card{width:432px}}:host .alert-container .alert-card .alert-card-content{overflow:hidden}:host .alert-container .alert-card .alert-card-content .content-container{display:flex;position:relative;overflow:hidden}:host .alert-container .alert-card .alert-card-content .content-container .shadow{position:absolute;background:rgba(0, 0, 0, 0.03);width:100%;height:0;z-index:1;transition:height 300ms ease-in-out}:host .alert-container .alert-card .alert-card-content .content-container .shadow.top{top:0}:host .alert-container .alert-card .alert-card-content .content-container .shadow.bottom{bottom:0}:host .alert-container .alert-card .alert-card-content .content-container .shadow.visible{height:4px}:host .alert-container .alert-card .alert-card-content .content-container .scrolling-container{display:flex;flex-direction:column;flex:1;overflow-x:hidden;overflow-y:auto;position:relative;padding-bottom:16px}:host .alert-container .alert-card .alert-card-content .content-container .scrolling-container.contains-icon .titlestring{margin-top:8px}:host .alert-container .alert-card .alert-card-content .content-container .scrolling-container .content{margin-top:16px}:host .alert-container .alert-card .alert-card-content .content-container .scrolling-container .sublabel{margin-top:8px}:host .alert-container .alert-card .alert-card-content .content-container .scrolling-container .custom-container{margin-top:16px}:host .alert-container .alert-card .alert-card-content .horizontal-line{height:1px;width:100%;background-color:#d6d6d6}:host .alert-container .alert-card .actions-container{display:flex;flex-direction:column}:host .alert-container .alert-card .actions-container ::slotted(dx-button){margin-top:16px}:host .alert-container .alert-card .actions-container.direction-row{flex-direction:row-reverse;justify-content:space-between}";

const DxAlert = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    /**
     * Defines the visual representation of the button.
     * @value default: Shows the titlestring and icon in a dark color.
     * @value error: Shows the titlestring and icon in a red color to imply an error.
     *
     * @example type-error
     * @example type-default
     */
    this.type = "default";
    /**
     * Defines the visibility of the alert.
     * @value true: Alert is visible.
     * @value false: Alert is not visible.
     *
     * @example visible
     */
    this.visible = false;
    /**
     * Defines in which direction the buttons should be displayed.
     *
     * @value column: The buttons will be displayed from left to right.
     * @value row: The buttons will be displayed from top to bottom.
     *
     * @example actions-direction-row
     * @example actions-direction-column
     * @default "column"
     */
    this.actionsdirection = ActionLayoutDirection.COLUMN;
  }
  componentWillLoad() {
    const exactlyTwoActions = this.self.querySelectorAll("*[slot='action']").length == 2;
    this.internalActionsDirection = exactlyTwoActions
      ? this.actionsdirection
      : ActionLayoutDirection.COLUMN;
    this.slotObserver = new SlotObserver(this.self, "dx-button[slot='action']", (nodes) => {
      nodes.forEach((node, index) => {
        const validIndex = index <= 2;
        assert(validIndex, () => "There is only a maximum of 3 actions permitted. The following element will not be rendered!", node);
        node.slot = validIndex ? node.slot : "no-valid-button";
        node.stretch =
          this.internalActionsDirection === ActionLayoutDirection.COLUMN;
      });
    });
  }
  componentDidRender() {
    const scrollHelper = ModalScrollHelper.instance();
    if (this.visible) {
      scrollHelper.block(this.modalDialog);
    }
    else {
      scrollHelper.unblock(this.modalDialog);
    }
  }
  disconnectedCallback() {
    var _a;
    (_a = this.slotObserver) === null || _a === void 0 ? void 0 : _a.disconnect();
    ModalScrollHelper.instance().unblock(this.self);
  }
  updateShadowVisibility(scrollContainer) {
    this.shadowTopVisible = scrollContainer.scrollTop > 0;
    this.shadowBottomVisible =
      scrollContainer.scrollHeight -
        scrollContainer.scrollTop -
        scrollContainer.offsetHeight >
        0;
  }
  renderIcon(color) {
    if (!this.icon) {
      return;
    }
    return (h("div", { class: "icon-container" }, h("dx-icon", { class: "icon", icon: this.icon, color: color })));
  }
  renderContent() {
    if (this.content) {
      return (h("dx-text", { class: "content", type: "it", color: "paragraph" }, this.content));
    }
  }
  renderSublabel() {
    if (this.sublabel) {
      return (h("dx-text", { class: "sublabel", type: "it", color: "gray-50" }, this.sublabel));
    }
  }
  renderCustom() {
    if (isSlotUndefined(this.self, "custom")) {
      return;
    }
    return (h("div", { class: "custom-container" }, h("slot", { name: "custom" })));
  }
  renderActions() {
    assert(isSlotDefined(this.self, "action"), () => 'You must define at least one button within the "action" slot!');
    return (h("div", { class: {
        "actions-container": true,
        "direction-row": this.internalActionsDirection === ActionLayoutDirection.ROW,
      } }, h("slot", { name: "action" })));
  }
  render() {
    const typeColor = COLOR_FOR_TYPE[this.type];
    return (h(Host, { class: {
        "state-closed": !this.visible,
        "state-opened": this.visible,
      } }, h("div", { class: "alert-container" }, h("dx-card", { class: "alert-card", ref: (el) => (this.modalDialog = el) }, h("dx-card-content", { class: "alert-card-content" }, h("div", { class: "content-container" }, h("div", { class: {
        shadow: true,
        top: true,
        visible: this.shadowTopVisible,
      } }), h("div", { class: {
        shadow: true,
        bottom: true,
        visible: this.shadowBottomVisible,
      } }), h("div", { class: {
        "scrolling-container": true,
        "contains-icon": !!this.icon,
      }, ref: (ref) => {
        writeTask(() => {
          this.updateShadowVisibility(ref);
        });
      }, onScroll: (e) => {
        this.updateShadowVisibility(e.target);
      } }, this.renderIcon(typeColor), h("dx-text", { class: "titlestring", type: "ps", color: typeColor }, this.titlestring), this.renderContent(), this.renderSublabel(), this.renderCustom())), h("div", { class: "horizontal-line" }), this.renderActions())))));
  }
  get self() { return getElement(this); }
};
const COLOR_FOR_TYPE = {
  default: "headline",
  error: "error",
};
const ActionLayoutDirection = {
  ROW: "row",
  COLUMN: "column",
};
DxAlert.style = dxAlertCss;

export { DxAlert as dx_alert };
