import { r as registerInstance, c as createEvent, f as forceUpdate, h, H as Host, g as getElement } from './index-04c470ea.js';
import { a as assert } from './assert-7fc7463a.js';
import { D as DragController } from './drag-controller-3573133f.js';
import { c as clamp } from './math-util-3928f6c7.js';
import { P as PreciseCssSetter } from './precise-css-setter-853ba367.js';
import { o as onNextFrame } from './render-util-1dee6655.js';

/**
 * Format a number value based on a specific pattern.
 * The pattern uses '$2' to indicate the placeholder for the number
 * and the count of decimal digits.
 */
function formatValue(value, pattern) {
  if (pattern) {
    if (pattern.includes("$")) {
      try {
        const match = pattern.match(/(.*)(\$\d)(.*)/); // capture 3 groups: before, digits indicator, after
        const digits = parseInt(match[2].substring(1));
        const formattedNumber = value.toFixed(digits).replace(".", ",");
        return match[1] + formattedNumber + match[3];
      }
      catch (e) {
        throw new Error("Error formatting value '" +
          value +
          "' with pattern '" +
          pattern +
          "'.");
      }
    }
  }
  return value === null || value === void 0 ? void 0 : value.toString();
}
/**
 * Rounds a [relativeValue] (0.0 ... 1.0) within a range defined by [min] and [max] based
 * on a specified [step] size.
 */
function roundByStep(relativeValue, min, max, step) {
  var _a;
  const computedValue = Math.round((min + relativeValue * (max - min)) / step) * step;
  const fractionDigits = ((_a = step.toString().split(".")[1]) === null || _a === void 0 ? void 0 : _a.length) || 0;
  return parseFloat(computedValue.toFixed(fractionDigits));
}

const dxSliderCss = ":host{display:flex;flex-direction:column}:host:host([hidden]){display:none !important}:host:host(:focus-visible){outline:2px solid #004763}:host:host(.is-safari:focus){outline:none}:host .value{flex-shrink:0;white-space:nowrap;width:max-content;margin-bottom:4px}:host .slider{height:40px;display:flex;align-items:center;cursor:pointer;position:relative}:host .slider .line{flex-shrink:0;width:100%;height:2px;background:#d6d6d6}:host .slider .line .filled{width:100%;height:100%;background:#337a96;transform-origin:left center}:host .slider .min-max-labels{position:absolute;top:0;width:100%;display:flex;justify-content:space-between;white-space:nowrap}:host .slider .min-max-labels dx-text{opacity:0}:host .slider .min-max-labels dx-text.visible{opacity:1}:host .slider .min-max-labels dx-text.animated{transition:opacity 150ms ease-in-out}:host .slider .knob{position:absolute;top:0;left:0;width:40px;height:40px;border-radius:50%;box-sizing:border-box;border:2px solid #337a96;background:#ffffff}:host .label{margin-top:8px;white-space:nowrap}:host:host(.readonly){pointer-events:none}:host:host(.readonly) .value{transform:none !important;margin-bottom:8px}:host:host(.readonly) .slider{height:auto}:host:host(.readonly) .slider .knob{display:none}:host:host(.disabled){pointer-events:none;user-select:none;opacity:0.4}";

const DxSlider = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.valueChange = createEvent(this, "valueChange", 7);
    this.ticksOfKeyDown = 0;
    /**
     * Step size of the slider values. Possible values are always multiples of
     * the step size. Values are automatically rounded to match the step size.
     * @value number: step size.
     * @example step
     */
    this.step = 0.01;
    /**
     * If enabled, it displays labels for the minimum and maximum values.
     * @value false: labels are hidden (default)
     * @value true: labels are shown
     * @example show-min-max-label
     */
    this.showminmaxlabel = false;
    /**
     * If enabled, it displays a label with the current value above the knob.
     * @value true: label is shown (default)
     * @value false: label is hidden
     * @example show-value-label
     */
    this.showvaluelabel = true;
    /**
     * Pattern used to format the current value.
     * A '$' followed by a digit represents the value of the slider.
     * The value of digits determines the amount of decimal numbers.
     *
     * @value string: formatting of the slider value, e.g. `$1 %` or `$2 â‚¬`
     * @example formattingpattern
     */
    this.formattingpattern = "$0";
    /**
     * Turns the input into the read-only mode.
     * @value false: value can be modified by the user (default)
     * @value true: value can not be modified by the user
     * @example readonly
     */
    this.readonly = false;
    /**
     * Defines if the input field is enabled or not.
     * @value true: Input ist disabled
     * @value false: Input is not disabled
     * @example disabled
     */
    this.disabled = false;
  }
  valueChanged() {
    if (this.value != null && isNaN(this.value)) {
      console.error(`<dx-slider> has an invalid value set for property 'value'.`);
      // Stencil's implicit type conversion interpreted some input for 'value' as NaN.
      // We need to fix this immediately.
      this.value = null;
    }
  }
  componentDidRender() {
    onNextFrame(() => this.updatePosition());
  }
  componentWillLoad() {
    this.dragController = new DragController(() => this.value, (e) => {
      const boundingBox = this.lineElement.getBoundingClientRect();
      const leftLimit = boundingBox.left;
      const rightLimit = boundingBox.right;
      const relativeValue = Math.max(0, Math.min((e.x - leftLimit) / (rightLimit - leftLimit), 1));
      this.applyNewValue(relativeValue);
    });
  }
  connectedCallback() {
    this.resizeObserver = new ResizeObserver(() => forceUpdate(this));
    this.resizeObserver.observe(this.self);
  }
  disconnectedCallback() {
    var _a;
    (_a = this.resizeObserver) === null || _a === void 0 ? void 0 : _a.disconnect();
  }
  updatePosition() {
    const lineWidth = this.lineElement.offsetWidth;
    // Position of the knob
    const knobLeft = (lineWidth - KNOB_WIDTH) * this.relativeValue;
    this.knobElement.style.transform = `translateX(${knobLeft}px)`;
    // Position the value label above the knob
    if (this.showvaluelabel) {
      this.updateValueLabelPosition(lineWidth);
    }
    // Show / hide the min max label, if they overlap with knob
    if (this.showminmaxlabel) {
      this.updateMinMaxLabelVisibility(knobLeft);
    }
  }
  updateValueLabelPosition(lineWidth) {
    const labelTextWidth = this.labelTextElement.offsetWidth;
    this.valueElement.style.transform = `translateX(${clamp((lineWidth - KNOB_WIDTH) * this.relativeValue -
      labelTextWidth / 2 +
      KNOB_WIDTH / 2, 0, Math.max(0, lineWidth - labelTextWidth))}px)`;
  }
  updateMinMaxLabelVisibility(knobLeft) {
    const minRect = this.minLabelElement.getBoundingClientRect();
    const maxRect = this.maxLabelElement.getBoundingClientRect();
    const knobRectLeft = minRect.left + knobLeft;
    const knobRectRight = knobRectLeft + KNOB_WIDTH;
    new PreciseCssSetter(this.minLabelElement)
      .set("visible", knobRectLeft > minRect.right)
      .execute();
    new PreciseCssSetter(this.maxLabelElement)
      .set("visible", knobRectRight < maxRect.left)
      .execute();
    // After first rendering (therefore we need onNextFrame), we make this animating
    if (!this.minLabelElement.classList.contains("animated")) {
      onNextFrame(() => {
        this.minLabelElement.classList.add("animated");
        this.maxLabelElement.classList.add("animated");
      });
    }
  }
  clickOnSlider(e) {
    const lineRect = this.lineElement.getBoundingClientRect();
    const left = lineRect.left + KNOB_WIDTH * 0.5;
    const right = lineRect.right - KNOB_WIDTH * 0.5;
    const relativeValue = clamp((e.clientX - left) / (right - left), 0, 1);
    this.applyNewValue(relativeValue);
  }
  applyNewValue(relativeValue) {
    this.value = roundByStep(relativeValue, this.min, this.max, this.step);
    this.valueChange.emit(this.value);
  }
  eventCanControlValueByKey(e) {
    return (!this.readonly &&
      !this.disabled &&
      (e.key === "ArrowLeft" || e.key === "ArrowRight"));
  }
  keyDownOnSlider(e) {
    if (!this.eventCanControlValueByKey(e)) {
      return;
    }
    // Count each key down event as a tick
    this.ticksOfKeyDown++;
    // Compute delta
    const sign = e.key === "ArrowLeft" ? -1 : 1;
    const delta = sign *
      (!e.shiftKey
        ? // by default: increase step size a magnitude (10^n) each 10 ticks
          this.step * Math.pow(10, Math.floor(this.ticksOfKeyDown / 10))
        : // with shift-key: step by 1/10th of the range
          (this.max - this.min) / 10);
    // Convert to a relative value, so we can apply it by our default roundByStep function
    const relativeValue = clamp((this.value + delta - this.min) / (this.max - this.min), 0, 1);
    this.applyNewValue(relativeValue);
    e.preventDefault(); // prevents scrolling
  }
  keyUpOnSlider(e) {
    if (!this.eventCanControlValueByKey(e)) {
      return;
    }
    // If a key is released, reset time information
    this.ticksOfKeyDown = 0;
    e.preventDefault(); // prevents scrolling
  }
  checkAsserts() {
    assert(this.min != null, () => "<dx-slider> requires the property 'min'");
    assert(this.max != null, () => "<dx-slider> requires the property 'max'");
    assert(this.min < this.max, () => "<dx-slider> requires 'min' to be lower then 'max'");
    assert(this.value >= this.min && this.value <= this.max, () => "<dx-slider> requires 'value' to be between 'min' and 'max'");
  }
  get usedValue() {
    return clamp(this.value, this.min, this.max);
  }
  /**
   * The relative value represents the [value] within the [min] and [max] range
   * as a value between 0.0 and 1.0.
   */
  get relativeValue() {
    return (this.usedValue - this.min) / (this.max - this.min);
  }
  renderLabel() {
    var _a;
    if (((_a = this.label) === null || _a === void 0 ? void 0 : _a.length) > 0) {
      return (h("div", { class: "label" }, h("dx-text", { type: "Infotext-Standard", color: "headline" }, this.label)));
    }
  }
  renderMinMaxLabels() {
    if (this.showminmaxlabel) {
      return (h("div", { class: "min-max-labels" }, h("dx-text", { type: "Infotext-Small", color: "tags", ref: (el) => (this.minLabelElement = el) }, formatValue(this.min, this.formattingpattern)), h("dx-text", { type: "Infotext-Small", color: "tags", ref: (el) => (this.maxLabelElement = el) }, formatValue(this.max, this.formattingpattern))));
    }
  }
  renderValue() {
    if (this.showvaluelabel) {
      return (h("div", { class: "value", ref: (el) => (this.valueElement = el) }, h("dx-text", { type: "Paragraph-Big", color: "headline", ref: (el) => (this.labelTextElement = el) }, formatValue(this.usedValue, this.formattingpattern))));
    }
  }
  render() {
    this.checkAsserts();
    const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
    return (h(Host, { class: {
        readonly: this.readonly,
        disabled: this.disabled,
        "is-safari": isSafari,
      }, tabIndex: 0, onKeyDown: (e) => this.keyDownOnSlider(e), onKeyUp: (e) => this.keyUpOnSlider(e) }, this.renderValue(), h("div", { class: "slider", onClick: (e) => this.clickOnSlider(e) }, h("div", { class: "line", ref: (el) => (this.lineElement = el) }, h("div", { class: "filled", style: { transform: `scaleX(${this.relativeValue})` } })), this.renderMinMaxLabels(), h("div", { class: "knob", ref: (el) => (this.knobElement = el), onClick: (e) => e.stopPropagation(), onPointerDown: (e) => this.dragController.onPointerDown(e), onTouchStart: (e) => this.dragController.onTouchStart(e) })), this.renderLabel(), h("div", { class: "keyboard-focus" })));
  }
  get self() { return getElement(this); }
  static get watchers() { return {
    "value": ["valueChanged"]
  }; }
};
const KNOB_WIDTH = 40;
DxSlider.style = dxSliderCss;

export { DxSlider as dx_slider };
