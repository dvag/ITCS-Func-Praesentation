import { r as registerInstance, h, H as Host, g as getElement } from './index-04c470ea.js';
import { o as onNextFrame } from './render-util-1dee6655.js';

const dxElementSwapperCss = ":host{display:block;position:relative;width:max-content;height:max-content}:host:host([hidden]){display:none !important}:host .swappable{line-height:0;will-change:transform, opacity;transition:transform var(--dx-element-swapper-transition-duration, 150ms) ease-in-out, opacity var(--dx-element-swapper-transition-duration, 150ms) ease-in-out;z-index:1}:host .swappable.hidden{opacity:0;transform:scale(0.25);z-index:-1}:host .swappable.overlap-parent{position:absolute;top:0;left:0;width:100%;height:100%;display:flex;align-items:center;justify-content:center}";

const DxElementSwapper = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    /**
     * Defines whether the first or the second slot is currently visible.
     *
     * @value first: First slot is visible.
     * @value second: Second slot is visible.
     * @value none: No slot is visible.
     */
    this.active = "first";
  }
  render() {
    return (h(Host, null, h("div", { class: {
        swappable: true,
        hidden: this.active !== "first",
      } }, h("slot", { name: "first" })), h("div", { class: {
        swappable: true,
        "overlap-parent": true,
        hidden: this.active !== "second",
      } }, h("slot", { name: "second" }))));
  }
};
DxElementSwapper.style = dxElementSwapperCss;

const dxHorizontalGrowBoxCss = ".sc-dx-horizontal-grow-box-h{display:flex;flex-direction:row;visibility:hidden}.sc-dx-horizontal-grow-box-h([hidden]).sc-dx-horizontal-grow-box-h{display:none !important}.animate-from-left.sc-dx-horizontal-grow-box-h{flex-direction:row-reverse}.sc-dx-horizontal-grow-box-h .slot-container.sc-dx-horizontal-grow-box{display:flex;width:max-content}.overflow-hidden.sc-dx-horizontal-grow-box-h{overflow:hidden}.transition-enabled.sc-dx-horizontal-grow-box-h{transition:width 300ms ease-in-out}.visible.sc-dx-horizontal-grow-box-h{visibility:visible}";

const DxHorizontalGrowBox = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.overflowHidden = true;
    this.visible = true;
    this.transitionEnabled = false;
    /**
     * Whether the container is open or not. When changed the container transitions smoothly to the correct width.
     *
     * @value true: The container displays it's content.
     * @value false: The container hides it's content.
     */
    this.open = true;
    /**
     * Disconnects the resizeObserver after
     */
    this.limitresizes = -1;
    this.animationmode = "open-from-right";
  }
  onForceWidthChanged() {
    var _a;
    if (this.forcewidth == null) {
      this.initializeResizeObserver();
    }
    else {
      (_a = this.resizeObserver) === null || _a === void 0 ? void 0 : _a.disconnect();
      this.resizeObserver = null;
      this.updateWidth();
    }
  }
  onOpenChanged() {
    this.updateWidth();
  }
  connectedCallback() {
    if (this.forcewidth == null) {
      this.initializeResizeObserver();
    }
    else {
      this.updateWidth();
    }
  }
  componentDidLoad() {
    onNextFrame(() => {
      this.transitionEnabled = true;
      this.overflowHidden = !this.open;
      this.visible = this.open;
    });
  }
  onTransitionStart(e) {
    if (e.target !== this.self) {
      return;
    }
    this.overflowHidden = true;
    this.visible = true;
  }
  onTransitionEnd(e) {
    if (e.target !== this.self) {
      return;
    }
    this.overflowHidden = !this.open;
    this.visible = this.open;
  }
  getWidthOfContent() {
    var _a, _b, _c;
    if (!this.open) {
      return 0;
    }
    return (_c = (_a = this.forcewidth) !== null && _a !== void 0 ? _a : (_b = this.slotContainer) === null || _b === void 0 ? void 0 : _b.scrollWidth) !== null && _c !== void 0 ? _c : 0;
  }
  initializeResizeObserver() {
    this.resizeObserver = new ResizeObserver(() => {
      onNextFrame(() => this.updateWidth());
    });
  }
  updateWidth() {
    // Immediately update width on self
    this.self.style.width = this.getWidthOfContent() + "px";
  }
  setSlotContainer(slotContainer) {
    if (this.forcewidth != null) {
      return;
    }
    if (this.slotContainer !== slotContainer) {
      this.resizeObserver.disconnect();
    }
    this.slotContainer = slotContainer;
    this.resizeObserver.observe(this.slotContainer);
  }
  disconnectedCallback() {
    var _a;
    (_a = this.resizeObserver) === null || _a === void 0 ? void 0 : _a.disconnect();
  }
  render() {
    return (h(Host, { class: {
        "animate-from-left": this.animationmode === "open-from-left",
        "overflow-hidden": this.overflowHidden,
        visible: this.visible,
        "transition-enabled": this.transitionEnabled,
      } }, h("div", { class: "slot-container", ref: (ref) => this.setSlotContainer(ref) }, h("slot", null))));
  }
  get self() { return getElement(this); }
  static get watchers() { return {
    "forcewidth": ["onForceWidthChanged"],
    "open": ["onOpenChanged"]
  }; }
};
DxHorizontalGrowBox.style = dxHorizontalGrowBoxCss;

export { DxElementSwapper as dx_element_swapper, DxHorizontalGrowBox as dx_horizontal_grow_box };
