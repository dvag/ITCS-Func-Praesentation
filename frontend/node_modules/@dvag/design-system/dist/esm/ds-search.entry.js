import { r as registerInstance, c as createEvent, h, H as Host, g as getElement } from './index-04c470ea.js';
import { v as verifyElementId, E as ElementIdGenerator } from './element-id-handling-bb37154e.js';
import { D as Debounce } from './debounce-b376d37b.js';
import { o as onNextFrame } from './render-util-1dee6655.js';
import { i as isIos } from './platform.util-d50d8be8.js';
import { I as InputContainer } from './input-container-97f842b4.js';
import './value-store-f4663db1.js';

class SearchAutoCompleteHandler {
  constructor(requestId, value) {
    this.requestId = requestId;
    this.value = value;
  }
  provideValues(values) {
    this.internalValues = values === null || values === void 0 ? void 0 : values.map((value, index) => {
      return Object.assign({ id: `${index}` }, value);
    });
    // valuesProvided is the Promise resolver of the waitForValues() function
    this.valuesProvided(this.requestId);
  }
  waitForValues() {
    return new Promise((resolve) => (this.valuesProvided = resolve));
  }
  getValues() {
    return this.internalValues;
  }
}

const dsSearchCss = ":host{display:block}:host:host([hidden]){display:none !important}:host .container{position:relative;top:0;left:0;display:flex;height:38px;border-radius:4px;border:1px solid #c1c1c1;background-color:#ffffff;box-sizing:border-box;align-items:center}:host .container.required-outline{border-color:#e8b50e}:host .container.requirement-fulfilled{border-color:#c1c1c1}:host .container.red-outline{border-color:#be1413}:host .container.disabled-outline{border-color:#ebebeb}:host .container.active{border-color:#4c4c4c}:host .container ds-icon{padding-left:11px;cursor:pointer}:host .container input{height:22px;margin:8px 0 8px 8px;border:none;outline:none;font-family:\"Helvetica Neue\", \"Helvetica Neue LT W01\";font-size:16px;line-height:24px;letter-spacing:0.02px;color:#4c4c4c;width:1px;flex-grow:1}:host .container input::placeholder{color:#c1c1c1}:host .container input:disabled{background-color:#ffffff;color:#c1c1c1}:host .container .clear-button{visibility:hidden}:host .container .clear-button.visible{visibility:visible}:host .autocomplete-container{box-shadow:0 4px 12px 0 rgba(0, 0, 0, 0.32);border-radius:4px}:host .autocomplete-container .autocomplete-popup{width:100%;max-height:var(--ds-search-popup-height, 190px);background-color:#ffffff;overflow-y:scroll}:host .autocomplete-container .autocomplete-popup .wait-for-search-results{display:flex;justify-content:center;align-items:center;padding:16px 0 16px 0;height:64px}:host .autocomplete-container .autocomplete-popup .no-hits{display:flex;justify-content:center;align-items:center;text-align:center;padding:16px;min-height:64px}:host .autocomplete-container .autocomplete-popup .category-container .category-headline-container{border-bottom:1px solid #dedede;padding:16px;user-select:none}:host .autocomplete-container .autocomplete-popup .category-container .category-headline-container .category-headline{word-break:break-all;color:#7f7f7f}:host .autocomplete-container .autocomplete-popup .autocomplete-item{position:relative;user-select:none;-webkit-user-select:none;text-align:left;display:flex;flex-direction:column;justify-content:center;align-items:flex-start;box-sizing:border-box;padding:16px;color:#666666}:host .autocomplete-container .autocomplete-popup .autocomplete-item.selected{background-color:#f5f5f5}:host .autocomplete-container .autocomplete-popup .autocomplete-item:not(:last-child):after{border-bottom:1px solid #dedede;content:\"\";width:calc(100% - 16px);position:absolute;bottom:0px}:host .autocomplete-container .autocomplete-popup .autocomplete-item:hover{background-color:#f5f5f5;cursor:pointer}";

const DsSearch = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.search = createEvent(this, "search", 7);
    this.selectSearch = createEvent(this, "selectSearch", 7);
    this.valueChange = createEvent(this, "valueChange", 7);
    this.valueComplete = createEvent(this, "valueComplete", 7);
    this.searchDebounce = new Debounce(500);
    this.categories = new Map();
    this.navigatableListItems = [];
    this.inputFocused = false;
    this.internalValue = "";
    this.waitForSearchValues = false;
    this.popupopen = false;
    /**
     * Specifies the search term.
     * @value string: Search term
     */
    this.value = "";
    /**
     * Specifies the placeholder text of this component.
     * @value string: Text used as the placeholder.
     */
    this.placeholder = "Bitte eingeben ...";
    /**
     * Specifies how many entries are visible when the popup is open.
     *
     * @value number: a number like 2.5 or 4.5
     * @example example
     */
    this.visibleentries = 2.5;
    /**
     * Specifies the text that will be shown when there are no search results.
     * @value string: Text which will be displayed.
     * @example no-results-text
     */
    this.noresultstext = "Ihre Suche ergab leider keine Treffer.";
    /**
     * Component will call the browsers `scrollIntoView()` method on the form
     * component after each search request. So the user can easily see the popup to choose from.
     *
     * @value true: Component will scroll popup list into view.
     * @value false: Component won't touch scrolling at all.
     * @example autoscrollintoview
     */
    this.autoscrollintoview = false;
  }
  valueChanged() {
    this.obtainValueChangesFromOutside();
  }
  /**
   * Focuses this search.
   */
  async focusControl() {
    this.inputElement.focus();
  }
  componentWillLoad() {
    verifyElementId(this.self);
    this.obtainValueChangesFromOutside();
  }
  componentDidRender() {
    if (this.selectedOption != undefined && this.popupopen)
      this.scrollIntoView(this.selectedOption);
  }
  disconnectedCallback() {
    this.searchDebounce.reset();
  }
  obtainValueChangesFromOutside() {
    if (this.value !== this.internalValue) {
      this.internalValue = this.value;
      this.lastEmittedCompleteValue = this.value;
      this.selectedOption = this.createDummySelectedOptionWithCurrentValue();
    }
  }
  createDummySelectedOptionWithCurrentValue() {
    var _a;
    return ((_a = this.value) === null || _a === void 0 ? void 0 : _a.length) > 0
      ? {
        id: null,
        label: this.value,
        prelabel: null,
        sublabel: null,
        category: null,
        data: null,
      }
      : null;
  }
  onInputFocused() {
    this.popupopen = true;
    this.inputFocused = true;
    this.emitSearchEvent();
  }
  onInputBlurred() {
    onNextFrame(() => {
      this.waitForSearchValues = false;
      this.popupopen = false;
      this.emitValueChange();
      this.emitValueComplete();
      // If we already set inputFocused to false we don't want to
      if (this.inputFocused) {
        this.inputFocused = false;
        this.selectSearchValue(this.selectedOption);
      }
    });
  }
  clearInput() {
    this.inputElement.value = "";
    this.internalValue = "";
    this.selectedOption = null;
    this.searchValues = null;
    this.popupopen = false;
    this.selectSearch.emit(null);
    this.emitValueChange();
  }
  blurInput() {
    var _a;
    this.inputFocused = false;
    (_a = this.inputElement) === null || _a === void 0 ? void 0 : _a.blur();
  }
  getCurrentSearchValue() {
    var _a, _b, _c;
    if (!this.popupopen) {
      return null;
    }
    return ((_b = (_a = this.searchValues) === null || _a === void 0 ? void 0 : _a.find((searchValue) => searchValue.label.toLowerCase() === this.internalValue.toLowerCase())) !== null && _b !== void 0 ? _b : (_c = this.searchValues) === null || _c === void 0 ? void 0 : _c[0]);
  }
  onInputKeyUp(event) {
    if (this.handleUpAndDownNavigation(event)) ;
    else if (["Enter", "Escape"].includes(event.key)) {
      if ("Enter".includes(event.key)) {
        const directMatch = this.getCurrentSearchValue();
        if (directMatch == null) {
          this.clearInput();
          this.blurInput();
          return;
        }
        this.selectedOption = directMatch;
        this.selectSearchValue(this.selectedOption);
      }
      if ("Escape".includes(event.code) && this.popupopen) {
        this.popupopen = false;
      }
    }
  }
  handleUpAndDownNavigation(event) {
    var _a;
    if (["ArrowDown", "ArrowUp"].includes(event.code)) {
      if (((_a = this.navigatableListItems) === null || _a === void 0 ? void 0 : _a.length) > 0 && this.popupopen) {
        // no searchvalues present-> prevent select actions
        this.selectEntryWithArrowDownOrUp(event.code);
        event.preventDefault();
        event.stopImmediatePropagation();
        return true;
      }
      else if (this.internalValue === "") {
        //keep the popup closed no text in the input
        return;
      }
      else if (!this.popupopen) {
        this.emitSearchEvent();
        this.popupopen = true;
      }
    }
    return false;
  }
  selectEntryWithArrowDownOrUp(keyCode) {
    let selectedIndex = this.navigatableListItems.findIndex((option) => {
      var _a;
      if (instanceOfSearchAutocompleteValue(option)) {
        return option.id === ((_a = this.selectedOption) === null || _a === void 0 ? void 0 : _a.id);
      }
    });
    if (keyCode === "ArrowDown") {
      if (selectedIndex === -1 ||
        selectedIndex === this.navigatableListItems.length - 1) {
        this.selectOption(this.navigatableListItems.find((o) => instanceOfSearchAutocompleteValue(o)));
      }
      else {
        selectedIndex++;
        if (!instanceOfSearchAutocompleteValue(this.navigatableListItems[selectedIndex])) {
          selectedIndex++;
        }
        this.selectOption(this.navigatableListItems[selectedIndex]);
      }
    }
    else if (keyCode === "ArrowUp") {
      if (selectedIndex <= 0) {
        this.selectOption(this.navigatableListItems[this.navigatableListItems.length - 1]);
      }
      else {
        selectedIndex--;
        if (selectedIndex <= 0) {
          selectedIndex = this.navigatableListItems.length - 1;
        }
        if (!instanceOfSearchAutocompleteValue(this.navigatableListItems[selectedIndex])) {
          selectedIndex--;
        }
        if (selectedIndex > 0) {
          this.selectOption(this.navigatableListItems[selectedIndex]);
        }
      }
    }
  }
  selectOption(option) {
    this.selectedOption = option;
    this.internalValue = this.selectedOption.label;
    this.emitValueChange();
    this.scrollIntoView(this.selectedOption);
  }
  selectSearchValue(value) {
    if (value == undefined) {
      return;
    }
    this.selectedOption = value;
    this.internalValue = value.label;
    this.searchValues = null;
    this.selectSearch.emit(value);
    this.popupopen = false;
    this.blurInput();
  }
  scrollIntoView(optionToView) {
    var _a, _b, _c;
    if (this.popupopen) {
      const selectedIndex = this.navigatableListItems.findIndex((option) => option.id === (optionToView === null || optionToView === void 0 ? void 0 : optionToView.id));
      if (selectedIndex > -1) {
        const list = this.self.shadowRoot.querySelector(".autocomplete-popup");
        const items = Array.from(this.self.shadowRoot.querySelectorAll(".autocomplete-item"));
        const listHeight = (_a = list === null || list === void 0 ? void 0 : list.offsetHeight) !== null && _a !== void 0 ? _a : 0;
        const itemHeight = (_c = (_b = items[0]) === null || _b === void 0 ? void 0 : _b.offsetHeight) !== null && _c !== void 0 ? _c : 0;
        list.scrollTop =
          itemHeight * selectedIndex - listHeight / 2 + itemHeight / 2;
      }
    }
  }
  onInputInput() {
    var _a;
    this.internalValue = this.inputElement.value;
    if (((_a = this.internalValue) === null || _a === void 0 ? void 0 : _a.length) > 0) {
      this.popupopen = true;
      this.emitValueChange();
    }
    else {
      this.popupopen = false;
      this.searchValues = null;
    }
    this.searchDebounce.run(() => {
      this.emitSearchEvent();
    });
  }
  emitSearchEvent() {
    this.waitForSearchValues = true;
    const searchId = dsSearchIdCounter++;
    const handler = new SearchAutoCompleteHandler(searchId, this.internalValue);
    handler.waitForValues().then((id) => {
      if (this.lastSearchId === id) {
        this.searchValues = handler.getValues();
        this.extractCategories();
        this.waitForSearchValues = false;
        if (this.autoscrollintoview && this.searchValues.length > 0) {
          onNextFrame(() => onNextFrame(() => this.inputElement.scrollIntoView({
            block: "start",
            behavior: "smooth",
          })));
        }
      }
    });
    this.lastSearchId = searchId;
    this.search.emit(handler);
  }
  extractCategories() {
    this.categories.clear();
    this.navigatableListItems = [];
    if (this.searchValues == undefined) {
      return;
    }
    this.populateCategoriesFromSearchResults();
    this.fillNavigatableListFromCategories();
  }
  populateCategoriesFromSearchResults() {
    this.searchValues.forEach((value) => {
      var _a, _b;
      if (value.category == undefined || value.category == "") {
        this.categories.set(null, [
          ...((_a = this.categories.get(null)) !== null && _a !== void 0 ? _a : []),
          value,
        ]);
      }
      else {
        this.categories.set(value.category, [
          ...((_b = this.categories.get(value.category)) !== null && _b !== void 0 ? _b : []),
          value,
        ]);
      }
    });
  }
  fillNavigatableListFromCategories() {
    Array.from(this.categories.keys()).map((headline) => {
      this.navigatableListItems.push({
        label: headline,
      });
      this.categories.get(headline).forEach((v) => {
        this.navigatableListItems.push(v);
      });
    });
  }
  emitValueComplete() {
    if (this.lastEmittedCompleteValue !== this.internalValue) {
      this.valueComplete.emit(this.internalValue);
      this.value = this.internalValue;
      this.lastEmittedCompleteValue = this.internalValue;
    }
  }
  emitValueChange() {
    if (this.lastEmittedChangeValue !== this.internalValue) {
      this.lastEmittedChangeValue = this.internalValue;
      this.value = this.internalValue;
      this.valueChange.emit(this.internalValue);
    }
  }
  render() {
    return h(Host, null, this.renderInput());
  }
  renderInput() {
    const popupHeight = this.visibleentries * POPUP_ENTRY_HEIGHT;
    return (h("dx-overlay", { position: "bottom", offsety: 4, disabled: !this.popupopen }, h(InputContainer, { active: this.inputFocused, title: this.value }, h("ds-icon", { icon: "suchen", size: 24 }), h("input", { id: ElementIdGenerator.createId(this.self, "control"), ref: (el) => (this.inputElement = el), onInput: () => this.onInputInput(), onKeyUp: (event) => this.onInputKeyUp(event), onFocus: () => this.onInputFocused(), onBlur: () => this.onInputBlurred(), type: "text", placeholder: this.placeholder, value: this.internalValue }), this.renderClearButton()), this.renderAutocompleteValues(popupHeight)));
  }
  renderClearButton() {
    const isClearButtonVisible = this.internalValue !== "" && this.inputFocused;
    return (h("ds-function-icon-button", { id: ElementIdGenerator.createId(this.self, "clear-button"), unfocusable: true, class: {
        "clear-button": true,
        visible: isClearButtonVisible,
      }, onPointerDown: () => this.clearInput() }, h("ds-icon", { icon: "schliessen-input", size: 16 })));
  }
  renderAutocompleteValues(popupHeight) {
    if (!this.popupopen) {
      return;
    }
    return (h("div", { class: "autocomplete-container", slot: "overlay" }, h("div", { class: "autocomplete-popup", style: {
        "--ds-search-popup-height": `${popupHeight}px`,
      } }, this.renderPopupContent())));
  }
  renderPopupContent() {
    if (this.waitForSearchValues) {
      return this.renderWaitingSpinner();
    }
    if (this.searchValues == undefined) {
      return;
    }
    if (this.searchValues.length === 0) {
      return this.renderEmptySearchResults();
    }
    return this.renderCategories();
  }
  renderCategories() {
    return Array.from(this.categories.keys()).map((key) => {
      return (h("div", { class: "category-container" }, this.renderCategoryHeadline(key), h("div", null, Array.from(this.categories.get(key)).map((entry) => {
        var _a, _b;
        return (h("div", { class: {
            "autocomplete-item": true,
            selected: (entry === null || entry === void 0 ? void 0 : entry.label) == ((_a = this.selectedOption) === null || _a === void 0 ? void 0 : _a.label) &&
              entry.category == ((_b = this.selectedOption) === null || _b === void 0 ? void 0 : _b.category),
          }, onPointerDown: () => {
            // because autocomplete list is attached to input's focus state
            // it's too late to wait for a click's mouseup part.
            if (!isIos()) {
              this.selectSearchValue(entry);
            }
          }, onClick: () => {
            // we can't use pointerdown at ios because of scrolling behavior
            if (isIos()) {
              this.selectSearchValue(entry);
            }
          } }, this.renderAutoCompleteItem(entry)));
      }))));
    });
  }
  renderCategoryHeadline(key) {
    if (key != undefined && key != "") {
      return (h("div", { class: "category-headline-container" }, h("ds-text", { class: "category-headline", type: "ftf" }, key)));
    }
  }
  renderWaitingSpinner() {
    return (h("div", { class: "wait-for-search-results" }, h("ds-spinner", { size: "medium" })));
  }
  renderEmptySearchResults() {
    return (h("div", { class: "no-hits" }, h("ds-text", { type: "it" }, this.noresultstext)));
  }
  renderAutoCompleteItem(value) {
    const renderText = (text, type = undefined) => {
      return (text === null || text === void 0 ? void 0 : text.length) > 0 ? h("ds-text", { type: type }, text) : null;
    };
    return (h("ds-column", null, [
      renderText(value.prelabel, "itk"),
      renderText(value.label),
      renderText(value.sublabel, "itk"),
    ]));
  }
  get self() { return getElement(this); }
  static get watchers() { return {
    "value": ["valueChanged"]
  }; }
};
function instanceOfSearchAutocompleteValue(object) {
  if (object != undefined) {
    return "id" in object && "label" in object;
  }
  return false;
}
let dsSearchIdCounter = 0;
const POPUP_ENTRY_HEIGHT = 76;
DsSearch.style = dsSearchCss;

export { DsSearch as ds_search };
