import { r as registerInstance, c as createEvent, a as readTask, w as writeTask, f as forceUpdate, h, H as Host, g as getElement } from './index-04c470ea.js';
import { D as Debounce } from './debounce-b376d37b.js';
import { s as sameArrayIgnoreOrder, c as sameArrayInOrder } from './misc-util-d3b69f2c.js';
import { a as assert } from './assert-7fc7463a.js';
import { E as ElementIdGenerator } from './element-id-handling-bb37154e.js';
import { c as containsExpandableRows } from './table.util-f19f1aef.js';
import { u as unawaited } from './async-0c539b38.js';
import './value-store-f4663db1.js';

function sameColumnSettings(a, b) {
  return ((a === null || a === void 0 ? void 0 : a.type) === (b === null || b === void 0 ? void 0 : b.type) &&
    (a === null || a === void 0 ? void 0 : a.align) === (b === null || b === void 0 ? void 0 : b.align) &&
    (a === null || a === void 0 ? void 0 : a.lines) === (b === null || b === void 0 ? void 0 : b.lines) &&
    JSON.stringify(a === null || a === void 0 ? void 0 : a.sizeStyle) == JSON.stringify(b === null || b === void 0 ? void 0 : b.sizeStyle));
}

const dxTableCss = "@keyframes slide-left{0%{transform:translateX(0)}100%{transform:translateX(-10px)}}:host{width:100%;--dx-table-sticky-columns-width:calc(var(--dx-table-selection-column-width, 0px) + var(--dx-table-expansion-column-width, 0px))}:host:host([hidden]){display:none !important}@media (min-width: 760px){:host{--dx-table-sticky-columns-width:var(--dx-internal-table-sticky-columns-width, 0)}}:host .page-size-picker{margin-bottom:12px}:host .table-container{display:flex}:host .table-container.uses-pagination{margin-bottom:16px}:host .table-container .table{display:flex;width:100%;overflow:hidden;flex-direction:column;position:relative}:host .table-container .table.selection-enabled{--dx-table-selection-display:flex}:host .table-container .table.with-collapse-rows{--dx-table-expand-display:flex}:host .table-container .table .scrollable{position:relative;overflow-x:auto;display:flex;flex-direction:column;margin-bottom:8px;min-width:100%;--dx-table-row-overflow:visible}:host .table-container .table .scrollable::-webkit-scrollbar{display:none}:host .table-container .table .shadow{position:absolute;top:0;width:0;background-color:rgba(0, 0, 0, 0.03);z-index:1;height:calc(100% - 8px);transition:width 300ms ease-in-out}:host .table-container .table .shadow.left{left:var(--dx-table-sticky-columns-width)}:host .table-container .table .shadow.right{right:0}:host .table-container .table .shadow.show{width:4px}:host .table-container .table .shadow.show.left{border-left:1px solid #d6d6d6}:host .table-container .table .shadow.show.right{border-right:1px solid #d6d6d6}:host .table-container ds-scroll-container.table{overflow:visible}:host .table-container .over-last-border{position:absolute;background:white;bottom:0;height:1px;width:100%}:host .table-container .over-last-border.with-scrollbar-offset{bottom:8px}:host .table-container .footer{display:flex;justify-content:flex-end;padding:12px 24px}:host .paginator-container{display:flex;justify-content:flex-end;margin-top:16px}:host .paginator-container .paginator{flex:0 0 266px}@media (min-width: 476px){:host .paginator-container .paginator{flex:0 0 392px}}.sidebar-container{display:flex;flex-direction:row-reverse;position:relative;transition:transform 300ms ease-in-out, flex 300ms ease-in-out;will-change:flex;flex:0 0 0;height:max-content;overflow:hidden;z-index:2}.sidebar-container.open{flex:0 0 56px;transition:transform 300ms ease-in-out, flex 300ms ease-in-out}.sidebar-container.open .sidebar .row{align-items:center}.sidebar-container .sidebar{display:flex;flex-direction:column;flex:0 0 56px;width:56px}.sidebar-container .sidebar .header{border-bottom:1px solid #c8aa22;box-sizing:border-box}.sidebar-container .sidebar .row{display:none;box-sizing:border-box;border-bottom:1px solid #d6d6d6}.sidebar-container .sidebar .row.selected{background-color:#f7f7f7}.sidebar-container .sidebar .row.visible{display:block}.sidebar-container .sidebar .row.last-row{border-bottom:none}.sidebar-container .sidebar .row .selection-container{display:flex;height:64px;justify-content:center;align-items:center}.sidebar-container .sidebar .footer{margin-top:4px;background-color:#e4ebcc}";

const DxTable = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.tableStateChanged = createEvent(this, "tableStateChanged", 7);
    this.selectionStateChanged = createEvent(this, "selectionStateChanged", 7);
    this.expansionChanged = createEvent(this, "expansionChanged", 7);
    this.internalScrollChanged = createEvent(this, "internalScrollChanged", 7);
    this.rowsSelected = createEvent(this, "rowsSelected", 7);
    this.currentSortSettings = { column: null, reverse: false };
    this.sortDebounce = new Debounce(50);
    this.rowDebounce = new Debounce(200);
    this.touchMoveDetected = false;
    this.expansionEnabled = false;
    this.initialized = false;
    this.scrollHandler = () => {
      this.controlOpticalHints();
    };
    this.currentPage = 1;
    this.selectedRowKeys = [];
    this.rowElements = [];
    /**
     * @internal
     */
    this.internalScrollable = false;
    /**
     * The initially selected option for the page size.
     * It only has an effect if the `pagesizes` property is defined.
     *
     * @value number: Number of rows per page.
     *
     * @example paginator
     */
    this.pagesize = 25;
    /**
     * When defined it enables the pagination for this table.
     * It defines the available page sizes a user is able to select.
     *
     * @value ArrayString: Comma separated List of values in JSON-format e.g.: "[5,10,25]"
     * @value number[]: Array of numbers.
     *
     * @example paginator
     */
    this.pagesizes = null;
    /**
     * Specifies the initial sort direction.
     *
     * @value asc: Ascending order.
     * @value desc: Descending order.
     *
     * @example initial-sort
     */
    this.initialsortdirection = "asc";
    /**
     * Specifies whether the table is self-managed or remote-controlled.
     *
     * @value managed: The table is responsible for sorting and pagination.
     * @value remote: The table relies on an external implementation for creating rows, sorting and pagination using the `tableStateChanged` event.
     *
     * @example remote
     * @example remote-complex
     */
    this.mode = "managed";
    /**
     * Enables the selection of rows.
     * A `key` for every row has to be specified.
     *
     * @value true: The selection-group will be opened.
     * @value false: The selection-group will be closed.
     *
     * @example selection
     */
    this.selectionenabled = false;
    /**
     * Specifies if only one or multiple rows can be selected.
     *
     * @value multi: Multiple rows can be selected.
     * @value single: One row can be selected at a time.
     *
     * @example selection-mode
     */
    this.selectionmode = "multi";
    /**
     * The data length this table should visualize. In case the table manages itself this attribute should not be set.
     * If the table is remote-controlled this attribute has to be set because the table needs to know the exact amount
     * of data to visualize the **paging** accordingly.
     *
     * @example remote
     * @example remote-complex
     */
    this.rowcount = 0;
  }
  onInternalScrollableChanged() {
    this.internalScrollChanged.emit(this.internalScrollable);
  }
  onSideBarOpenChange() {
    if (!this.selectionenabled) {
      this.selectedRowKeys = [];
      if (this.selectionGroup != null) {
        this.selectionGroup.value = null;
        this.rowsSelected.emit(null);
      }
      else {
        this.rowsSelected.emit([]);
      }
    }
    else {
      const noRowIdsDefined = this.getRows().every((row) => row.rowid == null);
      if (noRowIdsDefined) {
        console.warn("To use table selection you have to define at least one <dx-table-row> with a valid 'rowid'!\n", this.self);
        this.selectionenabled = false;
      }
    }
    this.controlOpticalHints();
    this.emitSelectionChanged();
    readTask(() => unawaited(this.updateTableScroll(this.self.offsetWidth)));
  }
  onSelectionModeChanged() {
    this.emitSelectionChanged();
  }
  onScrollableChange() {
    var _a;
    this.setScrollable();
    this.controlOpticalHints();
    (_a = this.headerItemElements) === null || _a === void 0 ? void 0 : _a.forEach((headerItem) => {
      headerItem.usemaxwidth = this.internalScrollable;
    });
  }
  onTouchStart() {
    this.touchMoveDetected = false;
  }
  onTouchmove() {
    this.touchMoveDetected = true;
  }
  onTouchEnd(event) {
    if (this.touchMoveDetected) {
      event.stopImmediatePropagation();
      this.touchMoveDetected = false;
    }
  }
  connectedCallback() {
    this.initialized = false;
    this.mutationObserver = new MutationObserver(() => {
      const headerItems = this.self.querySelectorAll("dx-table-header-item");
      const rows = this.self.querySelectorAll("dx-table-row");
      this.updateHeaderItems(Array.from(headerItems)).then(() => {
        this.updateRows(Array.from(rows));
        const expansionEnabled = containsExpandableRows(this.self);
        if (expansionEnabled !== this.expansionEnabled) {
          this.expansionEnabled = expansionEnabled;
          this.expansionChanged.emit(expansionEnabled);
        }
      });
    });
    this.mutationObserver.observe(this.self, {
      childList: true,
      subtree: true,
      attributes: true,
    });
    this.setScrollable();
  }
  disconnectedCallback() {
    var _a, _b;
    (_a = this.mutationObserver) === null || _a === void 0 ? void 0 : _a.disconnect();
    this.rowDebounce.reset();
    this.sortDebounce.reset();
    (_b = this.tableResizeObserver) === null || _b === void 0 ? void 0 : _b.disconnect();
  }
  initTableResizeObserver() {
    this.tableResizeObserver = new ResizeObserver((entries) => {
      this.updateTableScroll(entries[0].contentRect.width).then(() => {
        this.controlOpticalHints();
      });
      writeTask(() => {
        this.self.style.setProperty("--dx-table-width", `${entries[0].contentRect.width}px`);
      });
    });
  }
  setScrollable() {
    var _a;
    if (this.scrollable) {
      this.initTableResizeObserver();
    }
    else {
      (_a = this.tableResizeObserver) === null || _a === void 0 ? void 0 : _a.disconnect();
      this.tableResizeObserver = null;
      this.internalScrollable = false;
      this.updateCellSettings().then();
      writeTask(() => {
        this.self.style.removeProperty("--dx-table-width");
      });
    }
  }
  emitSelectionChanged() {
    this.selectionStateChanged.emit({
      enabled: this.selectionenabled,
      mode: this.selectionmode,
    });
  }
  async updateTableHeaderWidths() {
    var _a, _b;
    const headerItemWidthsPromises = (_b = (_a = this.headerItemElements) === null || _a === void 0 ? void 0 : _a.map(async (headerItem) => {
      const maxWidth = await headerItem.getMaxWidth();
      return {
        headerItemElement: headerItem,
        width: isNaN(maxWidth) ? await headerItem.getMinWidth() : maxWidth,
      };
    })) !== null && _b !== void 0 ? _b : [];
    this.headerItemElementsWidth = await Promise.all(headerItemWidthsPromises).then((headerItemElements) => {
      return headerItemElements.reduce((map, headerItemWidth) => {
        return map.set(headerItemWidth.headerItemElement, headerItemWidth.width);
      }, new Map());
    });
  }
  getStickyColumnsWidth() {
    var _a, _b;
    const expansionSpace = containsExpandableRows(this.self)
      ? EXPANSION_COLUMN_WIDTH
      : 0;
    const selectionSpace = this.selectionenabled ? SELECTION_COLUMN_WIDTH : 0;
    return (((_b = (_a = this.headerItemElements) === null || _a === void 0 ? void 0 : _a.filter((headerItem) => headerItem.slot === "sticky")) === null || _b === void 0 ? void 0 : _b.reduce((acc, headerItem) => {
      var _a;
      return (_a = acc + this.headerItemElementsWidth.get(headerItem)) !== null && _a !== void 0 ? _a : 0;
    }, 0)) +
      expansionSpace +
      selectionSpace);
  }
  getScrollWidth() {
    var _a, _b;
    const collapsableSpace = containsExpandableRows(this.self)
      ? EXPANSION_COLUMN_WIDTH
      : 0;
    const selectionSpace = this.selectionenabled ? SELECTION_COLUMN_WIDTH : 0;
    return (((_b = (_a = this.headerItemElements) === null || _a === void 0 ? void 0 : _a.reduce((acc, headerItem) => {
      var _a;
      return (_a = acc + this.headerItemElementsWidth.get(headerItem)) !== null && _a !== void 0 ? _a : 0;
    }, 0)) !== null && _b !== void 0 ? _b : 0) +
      collapsableSpace +
      selectionSpace);
  }
  setScrollContainer(scrollContainer) {
    var _a, _b;
    if (this.scrollContainer === scrollContainer) {
      return;
    }
    (_a = this.scrollContainer) === null || _a === void 0 ? void 0 : _a.removeEventListener("scroll", this.scrollHandler);
    this.scrollContainer = scrollContainer;
    (_b = this.scrollContainer) === null || _b === void 0 ? void 0 : _b.addEventListener("scroll", this.scrollHandler);
  }
  async updateTableScroll(tableWidth) {
    var _a;
    if (!this.scrollable) {
      return;
    }
    if (this.headerItemElements == null ||
      this.headerItemElements.length === 0) {
      return;
    }
    const collapsableSpace = containsExpandableRows(this.self)
      ? EXPANSION_COLUMN_WIDTH
      : 0;
    const selectionSpace = this.selectionenabled ? SELECTION_COLUMN_WIDTH : 0;
    await Promise.all((_a = this.headerItemElements) === null || _a === void 0 ? void 0 : _a.map((headerItemElement) => headerItemElement.getMinWidth())).then((minWidthArray) => {
      var _a;
      const columnsMinWidthsSum = (_a = minWidthArray === null || minWidthArray === void 0 ? void 0 : minWidthArray.reduce((acc, currentValue) => {
        if (isNaN(currentValue)) {
          console.error(`dx-table:`, this.self, `Every <dx-table-header-item> in a scrollable table has to set a minwidth. At least one <dx-table-header-item> was not given a size.`);
        }
        return acc + currentValue;
      }, 0)) !== null && _a !== void 0 ? _a : 0;
      const isScrollable = columnsMinWidthsSum + selectionSpace + collapsableSpace > tableWidth;
      if (this.internalScrollable !== isScrollable) {
        this.internalScrollable = isScrollable;
        this.updateCellSettings().then();
        if (!isScrollable) {
          this.showLeftShadow = false;
          this.showRightShadow = false;
        }
      }
    });
  }
  controlOpticalHints() {
    if (!this.internalScrollable || this.scrollContainer == null) {
      return;
    }
    const scrollDistance = this.scrollContainer.scrollLeft;
    const maxScrollDistance = this.scrollContainer.scrollWidth - this.scrollContainer.clientWidth;
    writeTask(() => {
      var _a;
      this.showRightShadow = scrollDistance < maxScrollDistance;
      this.showLeftShadow =
        this.isScrollingPossible() && ((_a = this.scrollContainer) === null || _a === void 0 ? void 0 : _a.scrollLeft) > 0;
    });
  }
  isScrollingPossible() {
    var _a, _b;
    return (this.internalScrollable &&
      ((_a = this.scrollContainer) === null || _a === void 0 ? void 0 : _a.scrollWidth) > ((_b = this.scrollContainer) === null || _b === void 0 ? void 0 : _b.clientWidth));
  }
  /**
   * @internal
   */
  async invokeSort(element, reverse) {
    if (!this.initialized) {
      this.invokeSortInputParamsBeforeInit = {
        element,
        reverse,
      };
      return;
    }
    return this.internalInvokeSort(element, reverse);
  }
  async internalInvokeSort(element, reverse) {
    var _a;
    const index = this.headerItemElements.indexOf(element);
    this.headerItemElements.forEach((el, i) => {
      if (index !== i) {
        el.setSortDirection("neutral");
      }
    });
    this.sortState = {
      column: (_a = element.columnid) !== null && _a !== void 0 ? _a : element.label,
      index: index,
      direction: reverse ? "desc" : "asc",
    };
    this.sortRows({ column: index, reverse: reverse });
  }
  reSort() {
    if (this.currentSortSettings.column !== null) {
      this.sortRows(this.currentSortSettings);
    }
  }
  handlePaginationPageSizeChanged(e) {
    this.pagesize = e.detail;
    this.emitTableStateChanged();
    this.updateVisibility();
  }
  isUsingPagination() {
    return this.pagesizes != null && this.pagesizes.length > 0;
  }
  updateRows(rows) {
    this.rowDebounce.run(async () => {
      // Disconnect to prevent further SlotObserver calls through DOM Manipulation
      this.mutationObserver.disconnect();
      this.checkForDuplicateRowKeys(rows);
      this.handleRemoteSelection(rows);
      if (!sameArrayIgnoreOrder(rows, this.rowElements)) {
        this.rowElements = rows;
        if (this.mode === "managed") {
          this.rowcount = rows.length;
          if (!hasAnySortableColumns(this.headerItemElements)) {
            await this.reOrderRows(this.rowElements);
          }
          else {
            this.reSort();
          }
        }
      }
      else {
        forceUpdate(this.self);
      }
      await this.updateVisibility();
      await this.updateCellSettings();
      // Reconnect SlotObserver
      this.mutationObserver.observe(this.self, {
        childList: true,
        subtree: true,
        attributes: true,
      });
      this.init();
    });
  }
  handleRemoteSelection(currentRows) {
    requestAnimationFrame(() => {
      var _a;
      const tmpRowsSelected = [...this.selectedRowKeys];
      if (this.selectionmode === "single") {
        const previousSelectedRowId = this.selectedRowKeys[0];
        const newlySelectedRowID = (_a = currentRows
          .filter((row) => row.selected == true)
          .filter((row) => row.rowid !== previousSelectedRowId)[0]) === null || _a === void 0 ? void 0 : _a.rowid;
        if (newlySelectedRowID == undefined) {
          return;
        }
        this.selectionenabled = true;
        this.handleRadioSelection(newlySelectedRowID);
      }
      else {
        currentRows.forEach((row) => {
          this.selectionenabled || (this.selectionenabled = row.selected);
          this.handleCheckboxSelection(row.rowid, row.selected);
        });
      }
      if (!sameArrayIgnoreOrder(tmpRowsSelected, this.selectedRowKeys)) {
        this.rowsSelected.emit([...this.selectedRowKeys]);
      }
    });
  }
  init() {
    this.initialized = true;
    if (this.invokeSortInputParamsBeforeInit != null) {
      this.internalInvokeSort(this.invokeSortInputParamsBeforeInit.element, this.invokeSortInputParamsBeforeInit.reverse).then();
      this.invokeSortInputParamsBeforeInit = null;
    }
  }
  getCurrentRowsRangeIndices() {
    var _a, _b;
    const fromIndex = ((_a = this.pagesize) !== null && _a !== void 0 ? _a : 0) * (this.currentPage - 1);
    const result = {
      fromIndex: fromIndex,
      toIndex: fromIndex,
    };
    if (this.mode === "managed") {
      result.toIndex += ((_b = this.pagesize) !== null && _b !== void 0 ? _b : this.rowcount) - 1;
    }
    else {
      result.toIndex += this.pagesize - 1;
    }
    // There could be fewer rows visible than the pagesize allows at the last page
    result.toIndex = Math.min(this.rowcount - 1, result.toIndex);
    return result;
  }
  emitTableStateChanged() {
    const currentRowsRangeIndices = this.getCurrentRowsRangeIndices();
    this.tableStateChanged.emit({
      page: this.currentPage,
      pageSize: this.pagesize,
      fromIndex: currentRowsRangeIndices.fromIndex,
      toIndex: currentRowsRangeIndices.toIndex,
      sortState: this.sortState,
    });
  }
  async updateHeaderItems(headerItems) {
    var _a, _b;
    const newSettings = await Promise.all(headerItems.map((headerItem) => {
      return headerItem.toColumnSettings();
    }));
    if (this.sameSettings(newSettings) &&
      sameArrayInOrder(this.headerItemElements, headerItems)) {
      return;
    }
    this.settings = newSettings;
    const hadAnySortableColumnsBeforeChange = hasAnySortableColumns(this.headerItemElements);
    this.headerItemElements = headerItems;
    if (!hadAnySortableColumnsBeforeChange) {
      const sortableHeaderColumns = headerItems === null || headerItems === void 0 ? void 0 : headerItems.filter((headerItem) => headerItem.sortable);
      let sortedHeaderColumn = null;
      if (((_a = this.initialsort) === null || _a === void 0 ? void 0 : _a.length) > 0) {
        sortedHeaderColumn = sortableHeaderColumns === null || sortableHeaderColumns === void 0 ? void 0 : sortableHeaderColumns.find((headerItem) => {
          return (headerItem.columnid === this.initialsort ||
            headerItem.label === this.initialsort);
        });
        assert(sortedHeaderColumn != null, () => `No <dx-table-header-item> element with 'columnid' or 'label' "${this.initialsort}" found`);
      }
      sortedHeaderColumn !== null && sortedHeaderColumn !== void 0 ? sortedHeaderColumn : (sortedHeaderColumn = sortableHeaderColumns === null || sortableHeaderColumns === void 0 ? void 0 : sortableHeaderColumns[0]);
      sortedHeaderColumn === null || sortedHeaderColumn === void 0 ? void 0 : sortedHeaderColumn.setSortDirection((_b = this.initialsortdirection) !== null && _b !== void 0 ? _b : "asc");
    }
    readTask(() => {
      const table = this.self.shadowRoot.querySelector(".table");
      if (table != null) {
        unawaited(this.updateTableScroll(table.getBoundingClientRect().width));
      }
      this.updateCellSettings().then();
    });
  }
  sameSettings(settings) {
    return (this.settings != null &&
      this.settings.length === settings.length &&
      settings.every((setting, index) => {
        return sameColumnSettings(setting, this.settings[index]);
      }));
  }
  async updateCellSettings() {
    var _a;
    (_a = this.headerItemElements) === null || _a === void 0 ? void 0 : _a.forEach((headerItem) => {
      headerItem.usemaxwidth = this.internalScrollable;
    });
    return Promise.all(this.getRows().concat(this.getFooters()).flatMap((row) => {
      return Array.from(row.querySelectorAll("dx-table-cell"))
        .map((cell, index) => {
        var _a;
        if (index < ((_a = this.headerItemElements) === null || _a === void 0 ? void 0 : _a.length)) {
          return cell.obtainSettings(this.settings[index]);
        }
        return null;
      })
        .filter((promise) => promise != null);
    }));
  }
  getRows() {
    var _a;
    return (_a = this.rowElements) !== null && _a !== void 0 ? _a : [];
  }
  getFooters() {
    var _a;
    return (_a = Array.from(this.self.querySelectorAll("dx-table-footer"))) !== null && _a !== void 0 ? _a : [];
  }
  compareColumns(firstRow, secondRow, columnIndex, type) {
    var _a;
    const columnSelector = "dx-table-cell:nth-child(" + (columnIndex + 1) + ")";
    if (type === "html") {
      const headerItem = this.headerItemElements[columnIndex];
      if (headerItem.customSort != null) {
        return headerItem.customSort(firstRow.querySelector(columnSelector), secondRow.querySelector(columnSelector));
      }
      return 0;
    }
    const valueA = firstRow.querySelector(columnSelector).getAttribute("value");
    const valueB = secondRow
      .querySelector(columnSelector)
      .getAttribute("value");
    if (type === "numeric" || type === "currency") {
      return parseFloat(valueA) - parseFloat(valueB);
    }
    return (_a = valueA === null || valueA === void 0 ? void 0 : valueA.localeCompare(valueB)) !== null && _a !== void 0 ? _a : (valueB ? -1 : 0);
  }
  sortRows(sortSettings) {
    if (!equalSortSettings(this.currentSortSettings, sortSettings)) {
      this.currentPage = 1;
      this.emitTableStateChanged();
    }
    if (this.mode === "remote") {
      return;
    }
    this.currentSortSettings.column = sortSettings.column;
    this.currentSortSettings.reverse = sortSettings.reverse;
    this.sortDebounce.run(async () => {
      var _a, _b;
      const rows = [...((_a = this.getRows()) !== null && _a !== void 0 ? _a : [])];
      const type = (_b = this.settings[sortSettings.column]) === null || _b === void 0 ? void 0 : _b.type;
      const sortScale = sortSettings.reverse ? -1 : 1;
      const sortOrder = this.headerItemElements
        .filter((_, index) => index !== sortSettings.column)
        .filter((headerItem) => headerItem.sortable && headerItem.sortpriority != null)
        .sort((a, b) => b.sortpriority - a.sortpriority)
        .map((headerItem) => this.headerItemElements.indexOf(headerItem));
      rows.sort((a, b) => {
        var _a;
        let currentColumnIndex = sortSettings.column;
        let currentType = type;
        const sortOrderCpy = [...sortOrder];
        let result = this.compareColumns(a, b, currentColumnIndex, currentType) *
          sortScale;
        // Secondary sorting
        while (result === 0 && sortOrderCpy.length > 0) {
          currentColumnIndex = sortOrderCpy.pop();
          currentType = (_a = this.settings[currentColumnIndex]) === null || _a === void 0 ? void 0 : _a.type;
          // Do not apply scale because we want to always sort ascending for secondary sorting
          result = this.compareColumns(a, b, currentColumnIndex, currentType);
        }
        return result;
      });
      await this.reOrderRows(rows);
      this.updateVisibility();
    });
  }
  checkForDuplicateRowKeys(currentRows) {
    const duplicateMap = currentRows.reduce((map, row) => {
      var _a, _b;
      if (row.rowid != null) {
        map[row.rowid] = (_b = (_a = map[row.rowid]) === null || _a === void 0 ? void 0 : _a.concat(row)) !== null && _b !== void 0 ? _b : [row];
      }
      return map;
    }, {});
    Object.keys(duplicateMap).forEach((key) => {
      const rowList = duplicateMap[key];
      if (rowList.length > 1) {
        console.error(`Duplicate key "${key}" in rows:\n`, ...rowList);
      }
    });
  }
  async reOrderRows(rows) {
    return new Promise((resolve) => {
      writeTask(() => {
        rows.forEach((row, index) => {
          row.style.order = (index + 1).toString();
        });
        resolve();
      });
    });
  }
  async updateVisibility() {
    const rows = this.getRows();
    if (this.mode === "managed" && this.isUsingPagination()) {
      const visibleRowRange = this.getCurrentRowsRangeIndices();
      await new Promise((resolve) => {
        readTask(() => {
          const rowVisibilities = rows.map((row) => {
            const sortIndex = parseInt(row.style.order) - 1;
            return (sortIndex >= visibleRowRange.fromIndex &&
              sortIndex <= visibleRowRange.toIndex);
          });
          writeTask(() => {
            rows.forEach((row, index) => {
              row.setAttribute("visible", rowVisibilities[index].toString());
            });
            resolve();
          });
        });
      });
    }
    const lastRow = this.getLastVisibleRow();
    if (lastRow != null) {
      lastRow.style.setProperty(BORDER_BOTTOM_PROPERTY, "none");
    }
    rows.forEach((row) => {
      const isLastRow = lastRow === row;
      if (!isLastRow) {
        row.style.removeProperty(BORDER_BOTTOM_PROPERTY);
      }
    });
  }
  getLastVisibleRow(rows) {
    return (rows !== null && rows !== void 0 ? rows : this.getRows())
      .filter((row) => row.visible)
      .reduce((rowAndOrder, currentRow) => {
      const order = parseInt(currentRow.style.order);
      if (order > rowAndOrder.order ||
        rowAndOrder.order === -1 ||
        isNaN(rowAndOrder.order)) {
        return {
          order: order,
          row: currentRow,
        };
      }
      return rowAndOrder;
    }, {
      order: -1,
      row: null,
    }).row;
  }
  handlePaginationPageChanged(e) {
    const page = e.detail;
    if (this.currentPage !== page) {
      this.currentPage = page;
      this.emitTableStateChanged();
      this.updateVisibility();
    }
  }
  handleRadioSelection(key) {
    if (this.selectedRowKeys[0] === key) {
      return;
    }
    this.selectedRowKeys = [key];
    this.rowElements.forEach((row) => {
      row.selected = row.rowid == this.selectedRowKeys[0];
    });
  }
  handleCheckboxSelection(key, checked) {
    const containsKey = this.selectedRowKeys.includes(key);
    if (containsKey && !checked) {
      this.selectedRowKeys = this.selectedRowKeys.filter((rowKey) => rowKey !== key);
    }
    else if (!containsKey && checked) {
      this.selectedRowKeys = [...this.selectedRowKeys, key];
    }
  }
  componentDidRender() {
    this.controlOpticalHints();
    if (this.selectionmode === "single") {
      this.selectionGroup.value = this.selectedRowKeys[0];
    }
  }
  async componentWillRender() {
    await this.updateTableHeaderWidths();
  }
  render() {
    return (h(Host, { role: "table", style: {
        "--dx-internal-table-sticky-columns-width": this.getStickyColumnsWidth().toString() + "px",
        "--dx-table-selection-column-width": this.selectionenabled
          ? `${SELECTION_COLUMN_WIDTH}px`
          : "0px",
        "--dx-table-expansion-column-width": this.expansionEnabled
          ? `${EXPANSION_COLUMN_WIDTH}px`
          : "0px",
      } }, this.renderPageSizePicker(), h("dx-radio-button-group", { radiogroupid: "table-selection-group", ref: (ref) => {
        this.selectionGroup = ref;
      } }, h("div", { class: "table-container" }, this.renderTable())), this.renderPaginator()));
  }
  renderPageSizePicker() {
    if (!this.isUsingPagination()) {
      return;
    }
    return (h("dx-number-picker", { id: ElementIdGenerator.createId(this.self, "page-size-picker"), align: "right", class: "page-size-picker", value: this.pagesize, values: this.pagesizes, onValueChange: (e) => this.handlePaginationPageSizeChanged(e) }));
  }
  renderPaginator() {
    if (!this.isUsingPagination()) {
      return;
    }
    return (h("div", { class: "paginator-container" }, h("dx-number-paginator", { id: ElementIdGenerator.createId(this.self, "paginator"), class: "paginator", onPageChanged: (e) => this.handlePaginationPageChanged(e), current: this.currentPage, count: Math.ceil(this.rowcount / this.pagesize) })));
  }
  renderScrollableTableContent() {
    return (h("div", null, h("ds-scroll-container", { scrollbarborderradius: 0, thumbwidth: 8, scrollbaroffset: 4 }, h("div", { ref: (ref) => {
        writeTask(() => {
          this.setScrollContainer(ref);
        });
      }, class: { scrollable: true }, style: {
        "--dx-table-row-width": this.internalScrollable
          ? `${this.getScrollWidth()}px`
          : "none",
      } }, h("slot", null)))));
  }
  renderTable() {
    const reserveSpaceForCollapsableRows = containsExpandableRows(this.self);
    return [
      h("div", { class: {
          table: true,
          "with-collapse-rows": reserveSpaceForCollapsableRows,
          "selection-enabled": this.selectionenabled,
        }, ref: (ref) => {
          var _a;
          (_a = this.tableResizeObserver) === null || _a === void 0 ? void 0 : _a.observe(ref);
        } }, this.internalScrollable ? (this.renderScrollableTableContent()) : (h("slot", null)), h("div", { class: {
          shadow: true,
          left: true,
          show: this.showLeftShadow,
        } }, "\u00A0"), h("div", { class: {
          shadow: true,
          right: true,
          show: this.showRightShadow,
        } }, "\u00A0")),
    ];
  }
  get self() { return getElement(this); }
  static get watchers() { return {
    "internalScrollable": ["onInternalScrollableChanged"],
    "selectionenabled": ["onSideBarOpenChange"],
    "selectionmode": ["onSelectionModeChanged"],
    "scrollable": ["onScrollableChange"]
  }; }
};
const BORDER_BOTTOM_PROPERTY = "--dx-table-row-border-bottom";
function hasAnySortableColumns(headerItems) {
  return headerItems === null || headerItems === void 0 ? void 0 : headerItems.some((headerItem) => headerItem.sortable);
}
function equalSortSettings(first, second) {
  return first.column === second.column && first.reverse === second.reverse;
}
const EXPANSION_COLUMN_WIDTH = 64;
const SELECTION_COLUMN_WIDTH = 56;
DxTable.style = dxTableCss;

export { DxTable as dx_table };
