import { r as registerInstance, c as createEvent, h, H as Host, g as getElement } from './index-04c470ea.js';
import { E as ElementIdGenerator } from './element-id-handling-bb37154e.js';
import { o as onNextFrame } from './render-util-1dee6655.js';
import { a as isActiveElement } from './misc-util-d3b69f2c.js';
import { I as InputContainer } from './input-container-97f842b4.js';
import { R as ReadonlyTextElement } from './base-elements-20abac26.js';
import { E as ErrorPopup } from './error-popup-5aa6e69c.js';
import './value-store-f4663db1.js';

function configToNumber(config) {
  if (config == undefined) {
    return null;
  }
  return parseInt(`${config.prefix ? "1" : "0"}${config.focusNext ? "1" : "0"}`, 10);
}
function numberToConfig(number) {
  if (number == undefined) {
    return null;
  }
  const string = number.toString().padStart(2, "0");
  const toBool = (char) => char === "1";
  return { prefix: toBool(string[0]), focusNext: toBool(string[1]) };
}

const numberMaskIndicator = "#";
const characterMaskIndicator = "ยง";
class InputGroup {
  constructor() {
    this.pattern = "";
  }
}
class Delimiter {
}
function computeGroups(mask) {
  const chars = [...mask];
  const groups = [];
  let groupSize = 0;
  let group = new InputGroup();
  let delimiter = new Delimiter();
  let lastGroupCharacter = "";
  chars.forEach((c, i) => {
    if (c.match(inputGroupExp)) {
      //update new or current group
      if (lastGroupCharacter == "" || c == lastGroupCharacter) {
        ++groupSize;
        group.pattern = group.pattern + c;
        lastGroupCharacter = c;
        //handle single character
      }
      else if (lastGroupCharacter != c && groupSize === 0) {
        ++groupSize;
        lastGroupCharacter = c;
        group.pattern = group.pattern + c;
        //complete group and start new
      }
      else {
        group.width = groupSize;
        groups.push(group);
        group = new InputGroup();
        groupSize = 1;
        group.pattern = group.pattern + c;
        lastGroupCharacter = c;
      }
    }
    else if (c.match(delimiterExp)) {
      if (groupSize > 0) {
        group.width = groupSize;
        groups.push(group);
        group = new InputGroup();
      }
      delimiter.delimiter = c;
      groups.push(delimiter);
      delimiter = new Delimiter();
      groupSize = 0;
    }
    if (i == chars.length - 1) {
      if (groupSize > 0) {
        group.width = groupSize;
        groups.push(group);
      }
      group = new InputGroup();
    }
  });
  return groups;
}
const inputGroupExp = /[#ยง]/;
const delimiterExp = /[^ยง#]+/;

class GroupedTextInputController {
  constructor(inputGroup) {
    this.inputGroup = inputGroup;
    this.inputElement = null;
    this.lastValue = "";
  }
  setInputElement(el) {
    if (this.inputElement !== el) {
      this.inputElement = el;
    }
  }
  getInputGroup() {
    return this.inputGroup;
  }
  getInputElement() {
    return this.inputElement;
  }
  getInputValue() {
    var _a;
    return (_a = this.inputElement) === null || _a === void 0 ? void 0 : _a.value;
  }
  extractCharacters(amount, inputType) {
    const extracted = this.inputElement.value.substring(0, amount);
    this.inputElement.value = this.inputElement.value.slice(amount);
    this.onDeleteEvent(this, inputType);
    return extracted;
  }
  appendExtractedToValue(toBeSet, inputType) {
    this.inputElement.value += toBeSet;
    const newCaretPosition = inputType == "deleteContentBackward"
      ? this.caretPosition - 1
      : this.caretPosition;
    this.inputElement.selectionStart = newCaretPosition;
    this.inputElement.selectionEnd = newCaretPosition;
    this.caretPosition = newCaretPosition;
  }
  clearInput() {
    this.inputElement.value = "";
    this.lastValue = "";
    this.recomputeTextInputWidth();
  }
  checkIsFulfilled() {
    var _a;
    return ((_a = this.inputElement) === null || _a === void 0 ? void 0 : _a.value.length) == this.inputGroup.pattern.length;
  }
  focus() {
    this.inputElement.focus();
  }
  focusAndSetCaretPosition(selectionStart, selectionEnd) {
    this.inputElement.focus();
    this.inputElement.selectionStart = selectionStart;
    this.inputElement.selectionEnd = selectionEnd;
  }
  saveCurrentValue() {
    this.lastValue = this.inputElement.value;
  }
  resetToLastValue() {
    this.inputElement.value = this.lastValue;
  }
  checkPreventInput(e) {
    if (this.inputGroup.pattern[0] === characterMaskIndicator) {
      if (!e.data[0].match(/[a-zA-Z\W_]/)) {
        return true;
      }
    }
    else {
      if (!e.data[0].match(/\d/)) {
        return true;
      }
    }
    return false;
  }
  onInput(e) {
    e.preventDefault();
    if (!e.isTrusted) {
      if (this.shouldPrefixValue(e)) {
        this.inputElement.value = e.data + this.inputElement.value;
      }
      else {
        this.inputElement.value += e.data;
      }
    }
    const eventProps = numberToConfig(Number(e.detail));
    this.handleDeleteEvent(e);
    const overflow = this.handlePaste(e, eventProps.focusNext);
    this.handleOverflow(overflow, e.isTrusted, eventProps.focusNext);
    if (e.data != null && this.checkPreventInput(e)) {
      this.resetToLastValue();
      return;
    }
    this.saveCurrentValue();
    this.recomputeTextInputWidth();
    this.onValueChanged();
  }
  handleOverflow(overflow, currentlyFocused, shouldFocusNext = true) {
    const caretPosition = currentlyFocused
      ? this.inputElement.selectionStart - 1
      : null;
    const overflowsFromPaste = overflow.length > 0;
    const inputElementValue = this.getInputValue();
    const isOverflowing = overflowsFromPaste ||
      inputElementValue.length >= this.inputGroup.width + 1;
    if (isOverflowing) {
      if (overflowsFromPaste) {
        this.inputInNextGroupedInput(overflow, true, true, shouldFocusNext, 0);
      }
      else {
        const pushedChar = inputElementValue.slice(-1);
        this.inputElement.value = this.inputElement.value.slice(0, this.inputGroup.width);
        if (caretPosition != null) {
          this.inputElement.selectionStart = caretPosition + 1;
          this.inputElement.selectionEnd = caretPosition + 1;
        }
        const gotoNextInput = this.inputGroup.width == caretPosition;
        this.inputInNextGroupedInput(pushedChar, false, true, gotoNextInput, 1);
      }
    }
  }
  handlePaste(e, shouldFocusNext = true) {
    if (e.inputType === "insertFromPaste") {
      const inputValue = this.getInputValue();
      const remaining = inputValue.substring(0, this.inputGroup.width);
      this.acceptPasteOrReset(remaining, shouldFocusNext);
      const overflow = inputValue.substring(this.inputGroup.width, inputValue.length);
      return overflow;
    }
    return "";
  }
  handleDeleteEvent(e) {
    if (this.isDeleteEvent(e)) {
      const inputValue = this.getInputValue();
      this.onDeleteEvent(this, e.inputType);
      if (inputValue == undefined || inputValue.length == 0) {
        this.saveCurrentValue();
        this.focusPrevController();
      }
      this.recomputeTextInputWidth();
      this.caretPosition = this.inputElement.selectionStart;
    }
  }
  shouldPrefixValue(e) {
    const result = numberToConfig(Number(e.detail));
    return result.prefix;
  }
  acceptPasteOrReset(remaining, shouldFocus = true) {
    if (this.checkPattern(remaining)) {
      this.inputElement.value = remaining;
      if (shouldFocus) {
        this.inputElement.focus();
      }
    }
    else {
      this.resetToLastValue();
    }
  }
  isDeleteEvent(e) {
    return (e.inputType === "deleteContentBackward" ||
      e.inputType === "deleteContentForward");
  }
  handleKeyDown(event) {
    if (event.code === "Backspace") {
      this.saveCurrentValue();
      if (this.inputElement.selectionStart == 0) {
        this.focusPrevController();
      }
    }
  }
  checkPattern(actualValue) {
    const pattern = this.inputGroup.pattern;
    return !actualValue.split("").some((char, index) => {
      if (pattern[index] === characterMaskIndicator) {
        if (/\d/.test(char)) {
          return true;
        }
      }
      else if (pattern[index] === numberMaskIndicator) {
        if (!/\d/.test(char)) {
          return true;
        }
      }
      else if (pattern[index] !== char) {
        return true;
      }
      return false;
    });
  }
  inputInNextGroupedInput(data, paste, prefix = false, focusNext, caretPosition) {
    this.onOverflow({
      data: data,
      input: this,
      paste: paste,
      shouldPrefix: prefix,
      focusNext: focusNext,
      caretPosition: caretPosition,
    });
  }
  focusPrevController() {
    this.onGotoGroup(this, true);
  }
  focusNextController() {
    this.onGotoGroup(this, false);
  }
  handleArrowKey(e) {
    e.preventDefault();
    const position = this.inputElement.selectionStart;
    const valueLength = this.inputElement.value.length;
    if (valueLength == undefined) {
      return;
    }
    if (this.caretPosition === position) {
      if (e.key === "ArrowLeft") {
        if (position === 0 || valueLength === 0) {
          this.focusPrevController();
        }
      }
      else if (e.key === "ArrowRight") {
        if (position === valueLength || valueLength === 0) {
          this.focusNextController();
        }
      }
    }
    this.caretPosition = position;
  }
  onBlur() {
    this.caretPosition = null;
  }
  recomputeTextInputWidth() {
    const textWidthPlaceholderSpace = 8;
    // width calculation needs an extra tweaking.
    const span = document.createElement("span");
    span.style.fontFamily = "Helvetica Neue LT W01";
    span.style.height = "auto";
    span.style.width = "auto";
    span.style.position = "absolute";
    span.style.whiteSpace = "no-wrap";
    span.style.top = "-10000px";
    span.style.opacity = "0";
    span.innerHTML =
      this.inputElement.value.length > 0
        ? this.inputElement.value
        : this.inputGroup.pattern;
    document.body.appendChild(span);
    const width = Math.max(span.clientWidth, this.inputGroup.width * textWidthPlaceholderSpace);
    document.body.removeChild(span);
    this.inputElement.style.width = `${width}px`;
  }
}

const dsGroupedTextInputCss = ":host{display:block}:host:host([hidden]){display:none !important}:host .input-readonly .container{border:none;visibility:hidden}:host .input-readonly .container>input{pointer-events:none}:host .input-readonly .container .readonly-text{position:absolute;visibility:initial;color:#4c4c4c}:host .container{position:relative;top:0;left:0;display:flex;height:38px;border-radius:4px;border:1px solid #c1c1c1;background-color:#ffffff;box-sizing:border-box;align-items:center}:host .container.required-outline{border-color:#e8b50e}:host .container.requirement-fulfilled{border-color:#c1c1c1}:host .container.red-outline{border-color:#be1413}:host .container.disabled-outline{border-color:#ebebeb}:host .container.active{border-color:#4c4c4c}:host .container>ds-text:first-child{margin-left:8px}:host .container>input{height:22px;margin:8px 0 8px 8px;border:none;outline:none;font-family:\"Helvetica Neue\", \"Helvetica Neue LT W01\";font-size:16px;line-height:24px;letter-spacing:0.02px;color:#4c4c4c;width:1px;flex-grow:1;width:var(--ds-grouped-text-input-width, 4ch);display:inline;flex-grow:0;margin:0;padding:0;line-height:24px}:host .container>input::placeholder{color:#c1c1c1}:host .container>input:disabled{background-color:#ffffff;color:#c1c1c1}:host .container>input:first-child{margin-left:8px}:host .container ds-function-icon-button{margin-left:auto}:host .container.disabled-outline>ds-text{color:#dedede}:host .container.disabled-outline input{color:#dedede}:host .clear-button{visibility:hidden}:host .clear-button.visible{visibility:visible}";

const DsGroupedTextInput = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.valueChange = createEvent(this, "valueChange", 7);
    this.valueComplete = createEvent(this, "valueComplete", 7);
    this.allGroupedTextInputController = [];
    this.groups = [];
    this.active = false;
    this.userInputed = false;
    /**
     * Label which is displayed above the input field.
     * @important
     * @value string: Label e.g `first name`
     * @example label
     */
    this.label = "";
    /**
     * @important
     * @value string: value of this input.
     * @example value
     */
    this.value = "";
    /**
     * Colors the frame of the input field red.
     * @value true: Red outline
     * @value false: Gray outline
     * @example error
     */
    this.error = false;
    /**
     * Input is no longer operable.
     * Label and frame are gray.
     * @value true: Input is disabled
     * @value false: Input ist not disabled
     * @example disabled
     */
    this.disabled = false;
    /**
     * Marks this form field as mandatory
     * @value false: Required form field (default)
     * @value true: Reguired form field
     * @example required
     */
    this.required = false;
    /**
     * Input field is in readonly mode.
     * The value of this input is displaey in an simplified manner.
     * The input field is not interactable.
     * @value false: input is not editable.
     * @value true: input is read-only.
     */
    this.readonly = false;
  }
  onMaskChanged() {
    this.reConstructInputsAndDelimiter();
  }
  onValueChanged() {
    this.obtainValueFromOutside();
  }
  connectedCallback() {
    this.reConstructInputsAndDelimiter();
  }
  componentWillLoad() {
    this.internalValue = this.computeNewValue();
  }
  componentDidRender() {
    this.obtainValueFromOutside();
  }
  obtainValueFromOutside() {
    if (this.value === this.computeNewValue() || this.value.length === 0) {
      return;
    }
    const extracted = this.normalizeValue();
    this.clearAllInputs();
    const event = new InputEvent("input", {
      data: extracted,
      inputType: "insertFromPaste",
      detail: configToNumber({
        prefix: true,
        focusNext: false,
      }),
    });
    onNextFrame(() => {
      this.getFirstController().getInputElement().dispatchEvent(event);
    });
  }
  checkFilledOut() {
    return this.allGroupedTextInputController
      .filter((ic) => ic != undefined)
      .every((ic) => {
      return ic.checkIsFulfilled();
    });
  }
  normalizeValue() {
    if (this.value.length <= 0) {
      return "";
    }
    const valueArray = [...this.value];
    const maskArray = [...this.mask];
    maskArray.forEach((char, index) => {
      if (char.match(delimiterExp)) {
        if (index <= valueArray.length) {
          if (valueArray[index] == char) {
            valueArray[index] = "";
          }
        }
        else {
          return;
        }
      }
    });
    return valueArray.reduce((prev, curr) => {
      return prev + curr;
    });
  }
  findInnerInputElement(e) {
    return e.composedPath().find((target) => {
      const element = target;
      return /input-[\d]+/.test(element === null || element === void 0 ? void 0 : element.id);
    });
  }
  focusFirstUnfulfilledInput() {
    const firstUnfullfilled = this.allGroupedTextInputController
      .filter((ic) => {
      return ic != undefined;
    })
      .find((ic) => !ic.checkIsFulfilled());
    if (firstUnfullfilled) {
      firstUnfullfilled.focus();
    }
    else {
      this.focusFirstInput();
    }
  }
  focusFirstInput() {
    var _a;
    (_a = this.allGroupedTextInputController
      .filter((ic) => {
      return ic != undefined;
    })[0]) === null || _a === void 0 ? void 0 : _a.focus();
  }
  blurAllInputs() {
    this.allGroupedTextInputController
      .filter((controller) => controller != undefined)
      .forEach((controller) => {
      controller.getInputElement().blur();
    });
  }
  blurWhenInactive() {
    setTimeout(() => {
      if (this.forceBlur || !isActiveElement(this.self)) {
        this.active = false;
        this.forceBlur = false;
        this.valueComplete.emit(this.internalValue);
      }
    }, 200);
  }
  checkUserInputed() {
    this.userInputed = this.allGroupedTextInputController
      .filter((ic) => ic != undefined)
      .some((ic) => {
      var _a;
      return ((_a = ic.getInputValue()) === null || _a === void 0 ? void 0 : _a.length) > 0;
    });
  }
  clearAllInputs() {
    onNextFrame(() => {
      this.allGroupedTextInputController
        .filter((controller) => controller != undefined)
        .forEach((controller) => {
        controller.clearInput();
      });
      this.value = "";
      this.internalValue = "";
      this.valueChanged();
    });
    this.userInputed = false;
  }
  reConstructInputsAndDelimiter() {
    this.groups = computeGroups(this.mask);
    this.allGroupedTextInputController = this.groups.map((g) => {
      if (g instanceof InputGroup) {
        const c = new GroupedTextInputController(g);
        g.controller = c;
        return c;
      }
    });
  }
  handleInput(e, inputController) {
    this.checkUserInputed();
    inputController.onInput(e);
  }
  handleKeyDown(event, groupInputController) {
    groupInputController.handleKeyDown(event);
  }
  getFirstController() {
    const candidates = this.allGroupedTextInputController.filter((ic) => {
      return ic != undefined;
    });
    return candidates.length > 0 ? candidates[0] : null;
  }
  getNextController(ic) {
    let index = this.allGroupedTextInputController.indexOf(ic);
    let nextController = undefined;
    let found = false;
    while (index <= this.allGroupedTextInputController.length && !found) {
      index = index + 1;
      if (this.allGroupedTextInputController[index] != undefined) {
        nextController = this.allGroupedTextInputController[index];
        found = true;
      }
    }
    return nextController;
  }
  getPreviousController(ic) {
    let index = this.allGroupedTextInputController.indexOf(ic);
    let previousController = undefined;
    let found = false;
    while (index >= 0 && !found) {
      index = index - 1;
      if (this.allGroupedTextInputController[index] != undefined) {
        previousController = this.allGroupedTextInputController[index];
        found = true;
      }
    }
    return previousController;
  }
  focusPreviousController(ic) {
    const prevController = this.getPreviousController(ic);
    if (prevController != undefined) {
      const caretPosition = prevController.getInputValue().length;
      prevController.focusAndSetCaretPosition(caretPosition, caretPosition);
    }
  }
  focusNextController(ic) {
    var _a;
    (_a = this.getNextController(ic)) === null || _a === void 0 ? void 0 : _a.focusAndSetCaretPosition(0, 0);
  }
  writeOverflowToNextInputController(data) {
    const nextController = this.getNextController(data.input);
    if (nextController != undefined || !this.checkFilledOut()) {
      if (!data.paste) {
        const event = new InputEvent("input", {
          data: data.data,
          inputType: "insertText",
          detail: configToNumber({
            prefix: data.shouldPrefix,
            focusNext: data.focusNext,
          }),
        });
        const inputElement = nextController === null || nextController === void 0 ? void 0 : nextController.getInputElement();
        if (inputElement == null) {
          return;
        }
        inputElement.dispatchEvent(event);
        if (data.focusNext) {
          nextController.focusAndSetCaretPosition(data.caretPosition, data.caretPosition);
        }
      }
      else {
        const event = new InputEvent("input", {
          data: data.data,
          inputType: "insertFromPaste",
          detail: configToNumber({
            prefix: data.shouldPrefix,
            focusNext: data.focusNext,
          }),
        });
        nextController.getInputElement().dispatchEvent(event);
      }
    }
  }
  computeNewValue() {
    return this.groups
      .filter((groupOrDelimiter) => {
      return (groupOrDelimiter instanceof InputGroup ||
        groupOrDelimiter instanceof Delimiter);
    })
      .map((groupOrDelimiter) => {
      var _a;
      if (groupOrDelimiter instanceof Delimiter) {
        return groupOrDelimiter.delimiter;
      }
      if (groupOrDelimiter instanceof InputGroup) {
        return (_a = groupOrDelimiter.controller.getInputValue()) !== null && _a !== void 0 ? _a : "";
      }
    })
      .reduce((previousValue, currentValue) => {
      return previousValue + currentValue;
    });
  }
  valueChanged() {
    const newValue = this.computeNewValue();
    if (this.internalValue !== newValue) {
      this.internalValue = newValue;
      this.value = this.internalValue;
      this.valueChange.emit(newValue);
    }
  }
  handleOnKeyUp(event, controller) {
    if (event.key == "Enter") {
      this.forceBlur = true;
      this.blurAllInputs();
      this.self.blur();
    }
    else if (event.key === "ArrowLeft" || event.key === "ArrowRight") {
      this.handleArrowKeys(event, controller);
    }
    else {
      this.handleKeyDown(event, controller);
    }
  }
  handleArrowKeys(e, ic) {
    ic.handleArrowKey(e);
  }
  onDeleteBackwards(input, inputType) {
    const nextController = this.getNextController(input);
    if (nextController != undefined &&
      nextController.getInputGroup().pattern[0] ===
        input.getInputGroup().pattern[0] &&
      nextController.getInputValue().length > 0) {
      const amountTObeExtracted = input.getInputGroup().width - input.getInputValue().length;
      input.appendExtractedToValue(nextController.extractCharacters(amountTObeExtracted, inputType), inputType);
    }
    return;
  }
  initalizeGroupedTextInputController(groupInputController, el) {
    groupInputController.setInputElement(el);
    groupInputController.onGotoGroup = (ic, previous) => {
      if (previous) {
        this.focusPreviousController(ic);
      }
      else {
        this.focusNextController(ic);
      }
    };
    groupInputController.onOverflow = (data) => {
      this.writeOverflowToNextInputController(data);
    };
    groupInputController.onValueChanged = () => {
      this.valueChanged();
    };
    groupInputController.onDeleteEvent = (input, inputType) => {
      this.onDeleteBackwards(input, inputType);
    };
  }
  render() {
    var _a;
    const isErrorOutline = ((_a = this.errormessage) === null || _a === void 0 ? void 0 : _a.length) > 0 || this.error;
    return (h(Host, { title: this.mask, onClick: (e) => {
        if (this.findInnerInputElement(e) == undefined) {
          this.focusFirstUnfulfilledInput();
        }
      }, onBlur: () => {
        this.blurWhenInactive();
      } }, h("ds-input-label", { disabled: this.disabled, label: this.label, kisynced: false }), h("div", { class: { "input-readonly": this.readonly } }, h(InputContainer, { active: this.active, error: isErrorOutline, required: this.required, requirementFulfilled: this.checkFilledOut(), disabled: this.disabled, title: this.internalValue }, this.renderReadonly(), this.renderGroups(), this.renderClearButton(), h(ErrorPopup, { text: this.errormessage, show: this.active })), h("ds-required-hint", { required: this.required, fulfilled: this.checkFilledOut() }))));
  }
  renderGroups() {
    return this.groups.map((groupOrDelimiter, index) => {
      if (groupOrDelimiter instanceof InputGroup) {
        const inputWidthInCharacters = groupOrDelimiter.width;
        const groupedTextInputController = this.allGroupedTextInputController[index];
        return (h("input", { id: `input-${index}`, ref: (el) => {
            this.initalizeGroupedTextInputController(groupedTextInputController, el);
          }, disabled: this.disabled, placeholder: groupOrDelimiter.pattern, style: {
            "--ds-grouped-text-input-width": `${inputWidthInCharacters}ch`,
          }, onFocus: () => {
            this.active = true;
          }, onBlur: () => {
            groupedTextInputController.onBlur();
          }, onKeyUp: (event) => {
            this.handleOnKeyUp(event, groupedTextInputController);
          }, onInput: (event) => this.handleInput(event, groupedTextInputController) }));
      }
      else {
        return groupOrDelimiter.delimiter === " " ? (h("ds-text", { type: "ft", screensize: "small" }, "\u00A0")) : (h("ds-text", { type: "ft", screensize: "small" }, groupOrDelimiter.delimiter));
      }
    });
  }
  renderReadonly() {
    if (this.readonly) {
      this.computeNewValue();
      return (h("div", { class: "readonly-text" }, h(ReadonlyTextElement, { text: this.internalValue, kisynced: false })));
    }
    return null;
  }
  renderClearButton() {
    const isClearButtonVisible = this.active && this.userInputed && !this.readonly;
    return (h("ds-function-icon-button", { id: ElementIdGenerator.createId(this.self, "clear-button"), unfocusable: true, class: {
        "clear-button": true,
        visible: isClearButtonVisible,
      }, onPointerDown: () => this.clearAllInputs() }, h("ds-icon", { icon: "schliessen-input", size: 16 })));
  }
  get self() { return getElement(this); }
  static get watchers() { return {
    "mask": ["onMaskChanged"],
    "value": ["onValueChanged"]
  }; }
};
DsGroupedTextInput.style = dsGroupedTextInputCss;

export { DsGroupedTextInput as ds_grouped_text_input };
