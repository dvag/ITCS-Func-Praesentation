import { r as registerInstance, c as createEvent, f as forceUpdate, h, H as Host, g as getElement } from './index-04c470ea.js';
import { S as SlotObserver } from './slot-observer-9196738e.js';
import { D as Debounce } from './debounce-b376d37b.js';
import { s as sameArrayIgnoreOrder, c as sameArrayInOrder } from './misc-util-d3b69f2c.js';
import { a as assert } from './assert-7fc7463a.js';
import { E as ElementIdGenerator } from './element-id-handling-bb37154e.js';
import './query-util-02753b43.js';
import './value-store-f4663db1.js';

function sameColumnSettings(a, b) {
  return ((a === null || a === void 0 ? void 0 : a.type) === (b === null || b === void 0 ? void 0 : b.type) &&
    (a === null || a === void 0 ? void 0 : a.align) === (b === null || b === void 0 ? void 0 : b.align) &&
    (a === null || a === void 0 ? void 0 : a.lines) === (b === null || b === void 0 ? void 0 : b.lines) &&
    JSON.stringify(a === null || a === void 0 ? void 0 : a.sizeStyle) == JSON.stringify(b === null || b === void 0 ? void 0 : b.sizeStyle));
}

const dsTableCss = "@keyframes slide-left{0%{transform:translateX(0)}100%{transform:translateX(-10px)}}:host{display:flex;width:100%}:host:host([hidden]){display:none !important}:host .card-content-bottom-margin{display:flex;width:100%;margin-bottom:8px}:host ds-card{width:100%}:host .table{display:flex;width:100%;overflow:hidden;flex-direction:column;position:relative}:host .table .scroll-hint{display:var(--display-for-backstop-tests, flex);position:absolute;right:20px;bottom:calc(50% - (48px / 2));border-radius:6px;z-index:2;transition:opacity ease-in-out 1s;opacity:0;width:48px;height:48px;background-color:#666666;animation:slide-left 0.75s cubic-bezier(0.25, 0.46, 0.45, 0.94) infinite alternate both;justify-content:center;align-items:center}:host .table .scroll-hint.show{opacity:0.6}:host .table .left-gradient{transition:width 300ms ease-in-out;z-index:1;height:calc(100% - 8px);position:absolute;background:radial-gradient(at left center, #c1c1c1, transparent 80%);pointer-events:none;top:0;width:0}:host .table .left-gradient.show-gradient{width:15px}:host .table .right-gradient{transition:width 300ms ease-in-out;width:0;height:100%;z-index:1;position:absolute;right:0px;background:linear-gradient(270deg, white, rgba(255, 255, 255, 0));top:0px;pointer-events:none}:host .table .right-gradient.show-gradient{width:25px}:host .table .scrollable{position:relative;overflow-x:auto;margin-bottom:8px;min-width:100%}:host .table .scrollable::-webkit-scrollbar{display:none}:host ds-scroll-container.table{overflow:visible}:host .footer{display:flex;justify-content:flex-end;padding:12px 24px}:host .footer ds-paginator{width:350px}:host:host(.paginated){border-radius:6px}:host:host(.paginated-shadow){box-shadow:0 4px 12px 0 rgba(0, 0, 0, 0.16)}.sidebar-container{display:flex;flex-direction:row-reverse;position:relative;transition:transform 300ms ease-in-out, flex 300ms ease-in-out;will-change:flex;flex:0 0 0;height:max-content;overflow:hidden;border-bottom-left-radius:6px;border-top-left-radius:6px;z-index:2}.sidebar-container.open{flex:0 0 40px;transition:transform 300ms ease-in-out, flex 300ms ease-in-out}.sidebar-container.open .sidebar .row{border-radius:6px 0 0 6px;align-items:center}.sidebar-container .sidebar{flex:0 0 40px}.sidebar-container .sidebar .row{display:flex;justify-content:center;border-radius:6px 0 0 6px;box-sizing:border-box;align-items:center}.sidebar-container .sidebar .row.odd{background-color:#f5f5f5}.sidebar-container .sidebar .row.selected{background-color:#dedede}.sidebar-container .sidebar .footer{margin-top:4px;border-bottom-left-radius:6px;border-top-left-radius:6px;background-color:#e2ecd0}";

const DEFAULT_ROW_HEIGHT = 40;
const DsTable = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.tableStateChanged = createEvent(this, "tableStateChanged", 7);
    this.rowsSelected = createEvent(this, "rowsSelected", 7);
    this.currentSortSettings = { column: null, reverse: false };
    this.sortDebounce = new Debounce(50);
    this.rowDebounce = new Debounce(200);
    this.touchMoveDetected = false;
    this.scrollHintFadedOutHandler = () => {
      this.scrollHintNecessary = this.showScrollHint;
    };
    this.scrollHandler = () => {
      this.controlOpticalHints();
    };
    this.currentPage = 1;
    this.selectedRowKeys = [];
    this.showScrollHint = true;
    this.scrollHintNecessary = false;
    this.internalScrollable = false;
    /**
     * Defines the style of this table.
     *
     * @value default: Default table
     * @value paginated-card: Table within a card with pagination.
     * @value paginated-card-shadow: Table within a shadowed card with pagination.
     *
     * @example paginator
     */
    this.view = "default";
    /**
     * Defines the options for the page size that a user can pick from.
     * It only has an effect if the `view` attribute supports pagination.
     *
     * @value string: Comma seperated list of numbers (e.g: [25,50,100]).
     *
     * @example paginator
     */
    this.pagesizes = "[25,50,100]";
    /**
     * The initially selected option for the page size.
     * It only has an effect if the `view` attribute supports pagination.
     *
     * @value number: Number of rows per page.
     *
     * @example paginator
     */
    this.pagesize = 25;
    /**
     * Specifies the initial sort direction.
     *
     * @value asc: Ascending order.
     * @value desc: Descending order.
     *
     * @example initial-sort
     */
    this.initialsortdirection = "asc";
    /**
     * Specifies whether the table is self-managed or remote-controlled.
     *
     * @value managed: The table is responsible for sorting and pagination.
     * @value remote: The table relies on an external implementation for creating rows, sorting and pagination using the `tableStateChanged` event.
     *
     * @example remote
     * @example remote-complex
     */
    this.mode = "managed";
    /**
     * **Warning: This feature is highly experimental.**
     *
     * Enables the selection of rows.
     * A `key` for every row has to be specified.
     *
     * @value true: The selection-group will be opened.
     * @value false: The selection-group will be closed.
     *
     * @example selection
     */
    this.selectionenabled = false;
    /**
     * **Warning: This feature is highly experimental.**
     *
     * Specifies if only one or multiple rows can be selected.
     *
     * @value multi: Multiple rows can be selected.
     * @value single: One row can be selected at a time.
     *
     * @example selection-mode
     */
    this.selectionmode = "multi";
    /**
     * The data length this table should visualize. In case the table manages itself this attribute should not be set.
     * If the table is remote-controlled this attribute has to be set because the table needs to know the exact amount
     * of data to visualize the **paging** accordingly.
     *
     * @example remote
     * @example remote-complex
     */
    this.rowcount = 0;
    this.initialized = false;
  }
  onSideBarOpenChange() {
    if (!this.selectionenabled) {
      this.selectedRowKeys = [];
      if (this.selectionGroup != null) {
        this.selectionGroup.value = null;
        this.rowsSelected.emit(null);
      }
      else {
        this.rowsSelected.emit([]);
      }
    }
    else {
      const noRowIdsDefined = this.getRows().every((row) => row.rowid == null);
      if (noRowIdsDefined) {
        console.warn("To use table selection you have to define at least one <ds-table-row> with a valid 'rowid'!\n", this.self);
        this.selectionenabled = false;
      }
    }
    this.controlOpticalHints();
  }
  onScrollableChange() {
    var _a;
    this.setScrollable();
    this.controlOpticalHints();
    (_a = this.headerItemElements) === null || _a === void 0 ? void 0 : _a.forEach((headerItem) => {
      headerItem.usemaxwidth = this.internalScrollable;
    });
  }
  onTouchStart() {
    this.touchMoveDetected = false;
  }
  onTouchmove() {
    this.touchMoveDetected = true;
  }
  onTouchEnd(event) {
    if (this.touchMoveDetected) {
      event.stopImmediatePropagation();
      this.touchMoveDetected = false;
    }
  }
  connectedCallback() {
    this.initialized = false;
    this.observeHeaderItems();
    this.observeRows();
    this.setScrollable();
  }
  initResizeObserver() {
    this.tableResizeObserver = new ResizeObserver((entries) => {
      this.updateTableScroll(entries[0].contentRect.width);
      this.controlOpticalHints();
    });
  }
  setScrollable() {
    var _a;
    if (this.scrollable) {
      this.initResizeObserver();
    }
    else {
      (_a = this.tableResizeObserver) === null || _a === void 0 ? void 0 : _a.disconnect();
      this.tableResizeObserver = null;
      this.internalScrollable = this.scrollable;
      this.updateCellSettings().then();
    }
  }
  updateTableScroll(tableWidth) {
    if (this.headerItemElements == null ||
      this.headerItemElements.length === 0) {
      return;
    }
    const oneTimePaddingLeft = 16;
    const columnsSum = this.headerItemElements.reduce((acc, currentValue) => {
      var _a;
      const minWidth = parseInt((_a = currentValue.minwidth) === null || _a === void 0 ? void 0 : _a.toString());
      if (isNaN(minWidth)) {
        console.error(`ds-table:`, this.self, `Every <ds-table-header-item> in a scrollable table has to set a minwidth. At least one <ds-table-header-item> was not given a size.`);
      }
      const sideMargin = 16;
      return acc + currentValue.minwidth + sideMargin;
    }, 0) + oneTimePaddingLeft;
    const isScrollable = columnsSum > tableWidth;
    if (this.internalScrollable !== isScrollable) {
      this.internalScrollable = isScrollable;
      this.updateCellSettings().then();
      if (!isScrollable) {
        this.showLeftGradient = false;
        this.showRightGradient = false;
      }
    }
  }
  hideScrollHint() {
    this.showScrollHint = false;
  }
  controlOpticalHints() {
    if (!this.internalScrollable || this.scrollContainer == null) {
      return;
    }
    const scrollDistance = this.scrollContainer.scrollLeft;
    const maxScrollDistance = this.scrollContainer.scrollWidth - this.scrollContainer.clientWidth;
    requestAnimationFrame(() => {
      const isScrolledLeft = scrollDistance < maxScrollDistance;
      const isScrolledRight = scrollDistance > 0;
      this.showRightGradient = isScrolledLeft;
      this.showLeftGradient =
        this.isScrollingPossible() && this.selectionenabled;
      this.calculateShouldHideScrollHint(isScrolledRight);
    });
  }
  isScrollingPossible() {
    var _a, _b;
    return (this.internalScrollable &&
      ((_a = this.scrollContainer) === null || _a === void 0 ? void 0 : _a.scrollWidth) > ((_b = this.scrollContainer) === null || _b === void 0 ? void 0 : _b.clientWidth));
  }
  calculateScrollHintNecessary() {
    this.scrollHintNecessary = this.isScrollingPossible();
  }
  calculateShouldHideScrollHint(isScrolledRight) {
    if (isScrolledRight && this.showScrollHint) {
      this.hideScrollHint();
    }
  }
  disconnectedCallback() {
    var _a, _b, _c;
    (_a = this.headerItemObserver) === null || _a === void 0 ? void 0 : _a.disconnect();
    (_b = this.rowObserver) === null || _b === void 0 ? void 0 : _b.disconnect();
    this.rowDebounce.reset();
    this.sortDebounce.reset();
    (_c = this.tableResizeObserver) === null || _c === void 0 ? void 0 : _c.disconnect();
  }
  /**
   * @internal
   */
  async invokeSort(element, reverse) {
    if (!this.initialized) {
      this.invokeSortInputParamsBeforeInit = {
        element,
        reverse,
      };
      return;
    }
    return this.internalInvokeSort(element, reverse);
  }
  async internalInvokeSort(element, reverse) {
    var _a;
    const index = this.headerItemElements.indexOf(element);
    this.headerItemElements.forEach((el, i) => {
      if (index !== i) {
        el.setSortDirection("neutral");
      }
    });
    this.sortState = {
      column: (_a = element.columnid) !== null && _a !== void 0 ? _a : element.label,
      index: index,
      direction: reverse ? "desc" : "asc",
    };
    this.sortRows({ column: index, reverse: reverse });
  }
  reSort() {
    if (this.currentSortSettings.column !== null) {
      this.sortRows(this.currentSortSettings);
    }
  }
  isViewUsingPagination() {
    return this.view.includes("paginated");
  }
  observeRows() {
    this.rowObserver = new SlotObserver(this.self, "ds-table-row", () => {
      this.rowDebounce.run(async () => {
        // Disconnect to prevent further SlotObserver calls through DOM Manipulation
        this.rowObserver.disconnect();
        await this.updateCellSettings();
        const currentRows = this.getRows();
        this.checkForDuplicateRowKeys(currentRows);
        this.handleRemoteSelection(currentRows);
        if (!sameArrayIgnoreOrder(currentRows, this.rowElements)) {
          this.rowElements = currentRows;
          if (this.mode === "managed") {
            this.rowcount = currentRows.length;
            if (!hasAnySortableColumns(this.headerItemElements)) {
              this.manipulateDOMRows(this.rowElements);
            }
            else {
              this.reSort();
            }
          }
          this.updateVisibility();
        }
        else {
          forceUpdate(this.self);
        }
        // Reconnect SlotObserver
        this.rowObserver.connect();
        this.init();
      });
    });
  }
  handleRemoteSelection(currentRows) {
    requestAnimationFrame(() => {
      var _a;
      if (this.selectionmode === "single") {
        const previousSelectedRowId = this.selectedRowKeys[0];
        const newlySelectedRowID = (_a = currentRows
          .filter((row) => row.selected == true)
          .filter((row) => row.rowid !== previousSelectedRowId)[0]) === null || _a === void 0 ? void 0 : _a.rowid;
        if (newlySelectedRowID == undefined) {
          return;
        }
        this.selectionenabled = true;
        this.handleRadioSelection(newlySelectedRowID);
      }
      else {
        currentRows.forEach((row) => {
          this.selectionenabled || (this.selectionenabled = row.selected);
          this.handleCheckboxSelection(row.rowid, row.selected);
        });
      }
    });
  }
  init() {
    this.initialized = true;
    if (this.invokeSortInputParamsBeforeInit != null) {
      this.internalInvokeSort(this.invokeSortInputParamsBeforeInit.element, this.invokeSortInputParamsBeforeInit.reverse).then();
      this.invokeSortInputParamsBeforeInit = null;
    }
  }
  updateVisibility() {
    if (this.mode === "managed" && this.isViewUsingPagination()) {
      const currentRows = this.getRows();
      const visibleRowRange = this.getCurrentRowsRangeIndices();
      currentRows.forEach((row, index) => {
        row.setAttribute("visible", "" +
          (index >= visibleRowRange.fromIndex &&
            index <= visibleRowRange.toIndex));
      });
    }
    this.updateAlternatingRowHighlights();
  }
  getCurrentRowsRangeIndices() {
    var _a, _b;
    const fromIndex = ((_a = this.pagesize) !== null && _a !== void 0 ? _a : 0) * (this.currentPage - 1);
    const result = {
      fromIndex: fromIndex,
      toIndex: fromIndex,
    };
    if (this.mode === "managed") {
      result.toIndex += ((_b = this.pagesize) !== null && _b !== void 0 ? _b : this.rowcount) - 1;
    }
    else {
      result.toIndex += this.pagesize - 1;
    }
    // There could be fewer rows visible than the pagesize allows at the last page
    result.toIndex = Math.min(this.rowcount - 1, result.toIndex);
    return result;
  }
  updateAlternatingRowHighlights() {
    this.getRows().forEach((row, index) => {
      row.classList.remove("odd");
      if ((index % this.pagesize) % 2 == 0) {
        row.classList.add("odd");
      }
    });
  }
  emitTableStateChanged() {
    const currentRowsRangeIndices = this.getCurrentRowsRangeIndices();
    this.tableStateChanged.emit({
      page: this.currentPage,
      pageSize: this.pagesize,
      fromIndex: currentRowsRangeIndices.fromIndex,
      toIndex: currentRowsRangeIndices.toIndex,
      sortState: this.sortState,
    });
  }
  observeHeaderItems() {
    this.headerItemObserver = new SlotObserver(this.self, "ds-table-header-item", async (nodes) => {
      var _a, _b;
      const newSettings = await Promise.all(nodes.map((node) => {
        return node.toColumnSettings();
      }));
      if (!this.differentSettings(newSettings) &&
        sameArrayInOrder(this.headerItemElements, nodes)) {
        return;
      }
      this.settings = newSettings;
      //TODO check delete all columns and creating new ones triggers sort?
      const hadAnySortableColumnsBeforeChange = hasAnySortableColumns(this.headerItemElements);
      this.headerItemElements = nodes;
      if (!hadAnySortableColumnsBeforeChange) {
        const sortableHeaderColumns = await (nodes === null || nodes === void 0 ? void 0 : nodes.filter((headerItem) => headerItem.sortable));
        let sortedHeaderColumn = null;
        if (((_a = this.initialsort) === null || _a === void 0 ? void 0 : _a.length) > 0) {
          sortedHeaderColumn = sortableHeaderColumns === null || sortableHeaderColumns === void 0 ? void 0 : sortableHeaderColumns.find((headerItem) => {
            return (headerItem.columnid === this.initialsort ||
              headerItem.label === this.initialsort);
          });
          assert(sortedHeaderColumn != null, () => `Kein <ds-header-item-element> mit der 'columnid' oder dem 'label' "${this.initialsort}" gefunden`);
        }
        sortedHeaderColumn !== null && sortedHeaderColumn !== void 0 ? sortedHeaderColumn : (sortedHeaderColumn = sortableHeaderColumns === null || sortableHeaderColumns === void 0 ? void 0 : sortableHeaderColumns[0]);
        sortedHeaderColumn === null || sortedHeaderColumn === void 0 ? void 0 : sortedHeaderColumn.setSortDirection((_b = this.initialsortdirection) !== null && _b !== void 0 ? _b : "asc");
      }
      this.updateCellSettings().then();
    });
  }
  differentSettings(settings) {
    return (this.settings == null ||
      settings.find((setting, index) => {
        return !sameColumnSettings(setting, this.settings[index]);
      }) != null);
  }
  async updateCellSettings() {
    var _a;
    (_a = this.headerItemElements) === null || _a === void 0 ? void 0 : _a.forEach((headerItem) => {
      headerItem.usemaxwidth = this.internalScrollable;
    });
    return Promise.all(this.getRows().concat(this.getFooters()).flatMap((row) => {
      return Array.from(row.querySelectorAll("ds-table-cell"))
        .map((cell, index) => {
        var _a;
        if (index < ((_a = this.headerItemElements) === null || _a === void 0 ? void 0 : _a.length)) {
          return cell.obtainSettings(this.settings[index]);
        }
        return null;
      })
        .filter((promise) => promise != null);
    }));
  }
  getRows() {
    return Array.from(this.self.querySelectorAll("ds-table-row"));
  }
  getFooters() {
    return Array.from(this.self.querySelectorAll("ds-table-footer"));
  }
  compareColumns(firstRow, secondRow, columnIndex, type) {
    var _a;
    const columnSelector = "ds-table-cell:nth-child(" + (columnIndex + 1) + ")";
    if (type === "html") {
      const headerItem = this.headerItemElements[columnIndex];
      if (headerItem.customSort != null) {
        return headerItem.customSort(firstRow.querySelector(columnSelector), secondRow.querySelector(columnSelector));
      }
      return 0;
    }
    const valueA = firstRow.querySelector(columnSelector).getAttribute("value");
    const valueB = secondRow
      .querySelector(columnSelector)
      .getAttribute("value");
    if (type === "numeric" || type === "currency") {
      return parseFloat(valueA) - parseFloat(valueB);
    }
    return (_a = valueA === null || valueA === void 0 ? void 0 : valueA.localeCompare(valueB)) !== null && _a !== void 0 ? _a : (valueB ? -1 : 0);
  }
  sortRows(sortSettings) {
    if (!equalSortSettings(this.currentSortSettings, sortSettings)) {
      this.currentPage = 1;
      this.emitTableStateChanged();
    }
    if (this.mode === "remote") {
      return;
    }
    this.currentSortSettings.column = sortSettings.column;
    this.currentSortSettings.reverse = sortSettings.reverse;
    this.sortDebounce.run(() => {
      var _a, _b;
      const rows = [...((_a = this.getRows()) !== null && _a !== void 0 ? _a : [])];
      const type = (_b = this.settings[sortSettings.column]) === null || _b === void 0 ? void 0 : _b.type;
      const sortScale = sortSettings.reverse ? -1 : 1;
      const sortOrder = this.headerItemElements
        .filter((_, index) => index !== sortSettings.column)
        .filter((headerItem) => headerItem.sortable && headerItem.sortpriority != null)
        .sort((a, b) => b.sortpriority - a.sortpriority)
        .map((headerItem) => this.headerItemElements.indexOf(headerItem));
      rows.sort((a, b) => {
        var _a;
        let currentColumnIndex = sortSettings.column;
        let currentType = type;
        const sortOrderCpy = [...sortOrder];
        let result = this.compareColumns(a, b, currentColumnIndex, currentType) *
          sortScale;
        // Secondary sorting
        while (result === 0 && sortOrderCpy.length > 0) {
          currentColumnIndex = sortOrderCpy.pop();
          currentType = (_a = this.settings[currentColumnIndex]) === null || _a === void 0 ? void 0 : _a.type;
          // Do not apply scale because we want to always sort ascending for secondary sorting
          result = this.compareColumns(a, b, currentColumnIndex, currentType);
        }
        return result;
      });
      this.manipulateDOMRows(rows);
      this.updateVisibility();
    });
  }
  checkForDuplicateRowKeys(currentRows) {
    const duplicateMap = currentRows.reduce((map, row) => {
      var _a, _b;
      if (row.rowid != null) {
        map[row.rowid] = (_b = (_a = map[row.rowid]) === null || _a === void 0 ? void 0 : _a.concat(row)) !== null && _b !== void 0 ? _b : [row];
      }
      return map;
    }, {});
    Object.keys(duplicateMap).forEach((key) => {
      const rowList = duplicateMap[key];
      if (rowList.length > 1) {
        console.error(`Duplicate key "${key}" in rows:\n`, ...rowList);
      }
    });
  }
  manipulateDOMRows(rows) {
    let insertAfterElement = null;
    this.self.querySelectorAll(":scope > *").forEach((el) => {
      if (!["ds-table-row", "ds-table-footer"].includes(el.tagName.toLowerCase())) {
        insertAfterElement = el; // use last non-row element as insert point
      }
    });
    // Reverse is mutating an array so we have to copy the array
    [...rows].reverse().forEach((row) => {
      insertAfterElement.insertAdjacentElement("afterend", row);
    });
  }
  handlePaginationPageSizeChanged(e) {
    this.pagesize = e.detail;
    this.emitTableStateChanged();
    this.updateVisibility();
  }
  handlePaginationPageChanged(e) {
    const page = e.detail;
    if (this.currentPage !== page) {
      this.currentPage = page;
      this.emitTableStateChanged();
      this.updateVisibility();
    }
  }
  handleRadioSelection(key) {
    if (this.selectedRowKeys[0] === key) {
      return;
    }
    this.selectedRowKeys = [key];
    this.rowElements.forEach((row) => {
      row.selected = row.rowid == this.selectedRowKeys[0];
    });
    this.rowsSelected.emit([...this.selectedRowKeys]);
  }
  handleCheckboxSelection(key, checked) {
    const selectedRow = this.rowElements.filter((row) => row.rowid === key)[0];
    if (checked && !this.selectedRowKeys.includes(key)) {
      selectedRow.selected = true;
      this.selectedRowKeys.push(key);
    }
    else if (!checked) {
      selectedRow.selected = false;
      this.selectedRowKeys = this.selectedRowKeys.filter((rowKey) => {
        return rowKey !== key;
      });
    }
    this.rowsSelected.emit([...this.selectedRowKeys]);
  }
  componentDidRender() {
    var _a, _b;
    this.calculateScrollHintNecessary();
    this.controlOpticalHints();
    if (this.selectionmode === "multi") {
      const visibleRows = this.self.querySelectorAll("ds-table-row.visible");
      const selectionRows = (_b = (_a = this.self) === null || _a === void 0 ? void 0 : _a.shadowRoot) === null || _b === void 0 ? void 0 : _b.querySelectorAll(".row");
      selectionRows === null || selectionRows === void 0 ? void 0 : selectionRows.forEach((selectionRow, index) => {
        if (selectionRow.firstElementChild == null) {
          return;
        }
        const checkbox = selectionRow.querySelector("ds-checkbox");
        if (checkbox != null) {
          checkbox.checked = this.selectedRowKeys.includes(visibleRows[index].rowid);
        }
      });
    }
    else {
      this.selectionGroup.value = this.selectedRowKeys[0];
    }
  }
  render() {
    if (this.view === "default") {
      return this.renderDefault();
    }
    if (this.view === "paginated-card") {
      return this.renderPaginatedCard(false);
    }
    if (this.view === "paginated-card-shadow") {
      return this.renderPaginatedCard(true);
    }
  }
  renderSelectionGroup() {
    let referenceRows = this.getRows();
    if (this.mode === "managed") {
      const indexRange = this.getCurrentRowsRangeIndices();
      referenceRows = referenceRows.slice(indexRange.fromIndex, indexRange.toIndex + 1);
    }
    return this.selectionmode === "single"
      ? this.renderRadioSelection(referenceRows)
      : this.renderCheckboxSelection(referenceRows);
  }
  renderCheckboxSelection(rows) {
    return (h("div", null, rows.map((row, index) => {
      return (h("div", { class: {
          row: true,
          odd: index % 2 === 0,
        }, style: {
          height: row.offsetHeight < DEFAULT_ROW_HEIGHT
            ? `${DEFAULT_ROW_HEIGHT}px`
            : row.offsetHeight + "px",
        } }, row.rowid ? (h("ds-checkbox", { id: ElementIdGenerator.createId(this.self, `selection-button-${index}`), checked: this.selectedRowKeys.includes(row.rowid), onCheckedChange: (e) => this.handleCheckboxSelection(row.rowid, e.detail) })) : null));
    })));
  }
  renderRadioSelection(rows) {
    return (h("ds-radio-button-group", { id: ElementIdGenerator.createId(this.self, "selection-group"), ref: (ref) => (this.selectionGroup = ref), onValueChange: (e) => this.handleRadioSelection(e.detail) }, rows.map((row, index) => {
      return (h("div", { class: {
          row: true,
          odd: index % 2 === 0,
        }, style: {
          height: row.offsetHeight < DEFAULT_ROW_HEIGHT
            ? `${DEFAULT_ROW_HEIGHT}px`
            : row.offsetHeight + "px",
        } }, row.rowid ? (h("ds-radio-button", { id: ElementIdGenerator.createId(this.self, `selection-button-${index}`), value: row.rowid })) : null));
    })));
  }
  renderSidebarFooter() {
    return this.getFooters().map((footer) => {
      return (h("div", { style: {
          height: footer.offsetHeight - 4 + "px",
        }, class: { footer: true } }));
    });
  }
  getScrollWidth() {
    const oneTimePaddingLeft = 16;
    return (this.headerItemElements.reduce((acc, currentValue) => {
      var _a;
      const sideMargin = 16;
      return (acc +
        parseInt((_a = (currentValue.maxwidth || currentValue.minwidth)) === null || _a === void 0 ? void 0 : _a.toString()) +
        sideMargin);
    }, 0) + oneTimePaddingLeft);
  }
  renderSidebar() {
    var _a, _b;
    return (h("div", { class: {
        "sidebar-container": true,
        open: this.selectionenabled,
      } }, h("div", { class: "sidebar" }, h("div", { class: "header", style: {
        height: ((_b = (_a = this.headerItemElements) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.offsetHeight) + "px",
      } }), [this.renderSelectionGroup(), this.renderSidebarFooter()])));
  }
  setScrollContainer(scrollContainer) {
    var _a, _b;
    if (this.scrollContainer === scrollContainer) {
      return;
    }
    (_a = this.scrollContainer) === null || _a === void 0 ? void 0 : _a.removeEventListener("scroll", this.scrollHandler);
    this.scrollContainer = scrollContainer;
    (_b = this.scrollContainer) === null || _b === void 0 ? void 0 : _b.addEventListener("scroll", this.scrollHandler);
  }
  renderScrollableTableContent() {
    return (h("div", null, this.renderScrollHint(), h("ds-scroll-container", { scrollbarmargin: 8 }, h("div", { ref: (ref) => {
        this.setScrollContainer(ref);
      }, class: { scrollable: true }, style: {
        "--ds-table-row-width": this.internalScrollable
          ? `${this.getScrollWidth()}px`
          : "none",
      } }, h("slot", null)))));
  }
  renderScrollHint() {
    if (this.scrollHintNecessary) {
      return (h("div", { class: {
          "scroll-hint": true,
          show: this.showScrollHint,
        }, onTransitionEnd: () => this.scrollHintFadedOutHandler() }, h("ds-icon", { icon: "listenpfeil", color: "weiss", size: 32 })));
    }
    // By returning this we prevent the table from scrolling back after transition end is called
    return "";
  }
  renderTable() {
    return [
      this.renderSidebar(),
      h("div", { class: "table", style: {
          "--ds-row-border-left-radius": this.selectionenabled ? "0px" : "6px",
        }, ref: (ref) => {
          var _a;
          (_a = this.tableResizeObserver) === null || _a === void 0 ? void 0 : _a.observe(ref);
        } }, this.internalScrollable ? (this.renderScrollableTableContent()) : (h("slot", null)), h("div", { class: {
          "left-gradient": true,
          "show-gradient": this.showLeftGradient,
        }, style: {
          left: `${this.self.scrollLeft}`,
        } }, "\u00A0"), h("div", { class: {
          "right-gradient": true,
          "show-gradient": this.showRightGradient,
        } }, "\u00A0")),
    ];
  }
  renderDefault() {
    return h(Host, { role: "table" }, this.renderTable());
  }
  renderPaginatedCard(shadow) {
    return (h(Host, { role: "table", class: {
        paginated: true,
        "paginated-shadow": shadow,
      } }, h("ds-card", null, h("ds-card-header", null, h("div", null, h("slot", { name: "title" })), h("ds-table-page-size-picker", { value: this.pagesize, pagesizes: this.pagesizes, onPageSizeChanged: (e) => this.handlePaginationPageSizeChanged(e) })), h("ds-card-content", null, h("div", { class: "card-content-bottom-margin" }, this.renderTable())), h("ds-hr", null), h("div", { class: "footer" }, h("ds-paginator", { id: ElementIdGenerator.createId(this.self, "paginator"), onPageChanged: (e) => this.handlePaginationPageChanged(e), range: 1, current: this.currentPage, count: Math.ceil(this.rowcount / this.pagesize) })))));
  }
  get self() { return getElement(this); }
  static get watchers() { return {
    "selectionenabled": ["onSideBarOpenChange"],
    "scrollable": ["onScrollableChange"]
  }; }
};
function hasAnySortableColumns(headerItems) {
  return headerItems === null || headerItems === void 0 ? void 0 : headerItems.some((headerItem) => headerItem.sortable);
}
function equalSortSettings(first, second) {
  return first.column === second.column && first.reverse === second.reverse;
}
DsTable.style = dsTableCss;

export { DsTable as ds_table };
