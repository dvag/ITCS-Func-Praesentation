import { r as registerInstance, h, H as Host, g as getElement } from './index-04c470ea.js';
import { a as assert } from './assert-7fc7463a.js';
import { v as verifyElementId, E as ElementIdGenerator } from './element-id-handling-bb37154e.js';
import { d as findUpperElement } from './misc-util-d3b69f2c.js';
import { B as BreakpointAware } from './breakpoint-aware-0017fabb.js';
import './value-store-f4663db1.js';

const dxTableHeaderItemCss = ":host{overflow:hidden;display:flex;flex:1;padding-top:8px;padding-bottom:8px}:host:host([hidden]){display:none !important}:host:host(.align-left){justify-content:flex-start}:host:host(.align-right){justify-content:flex-end}:host:host(.align-center){justify-content:center}:host .sort-icon{cursor:pointer;margin-left:4px;flex:0 0 16px}:host .header{width:100%;overflow:hidden;width:auto;text-align:left;height:100%;border:none;text-decoration:none;background:none;padding:4px 0;cursor:pointer;-webkit-appearance:none;-moz-appearance:none;outline:none}:host .header .cell{font-family:DVAG-Type, sans-serif;color:#2b2b2b;overflow:hidden;white-space:nowrap;text-overflow:ellipsis;width:100%;box-sizing:border-box;padding:0 16px}:host .header .cell.multiple-lines{display:-webkit-box;-webkit-line-clamp:var(--dx-table-cell-lines, 1);-webkit-box-orient:vertical;white-space:break-spaces}:host .header .cell.align-left{text-align:start}:host .header .cell.align-right{text-align:end}:host .header .cell.align-center{text-align:center}:host .header .cell dx-text{overflow:hidden;text-overflow:ellipsis}:host .header .cell ::slotted(*){overflow:hidden;text-overflow:ellipsis}:host .header:host(.cell){font-family:DVAG-Type, sans-serif;color:#2b2b2b;overflow:hidden;white-space:nowrap;text-overflow:ellipsis;width:100%;box-sizing:border-box;padding:0 16px}:host .header:host(.cell).multiple-lines{display:-webkit-box;-webkit-line-clamp:var(--dx-table-cell-lines, 1);-webkit-box-orient:vertical;white-space:break-spaces}:host .header:host(.cell).align-left{text-align:start}:host .header:host(.cell).align-right{text-align:end}:host .header:host(.cell).align-center{text-align:center}:host .header:host(.cell) dx-text{overflow:hidden;text-overflow:ellipsis}:host .header:host(.cell) ::slotted(*){overflow:hidden;text-overflow:ellipsis}:host .header[disabled]{cursor:default}:host .header:focus-visible{outline:2px solid #004763;outline-offset:-2px}:host .header .cell .label-container{display:flex;align-items:center}:host .header .cell .label-container .label{flex:1;display:flex;overflow:hidden;text-overflow:ellipsis}:host .header .cell .label-container .label.multiple-lines{display:-webkit-box;-webkit-box-orient:vertical;white-space:break-spaces}";

const DxTableHeaderItem = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.tableScrollChanged = (e) => {
      this.tableScrollable = e.detail;
    };
    /**
     * Allows the table to sort this column.
     *
     * @value true: The column is sortable.
     * @value false: The column is not sortable.
     */
    this.sortable = false;
    /**
     * The alignment of the title text and the cell contents within this column.
     * **Warning:** The default alignment which is defined by the `type` property will be overriden.
     *
     * @value left: Child elements are left-aligned.
     * @value right: Child elements right-aligned.
     * @value center: Child elements are centered.
     */
    this.align = null;
    /**
     * Specifies the priority of this column which is considered in the table's secondary sorting.
     *
     * @value number: Priority. The lower this number the higher the chance this column will be considered first
     * in the secondary sorting of the table.
     *
     */
    this.sortpriority = null;
    /**
     * Specifies the number of rows within an column.
     *
     * @value s: Table cells have only 1 text row
     * @value m: Table cells have up to 2 text rows.
     * @value l: Table cell have up to 3 text rows.
     */
    this.linesize = "s";
    /**
     * @internal
     */
    this.usemaxwidth = false;
    /**
     * Whether this column is sticky or not.
     * @value true: The column and the corresponding cells are sticky and cannot be scrolled
     * @value false: The column can be scrolled away.
     */
    this.sticky = false;
    this.sortState = "neutral";
    this.internAlign = null;
    this.tableScrollable = false;
    this.mediaQueryAllowsStickyness = false;
  }
  onSortableChange() {
    if (this.sortable) {
      verifyElementId(this.self);
    }
  }
  onCustomSortChanged() {
    if (this.sortState !== "neutral") {
      this.invokeSort(this.sortState);
    }
  }
  onChangeAlign() {
    this.internAlign = this.getAlignment();
  }
  connectedCallback() {
    this.breakpointAware = new BreakpointAware(() => this.updateMediaQueryStickyness(), true);
    this.table = findUpperElement(this.self, "dx-table");
    this.table.addEventListener("internalScrollChanged", this.tableScrollChanged);
    this.tableScrollable = this.table.internalScrollable;
    this.updateMediaQueryStickyness();
  }
  disconnectedCallback() {
    this.table.removeEventListener("internalScrollChanged", this.tableScrollChanged);
    this.table = null;
    this.breakpointAware.disconnect();
  }
  componentWillLoad() {
    this.internAlign = this.getAlignment();
    assert(!!(this.label || this.columnid) || !this.sortable, () => "Sortable columns should define 'columnid' or 'label' properties. This is important for the table to differentiate between the columns.", this.self);
    if (this.sortable) {
      verifyElementId(this.self);
    }
  }
  /**
   * @internal
   */
  async setSortDirection(state) {
    this.invokeSort(state);
  }
  /**
   * @internal
   */
  async toColumnSettings() {
    return {
      type: this.type,
      align: this.internAlign,
      lines: this.getCellLines(),
      sizeStyle: this.buildStyle(),
      sticky: this.sticky,
    };
  }
  async getMinWidth() {
    return this.internalGetMinWidth();
  }
  async getMaxWidth() {
    return this.internalGetMaxWidth();
  }
  updateMediaQueryStickyness() {
    this.mediaQueryAllowsStickyness = this.breakpointAware.getEffectiveValue({
      mq1: false,
      mq3: true,
    });
  }
  getCellLines() {
    var _a;
    return {
      s: 1,
      m: 2,
      l: 3,
    }[(_a = this.linesize) !== null && _a !== void 0 ? _a : "s"];
  }
  buildStyle() {
    const minWidth = this.internalGetMinWidth();
    const maxWidth = this.internalGetMaxWidth();
    const style = {
      "max-width": isNaN(maxWidth) ? "100%" : maxWidth + "px",
      "min-width": minWidth + "px",
    };
    if (this.usemaxwidth) {
      const width = this.internalGetMaxWidth();
      style["width"] = width;
      style["flex"] = `0 0 ${width}`;
    }
    return style;
  }
  internalGetMinWidth() {
    return this.minwidth || this.maxwidth || 0;
  }
  internalGetMaxWidth() {
    if (this.isSticky()) {
      return this.internalGetMinWidth();
    }
    if (this.maxwidth != null) {
      return this.maxwidth;
    }
    if (this.usemaxwidth) {
      return this.internalGetMinWidth();
    }
    return NaN;
  }
  getAlignment() {
    var _a;
    return ((_a = this.align) !== null && _a !== void 0 ? _a : (this.type === "currency" || this.type === "numeric" ? "right" : "left"));
  }
  getSortIcon() {
    if (this.sortState === "neutral") {
      return "verteilen-vertik";
    }
    else if (this.sortState === "asc") {
      return "pfeil-hoch";
    }
    else {
      return "pfeil-runter";
    }
  }
  getHeaderCellLines() {
    return this.useMultipleLines() ? 2 : 1;
  }
  useMultipleLines() {
    return /\s|\xAD/.test(this.label); // &shy;
  }
  isSticky() {
    return (this.sticky && this.tableScrollable && this.mediaQueryAllowsStickyness);
  }
  render() {
    const alignClass = {};
    alignClass["align-" + this.internAlign] = true;
    return (h(Host, { slot: this.sticky ? "sticky" : undefined, style: this.buildStyle(), class: alignClass, role: "columnheader" }, h("button", { id: ElementIdGenerator.createId(this.self, "sort-button"), type: "button", disabled: !this.sortable, onClick: () => this.invokeSort(), class: "header" }, h("div", { class: Object.assign({ cell: true }, alignClass) }, h("div", { class: "label-container" }, h("div", { class: {
        label: true,
        "multiple-lines": this.useMultipleLines(),
      }, style: {
        "-webkit-line-clamp": `${this.getHeaderCellLines()}`,
      } }, this.renderLabel(), h("slot", null)), this.renderSortButton())))));
  }
  renderLabel() {
    if (this.label != null) {
      return (h("dx-text", { type: "ps", color: this.sortState !== "neutral" ? "default" : "gray-50" }, this.label));
    }
  }
  renderSortButton() {
    if (this.sortable) {
      return (h("dx-icon", { class: "sort-icon", icon: this.getSortIcon(), color: "default", size: 16 }));
    }
  }
  getNextSortState() {
    if (this.sortState == "neutral") {
      return "asc";
    }
    return this.sortState === "asc" ? "desc" : "asc";
  }
  invokeSort(state = undefined) {
    if (this.sortable) {
      this.sortState = state !== null && state !== void 0 ? state : this.getNextSortState();
      if (this.sortState !== "neutral") {
        const table = this.getParentTable();
        table.invokeSort(this.self, this.sortState === "desc").then();
      }
    }
  }
  getParentTable() {
    return this.self.closest("dx-table");
  }
  get self() { return getElement(this); }
  static get watchers() { return {
    "sortable": ["onSortableChange"],
    "customSort": ["onCustomSortChanged"],
    "align": ["onChangeAlign"]
  }; }
};
DxTableHeaderItem.style = dxTableHeaderItemCss;

export { DxTableHeaderItem as dx_table_header_item };
