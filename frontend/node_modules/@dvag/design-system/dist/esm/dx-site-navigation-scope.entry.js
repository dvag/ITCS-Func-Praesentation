import { r as registerInstance, h, H as Host, g as getElement } from './index-04c470ea.js';
import { u as unawaited, s as sleep } from './async-0c539b38.js';

const dxSiteNavigationScopeCss = ":host{display:block}:host:host([hidden]){display:none !important}";

const DxSiteNavigationScope = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
  }
  connectedCallback() {
    this.menu().then((menu) => unawaited(menu.addScope(this.self)));
  }
  disconnectedCallback() {
    this.menu().then((menu) => unawaited(menu.removeScope(this.self)));
  }
  async menu() {
    var _a, _b;
    // we could not be sure whether menu or scopes are hydrated first
    // so we add some tolerance in finding the "control center" ;-)
    let menu;
    while (!menu) {
      menu = (_b = (_a = this.self) === null || _a === void 0 ? void 0 : _a.closest("dx-site-navigation")) === null || _b === void 0 ? void 0 : _b.querySelector("dx-site-navigation-menu");
      if (!menu) {
        await sleep(PERFECT_AMOUNT_OF_TIME_FOR_A_GOOD_SLEEP);
      }
    }
    return menu;
  }
  render() {
    return (h(Host, null, h("slot", null)));
  }
  get self() { return getElement(this); }
};
const PERFECT_AMOUNT_OF_TIME_FOR_A_GOOD_SLEEP = 100;
DxSiteNavigationScope.style = dxSiteNavigationScopeCss;

export { DxSiteNavigationScope as dx_site_navigation_scope };
