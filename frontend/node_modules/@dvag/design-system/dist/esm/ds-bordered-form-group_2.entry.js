import { r as registerInstance, h, H as Host, g as getElement, c as createEvent } from './index-04c470ea.js';
import { u as unawaited } from './async-0c539b38.js';
import { P as PreciseCssSetter } from './precise-css-setter-853ba367.js';
import { o as onNextFrame } from './render-util-1dee6655.js';
import { S as SlotObserver } from './slot-observer-9196738e.js';
import { E as ErrorPopup } from './error-popup-5aa6e69c.js';
import { B as BaselineElement } from './base-elements-20abac26.js';
import './query-util-02753b43.js';

const ERROR_CLASS = 'has-error';
const FOCUS_CLASS = 'has-focus';
const REQUIRED_CLASS = 'is-required';
const REQUIREMENT_FULFILLED_CLASS = 'requirement-fulfilled';
const DISABLED_CLASS = 'is-disabled';
const READONLY_CLASS = 'is-readonly';

const dsBorderedFormGroupCss = ":host{display:block}:host:host([hidden]){display:none !important}:host .wrapper{display:flex;position:relative;border-radius:4px}:host .container{position:relative;display:block;width:max-content}:host:host(.row) .container .wrapper{flex-direction:row}:host:host(.column) .container .wrapper{flex-direction:column;width:fit-content;width:-moz-fit-content}:host:host(.parent-size) .container{width:100%}:host:host(.parent-size) .container .wrapper{width:100%}";

const FOCUSED_CLASS = "focused";
const NOT_FOCUSED_CLASS = "not-focused";
const DsBorderedFormGroup = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.blurTimeout = null;
    this.currentFocusedIndex = -1;
    this.containsRequiredField = false;
    /**
     * The direction the elements are aligned.
     *
     * @value row: Elements are displayed in a row
     * @value column: Elements are displayed in a column
     * @example column
     * @example row
     */
    this.direction = "row";
    /**
     * The way how the component computes the width of the child elements.
     *
     * @value parent: Fits the width of the parent element.
     * @value max-content: The largest child element defines the width.
     *
     * @example size-parent
     */
    this.size = "max-content";
    /**
     * @internal
     */
    this.requirementfulfilled = false;
    this.internalRequirementFulfilled = false;
  }
  onDirectionChange() {
    onNextFrame(() => {
      this.computeBorders();
      unawaited(this.refreshWidth());
    });
  }
  onRequirementFulfilled() {
    var _a;
    this.internalRequirementFulfilled = this.isRequirementFulfilled();
    (_a = this.getRequiredNodes()) === null || _a === void 0 ? void 0 : _a.forEach((item) => {
      new PreciseCssSetter(item)
        .set(REQUIREMENT_FULFILLED_CLASS, this.internalRequirementFulfilled)
        .execute();
    });
  }
  connectedCallback() {
    this.slotObserver = new SlotObserver(this.self, "ds-bordered-form-item", (nodes) => {
      this.nodes = nodes;
      this.containsRequiredField = this.nodes.some((node) => node.classList.contains(REQUIRED_CLASS));
      this.internalRequirementFulfilled = this.isRequirementFulfilled();
      const focusedElement = this.nodes.find((node) => node.classList.contains(FOCUS_CLASS));
      if (this.nodes.indexOf(focusedElement) !== this.currentFocusedIndex) {
        this.blurCurrent();
        this.focusElement(focusedElement);
      }
      this.computeBorders();
      this.refreshWidth().then();
    });
  }
  disconnectedCallback() {
    var _a;
    (_a = this.slotObserver) === null || _a === void 0 ? void 0 : _a.disconnect();
  }
  onChildWidthChanged(e) {
    var _a;
    if ((_a = this.nodes) === null || _a === void 0 ? void 0 : _a.includes(e.target)) {
      e.stopPropagation();
      this.refreshWidth().then();
    }
  }
  blurCurrent() {
    const currentFocusedElement = this.nodes[this.currentFocusedIndex];
    if (currentFocusedElement === null || currentFocusedElement === void 0 ? void 0 : currentFocusedElement.classList.contains(FOCUSED_CLASS)) {
      currentFocusedElement === null || currentFocusedElement === void 0 ? void 0 : currentFocusedElement.classList.remove(FOCUSED_CLASS);
    }
    if (!(currentFocusedElement === null || currentFocusedElement === void 0 ? void 0 : currentFocusedElement.classList.contains(NOT_FOCUSED_CLASS))) {
      currentFocusedElement === null || currentFocusedElement === void 0 ? void 0 : currentFocusedElement.classList.add(NOT_FOCUSED_CLASS);
    }
    const currentFocusedNeighborElement = this.nodes[this.currentFocusedIndex - 1];
    if (currentFocusedNeighborElement === null || currentFocusedNeighborElement === void 0 ? void 0 : currentFocusedNeighborElement.classList.contains(FOCUSED_CLASS)) {
      currentFocusedNeighborElement === null || currentFocusedNeighborElement === void 0 ? void 0 : currentFocusedNeighborElement.classList.remove(FOCUSED_CLASS);
    }
    if (!(currentFocusedNeighborElement === null || currentFocusedNeighborElement === void 0 ? void 0 : currentFocusedNeighborElement.classList.contains(NOT_FOCUSED_CLASS))) {
      currentFocusedNeighborElement === null || currentFocusedNeighborElement === void 0 ? void 0 : currentFocusedNeighborElement.classList.add(NOT_FOCUSED_CLASS);
    }
    this.currentFocusedIndex = -1;
  }
  focusElement(element) {
    clearTimeout(this.blurTimeout);
    const indexOfElement = this.nodes.indexOf(element);
    if (indexOfElement != this.currentFocusedIndex) {
      this.blurCurrent();
      const newFocusedElement = this.nodes[indexOfElement];
      newFocusedElement === null || newFocusedElement === void 0 ? void 0 : newFocusedElement.classList.remove(NOT_FOCUSED_CLASS);
      newFocusedElement === null || newFocusedElement === void 0 ? void 0 : newFocusedElement.classList.add(FOCUSED_CLASS);
      const newFocusedNeighborElement = this.nodes[indexOfElement - 1];
      newFocusedNeighborElement === null || newFocusedNeighborElement === void 0 ? void 0 : newFocusedNeighborElement.classList.remove(NOT_FOCUSED_CLASS);
      newFocusedNeighborElement === null || newFocusedNeighborElement === void 0 ? void 0 : newFocusedNeighborElement.classList.add(FOCUSED_CLASS);
      this.currentFocusedIndex = indexOfElement;
    }
  }
  async refreshWidth() {
    if (this.wrapperElement != null) {
      if (this.direction === "row") {
        if (this.size === "parent") {
          this.wrapperElement.style.width = "100%";
        }
        else {
          let maxWidth = 0;
          this.wrapperElement.style.width = `auto`; // layout trashing intended
          for (const item of this.nodes) {
            const formItemRightPadding = 24;
            const formItemLeftPadding = 12;
            const paddingPx = formItemRightPadding + formItemLeftPadding;
            const width = (await item.getContentWidth()) + paddingPx;
            maxWidth = Math.max(width, maxWidth);
          }
          if (maxWidth > 0) {
            const border = this.nodes.length + 1;
            this.wrapperElement.style.width = `${this.nodes.length * maxWidth + border}px`;
          }
        }
      }
      else {
        this.wrapperElement.style.width = null;
      }
    }
    this.nodes.forEach((node) => {
      const classList = node.classList;
      if (!classList.contains(FOCUSED_CLASS) &&
        !classList.contains(NOT_FOCUSED_CLASS)) {
        classList.add(NOT_FOCUSED_CLASS);
      }
    });
  }
  computeBorders() {
    const nodes = this.nodes.filter((node) => !node.hasAttribute("hidden"));
    nodes.forEach((node, index) => {
      const isFirst = index === 0;
      const isLast = index === nodes.length - 1;
      const isPreviousOf = (className) => !isLast && nodes[index + 1].classList.contains(className);
      const isNextOf = (className) => !isFirst && nodes[index - 1].classList.contains(className);
      const markFirst = isFirst || isNextOf(READONLY_CLASS);
      const markLast = isLast || isPreviousOf(READONLY_CLASS);
      const prevOfFocused = isPreviousOf(FOCUS_CLASS);
      const prevOfError = isPreviousOf(ERROR_CLASS);
      const prevOfRequired = isPreviousOf(REQUIRED_CLASS);
      const nextOfFocused = isNextOf(FOCUS_CLASS);
      const nextOfError = isNextOf(ERROR_CLASS);
      const nextOfRequired = isNextOf(REQUIRED_CLASS);
      new PreciseCssSetter(node)
        .set("first", markFirst)
        .set("last", markLast)
        .set("prev-of-focused", prevOfFocused)
        .set("prev-of-error", prevOfError)
        .set("prev-of-required", prevOfRequired)
        .set("next-of-focused", nextOfFocused)
        .set("next-of-error", nextOfError)
        .set("next-of-required", nextOfRequired)
        .set("in-column", this.direction === "column")
        .set("in-row", this.direction === "row")
        .set("parent-size", this.size === "parent")
        .execute();
    });
  }
  getRequiredNodes() {
    var _a;
    return (_a = this.nodes) === null || _a === void 0 ? void 0 : _a.filter((node) => node.classList.contains(REQUIRED_CLASS));
  }
  isRequirementFulfilled() {
    var _a;
    return (this.requirementfulfilled ||
      ((_a = this.getRequiredNodes()) === null || _a === void 0 ? void 0 : _a.every((node) => node.classList.contains(REQUIREMENT_FULFILLED_CLASS))));
  }
  render() {
    const directionClass = {};
    directionClass[this.direction] = true;
    return (h(Host, { class: Object.assign(Object.assign({}, directionClass), { "parent-size": this.size === "parent", required: this.containsRequiredField }) }, h("div", { class: "container" }, h("div", { class: "wrapper", ref: (el) => (this.wrapperElement = el) }, h("slot", null), h(ErrorPopup, { text: this.errormessage, show: this.currentFocusedIndex !== -1 })), h("ds-required-hint", { required: this.containsRequiredField, fulfilled: this.internalRequirementFulfilled }))));
  }
  get self() { return getElement(this); }
  static get watchers() { return {
    "direction": ["onDirectionChange"],
    "requirementfulfilled": ["onRequirementFulfilled"]
  }; }
};
DsBorderedFormGroup.style = dsBorderedFormGroupCss;

const dsBorderedFormItemCss = ":host{display:flex;align-items:center;pointer-events:all;outline:none;padding:8px 24px 8px 12px;--ds-form-item-focus-color:transparent;white-space:nowrap;border:1px solid #c1c1c1;--ds-show-required-hint:none;--ds-text-line-height:20px;box-sizing:border-box}:host:host([hidden]){display:none !important}:host:host(.parent-size){white-space:normal}:host:host(.has-form-component){cursor:pointer}:host:host(.in-column){border-top-width:0}:host:host(.in-row){width:100%;flex-grow:1;flex-shrink:1;border-left-width:0}:host:host(.first.in-column){border-top-width:1px;border-top-left-radius:4px;border-top-right-radius:4px}:host:host(.first.in-row){border-left-width:1px;border-top-left-radius:4px;border-bottom-left-radius:4px}:host:host(.last.in-column){border-bottom-left-radius:4px;border-bottom-right-radius:4px}:host:host(.last.in-row){border-top-right-radius:4px;border-bottom-right-radius:4px}:host:host(.prev-of-focused):host(.in-column),:host:host(.prev-of-error):host(.in-column),:host:host(.prev-of-required):host(.in-column){border-bottom-width:0}:host:host(.prev-of-focused):host(.in-row),:host:host(.prev-of-error):host(.in-row),:host:host(.prev-of-required):host(.in-row){border-right-width:0}:host:host(.is-required:not(.has-focus):not(.has-error)):host(:not(.requirement-fulfilled)){border-color:#e8b50e}:host:host(.is-required:not(.has-focus):not(.has-error)):host(.in-column){border-top-width:1px;border-bottom-width:1px}:host:host(.is-required:not(.has-focus):not(.has-error)):host(.in-column):host(.prev-of-focused),:host:host(.is-required:not(.has-focus):not(.has-error)):host(.in-column):host(.prev-of-error),:host:host(.is-required:not(.has-focus):not(.has-error)):host(.in-column):host(.prev-of-required){border-bottom-width:0}:host:host(.is-required:not(.has-focus):not(.has-error)):host(.in-column):host(.next-of-focused),:host:host(.is-required:not(.has-focus):not(.has-error)):host(.in-column):host(.next-of-error){border-top-width:0}:host:host(.is-required:not(.has-focus):not(.has-error)):host(.in-row){border-left-width:1px;border-right-width:1px}:host:host(.is-required:not(.has-focus):not(.has-error)):host(.in-row):host(.prev-of-focused),:host:host(.is-required:not(.has-focus):not(.has-error)):host(.in-row):host(.prev-of-error),:host:host(.is-required:not(.has-focus):not(.has-error)):host(.in-row):host(.prev-of-required){border-right-width:0}:host:host(.is-required:not(.has-focus):not(.has-error)):host(.in-row):host(.next-of-focused),:host:host(.is-required:not(.has-focus):not(.has-error)):host(.in-row):host(.next-of-error){border-left-width:0}:host:host(.has-error){position:relative;--dx-popup-offset-left:0px;--ds-display-popup:none}:host dx-popup{left:var(--ds-error-popup-offset, 0px)}:host:host(.has-error:not(.has-focus)){border-color:#be1413}:host:host(.has-error:not(.has-focus)):host(.in-column){border-top-width:1px;border-bottom-width:1px}:host:host(.has-error:not(.has-focus)):host(.in-column):host(.prev-of-focused),:host:host(.has-error:not(.has-focus)):host(.in-column):host(.prev-of-error){border-bottom-width:0}:host:host(.has-error:not(.has-focus)):host(.in-column):host(.next-of-focused){border-top-width:0}:host:host(.has-error:not(.has-focus)):host(.in-row){border-left-width:1px;border-right-width:1px}:host:host(.has-error:not(.has-focus)):host(.in-row):host(.prev-of-focused),:host:host(.has-error:not(.has-focus)):host(.in-row):host(.prev-of-error){border-right-width:0}:host:host(.has-error:not(.has-focus)):host(.in-row):host(.next-of-focused){border-left-width:0}:host:host(.has-focus){border-color:#4c4c4c}:host:host(.has-focus):host(.in-column){border-top-width:1px;border-bottom-width:1px}:host:host(.has-focus):host(.in-column):host(.prev-of-focused){border-bottom-width:0}:host:host(.has-focus):host(.in-row){border-left-width:1px;border-right-width:1px}:host:host(.has-focus):host(.in-row):host(.prev-of-focused){border-right-width:0}:host:host(.is-disabled),:host:host(.is-readonly){pointer-events:none;cursor:default}:host:host(.is-readonly){border-color:transparent;padding:0}";

const FORM_COMPONENT_TAGS = ["ds-radio-button", "ds-checkbox"];
const DsBorderedFormItem = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.widthChanged = createEvent(this, "widthChanged", 7);
    this.inputFocused = false;
  }
  connectedCallback() {
    var _a;
    this.slotObserver = new SlotObserver(this.self, "*", (nodes) => {
      this.formComponent = nodes.find((node) => {
        return (FORM_COMPONENT_TAGS.includes(node.tagName.toLowerCase()) &&
          node.classList.contains("hydrated"));
      });
      this.errormessage = this.getFormComponentAttribute("errormessage");
      this.configureStates();
    });
    (_a = this.resizeObserver) === null || _a === void 0 ? void 0 : _a.observe(this.contentElement);
  }
  componentDidLoad() {
    this.resizeObserver = new ResizeObserver(() => {
      this.widthChanged.emit(this.contentElement.offsetWidth);
    });
    this.resizeObserver.observe(this.contentElement);
  }
  disconnectedCallback() {
    var _a, _b;
    (_a = this.slotObserver) === null || _a === void 0 ? void 0 : _a.disconnect();
    (_b = this.resizeObserver) === null || _b === void 0 ? void 0 : _b.disconnect();
  }
  getFormComponentAttribute(attributeName, fallback = null) {
    var _a, _b, _c, _d;
    if ((_a = this.formComponent) === null || _a === void 0 ? void 0 : _a[attributeName]) {
      return (_b = this.formComponent) === null || _b === void 0 ? void 0 : _b[attributeName];
    }
    const value = (_c = this.formComponent) === null || _c === void 0 ? void 0 : _c.getAttribute(attributeName);
    if (typeof fallback === "boolean") {
      return (value === "true");
    }
    else if (typeof fallback === "number") {
      return (isNaN(+value) ? null : +value);
    }
    return (_d = value) !== null && _d !== void 0 ? _d : fallback;
  }
  configureStates() {
    var _a, _b, _c;
    this.inputFocused = !!((_a = this.formComponent) === null || _a === void 0 ? void 0 : _a.classList.contains(FOCUS_CLASS));
    new PreciseCssSetter(this.self)
      .set(ERROR_CLASS, ((_b = this.errormessage) === null || _b === void 0 ? void 0 : _b.length) > 0 ||
      this.getFormComponentAttribute("error", false))
      .set(FOCUS_CLASS, this.inputFocused)
      .set(DISABLED_CLASS, this.getFormComponentAttribute("disabled", false) ||
      ((_c = this.formComponent) === null || _c === void 0 ? void 0 : _c.classList.contains("disabled")))
      .set(READONLY_CLASS, this.getFormComponentAttribute("readonly", false))
      .set(REQUIRED_CLASS, this.getFormComponentAttribute("required", false))
      .set(REQUIREMENT_FULFILLED_CLASS, this.getFormComponentAttribute("requirementfulfilled", false))
      .set("has-form-component", this.formComponent != null)
      .execute();
  }
  /**
   * @internal
   */
  async getContentWidth() {
    var _a;
    return (_a = this.contentElement) === null || _a === void 0 ? void 0 : _a.offsetWidth;
  }
  delegateEvent(srcEvent) {
    var _a, _b;
    if (this.formComponent == null ||
      this.getFormComponentAttribute("disabled", false) ||
      this.getFormComponentAttribute("readonly", false)) {
      return;
    }
    const anyChildGotEvent = srcEvent
      .composedPath()
      .includes(this.formComponent);
    if (!anyChildGotEvent) {
      (_b = (_a = this.formComponent.shadowRoot) === null || _a === void 0 ? void 0 : _a.querySelector(".event-delegate-receiver")) === null || _b === void 0 ? void 0 : _b.dispatchEvent(new srcEvent.constructor(srcEvent.type, srcEvent));
    }
    if (["click", "mousedown"].includes(srcEvent.type)) {
      const abstractComponent = this.formComponent;
      if (abstractComponent.focusControl != null) {
        abstractComponent.focusControl();
      }
    }
  }
  render() {
    return (h(Host, { onClick: (e) => this.delegateEvent(e), onMouseDown: (e) => this.delegateEvent(e), onMouseEnter: (e) => this.delegateEvent(e), onMouseLeave: (e) => this.delegateEvent(e) }, 
    // TODO: Find better solution
    !window["chrome"] ? h(BaselineElement, { onlyDiv: true }) : null, h("div", { ref: (el) => (this.contentElement = el), class: "content-container" }, h("slot", null)), h(ErrorPopup, { text: this.errormessage, show: this.inputFocused })));
  }
  get self() { return getElement(this); }
};
DsBorderedFormItem.style = dsBorderedFormItemCss;

export { DsBorderedFormGroup as ds_bordered_form_group, DsBorderedFormItem as ds_bordered_form_item };
