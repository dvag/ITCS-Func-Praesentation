import{r as t,h as s,H as i,g as e}from"./p-c66bef8d.js";import{G as n,g as r}from"./p-9de2ff9f.js";import{B as o}from"./p-76fa4815.js";import{S as h}from"./p-968cb048.js";import{a}from"./p-dc250dcd.js";import{a as l}from"./p-ab7cc717.js";import"./p-fabbcf47.js";class c{parse(t,s){const i={rows:t.split("/").map((t=>this.parseRow(t))),breakpoint:s,expression:t,error:""};return i.rows.filter((t=>"columns"===t.type)).flatMap((t=>t.columns)).filter((t=>isNaN(t.size))).length>0&&(i.error+=`Fehler beim Parsen von ${s}="${t}". Syntaxfehler.`),i}parseRow(t){return"*"===t?{type:"repeat"}:{type:"columns",columns:t.split("-").map((t=>d.test(t)?{type:"whitespace",size:parseInt(t.match(d)[1])}:{type:"slotelement",size:parseInt(t)}))}}}const d=/^\((.+)\)$/i;class p{constructor(t){this.base=t}validate(t){t.rows.forEach(((s,i)=>{if("columns"===s.type){const e=s.columns.reduce(((t,s)=>t+s.size),0),n=this.base.columns[t.breakpoint];e>n&&(t.error+=`Error parsing ${t.breakpoint}="${t.expression}". Line ${i+1} uses ${e} columns. Only ${n} columns are allowed.`)}}))}}const m={gapSizes:{mq1:16,mq2:16,mq3:24,mq4:24,mq5:24},columns:{mq1:12,mq2:12,mq3:12,mq4:12,mq5:12}};class u{build(t,s,i,e,n){const r=new f;r.writeCss(`:host {\n        column-gap: ${t.gapSizes[i]}px;\n        row-gap: ${n}px;\n        grid-template-columns: repeat(${t.columns[i]}, 1fr);\n      }\n    `);let o=0,h=0;return s.rows.forEach(((t,i)=>{var n;if("columns"===t.type&&(h++,o=this.processRow(t.columns,o,r,h)),"repeat"===t.type){const t=null===(n=s.rows[i-1])||void 0===n?void 0:n.columns;for(;o<e;)h++,o=this.processRow(t,o,r,h)}})),e>o&&r.writeError(`There are ${e} child elements within the grid, although it is only layed out for ${o} child elements.`),{css:r.css,error:r.error}}processRow(t,s,i,e){let n=1;return t.forEach((t=>{"slotelement"===t.type&&(s++,i.writeCss(t.size>0?`\n:host ::slotted(*:nth-child(${s})) {\n  grid-column-start: ${n};\n  grid-column-end: span ${t.size};\n  grid-row-start: ${e};\n  grid-row-end: span 1;\n}`:`\n:host ::slotted(*:nth-child(${s})) {\n  display: none !important;\n}`)),n+=t.size})),s}}class f{constructor(){this.css="",this.error=""}writeCss(t){this.css+=t}writeError(t){this.error+=t}}const g=class{constructor(s){t(this,s),this.base="page",this.rowgap="16",this.updateGridPoolBeforeRender=!1,this.gridPool=[]}updateGridPool(){a(null!=(this.mq1||this.mq2||this.mq3||this.mq4||this.mq5),(()=>'<dx-grid> There has to be at least one breakpoint defined: "mq1", "mq2", "mq3", "mq4" or "mq5".')),this.gridPool=[];const t=m;this.mq1&&this.gridPool.push((new c).parse(this.mq1,n.MQ1)),this.mq2&&this.gridPool.push((new c).parse(this.mq2,n.MQ2)),this.mq3&&this.gridPool.push((new c).parse(this.mq3,n.MQ3)),this.mq4&&this.gridPool.push((new c).parse(this.mq4,n.MQ4)),this.mq5&&this.gridPool.push((new c).parse(this.mq5,n.MQ5));const s=new p(t);this.gridPool.forEach((t=>s.validate(t))),this.updateChosenGrid()}componentWillLoad(){this.updateGridPool()}connectedCallback(){this.slotObserver=new h(this.self,"*",(t=>{this.numberOfChildNodes=t.filter((t=>t.parentElement===this.self)).length})),this.breakpointAware=new o((()=>this.updateChosenGrid()),!0)}disconnectedCallback(){var t,s;null===(t=this.breakpointAware)||void 0===t||t.disconnect(),null===(s=this.slotObserver)||void 0===s||s.disconnect()}componentShouldUpdate(t,s,i){i.startsWith("mq")&&(this.updateGridPoolBeforeRender=!0)}componentWillRender(){var t;l(null!==(t=this.rowgap)&&void 0!==t?t:"16",this.self),this.updateGridPoolBeforeRender&&(this.updateGridPool(),this.updateGridPoolBeforeRender=!1)}gridBase(){if("page"==this.base)return m;throw Error("<dx-grid> Invalid 'base' value")}getBreakpointFromBreakpointAware(){return this.breakpointAware.mq1?n.MQ1:this.breakpointAware.mq2?n.MQ2:this.breakpointAware.mq3?n.MQ3:this.breakpointAware.mq4?n.MQ4:n.MQ5}updateChosenGrid(){if(this.breakpoint=this.getBreakpointFromBreakpointAware(),this.usedGrid=this.gridPool.find((t=>t.breakpoint===this.breakpoint)),!this.usedGrid){const t=r(this.breakpoint);this.usedGrid=this.gridPool.reduce(((s,i)=>{const e=r(i.breakpoint);return e>r(s.breakpoint)&&e<t?i:s}))}this.usedGrid||(this.usedGrid=this.gridPool[0])}render(){let t=this.gridPool.map((t=>t.error)).reduce(((t,s)=>t+s),"");const e=parseInt(this.rowgap),n=(new u).build(this.gridBase(),this.usedGrid,this.getBreakpointFromBreakpointAware(),this.numberOfChildNodes,isNaN(e)?16:e);return t+=n.error,t.length>0?(console.error(`<dx-grid> ${t}`),`Grid-Error: ${t}`):s(i,null,s("style",null,n.css),s("slot",null))}get self(){return e(this)}};g.style=":host{display:grid}:host:host([hidden]){display:none !important}";export{g as dx_grid}