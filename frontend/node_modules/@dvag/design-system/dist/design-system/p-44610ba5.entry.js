import{r as s,h as t,H as e,g as i}from"./p-c66bef8d.js";import{a as n}from"./p-dc250dcd.js";import{B as r}from"./p-76fa4815.js";import{S as o}from"./p-968cb048.js";import"./p-fabbcf47.js";class l{parse(s,t){const e={rows:s.split("/").map((s=>this.parseRow(s))),breakpoint:t,expression:s,error:""};return e.rows.filter((s=>"columns"===s.type)).flatMap((s=>s.columns)).filter((s=>isNaN(s.size))).length>0&&(e.error+=`Fehler beim Parsen von ${t}="${s}". Syntaxfehler.`),e}parseRow(s){return"*"===s?{type:"repeat"}:{type:"columns",columns:s.split("-").map((s=>h.test(s)?{type:"whitespace",size:parseInt(s.match(h)[1])}:{type:"slotelement",size:parseInt(s)}))}}}const h=/^\((.+)\)$/i;class a{constructor(s){this.base=s}validate(s){s.rows.forEach(((t,e)=>{if("columns"===t.type){const i=t.columns.reduce(((s,t)=>s+t.size),0),n=this.base[s.breakpoint+"Columns"];i>n&&(s.error+=`Fehler beim Parsen von ${s.breakpoint}="${s.expression}". Zeile ${e+1} benutzt ${i} Spalten von maximal erlaubten ${n}.`)}}))}}const d={gapSizePx:24,xlColumns:12,lColumns:8,mColumns:6,sColumns:4};var c;function p(s){return s===c.XL?4:s===c.L?3:s===c.M?2:s===c.S?1:void 0}!function(s){s.XL="xl",s.L="l",s.M="m",s.S="s"}(c||(c={}));class m{build(s,t,e){const i=new u;i.writeCss(`\n:host {\n  column-gap: ${s.gapSizePx}px;\n  row-gap: ${s.gapSizePx}px;\n  grid-template-columns: repeat(${s[t.breakpoint+"Columns"]}, 1fr);\n}`);let n=0,r=0;return t.rows.forEach(((s,o)=>{var l;if("columns"===s.type&&(r++,n=this.processRow(s.columns,n,i,r)),"repeat"===s.type){const s=null===(l=t.rows[o-1])||void 0===l?void 0:l.columns;for(;n<e;)r++,n=this.processRow(s,n,i,r)}})),e>n&&i.writeError(`Das Grid ist für ${n} Child-Element(e) definiert, jedoch befinden sich dort aktuell ${e} Child-Element(e).`),{css:i.css,error:i.error}}processRow(s,t,e,i){let n=1;return s.forEach((s=>{"slotelement"===s.type&&(t++,e.writeCss(s.size>0?`\n:host ::slotted(*:nth-child(${t})) {\n  grid-column-start: ${n};\n  grid-column-end: span ${s.size};\n  grid-row-start: ${i};\n  grid-row-end: span 1;\n}`:`\n:host ::slotted(*:nth-child(${t})) {\n  display: none !important;\n}`)),n+=s.size})),t}}class u{constructor(){this.css="",this.error=""}writeCss(s){this.css+=s}writeError(s){this.error+=s}}const g=class{constructor(t){s(this,t),this.base="page",this.gridPool=[]}componentWillLoad(){n(null!=(this.s||this.m||this.l||this.xl),(()=>'<ds-grid> Es muss mindestens eine Größenangabe für die Properties "xl", "l", "m" oder "s" getätigt werden'));const s=d;this.s&&this.gridPool.push((new l).parse(this.s,c.S)),this.m&&this.gridPool.push((new l).parse(this.m,c.M)),this.l&&this.gridPool.push((new l).parse(this.l,c.L)),this.xl&&this.gridPool.push((new l).parse(this.xl,c.XL));const t=new a(s);this.gridPool.forEach((s=>t.validate(s))),this.updateChosenGrid()}connectedCallback(){this.breakpointAware=new r((()=>this.updateChosenGrid())),this.slotObserver=new o(this.self,"*",(s=>{this.numberOfChildNodes=s.filter((s=>s.parentElement===this.self)).length}))}disconnectedCallback(){var s,t;null===(s=this.breakpointAware)||void 0===s||s.disconnect(),null===(t=this.slotObserver)||void 0===t||t.disconnect()}gridBase(){if("page"==this.base)return d;throw Error("<ds-grid> Ungültige 'base'")}getBreakpointFromBreakpointAware(){return this.breakpointAware.xs?c.S:this.breakpointAware.md?c.M:this.breakpointAware.lg?c.L:c.XL}updateChosenGrid(){this.breakpoint=this.getBreakpointFromBreakpointAware(),this.usedGrid=this.gridPool.find((s=>s.breakpoint===this.breakpoint)),this.usedGrid||(this.usedGrid=this.gridPool.reduce(((s,t)=>p(t.breakpoint)>p(s.breakpoint)&&p(t.breakpoint)<p(this.breakpoint)?t:s))),this.usedGrid||(this.usedGrid=this.gridPool[0])}render(){let s=this.gridPool.map((s=>s.error)).reduce(((s,t)=>s+t),"");const i=(new m).build(this.gridBase(),this.usedGrid,this.numberOfChildNodes);return s+=i.error,s.length>0?(console.error(`<ds-grid> ${s}`),`Grid-Fehler: ${s}`):t(e,null,t("style",null,i.css),t("slot",null))}get self(){return i(this)}};g.style=":host{display:grid}:host:host([hidden]){display:none !important}";export{g as ds_grid}