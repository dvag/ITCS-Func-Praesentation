import { h, Host, writeTask, } from "@stencil/core";
import { createMetaComponentsSlotObserver, } from "../../../../classes/slot-observer";
import { isSlotDefined } from "../../../../classes/render-util";
import { DsSubject, } from "../../../../classes/multicast-observable";
import { ElementIdGenerator, verifyElementId, } from "../../../../classes/element-id-handling";
import { assert } from "../../../../classes/assert";
import { ModalScrollHelper } from "../../../../classes/modal-scroll-helper";
import { TransitionStartHelper } from "../../../../classes/event.util";
import { isInnerElement } from "../../../../classes/misc-util";
/**
 * Modal alert which overlays over the page to show a dialog which displays confirmation options.
 * @path /Modals
 * @name Alert
 * @icon exclamation-triangle
 * @stable
 */
export class DsAlert {
  constructor() {
    this.minButtonSpaceOnSides = 16;
    this.submitResult = new DsSubject();
    this.customShowCalled = false;
    this.transitionStartHelper = new TransitionStartHelper(this, this.handleTransitionStart);
    this.direction = "column";
    this.ignoreSlots = false;
    this.nooverlay = false;
    /**
     * Defines if the alert is visible or not.
     * @value true: Alert is visible.
     * @value false: Alert is not visible.
     *
     * @example visible
     */
    this.visible = false;
    /**
     * Defines in which direction the buttons should be displayed.
     *
     * @value column: The buttons will be displayed from left to right.
     * @value row: The buttons will be displayed from top to bottom.
     * @value auto: The direction is computed dependant on the label size of the buttons.
     * @example actions-direction-row
     * @example actions-direction-column
     * @example actions-direction-auto-s
     * @example actions-direction-auto-l
     */
    this.actionsdirection = "auto";
  }
  componentWillLoad() {
    verifyElementId(this.self);
    this.submitResultSubscription = this.submitResult.subscribe((newValue) => {
      this.buttonClick.emit(newValue);
    });
    this.nooverlay =
      getComputedStyle(this.self).getPropertyValue("--nooverlay").trim() ===
        "true";
  }
  connectedCallback() {
    this.slotObserver =
      createMetaComponentsSlotObserver(this.self, "ds-alert-button", async (nodes) => {
        this.buttonsData = await Promise.all(nodes.map((node) => node.toAlertButtonData()));
      });
  }
  componentDidRender() {
    const scrollHelper = ModalScrollHelper.instance();
    if (this.visible) {
      scrollHelper.block(this.modalDialog);
    }
    else {
      scrollHelper.unblock(this.modalDialog);
    }
    if (this.actionsdirection === "auto") {
      const texts = Array.from(this.self.shadowRoot.querySelectorAll(".button ds-text"));
      const textAlreadyRendered = texts.some((text) => text.offsetWidth !== 0);
      if (textAlreadyRendered) {
        writeTask(() => {
          this.direction = this.calculateDirection(texts);
        });
      }
      else {
        const mutationObserver = new MutationObserver(() => {
          this.direction = this.calculateDirection(texts);
          mutationObserver.disconnect();
        });
        const firstButtonText = this.self.shadowRoot.querySelector(".button ds-text");
        if (firstButtonText != null) {
          mutationObserver.observe(firstButtonText, {
            attributes: true,
            childList: true,
            characterData: true,
            subtree: true,
          });
        }
      }
    }
    else {
      writeTask(() => {
        this.direction = this.actionsdirection;
      });
    }
  }
  disconnectedCallback() {
    var _a, _b, _c;
    (_a = this.slotObserver) === null || _a === void 0 ? void 0 : _a.disconnect();
    (_b = this.submitResultSubscription) === null || _b === void 0 ? void 0 : _b.unsubscribe();
    (_c = this.transitionStartHelper) === null || _c === void 0 ? void 0 : _c.disconnect();
    ModalScrollHelper.instance().unblock(this.self);
  }
  onKeyDown(e) {
    if (this.visible && e.key === "Enter") {
      const explicitTargetElement = e.composedPath()[0];
      if (explicitTargetElement !== this.self) {
        const isTargetElementWithinSelf = isInnerElement(explicitTargetElement, this.self);
        // If the target element is one of the inner alert buttons we dont want to interfere
        if (isTargetElementWithinSelf) {
          return;
        }
        // If the target element is outside the alert we cancel the propagation and handle the input.
        e.preventDefault();
        e.stopPropagation();
      }
      const confirmButtonData = this.buttonsData.find((buttonData) => buttonData.confirm);
      if (confirmButtonData != null) {
        this.handleButtonClick(confirmButtonData);
      }
    }
  }
  calculateDirection(texts) {
    const maxTextWidth = 327 / texts.length - 2 * this.minButtonSpaceOnSides;
    const containsLargeText = texts.some((elem) => {
      return elem.offsetWidth > maxTextWidth;
    });
    return !containsLargeText ? "row" : "column";
  }
  async prepareShowAlert(body) {
    return new Promise((resolve) => {
      body(resolve);
      this.ignoreSlots = true;
      this.visible = true;
    }).then((result) => {
      this.ignoreSlots = false;
      return result;
    });
  }
  /**
   * Shows the alert and returns a promise with the users choice.
   * *Important*: This method should not be called with the `showAlert` or `showConfirm` method in an alert's lifecycle.
   *
   * @example method-show
   */
  async show() {
    assert(this.customShowCalled != true, () => `<ds-alert> show() sollte nicht benutzt werden, wenn vorher einer der vordefinierten showAlert() || showConfirm() Methoden benutzt wurde.`);
    return new Promise((resolve) => {
      const subscription = this.submitResult.subscribe((newValue) => {
        resolve(newValue);
        subscription === null || subscription === void 0 ? void 0 : subscription.unsubscribe();
      });
      const elementComment = document.createComment("cpIf " + "comment");
      elementComment.replaceWith(this.self);
      this.visible = true;
    });
  }
  /**
   * Shows a predefined alert with one confirmation button.
   *
   * *Important*: This method should not be called with the `show` method in an alert's lifecycle.
   *
   * @param title Title text.
   * @param body The content text below the title.
   * @param icon An icon name which is displayed over the title.
   * @param iconColor The icon color.
   * @param okLabel The label text of the confirmation button.
   * @example method-show-alert
   */
  async showAlert(title, body, okLabel = "Ok", icon = undefined, iconColor = undefined) {
    this.customShowCalled = true;
    return await this.prepareShowAlert((resolve) => {
      const confirmButtons = [
        createAlertButton(okLabel, undefined, true, "gold", false, false, () => resolve(true)),
      ];
      this.customRenderFunction = () => {
        return [
          this.renderIcon(icon, iconColor),
          this.renderContent(title, body),
          this.renderButtons(confirmButtons),
        ];
      };
    });
  }
  /**
   * Shows a predefined alert with two buttons.
   * The right button confirms and the left button cancels the alert.
   * The method returns a promise which resolves when the user interacts with one of the two options.
   * The resolved promise contains `true` when the user confirms the alert and `false` when the user cancels the alert.
   *
   * *Important*: This method should not be called with the `show` method in an alert's lifecycle.
   *
   * @param title Title text.
   * @param body The content text below the title.
   * @param cancelLabel The label text of the left button (cancel).
   * @param confirmLabel The label text of the right button (confirm).
   * @param icon An icon name which is displayed over the title.
   * @param iconColor The icon color.
   * @param destructive Indicates whether the alert implies a destructive action when confirming (e.g. deletion of a resource).
   * @example method-show-confirm1
   * @example method-show-confirm2
   */
  async showConfirm(title, body, cancelLabel, confirmLabel, icon = undefined, iconColor = undefined, destructive = false) {
    this.customShowCalled = true;
    return await this.prepareShowAlert((resolve) => {
      const confirmButtons = [
        createAlertButton(cancelLabel, "false", false, "gold", false, false, () => resolve(false)),
        createAlertButton(confirmLabel, "true", true, destructive ? "rot" : "gold", !destructive, false, () => resolve(true)),
      ];
      this.customRenderFunction = () => {
        return [
          this.renderIcon(icon, iconColor),
          this.renderContent(title, body),
          this.renderButtons(confirmButtons),
        ];
      };
    });
  }
  handleButtonClick(button) {
    this.submitResult.next(button.value);
    this.visible = false;
  }
  handleTransitionStart(e) {
    if (e.propertyName === "transform" && this.visible) {
      this.self.style["visibility"] = "visible";
      // We want to take the focus from the button which triggered this alert and start listen to keyboard events.
      this.self.focus();
    }
  }
  handleTransitionEnd(e) {
    if (e.propertyName === "transform" && !this.visible) {
      this.self.style["visibility"] = "hidden";
      // We have to blur this alert because it will stay on focus although visibility is hidden.
      this.self.blur();
    }
  }
  render() {
    return (h(Host, { class: {
        visible: this.visible,
        "no-overlay": this.nooverlay,
      }, tabIndex: 0 }, h("div", { class: "overlay" }), h("div", { class: "modal-layout", ref: (ref) => this.transitionStartHelper.on(ref), onTransitionEnd: (e) => this.handleTransitionEnd(e) }, h("ds-card", { class: "modal-element", ref: (el) => (this.modalDialog = el) }, this.ignoreSlots && this.customRenderFunction !== undefined
      ? this.customRenderFunction()
      : this.renderDefault()))));
  }
  renderDefault() {
    return [
      this.renderIconSlot(),
      this.renderDefaultContent(),
      this.renderButtons(this.buttonsData),
    ];
  }
  renderIcon(icon, iconColor) {
    if (icon != null) {
      return (h("div", { class: "icon-container" }, h("ds-icon", { size: 32, icon: icon, color: iconColor })));
    }
  }
  renderIconSlot() {
    if (isSlotDefined(this.self, "icon")) {
      return (h("div", { class: "icon-container" }, h("div", null, h("div", null, h("div", null, h("slot", { name: "icon" }))))));
    }
  }
  renderDefaultContent() {
    const titleSlotDefined = isSlotDefined(this.self, "title");
    const bodySlotDefined = isSlotDefined(this.self, "body");
    return [
      titleSlotDefined || bodySlotDefined ? (h("div", { class: { content: true } }, titleSlotDefined ? (h("div", { class: "title" }, h("div", null, h("slot", { name: "title" })))) : null, bodySlotDefined ? (h("div", { class: "body" }, h("div", null, h("slot", { name: "body" })))) : null)) : null,
      h("slot", null),
    ];
  }
  renderContent(title, body) {
    return (h("div", { class: { content: true } }, h("div", { class: "title" }, h("ds-text", { type: "u5" }, title)), h("div", { class: "body" }, h("ds-text", { type: "ft" }, body))));
  }
  renderButtons(buttonDataArray) {
    if ((buttonDataArray === null || buttonDataArray === void 0 ? void 0 : buttonDataArray.length) > 0) {
      const directionRight = this.direction === "row";
      return (h("div", { class: {
          "buttons-container": true,
          "direction-right": directionRight,
          "direction-down": !directionRight,
        } }, buttonDataArray.map((buttonData, buttonIndex) => this.renderButton(buttonData, buttonIndex))));
    }
  }
  renderButton(buttonData, buttonIndex) {
    const predefinedClickFunction = buttonData.onClick;
    return (h("div", { class: {
        button: true,
        disabled: buttonData.disabled,
      }, onClick: (e) => {
        if (predefinedClickFunction != null) {
          predefinedClickFunction(e);
        }
        this.handleButtonClick(buttonData);
      } }, h("ds-text-button", { id: ElementIdGenerator.createId(this.self, "button-" + buttonIndex), color: buttonData.color, disabled: buttonData.disabled }, h("ds-text", { type: buttonData.highlight ? "ftf" : undefined }, buttonData.label))));
  }
  static get is() { return "ds-alert"; }
  static get encapsulation() { return "shadow"; }
  static get originalStyleUrls() {
    return {
      "$": ["ds-alert.scss"]
    };
  }
  static get styleUrls() {
    return {
      "$": ["ds-alert.css"]
    };
  }
  static get properties() {
    return {
      "visible": {
        "type": "boolean",
        "mutable": true,
        "complexType": {
          "original": "boolean",
          "resolved": "boolean",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "true: Alert is visible."
            }, {
              "name": "value",
              "text": "false: Alert is not visible."
            }, {
              "name": "example",
              "text": "visible"
            }],
          "text": "Defines if the alert is visible or not."
        },
        "attribute": "visible",
        "reflect": true,
        "defaultValue": "false"
      },
      "actionsdirection": {
        "type": "string",
        "mutable": false,
        "complexType": {
          "original": "\"column\" | \"row\" | \"auto\"",
          "resolved": "\"auto\" | \"column\" | \"row\"",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "column: The buttons will be displayed from left to right."
            }, {
              "name": "value",
              "text": "row: The buttons will be displayed from top to bottom."
            }, {
              "name": "value",
              "text": "auto: The direction is computed dependant on the label size of the buttons."
            }, {
              "name": "example",
              "text": "actions-direction-row"
            }, {
              "name": "example",
              "text": "actions-direction-column"
            }, {
              "name": "example",
              "text": "actions-direction-auto-s"
            }, {
              "name": "example",
              "text": "actions-direction-auto-l"
            }],
          "text": "Defines in which direction the buttons should be displayed."
        },
        "attribute": "actionsdirection",
        "reflect": false,
        "defaultValue": "\"auto\""
      }
    };
  }
  static get states() {
    return {
      "customRenderFunction": {},
      "buttonsData": {},
      "direction": {},
      "ignoreSlots": {},
      "nooverlay": {}
    };
  }
  static get events() {
    return [{
        "method": "buttonClick",
        "name": "buttonClick",
        "bubbles": true,
        "cancelable": true,
        "composed": true,
        "docs": {
          "tags": [{
              "name": "exqmple",
              "text": "button-click"
            }],
          "text": "Fires when the user interacts with one of the alert's buttons."
        },
        "complexType": {
          "original": "string",
          "resolved": "string",
          "references": {}
        }
      }];
  }
  static get methods() {
    return {
      "show": {
        "complexType": {
          "signature": "() => Promise<any>",
          "parameters": [],
          "references": {
            "Promise": {
              "location": "global"
            }
          },
          "return": "Promise<any>"
        },
        "docs": {
          "text": "Shows the alert and returns a promise with the users choice.\n*Important*: This method should not be called with the `showAlert` or `showConfirm` method in an alert's lifecycle.",
          "tags": [{
              "name": "example",
              "text": "method-show"
            }]
        }
      },
      "showAlert": {
        "complexType": {
          "signature": "(title: string, body: string, okLabel?: string, icon?: string, iconColor?: string) => Promise<any>",
          "parameters": [{
              "tags": [{
                  "name": "param",
                  "text": "title Title text."
                }],
              "text": "Title text."
            }, {
              "tags": [{
                  "name": "param",
                  "text": "body The content text below the title."
                }],
              "text": "The content text below the title."
            }, {
              "tags": [{
                  "name": "param",
                  "text": "okLabel The label text of the confirmation button."
                }],
              "text": "The label text of the confirmation button."
            }, {
              "tags": [{
                  "name": "param",
                  "text": "icon An icon name which is displayed over the title."
                }],
              "text": "An icon name which is displayed over the title."
            }, {
              "tags": [{
                  "name": "param",
                  "text": "iconColor The icon color."
                }],
              "text": "The icon color."
            }],
          "references": {
            "Promise": {
              "location": "global"
            },
            "AlertButtonData": {
              "location": "import",
              "path": "../ds-alert-button/ds-alert-button"
            }
          },
          "return": "Promise<any>"
        },
        "docs": {
          "text": "Shows a predefined alert with one confirmation button.\n\n*Important*: This method should not be called with the `show` method in an alert's lifecycle.",
          "tags": [{
              "name": "param",
              "text": "title Title text."
            }, {
              "name": "param",
              "text": "body The content text below the title."
            }, {
              "name": "param",
              "text": "icon An icon name which is displayed over the title."
            }, {
              "name": "param",
              "text": "iconColor The icon color."
            }, {
              "name": "param",
              "text": "okLabel The label text of the confirmation button."
            }, {
              "name": "example",
              "text": "method-show-alert"
            }]
        }
      },
      "showConfirm": {
        "complexType": {
          "signature": "(title: string, body: string, cancelLabel: string, confirmLabel: string, icon?: string, iconColor?: string, destructive?: boolean) => Promise<boolean>",
          "parameters": [{
              "tags": [{
                  "name": "param",
                  "text": "title Title text."
                }],
              "text": "Title text."
            }, {
              "tags": [{
                  "name": "param",
                  "text": "body The content text below the title."
                }],
              "text": "The content text below the title."
            }, {
              "tags": [{
                  "name": "param",
                  "text": "cancelLabel The label text of the left button (cancel)."
                }],
              "text": "The label text of the left button (cancel)."
            }, {
              "tags": [{
                  "name": "param",
                  "text": "confirmLabel The label text of the right button (confirm)."
                }],
              "text": "The label text of the right button (confirm)."
            }, {
              "tags": [{
                  "name": "param",
                  "text": "icon An icon name which is displayed over the title."
                }],
              "text": "An icon name which is displayed over the title."
            }, {
              "tags": [{
                  "name": "param",
                  "text": "iconColor The icon color."
                }],
              "text": "The icon color."
            }, {
              "tags": [{
                  "name": "param",
                  "text": "destructive Indicates whether the alert implies a destructive action when confirming (e.g. deletion of a resource)."
                }],
              "text": "Indicates whether the alert implies a destructive action when confirming (e.g. deletion of a resource)."
            }],
          "references": {
            "Promise": {
              "location": "global"
            },
            "AlertButtonData": {
              "location": "import",
              "path": "../ds-alert-button/ds-alert-button"
            }
          },
          "return": "Promise<boolean>"
        },
        "docs": {
          "text": "Shows a predefined alert with two buttons.\nThe right button confirms and the left button cancels the alert.\nThe method returns a promise which resolves when the user interacts with one of the two options.\nThe resolved promise contains `true` when the user confirms the alert and `false` when the user cancels the alert.\n\n*Important*: This method should not be called with the `show` method in an alert's lifecycle.",
          "tags": [{
              "name": "param",
              "text": "title Title text."
            }, {
              "name": "param",
              "text": "body The content text below the title."
            }, {
              "name": "param",
              "text": "cancelLabel The label text of the left button (cancel)."
            }, {
              "name": "param",
              "text": "confirmLabel The label text of the right button (confirm)."
            }, {
              "name": "param",
              "text": "icon An icon name which is displayed over the title."
            }, {
              "name": "param",
              "text": "iconColor The icon color."
            }, {
              "name": "param",
              "text": "destructive Indicates whether the alert implies a destructive action when confirming (e.g. deletion of a resource)."
            }, {
              "name": "example",
              "text": "method-show-confirm1"
            }, {
              "name": "example",
              "text": "method-show-confirm2"
            }]
        }
      }
    };
  }
  static get elementRef() { return "self"; }
  static get listeners() {
    return [{
        "name": "keydown",
        "method": "onKeyDown",
        "target": "window",
        "capture": true,
        "passive": false
      }];
  }
}
function createAlertButton(label, value, confirm, color, highlight, disabled, onClick) {
  return {
    label,
    value,
    confirm,
    color,
    highlight,
    disabled,
    onClick,
  };
}
