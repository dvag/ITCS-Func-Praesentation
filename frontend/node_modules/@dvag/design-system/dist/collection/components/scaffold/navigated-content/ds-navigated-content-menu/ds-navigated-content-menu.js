import { h, Host, } from "@stencil/core";
import { createMetaComponentsSlotObserver, } from "../../../../classes/slot-observer";
import { ElementIdGenerator, verifyElementId, } from "../../../../classes/element-id-handling";
import { onNextFrame } from "../../../../classes/render-util";
import { HeaderService, subscribeToContentHeightBelowHeader, subscribeToHeaderHeight, } from "../../ds-header/header-service";
import { notHidden } from "../../../../classes/query-util";
/**
 * @name Site navigation base menu
 * @shortname Menu
 * @path /Scaffold/Site navigation
 * @slot bottom - Additional content under the menu within the menu-card.
 * @icon bars
 * @stable
 */
export class DsNavigatedContentMenu {
  constructor() {
    this.knobs = [];
    this.menuItems = [];
    this.headerHeight = 0;
    this.contentBelowHeaderHeight = 0;
    this.childrenBoxHeights = [];
  }
  connectedCallback() {
    this.registerMenuItemObserver();
    this.headerHeightSubscription = subscribeToHeaderHeight((height) => (this.headerHeight = height));
    this.contentHeightBelowHeaderSubscription =
      subscribeToContentHeightBelowHeader((height) => (this.contentBelowHeaderHeight = height));
    const headerService = HeaderService.instance();
    this.headerHeight = headerService.headerHeight;
    this.contentBelowHeaderHeight = headerService.contentHeightBelowHeader;
    this.resizeObserver = new ResizeObserver(() => {
      this.updateKnobPositions();
      this.measureChildrenBoxes();
    });
  }
  disconnectedCallback() {
    var _a, _b, _c, _d;
    (_a = this.menuItemObserver) === null || _a === void 0 ? void 0 : _a.disconnect();
    (_b = this.headerHeightSubscription) === null || _b === void 0 ? void 0 : _b.unsubscribe();
    (_c = this.contentHeightBelowHeaderSubscription) === null || _c === void 0 ? void 0 : _c.unsubscribe();
    (_d = this.resizeObserver) === null || _d === void 0 ? void 0 : _d.disconnect();
  }
  componentWillLoad() {
    verifyElementId(this.self);
  }
  updateKnobPositions() {
    var _a, _b;
    const knob = this.knobs.find((knob) => this.active.startsWith(knob.parentValue));
    if (knob == null) {
      return;
    }
    const isChildSelected = this.active.length > knob.parentValue.length + "/".length;
    const selectedChild = isChildSelected
      ? this.active.split("/")[1]
      : (_b = (_a = this.menuItems.find((item) => item.value === knob.parentValue)) === null || _a === void 0 ? void 0 : _a.children[0]) === null || _b === void 0 ? void 0 : _b.value;
    const childMenuItem = this.self.shadowRoot.querySelector(`.measurement-box .menu-item[data-path='${knob.parentValue}/${selectedChild}']`);
    if (childMenuItem == null) {
      return;
    }
    const childMenuItemBounds = childMenuItem.getBoundingClientRect();
    const childrenContainerBounds = childMenuItem.parentElement.getBoundingClientRect();
    const knobOffsetY = childMenuItemBounds.y - childrenContainerBounds.y;
    knob.element.style.transform = `translateY(${knobOffsetY}px)`;
    knob.element.style.height = `${childMenuItemBounds.height}px`;
  }
  registerMenuItemObserver() {
    this.menuItemObserver =
      createMetaComponentsSlotObserver(this.self, ":scope > ds-navigated-content-menu-item.hydrated", async (nodes) => {
        // The current implementation only support 2 levels of hierarchy
        this.menuItems = await Promise.all(nodes
          .map(async (node) => {
          return Object.assign(Object.assign({}, (await node.toMenuItemModel())), { children: await Promise.all(Array.from(node.querySelectorAll(notHidden("ds-navigated-content-menu-item"))).map((child) => child.toMenuItemModel())) });
        })
          .filter((model) => model != null));
      });
  }
  measureChildrenBoxes() {
    const childrenBoxHeights = Array.from(this.self.shadowRoot.querySelectorAll(".measurement-box")).map((element) => {
      return {
        value: element.getAttribute("data-measurementbox"),
        height: element.offsetHeight,
      };
    });
    if (diffChildHeights(childrenBoxHeights, this.childrenBoxHeights)) {
      onNextFrame(() => (this.childrenBoxHeights = childrenBoxHeights));
    }
  }
  pathForItem(item) {
    const rootItem = this.menuItems.find((someItem) => { var _a; return someItem === item || ((_a = someItem.children) === null || _a === void 0 ? void 0 : _a.includes(item)); });
    if (rootItem === item) {
      return rootItem.value;
    }
    else {
      const subItem = rootItem.children.find((subItem) => subItem === item);
      return `${rootItem.value}/${subItem.value}`;
    }
  }
  registerKnob(parentValue, element) {
    this.knobs = this.knobs.filter((knob) => knob.parentValue !== parentValue);
    this.knobs.push({ parentValue, element });
  }
  navigateToItem(item) {
    const path = this.pathForItem(item);
    this.navigate.emit({
      path,
      segments: path.split("/"),
    });
  }
  render() {
    return (h(Host, { style: {
        top: `${this.headerHeight +
          this.contentBelowHeaderHeight +
          MARGIN_TO_HEADER_PX}px`,
      } }, h("ds-card", null, h("ds-card-content", null, this.menuItems.map((item) => this.renderMenuItem(item)), h("slot", { name: "bottom" })))));
  }
  renderMenuItem(item) {
    var _a;
    const path = this.pathForItem(item);
    const isActive = this.active.startsWith(path);
    const hasChildren = ((_a = item.children) === null || _a === void 0 ? void 0 : _a.length) > 0;
    return (h("div", { class: {
        "menu-item": true,
        active: isActive,
        "has-children": hasChildren,
        "level-1": true,
      } }, h("div", { class: "menu-item-label" }, h("div", { class: "main" }, h("button", { type: "button", class: "navigate-button", id: ElementIdGenerator.createId(this.self, path), onClick: () => this.navigateToItem(item) }, h("ds-text", null, item.label), h("ds-icon", { icon: "drop-down", size: 16, class: {
        visible: hasChildren && !isActive,
        flip: isActive,
      } }))), this.renderStatusIcons(item)), this.renderItemChildren(item.children, item.value, isActive)));
  }
  renderItemChildren(children, parentValue, isExpanded) {
    if (!((children === null || children === void 0 ? void 0 : children.length) > 0)) {
      return null;
    }
    const heightInfo = this.childrenBoxHeights.find((item) => item.value === parentValue);
    return [
      this.renderItemChildrenMeasurementBox(children, parentValue),
      h("div", { class: {
          children: true,
          visible: isExpanded,
        }, style: {
          "max-height": heightInfo != null ? `${heightInfo.height}px` : "auto",
        } }, h("div", { class: "slider" }, h("div", { class: "line" }), h("div", { class: "knob", ref: (el) => this.registerKnob(parentValue, el) })), h("div", { class: "items" }, children.map((item) => this.renderChild(item, isExpanded)))),
    ];
  }
  renderItemChildrenMeasurementBox(children, parentValue) {
    return (h("div", { class: "measurement-box", "data-measurementbox": parentValue, ref: (ref) => {
        this.resizeObserver.disconnect();
        if (ref != null) {
          this.resizeObserver.observe(ref);
        }
      } }, h("div", { class: "items" }, children.map((item) => this.renderChild(item, false)))));
  }
  renderChild(item, isInteractive) {
    const path = this.pathForItem(item);
    return (h("div", { class: {
        "menu-item": true,
        "level-2": true,
      }, "data-path": path }, h("div", { class: "menu-item-label" }, h("div", { class: "main" }, h("button", { type: "button", class: "navigate-button", tabIndex: isInteractive ? 0 : -1, id: ElementIdGenerator.createId(this.self, path), onClick: () => {
        if (isInteractive) {
          this.navigateToItem(item);
        }
      } }, h("ds-text", null, item.label))), this.renderStatusIcons(item))));
  }
  renderStatusIcons(item) {
    const isError = item.error;
    const isWarning = !isError && item.warning;
    const isSuccess = !isError && !isWarning && item.success;
    return (h("div", { class: "status" }, isWarning ? (h("ds-icon", { icon: "achtung-circle", color: "gelb-1", size: 16 })) : null, isError ? (h("ds-icon", { icon: "achtung", color: "rot-1", size: 16 })) : null, isSuccess ? (h("ds-icon", { icon: "success", color: "gruen-1", size: 16 })) : null));
  }
  static get is() { return "ds-navigated-content-menu"; }
  static get encapsulation() { return "shadow"; }
  static get originalStyleUrls() {
    return {
      "$": ["ds-navigated-content-menu.scss"]
    };
  }
  static get styleUrls() {
    return {
      "$": ["ds-navigated-content-menu.css"]
    };
  }
  static get properties() {
    return {
      "active": {
        "type": "string",
        "mutable": false,
        "complexType": {
          "original": "string",
          "resolved": "string",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "string: Path e.g. `\"Toplevel\"` or `\"Toplevel/sublevel\"`"
            }],
          "text": "Description of the path of active menus."
        },
        "attribute": "active",
        "reflect": false
      }
    };
  }
  static get states() {
    return {
      "menuItems": {},
      "headerHeight": {},
      "contentBelowHeaderHeight": {},
      "childrenBoxHeights": {}
    };
  }
  static get events() {
    return [{
        "method": "navigate",
        "name": "navigate",
        "bubbles": true,
        "cancelable": true,
        "composed": true,
        "docs": {
          "tags": [],
          "text": "Is triggered if an user interacts with the menu entries.\nThe event detail contains following data structure: `{path: 'toplevel/sublevel', segments: ['toplevel', 'sublevel']}`"
        },
        "complexType": {
          "original": "NavigatedRoute",
          "resolved": "NavigatedRoute",
          "references": {
            "NavigatedRoute": {
              "location": "local"
            }
          }
        }
      }];
  }
  static get elementRef() { return "self"; }
}
const MARGIN_TO_HEADER_PX = 24;
function diffChildHeights(a, b) {
  if (a.length !== b.length) {
    return true;
  }
  const heightSumA = a.reduceRight((prev, curr) => prev + curr.height, 0);
  const heightSumB = b.reduceRight((prev, curr) => prev + curr.height, 0);
  if (heightSumA !== heightSumB) {
    return true;
  }
  return false;
}
