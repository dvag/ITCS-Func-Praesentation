import { h, Host, } from "@stencil/core";
import { createMetaComponentsSlotObserver, } from "../../../classes/slot-observer";
import { getPointOnCircle, PI } from "../../../classes/math-util";
/**
 * This component visualizes data array in the form of a donut chart.
 * It consists of multiple segments which each represents a data input.
 *
 * @name Donut-Chart
 * @shortname Donut
 * @path /Visualization
 * @icon chart-pie
 * @stable
 *
 * @slot content - `<ds-chart-sample>` elements which are translated to donut segments.
 * @slot-example content
 */
export class DsDonutChart {
  constructor() {
    this.mouseMoveHandler = (mouseEvent) => {
      this.handleMouseMove(mouseEvent);
    };
    this.chartInput = [];
    this.selected = null;
    /**
     * The radius of the donut.
     *
     * @value Number:
     */
    this.radius = 50;
    /**
     * Specifies the width of the donut's segments.
     *
     * @value number: The width of a segment.
     */
    this.segmentwidth = 10;
    /**
     * The distance between all segments.
     *
     * @value number: The distance in pixels.
     */
    this.offset = 5;
    /**
     * Specifies the scale factor of selected segments.
     *
     * @value number: The scaling factor of the selected segment.
     */
    this.scale = 1.5;
    /**
     * The starting angle of the first segment.
     *
     * @value number: An angle between 0 and 360.
     * e.g.:
     * First segment starts...
     * - 0: from the top (12 o'clock)
     * - 90: from the right (3 o'clock)
     * - 180: from the bottom (6 o'clock)
     * - 270: from the left (9 o'clock)
     */
    this.startangle = 0;
  }
  connectedCallback() {
    this.slotObserver =
      createMetaComponentsSlotObserver(this.self, "ds-chart-sample", (nodes) => this.collectSamplesFromChildren(nodes));
  }
  disconnectedCallback() {
    var _a;
    (_a = this.slotObserver) === null || _a === void 0 ? void 0 : _a.disconnect();
  }
  async collectSamplesFromChildren(nodes) {
    this.chartInput = await Promise.all(nodes.map((node) => node.toChartSample()));
  }
  getHitAngle(mouseX, mouseY) {
    const elementPosition = this.self.getBoundingClientRect();
    const relativeOrigin = this.circleOrigin;
    const clientOrigin = {
      x: relativeOrigin.x + elementPosition.x,
      y: relativeOrigin.y + elementPosition.y,
    };
    const mousePosition = { x: mouseX, y: mouseY };
    const direction = {
      x: mousePosition.x - clientOrigin.x,
      y: mousePosition.y - clientOrigin.y,
    };
    const lengthSquared = direction.x * direction.x + direction.y * direction.y;
    const scaledRadiusOuter = this.getScaledOuterRadius();
    const scaledRadiusInner = scaledRadiusOuter - this.segmentwidth * this.scale * 2;
    const minRadiusSquared = scaledRadiusInner * scaledRadiusInner;
    const maxRadiusSquared = scaledRadiusOuter * scaledRadiusOuter;
    // Check if the mouse is between the segments
    if (lengthSquared >= minRadiusSquared &&
      lengthSquared <= maxRadiusSquared) {
      let angle = (Math.acos(direction.x /
        Math.sqrt(direction.x * direction.x + direction.y * direction.y)) *
        180) /
        PI;
      if (mousePosition.y < clientOrigin.y) {
        angle = 360 - angle;
      }
      const angleOffset = this.startangle - 90;
      return (angle - angleOffset + 360) % 360;
    }
    return null;
  }
  handleMouseMove(e) {
    const angle = this.getHitAngle(e.clientX, e.clientY);
    if (angle != null) {
      this.selectSegmentByAngle(angle);
    }
    else {
      this.selectSegment(null);
    }
  }
  selectSegmentByAngle(angle) {
    const max = this.chartInput
      .map((input) => input.value)
      .reduce((previous, current) => previous + current, 0);
    let count = 0;
    const index = this.chartInput.findIndex((sample) => {
      const from = count;
      count += sample.value;
      const to = count;
      const fromAngle = (from / max) * 360;
      const toAngle = (to / max) * 360;
      return angle >= fromAngle && angle <= toAngle;
    });
    if (index !== -1) {
      this.selectSegment(index);
      return true;
    }
    return false;
  }
  selectSegment(index) {
    if (this.selected !== index) {
      this.selected = index;
      this.segmentSelect.emit(index);
    }
  }
  addWindowHandler() {
    window.addEventListener("mousemove", this.mouseMoveHandler);
  }
  removeWindowHandler() {
    window.removeEventListener("mousemove", this.mouseMoveHandler);
  }
  getCircleSegmentPoints(circleOrigin, radius, percentage, offset, width) {
    const points = [];
    const angleOffset = -90 + this.startangle;
    const fromAngle = offset * 3.6 + angleOffset;
    const toAngle = (offset + percentage) * 3.6 + angleOffset;
    const radiusOuter = radius + width * 0.5;
    const radiusInner = radiusOuter - width;
    let last = 0;
    for (let angle = fromAngle; angle < toAngle; angle += 5) {
      if (angle > toAngle) {
        angle = toAngle;
      }
      const circlePoint = getPointOnCircle(radiusOuter, angle);
      points.push(circlePoint);
      last = angle;
    }
    if (toAngle - last > 0) {
      const circlePoint = getPointOnCircle(radiusOuter, toAngle);
      points.push(circlePoint);
    }
    for (let i = points.length - 1; i >= 0; --i) {
      const widthDirection = {
        x: radiusInner * (points[i].x / radiusOuter),
        y: radiusInner * (points[i].y / radiusOuter),
      };
      points.push(widthDirection);
    }
    return points
      .map((point) => {
      point.x += circleOrigin.x;
      point.y += circleOrigin.y;
      return point.x + "," + point.y;
    })
      .join(" ");
  }
  generateDonutCreateData() {
    return this.chartInput.reduce((acc, input, i) => {
      const offset = i == 0
        ? 0
        : acc.segments[i - 1].offset + acc.segments[i - 1].input.value;
      return {
        segments: [
          ...acc.segments,
          {
            input,
            offset,
          },
        ],
        sum: acc.sum + input.value,
      };
    }, {
      segments: [],
      sum: 0,
    });
  }
  get maxSize() {
    return this.getScaledOuterRadius() * 2;
  }
  get circleOrigin() {
    return {
      x: this.maxSize * 0.5,
      y: this.maxSize * 0.5,
    };
  }
  getScaledOuterRadius() {
    const addedSegmentWidth = this.segmentwidth * this.scale;
    return this.radius + addedSegmentWidth * 0.5;
  }
  render() {
    if (this.chartInput == null)
      return (h(Host, null, h("slot", { name: "content" })));
    const halfSize = this.maxSize * 0.5;
    const minSize = (this.getScaledOuterRadius() - this.segmentwidth * this.scale) * 2;
    return (h(Host, { onMouseEnter: () => {
        this.addWindowHandler();
      }, onMouseLeave: () => {
        this.removeWindowHandler();
        this.selectSegment(null);
      } }, this.renderDonutChart(), h("div", { class: "center", style: {
        top: halfSize + "px",
        left: halfSize + "px",
        width: minSize + "px",
        height: minSize + "px",
      } }, h("slot", { name: "content" })), h("slot", null)));
  }
  renderDonutChart() {
    const createData = this.generateDonutCreateData();
    const svgSize = this.maxSize + "px";
    return (h("svg", { style: { width: svgSize, height: svgSize } }, this.renderSegments(createData)));
  }
  renderSegment(circleOrigin, radius, percentage, offset, width, color, strokeWidth) {
    if (percentage <= 0) {
      return;
    }
    return (h("polygon", { class: "segment", points: this.getCircleSegmentPoints(circleOrigin, radius, percentage, offset, width), style: {
        fill: color,
        stroke: "white",
        strokeWidth: strokeWidth,
      } }));
  }
  renderSegments(createData) {
    if (createData.sum === 0) {
      return null;
    }
    const circleOrigin = this.circleOrigin;
    const segments = createData.segments
      .map((segmentInfo, index) => {
      if (index != this.selected) {
        const percentage = (100 * segmentInfo.input.value) / createData.sum;
        const offsetPercentage = (100 * segmentInfo.offset) / createData.sum;
        return this.renderSegment(circleOrigin, this.radius, percentage, offsetPercentage, this.segmentwidth + this.offset, segmentInfo.input.color, `${this.offset}`);
      }
      return undefined;
    })
      .filter((item) => item !== undefined);
    // Always draw the selected segement last (z-index doesn't work for svgs)
    if (this.selected != null) {
      const segmentInfo = createData.segments[this.selected];
      const percentage = (100 * segmentInfo.input.value) / createData.sum;
      const offsetPercentage = (100 * segmentInfo.offset) / createData.sum;
      const scaledSegmentWidth = this.segmentwidth * this.scale + this.offset;
      segments.push(this.renderSegment(circleOrigin, this.radius, percentage, offsetPercentage, scaledSegmentWidth, segmentInfo.input.color, `${this.offset}`));
    }
    return segments;
  }
  static get is() { return "ds-donut-chart"; }
  static get encapsulation() { return "shadow"; }
  static get originalStyleUrls() {
    return {
      "$": ["ds-donut-chart.scss"]
    };
  }
  static get styleUrls() {
    return {
      "$": ["ds-donut-chart.css"]
    };
  }
  static get properties() {
    return {
      "radius": {
        "type": "number",
        "mutable": false,
        "complexType": {
          "original": "number",
          "resolved": "number",
          "references": {}
        },
        "required": false,
        "optional": true,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "Number:"
            }],
          "text": "The radius of the donut."
        },
        "attribute": "radius",
        "reflect": false,
        "defaultValue": "50"
      },
      "segmentwidth": {
        "type": "number",
        "mutable": false,
        "complexType": {
          "original": "number",
          "resolved": "number",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "number: The width of a segment."
            }],
          "text": "Specifies the width of the donut's segments."
        },
        "attribute": "segmentwidth",
        "reflect": false,
        "defaultValue": "10"
      },
      "offset": {
        "type": "number",
        "mutable": false,
        "complexType": {
          "original": "number",
          "resolved": "number",
          "references": {}
        },
        "required": false,
        "optional": true,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "number: The distance in pixels."
            }],
          "text": "The distance between all segments."
        },
        "attribute": "offset",
        "reflect": false,
        "defaultValue": "5"
      },
      "scale": {
        "type": "number",
        "mutable": false,
        "complexType": {
          "original": "number",
          "resolved": "number",
          "references": {}
        },
        "required": false,
        "optional": true,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "number: The scaling factor of the selected segment."
            }],
          "text": "Specifies the scale factor of selected segments."
        },
        "attribute": "scale",
        "reflect": false,
        "defaultValue": "1.5"
      },
      "startangle": {
        "type": "number",
        "mutable": false,
        "complexType": {
          "original": "number",
          "resolved": "number",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "number: An angle between 0 and 360.\ne.g.:\nFirst segment starts...\n- 0: from the top (12 o'clock)\n- 90: from the right (3 o'clock)\n- 180: from the bottom (6 o'clock)\n- 270: from the left (9 o'clock)"
            }],
          "text": "The starting angle of the first segment."
        },
        "attribute": "startangle",
        "reflect": false,
        "defaultValue": "0"
      }
    };
  }
  static get states() {
    return {
      "chartInput": {},
      "selected": {}
    };
  }
  static get events() {
    return [{
        "method": "segmentSelect",
        "name": "segmentSelect",
        "bubbles": true,
        "cancelable": true,
        "composed": true,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "number: The index of the selected segment."
            }],
          "text": "Triggers when a segment is clicked. It delegates the index of the selected segment."
        },
        "complexType": {
          "original": "number",
          "resolved": "number",
          "references": {}
        }
      }];
  }
  static get elementRef() { return "self"; }
}
