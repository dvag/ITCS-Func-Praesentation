import { h, Host, } from "@stencil/core";
import { SlotObserver } from "../../../classes/slot-observer";
import { onNextFrame } from "../../../classes/render-util";
/**
 * Layouts primary and secondary button components (`<ds-button>`) in a row
 * or column. It resizes all buttons to match the width of the largest button.
 *
 * @name Button Bar
 * @shortname Bar
 * @path /Buttons/Button
 * @slot - A set of button components that get layouted.
 */
export class DsButtonBar {
  constructor() {
    this.nodes = [];
    /**
     * Specifies the direction in which the buttons get arranged.
     *
     * @value row: Buttons get layouted from left to right.
     * @value column: Buttons get layouted from top to bottom.
     * @value auto: Button get layouted automatically.
     * @example column
     * @example row
     */
    this.direction = "row";
  }
  onDirectionChange() {
    if (this.direction !== "auto") {
      this.internalDirection = this.direction;
    }
  }
  onResize() {
    this.calculateDirection();
  }
  connectedCallback() {
    this.slotObserver = new SlotObserver(this.self, ":scope > *", (nodes) => {
      onNextFrame(() => {
        onNextFrame(() => {
          applyStyleWidth(nodes, maxWidth(nodes));
          configureDsButtonElementsForStretchedBehavior(nodes);
          this.nodes = nodes;
        });
      });
    });
  }
  componentWillLoad() {
    this.internalDirection =
      this.direction !== "auto" ? this.direction : "column";
  }
  componentDidLoad() {
    this.calculateDirection();
  }
  disconnectedCallback() {
    var _a;
    (_a = this.slotObserver) === null || _a === void 0 ? void 0 : _a.disconnect();
  }
  calculateDirection() {
    if (this.direction === "auto") {
      requestAnimationFrame(() => {
        if (this.checkOverflow()) {
          this.internalDirection = "column";
        }
        else {
          const nodesWidthTotal = this.nodes.reduceRight((prev, curr) => prev + curr.offsetWidth, 0);
          // test if nodes could be displayed in row-direction. This should prevent flickering
          if (nodesWidthTotal <= this.self.getBoundingClientRect().width) {
            this.internalDirection = "row";
          }
        }
      });
    }
  }
  checkOverflow() {
    const curOverflow = this.self.style.overflow;
    if (!curOverflow || curOverflow === "visible") {
      const isOverflowing = this.self.clientWidth < this.self.scrollWidth ||
        this.self.clientHeight < this.self.scrollHeight;
      this.self.style.overflow = curOverflow;
      return isOverflowing;
    }
  }
  render() {
    return (h(Host, { class: {
        "direction-row": this.internalDirection === "row",
        "direction-column": this.internalDirection === "column",
      } }, h("slot", null)));
  }
  static get is() { return "ds-button-bar"; }
  static get encapsulation() { return "shadow"; }
  static get originalStyleUrls() {
    return {
      "$": ["ds-button-bar.scss"]
    };
  }
  static get styleUrls() {
    return {
      "$": ["ds-button-bar.css"]
    };
  }
  static get properties() {
    return {
      "direction": {
        "type": "string",
        "mutable": true,
        "complexType": {
          "original": "\"row\" | \"column\" | \"auto\"",
          "resolved": "\"auto\" | \"column\" | \"row\"",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "row: Buttons get layouted from left to right."
            }, {
              "name": "value",
              "text": "column: Buttons get layouted from top to bottom."
            }, {
              "name": "value",
              "text": "auto: Button get layouted automatically."
            }, {
              "name": "example",
              "text": "column"
            }, {
              "name": "example",
              "text": "row"
            }],
          "text": "Specifies the direction in which the buttons get arranged."
        },
        "attribute": "direction",
        "reflect": false,
        "defaultValue": "\"row\""
      }
    };
  }
  static get states() {
    return {
      "internalDirection": {}
    };
  }
  static get elementRef() { return "self"; }
  static get watchers() {
    return [{
        "propName": "direction",
        "methodName": "onDirectionChange"
      }];
  }
  static get listeners() {
    return [{
        "name": "resize",
        "method": "onResize",
        "target": "window",
        "capture": false,
        "passive": true
      }];
  }
}
function applyStyleWidth(nodes, width) {
  nodes.forEach((el) => (el.style.width = `${width}px`));
}
function configureDsButtonElementsForStretchedBehavior(nodes) {
  nodes
    .filter((el) => el.tagName.toLowerCase() === "ds-button")
    .forEach((el) => (el.stretch = true));
}
function maxWidth(nodes) {
  return nodes.reduce((curr, next) => Math.max(curr, next.offsetWidth), 0);
}
