import { forceUpdate, h, Host, } from "@stencil/core";
import { BreakpointAware } from "../../../classes/breakpoint-aware";
import { assertPropertyValue } from "../../../classes/assert";
import { ElementIdGenerator, verifyElementId, } from "../../../classes/element-id-handling";
import { SlotObserver } from "../../../classes/slot-observer";
/**
 * Button used for a subtile call to action.
 *
 * @path /Buttons
 * @name Text-Button
 * @shortname Text
 * @icon external-link-alt
 * @stable
 *
 * @slot - Content of the button, that can be a combination `<ds-text>` und `<ds-icon>`. The `size` attribute of a `<ds-icon>` is set automatically.
 * @slot-example labeling
 */
export class DsTextButton {
  constructor() {
    /**
     * Specifies the responsiveness strategy.
     * @value auto: Text size is automatically determined by evaluating the device screen size.
     * @value small: Use text size for small device screens.
     * @value large: Use text size for large device screens.
     * @example screensize
     */
    this.screensize = "auto";
    /**
     * Sets the color of the button.
     * @value gold: Gold color (default value)
     * @value rot: Special case for destructive actions
     * @example color
     */
    this.color = "gold";
    /**
     * Disables user interaction on the button.
     * @value false: User can interaction with the button.
     * @value true: User can not interaction with the button.
     * @example disabled
     */
    this.disabled = false;
    /**
     * Disables the ability to focus the button via tabulator navigation.
     * @value false: Button is reachable via tab navigation.
     * @value true: Button is ignored when using tab navigation.
     */
    this.unfocusable = false;
  }
  screensizeChanged() {
    var _a;
    (_a = this.self
      .querySelectorAll("ds-text")) === null || _a === void 0 ? void 0 : _a.forEach((node) => {
      node.screensize = this.screensize;
    });
  }
  connectedCallback() {
    this.breakpointAware = new BreakpointAware(() => forceUpdate(this));
  }
  disconnectedCallback() {
    var _a, _b;
    (_a = this.breakpointAware) === null || _a === void 0 ? void 0 : _a.disconnect();
    (_b = this.slotObserver) === null || _b === void 0 ? void 0 : _b.disconnect();
  }
  componentWillLoad() {
    verifyElementId(this.self);
    this.slotObserver = new SlotObserver(this.self, "ds-text", (nodes) => {
      nodes.forEach((node) => {
        node.screensize = this.screensize;
      });
    });
  }
  /**
   * Focuses this element.
   */
  async focusControl() {
    this.buttonElement.focus();
  }
  render() {
    assertPropertyValue("ds-text-button", "screensize", this.screensize, [
      "auto",
      "small",
      "large",
    ]);
    assertPropertyValue("ds-text-button", "color", this.color, ["gold", "rot"]);
    return (h(Host, { class: {
        "screensize-small": this.screensize === "small" ||
          (this.screensize === "auto" && !this.breakpointAware.xl),
        "screensize-large": this.screensize === "large" ||
          (this.screensize === "auto" && this.breakpointAware.xl),
        "color-gold": this.color === "gold",
        "color-rot": this.color === "rot",
        disabled: this.disabled,
        unfocusable: this.unfocusable,
      } }, h("button", { type: "button", ref: (el) => (this.buttonElement = el), id: ElementIdGenerator.createId(this.self, "control"), disabled: this.disabled, tabIndex: this.unfocusable ? -1 : 0 }, h("slot", null))));
  }
  static get is() { return "ds-text-button"; }
  static get encapsulation() { return "shadow"; }
  static get originalStyleUrls() {
    return {
      "$": ["ds-text-button.scss"]
    };
  }
  static get styleUrls() {
    return {
      "$": ["ds-text-button.css"]
    };
  }
  static get properties() {
    return {
      "screensize": {
        "type": "string",
        "mutable": false,
        "complexType": {
          "original": "\"small\" | \"large\" | \"auto\"",
          "resolved": "\"auto\" | \"large\" | \"small\"",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "auto: Text size is automatically determined by evaluating the device screen size."
            }, {
              "name": "value",
              "text": "small: Use text size for small device screens."
            }, {
              "name": "value",
              "text": "large: Use text size for large device screens."
            }, {
              "name": "example",
              "text": "screensize"
            }],
          "text": "Specifies the responsiveness strategy."
        },
        "attribute": "screensize",
        "reflect": false,
        "defaultValue": "\"auto\""
      },
      "color": {
        "type": "string",
        "mutable": false,
        "complexType": {
          "original": "\"gold\" | \"rot\"",
          "resolved": "\"gold\" | \"rot\"",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "gold: Gold color (default value)"
            }, {
              "name": "value",
              "text": "rot: Special case for destructive actions"
            }, {
              "name": "example",
              "text": "color"
            }],
          "text": "Sets the color of the button."
        },
        "attribute": "color",
        "reflect": false,
        "defaultValue": "\"gold\""
      },
      "disabled": {
        "type": "boolean",
        "mutable": false,
        "complexType": {
          "original": "boolean",
          "resolved": "boolean",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "false: User can interaction with the button."
            }, {
              "name": "value",
              "text": "true: User can not interaction with the button."
            }, {
              "name": "example",
              "text": "disabled"
            }],
          "text": "Disables user interaction on the button."
        },
        "attribute": "disabled",
        "reflect": false,
        "defaultValue": "false"
      },
      "unfocusable": {
        "type": "boolean",
        "mutable": false,
        "complexType": {
          "original": "boolean",
          "resolved": "boolean",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "false: Button is reachable via tab navigation."
            }, {
              "name": "value",
              "text": "true: Button is ignored when using tab navigation."
            }],
          "text": "Disables the ability to focus the button via tabulator navigation."
        },
        "attribute": "unfocusable",
        "reflect": false,
        "defaultValue": "false"
      }
    };
  }
  static get methods() {
    return {
      "focusControl": {
        "complexType": {
          "signature": "() => Promise<void>",
          "parameters": [],
          "references": {
            "Promise": {
              "location": "global"
            }
          },
          "return": "Promise<void>"
        },
        "docs": {
          "text": "Focuses this element.",
          "tags": []
        }
      }
    };
  }
  static get elementRef() { return "self"; }
  static get watchers() {
    return [{
        "propName": "screensize",
        "methodName": "screensizeChanged"
      }];
  }
}
