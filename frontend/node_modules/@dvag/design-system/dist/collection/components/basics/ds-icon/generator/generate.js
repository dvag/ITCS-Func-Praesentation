// eslint-disable-next-line @typescript-eslint/no-var-requires
const fs = require("fs-extra");

function main() {
  const entries = scanForSVGs();

  generateComponents(entries);
  generateExamples(entries);
}

function removeAllIconTests() {
  const path = `${__dirname}/../usage`;
  fs.readdirSync(path).forEach((file) => {
    if (file.startsWith("internal-icon-")) {
      fs.removeSync(`${path}/${file}`);
    }
  });
}

function generateExamples(entries) {
  removeAllIconTests();

  let htmlCode = "<p>This example list all icon in dark color.</p>";
  entries.forEach((icon) => {
    const iconRowHtml = `<div style="display: flex; background: #fafafa; flex-wrap: wrap; border-bottom: 1px solid #ddd; padding-top: 10px"><div style="min-width: 300px; font-family: monospace"><ds-text>${
      icon.name
    }</ds-text></div>${icon.svgs
      .map(
        (svg) =>
          `\n<ds-icon icon="${icon.name}" size="${svg.size}" color="anthrazit" title="Größe: ${svg.size}" style="margin-left: 25px; margin-bottom: 10px; width: ${svg.size}px; height: ${svg.size}px"></ds-icon>`
      )
      .join("")}</div>`;

    const iconMd = `\`\`\`html
${iconRowHtml}
\`\`\``;

    fs.writeFileSync(
      `${__dirname}/../usage/internal-icon-${icon.name}.md`,
      iconMd,
      "utf-8"
    );
    htmlCode += `\n${iconRowHtml}`;
  });

  const alleIconsMd = `\`\`\`test
ignore
\`\`\`
\`\`\`preview-only-html
${htmlCode}
\`\`\``;

  fs.writeFileSync(__dirname + "/../usage/alle-icons.md", alleIconsMd, "utf-8");
}

function generateComponents(entries) {
  const destinationPath = __dirname + "/../components/";

  fs.removeSync(destinationPath);
  fs.mkdirsSync(destinationPath);

  entries.forEach((entry) => {
    const name = entry.name.replace(/-/g, "");
    const tagName = `ds-icon-${name}`;
    const className = `DsIcon${name
      .substring(0, 1)
      .toUpperCase()}${name.substring(1)}`;
    let tsx = `import {Component, h, Prop} from '@stencil/core';

/**
 * @internal
 */
@Component({
  tag: '${tagName}',
  scoped: true,
})
export class ${className} {

  /**
   * Size
   */
  @Prop() size: number;

  render(): any {
`;
    entry.svgs.forEach((svg) => {
      tsx += `
      if (this.size === ${svg.size}) {
        return (${escapeCharactersForTsx(svg.svg)});
      }
`;
    });
    tsx += `
  }
}
`;
    console.log(`Create Icon: ${destinationPath}/${tagName}`);
    fs.writeFileSync(`${destinationPath}/${tagName}.tsx`, tsx, "utf-8");
  });
}

function escapeCharactersForTsx(svg) {
  svg = svg.replace(/xlink:href/gi, "xlinkHref");

  return svg;
}

function scanForSVGs() {
  const entries = [];

  const baseDir = "source";
  for (const directory of fs.readdirSync(baseDir)) {
    if (directory.startsWith(".")) {
      continue;
    }

    const path = `${baseDir}/${directory}`;

    const svgs = [];
    for (const file of fs.readdirSync(path)) {
      if (file.startsWith(".")) {
        continue;
      }

      if (file.toLowerCase().endsWith(".svg")) {
        let size = null;

        // try parse '16px_some_name.svg'
        if (file.includes("px")) {
          size = parseInt(file);
        }

        if (size === null || isNaN(size)) {
          // try parse 'somename.targetsize-16.svg'
          const withoutSvgSuffixSplitted = file
            .substr(0, file.length - 4)
            .split("-");
          size = parseInt(
            withoutSvgSuffixSplitted[withoutSvgSuffixSplitted.length - 1]
          );
        }

        if (size === null || isNaN(size)) {
          throw Error("Error parsing pixel size from image path.");
        }

        const svgFilePath = `${path}/${file}`;

        const svg = cleanSvg(fs.readFileSync(svgFilePath, "utf-8"));

        svgs.push({ size, svg });
        console.log(`${file} => ${directory} ${size}`);
      }
    }

    if (svgs.length > 0) {
      entries.push({ name: directory.toLocaleLowerCase(), svgs });
    }
  }

  entries.sort((a, b) => a.name.localeCompare(b.name));

  return entries;
}

function cleanSvg(svg) {
  svg = svg.replace(/\n/gi, "");
  svg = svg.replace(/<\?xml.*?\?>/gi, "");
  svg = svg.replace(/<title>.*?<\/title>/gi, "");
  svg = svg.replace(/ id=".*?"/gi, "");
  svg = svg.replace(/ xmlns.*?=".*?"/gi, "");
  svg = svg.replace(/<!--.*-->/gs, "");
  svg = svg.replace(/style=".*;"/gi, "");
  svg = svg.replace(/xml:space="preserve"/gi, "");

  while (svg.includes("  ")) {
    svg = svg.replace(/\s\s/gi, " ");
  }

  svg = svg.replace(/>\s</gi, "><");

  svg = svg.replace(
    '<rect fill="#FFFFFF" x="0" y="0" width="1440" height="1440"></rect>',
    ""
  );

  if (svg.includes("{")) {
    // escape curly brackets for TSX
    svg = svg.replace(/{(.*?)}/gi, "{'{$1}'}");
  }

  // no hardcoded gold tinting
  svg = svg.replace(
    ' fill="#A7893D"',
    " style={{'fill': 'var(--ds-icon-color,#A7893D)'}}"
  );
  svg = svg.replace(
    ' stroke="#A7893D"',
    " style={{'stroke': 'var(--ds-icon-color,#A7893D)'}}"
  );
  svg = svg.replace("fill:#a7893d;", "fill:var(--ds-icon-color,#A7893D);");

  return svg;
}

main();
