import { h, Host, } from "@stencil/core";
import { GridSyntaxParser } from "./grid-syntax-parser";
import { assert } from "../../../classes/assert";
import { GridValidator } from "./grid-validator";
import { PAGE_GRID } from "./grid-base";
import { GridBreakpoint, ordinalOfGridBreakpoint, } from "./grid-models";
import { GridCssBuilder } from "./grid-css-builder";
import { BreakpointAware } from "../../../classes/breakpoint-aware";
import { SlotObserver } from "../../../classes/slot-observer";
/**
 * Responsive Layout-Element zur Anordnung mehrerer Elemente einem Grid-System.
 *
 * Es werden mehrere Grid-Systeme unterstützt, die mittels der `base` Property bestimmt werden.
 *
 * Es gibt vier Breakpoints (S für Smartphone, M für Tablets, L für Laptops, XL für Desktops), um responsives
 * Verhalten zu modellieren. Für jeden Breakpoint gibt eine Property, die mit einem Grid-Syntax definiert werden kann.
 *
 * ## Grid-Syntax
 * Der Syntax besteht aus 4 Operatoren:
 *
 * | Operator | Bedeutung |
 * |-----|-----|
 * | **`2`** | Eine Zahl beschreibt, wie viele Grid-Spalten sich ein Element nehmen soll. `0` bedeutet, Element ausblenden. |
 * | **`(3)`** | Eine Zahl in Klammern beschreibt, dass Weißraum mit einer gewissen Spaltengröße erzeugt wird. |
 * | **`-`** | Abgrenzung zwischen `Zahlen` in einer Zeile. Zusammen mit den Zahlen ergeben sie die Zeilen-Definition. z.B. `2-2-2`: drei Elemente in einer Zeile nehmen sich jeweils 2 Spalten. |
 * | **`/`** | Die nachfolgenden Zeilen-Definition wird in einer neuen Zeile anzeigt. z.B. `2-2/4`: Es gibt drei Elemente. Zwei werden in der ersten Zeile angezeigt, das dritte in der zweiten Zeile. |
 * | **`*`** | Wiederhole die vorherige Zeilen-Definition so oft, wie es Elemente gibt. z.B. `4/*`: Alle Elemente nutzen 4 Grid-Spalten und werden immer in einer neuen Zeile angezeigt. |
 *
 * ## Spaltenanzahl
 *
 * Die konkrete Spaltenanzahl wird über die Grid-Basis (`base` Property) bestimmt. Jeder Breakpoint hat eine feste zugewiesene
 * Spaltenanzahl.
 *
 * | Grid-Basis | S | M | L | XL |
 * |-----|-----|-----|-----|-----|
 * | `page` | 4 | 6 | 8 | 12 |
 *
 * *Beispiel: In einem `page`-Grid dürfen maximal 12 Spalten in der `xl`-Property pro Zeile verteilt werden.*
 *
 * @path /Layout
 * @name Grid
 * @stable
 * @icon th
 * @slot - Elemente für die das Layout erstellt werden soll.
 * @example tutorial-1
 */
export class DsGrid {
  constructor() {
    /**
     * Art des Grids (Grad-Basis) die für dieses Grid verwendet wird.
     * @value page: Standard-Seiten-Grid
     * @example page-1
     * @example page-2
     */
    this.base = "page";
    this.gridPool = [];
  }
  componentWillLoad() {
    assert((this.s || this.m || this.l || this.xl) != null, () => '<ds-grid> Es muss mindestens eine Größenangabe für die Properties "xl", "l", "m" oder "s" getätigt werden');
    const gridBase = PAGE_GRID;
    if (this.s) {
      this.gridPool.push(new GridSyntaxParser().parse(this.s, GridBreakpoint.S));
    }
    if (this.m) {
      this.gridPool.push(new GridSyntaxParser().parse(this.m, GridBreakpoint.M));
    }
    if (this.l) {
      this.gridPool.push(new GridSyntaxParser().parse(this.l, GridBreakpoint.L));
    }
    if (this.xl) {
      this.gridPool.push(new GridSyntaxParser().parse(this.xl, GridBreakpoint.XL));
    }
    const validator = new GridValidator(gridBase);
    this.gridPool.forEach((grid) => validator.validate(grid));
    this.updateChosenGrid();
  }
  connectedCallback() {
    this.breakpointAware = new BreakpointAware(() => this.updateChosenGrid());
    this.slotObserver = new SlotObserver(this.self, "*", (nodes) => {
      this.numberOfChildNodes = nodes.filter((node) => node.parentElement === this.self).length;
    });
  }
  disconnectedCallback() {
    var _a, _b;
    (_a = this.breakpointAware) === null || _a === void 0 ? void 0 : _a.disconnect();
    (_b = this.slotObserver) === null || _b === void 0 ? void 0 : _b.disconnect();
  }
  gridBase() {
    if (this.base == "page") {
      return PAGE_GRID;
    }
    throw Error("<ds-grid> Ungültige 'base'");
  }
  getBreakpointFromBreakpointAware() {
    if (this.breakpointAware.xs) {
      return GridBreakpoint.S;
    }
    else if (this.breakpointAware.md) {
      return GridBreakpoint.M;
    }
    else if (this.breakpointAware.lg) {
      return GridBreakpoint.L;
    }
    else {
      return GridBreakpoint.XL;
    }
  }
  updateChosenGrid() {
    this.breakpoint = this.getBreakpointFromBreakpointAware();
    // 1. use direct matches
    this.usedGrid = this.gridPool.find((grid) => grid.breakpoint === this.breakpoint);
    // 2. else: find next smallest breakpoint
    if (!this.usedGrid) {
      this.usedGrid = this.gridPool.reduce((prev, next) => {
        return ordinalOfGridBreakpoint(next.breakpoint) >
          ordinalOfGridBreakpoint(prev.breakpoint) &&
          ordinalOfGridBreakpoint(next.breakpoint) <
            ordinalOfGridBreakpoint(this.breakpoint)
          ? next
          : prev;
      });
    }
    // 3. else: use any
    if (!this.usedGrid) {
      this.usedGrid = this.gridPool[0];
    }
  }
  render() {
    let gridErrors = this.gridPool
      .map((grid) => grid.error)
      .reduce((a, b) => a + b, "");
    const result = new GridCssBuilder().build(this.gridBase(), this.usedGrid, this.numberOfChildNodes);
    gridErrors += result.error;
    if (gridErrors.length > 0) {
      console.error(`<ds-grid> ${gridErrors}`);
      return `Grid-Fehler: ${gridErrors}`;
    }
    return (h(Host, null, h("style", null, result.css), h("slot", null)));
  }
  static get is() { return "ds-grid"; }
  static get encapsulation() { return "shadow"; }
  static get originalStyleUrls() {
    return {
      "$": ["ds-grid.scss"]
    };
  }
  static get styleUrls() {
    return {
      "$": ["ds-grid.css"]
    };
  }
  static get properties() {
    return {
      "base": {
        "type": "string",
        "mutable": false,
        "complexType": {
          "original": "string",
          "resolved": "string",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "page: Standard-Seiten-Grid"
            }, {
              "name": "example",
              "text": "page-1"
            }, {
              "name": "example",
              "text": "page-2"
            }],
          "text": "Art des Grids (Grad-Basis) die f\u00FCr dieses Grid verwendet wird."
        },
        "attribute": "base",
        "reflect": false,
        "defaultValue": "\"page\""
      },
      "s": {
        "type": "string",
        "mutable": false,
        "complexType": {
          "original": "string",
          "resolved": "string",
          "references": {}
        },
        "required": false,
        "optional": true,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "string: Layout im Grid-Syntax"
            }, {
              "name": "important",
              "text": undefined
            }],
          "text": "Grid-Layout im Grid-Syntax (siehe oben) f\u00FCr Smartphone-Aufl\u00F6sungen.\n\nEs muss mindestens eine Breakpoint-Gr\u00F6\u00DFe (S, M, L oder XL) definiert sein."
        },
        "attribute": "s",
        "reflect": false
      },
      "m": {
        "type": "string",
        "mutable": false,
        "complexType": {
          "original": "string",
          "resolved": "string",
          "references": {}
        },
        "required": false,
        "optional": true,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "string: Layout im Grid-Syntax"
            }, {
              "name": "important",
              "text": undefined
            }],
          "text": "Grid-Layout im Grid-Syntax (siehe oben) f\u00FCr Tablet-Aufl\u00F6sungen.\n\nEs muss mindestens eine Breakpoint-Gr\u00F6\u00DFe (S, M, L oder XL) definiert sein."
        },
        "attribute": "m",
        "reflect": false
      },
      "l": {
        "type": "string",
        "mutable": false,
        "complexType": {
          "original": "string",
          "resolved": "string",
          "references": {}
        },
        "required": false,
        "optional": true,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "string: Layout im Grid-Syntax"
            }, {
              "name": "important",
              "text": undefined
            }],
          "text": "Grid-Layout im Grid-Syntax (siehe oben) f\u00FCr Laptop-Aufl\u00F6sungen.\n\nEs muss mindestens eine Breakpoint-Gr\u00F6\u00DFe (S, M, L oder XL) definiert sein."
        },
        "attribute": "l",
        "reflect": false
      },
      "xl": {
        "type": "string",
        "mutable": false,
        "complexType": {
          "original": "string",
          "resolved": "string",
          "references": {}
        },
        "required": false,
        "optional": true,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "string: Layout im Grid-Syntax"
            }, {
              "name": "important",
              "text": undefined
            }],
          "text": "Grid-Layout im Grid-Syntax (siehe oben) f\u00FCr Desktop-Aufl\u00F6sungen.\n\nEs muss mindestens eine Breakpoint-Gr\u00F6\u00DFe (S, M, L oder XL) definiert sein."
        },
        "attribute": "xl",
        "reflect": false
      }
    };
  }
  static get states() {
    return {
      "breakpoint": {},
      "numberOfChildNodes": {}
    };
  }
  static get elementRef() { return "self"; }
}
