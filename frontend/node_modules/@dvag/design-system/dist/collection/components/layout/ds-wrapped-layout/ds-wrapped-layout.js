import { h, Host, } from "@stencil/core";
import { SlotObserver } from "../../../classes/slot-observer";
import { BreakpointAware } from "../../../classes/breakpoint-aware";
import { onNextFrame } from "../../../classes/render-util";
/**
 * Layout-Komponente, die Elemente in einem Raster anordnet und dabei
 * automatisch umbricht.
 *
 * Die Elemente bekommen dadurch eine `width` zugewiesen und erhalten ein
 * `box-sizing: border-box`. Sollte das zu Problemen führen, können diese
 * Elemente mit einem neutralen Element (z.B. `<div>`) umschlossen werden.
 *
 * @name Umbrechendes Raster
 * @shortname Raster
 * @icon th
 * @path /Layout
 */
export class DsWrappedLayout {
  constructor() {
    /**
     * Legt die Größe der Elemente fest.
     *
     * Je kleiner die Elementgröße festgelegt wird, desto mehr
     * Elemente werden in einer Reihe angezeigt.
     * @value xs: Sehr klein
     * @value s: Klein
     * @value m: Normal
     * @value l: Groß
     * @value xl: Sehr groß
     * @example sizes
     */
    this.size = "m";
    /**
     * Ausrichtung von Elementen, wenn eine Reihe auf Grund der
     * Anzahl an Elementen nicht vervollständigt werden kann.
     * @value left: Linksbündig
     * @value center: Zentriert
     * @value right: Rechtsbündig
     * @example align-left
     * @example align-center
     * @example align-right
     */
    this.align = "center";
  }
  onWindowResize() {
    this.layout();
  }
  connectedCallback() {
    this.breakpointAware = new BreakpointAware(() => {
      // noop
    });
    this.slotObserver = new SlotObserver(this.self, "*", () => {
      this.layout();
    });
  }
  disconnectedCallback() {
    var _a, _b;
    (_a = this.slotObserver) === null || _a === void 0 ? void 0 : _a.disconnect();
    (_b = this.breakpointAware) === null || _b === void 0 ? void 0 : _b.disconnect();
  }
  componentDidRender() {
    onNextFrame(() => this.layout());
  }
  layout() {
    const slot = this.self.shadowRoot.querySelector("slot");
    if (slot == null) {
      return;
    }
    const nodes = Array.from(slot.assignedElements()).filter((node) => getComputedStyle(node).display !== "none");
    const availableWidth = this.self.getBoundingClientRect().width;
    const refWidth = this.referenceSize();
    const gapSize = this.gapSize();
    // Compute elements per row
    let elementsPerRow = Math.floor(availableWidth / refWidth + 0.25); // tolerate that element can be 25% smaller.
    elementsPerRow = Math.max(1, elementsPerRow);
    // Gaps between two elements
    const gaps = elementsPerRow - 1;
    // Effective elements with
    const elementWidth = (availableWidth - gaps * gapSize) / elementsPerRow;
    // Apply on all nodes
    nodes.forEach((node, index) => {
      const isFirstInRow = index % elementsPerRow === 0;
      const isInFirstRow = index < elementsPerRow;
      node.style.margin = "0"; // reset margin
      if (!isFirstInRow) {
        node.style.marginLeft = `${gapSize}px`;
      }
      if (!isInFirstRow) {
        node.style.marginTop = `${gapSize}px`;
      }
      node.style.width = `${elementWidth}px`;
    });
  }
  referenceSize() {
    if (this.size === "xs") {
      return 100;
    }
    if (this.size === "s") {
      return 200;
    }
    if (this.size === "m") {
      return 300;
    }
    if (this.size === "l") {
      return 400;
    }
    if (this.size === "xl") {
      return 500;
    }
  }
  gapSize() {
    if (this.breakpointAware.xl) {
      return 32;
    }
    if (this.breakpointAware.lg || this.breakpointAware.md) {
      return 24;
    }
    return 16;
  }
  render() {
    return (h(Host, { class: {
        "align-left": this.align === "left",
        "align-center": this.align === "center",
        "align-right": this.align === "right",
      } }, h("slot", null)));
  }
  static get is() { return "ds-wrapped-layout"; }
  static get encapsulation() { return "shadow"; }
  static get originalStyleUrls() {
    return {
      "$": ["ds-wrapped-layout.scss"]
    };
  }
  static get styleUrls() {
    return {
      "$": ["ds-wrapped-layout.css"]
    };
  }
  static get properties() {
    return {
      "size": {
        "type": "string",
        "mutable": false,
        "complexType": {
          "original": "\"xs\" | \"s\" | \"m\" | \"l\" | \"xl\"",
          "resolved": "\"l\" | \"m\" | \"s\" | \"xl\" | \"xs\"",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "xs: Sehr klein"
            }, {
              "name": "value",
              "text": "s: Klein"
            }, {
              "name": "value",
              "text": "m: Normal"
            }, {
              "name": "value",
              "text": "l: Gro\u00DF"
            }, {
              "name": "value",
              "text": "xl: Sehr gro\u00DF"
            }, {
              "name": "example",
              "text": "sizes"
            }],
          "text": "Legt die Gr\u00F6\u00DFe der Elemente fest.\n\nJe kleiner die Elementgr\u00F6\u00DFe festgelegt wird, desto mehr\nElemente werden in einer Reihe angezeigt."
        },
        "attribute": "size",
        "reflect": false,
        "defaultValue": "\"m\""
      },
      "align": {
        "type": "string",
        "mutable": false,
        "complexType": {
          "original": "\"left\" | \"center\" | \"right\"",
          "resolved": "\"center\" | \"left\" | \"right\"",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "left: Linksb\u00FCndig"
            }, {
              "name": "value",
              "text": "center: Zentriert"
            }, {
              "name": "value",
              "text": "right: Rechtsb\u00FCndig"
            }, {
              "name": "example",
              "text": "align-left"
            }, {
              "name": "example",
              "text": "align-center"
            }, {
              "name": "example",
              "text": "align-right"
            }],
          "text": "Ausrichtung von Elementen, wenn eine Reihe auf Grund der\nAnzahl an Elementen nicht vervollst\u00E4ndigt werden kann."
        },
        "attribute": "align",
        "reflect": false,
        "defaultValue": "\"center\""
      }
    };
  }
  static get elementRef() { return "self"; }
  static get listeners() {
    return [{
        "name": "resize",
        "method": "onWindowResize",
        "target": "window",
        "capture": false,
        "passive": true
      }];
  }
}
