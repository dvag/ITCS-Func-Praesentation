import { h, Host, } from "@stencil/core";
/**
 * Ein Container, der bei Hinzufügen und Entfernen von Inhalten automatisch auf die neue Höhe animiert.
 *
 * @name Grow Box
 * @shortname Growbox
 * @path /Layout
 * @icon box
 *
 * @slot - Der Inhalt der Box, der die Höhe für die Box vorgibt.
 */
export class DsGrowBox {
  constructor() {
    this.lastScrollHeight = null;
    this.isInTransition = false;
    this.childGrowboxIsGrowing = false;
    /**
     * Gibt an, ob die Box offen oder geschlossen sein soll. Wenn dieser Wert geändert wird, animiert die Box automatisch
     * auf die entsprechende Höhe.
     *
     * @value true: Die Box animiert seine Höhe auf die Höhe seiner Kind-Elemente.
     * @value false: Die Box animiert seine Höhe auf den Wert 0.
     *
     * @example open
     */
    this.open = true;
    /**
     * Gibt an, ob die Kind-Elemente mitgeschoben werden, wenn sich die Box öffnet oder schließt.
     *
     * @value true: Die Kind-Elemente werden nach oben bzw. unten geschoben, wenn sich der `open`-State der Box verändert.
     * @value false: Die Kind-Elemente bleiben immer an Ort und Stelle.
     *
     * @example slide-content
     */
    this.slidecontent = true;
    /**
     * Gibt an, ob nach dem Initialisieren der Box bereits animiert werden soll.
     *
     * @value true: Sofern das `open`-Attribute den Wert `true` hat, animiert die Box auf seine berechnete Höhe.
     * @value false: Beim Initialisieren der Box wird keine Animation stattfinden.
     *
     * @example animate-on-init
     */
    this.animateoninit = true;
  }
  onContentVisibilityChange(event) {
    if (event.target === this.self) {
      this.contentIsVisible = event.detail;
    }
    else {
      /// stop events contentVisiblityChange events from child growboxes
      event.stopPropagation();
      event.stopImmediatePropagation();
    }
  }
  onChildGrowboxGrowStart(event) {
    // only listen to child growboxes
    if (event.target !== this.self) {
      this.checkHeight();
      if (!this.isInTransition) {
        this.childGrowboxIsGrowing = true;
        // we need to suppress any 'slide content' effect while a child is animating, because it looks strange
        clearTimeout(this.suppressSlideContentTimeoutHandle);
        this.suppressSlideContentTimeoutHandle = setTimeout(() => (this.childGrowboxIsGrowing = false), event.detail + 200);
      }
    }
  }
  componentWillLoad() {
    this.contentIsVisible = this.open;
  }
  handleTransitionStart() {
    this.isInTransition = true;
  }
  handleTransitionEnd(event) {
    this.isInTransition = false;
    if (event.target === this.self && !this.open) {
      this.contentVisibilityChange.emit(false);
    }
  }
  contentElementCreated(contentElement) {
    var _a;
    if (this.contentElement === contentElement) {
      this.checkHeight();
      return;
    }
    this.contentElement = contentElement;
    (_a = this.resizeObserver) === null || _a === void 0 ? void 0 : _a.disconnect();
    this.resizeObserver = new ResizeObserver(() => {
      // Fix for DS-703: ResizeObserver loop limit exceeded error is thrown in chrome-headless mode of angular tests
      requestAnimationFrame(() => {
        this.checkHeight();
      });
    });
    this.resizeObserver.observe(this.contentElement);
  }
  // Checks the required height of the slotted element and initiates a transition
  checkHeight() {
    var _a;
    const scrollHeight = this.getHeightOfContent();
    if (this.lastScrollHeight === null ||
      this.lastScrollHeight !== scrollHeight) {
      const deltaPixel = Math.abs(scrollHeight - ((_a = this.lastScrollHeight) !== null && _a !== void 0 ? _a : 0));
      const duration = Math.min(Math.max(150, Math.round(deltaPixel * 1.5)), 600);
      this.self.style.transitionDuration = this.childGrowboxIsGrowing
        ? "0ms"
        : `${duration}ms`;
      this.self.style.height = `${scrollHeight}px`;
      this.growboxGrowStart.emit(duration);
      if (this.lastScrollHeight === 0 && scrollHeight !== 0) {
        this.contentVisibilityChange.emit(true);
      }
      this.lastScrollHeight = scrollHeight;
    }
  }
  getHeightOfContent() {
    var _a, _b;
    if (!this.open) {
      return 0;
    }
    return (_b = (_a = this.contentElement) === null || _a === void 0 ? void 0 : _a.scrollHeight) !== null && _b !== void 0 ? _b : 0;
  }
  render() {
    return (h(Host, { class: {
        "animate-on-init": this.animateoninit,
        "slide-content": this.slidecontent && !this.childGrowboxIsGrowing,
        "content-is-visible": this.contentIsVisible,
      }, onTransitionStart: () => this.handleTransitionStart(), onTransitionEnd: (event) => this.handleTransitionEnd(event) }, h("div", { ref: (el) => this.contentElementCreated(el) }, h("slot", null))));
  }
  static get is() { return "ds-grow-box"; }
  static get encapsulation() { return "shadow"; }
  static get originalStyleUrls() {
    return {
      "$": ["ds-grow-box.scss"]
    };
  }
  static get styleUrls() {
    return {
      "$": ["ds-grow-box.css"]
    };
  }
  static get properties() {
    return {
      "open": {
        "type": "boolean",
        "mutable": false,
        "complexType": {
          "original": "boolean",
          "resolved": "boolean",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "true: Die Box animiert seine H\u00F6he auf die H\u00F6he seiner Kind-Elemente."
            }, {
              "name": "value",
              "text": "false: Die Box animiert seine H\u00F6he auf den Wert 0."
            }, {
              "name": "example",
              "text": "open"
            }],
          "text": "Gibt an, ob die Box offen oder geschlossen sein soll. Wenn dieser Wert ge\u00E4ndert wird, animiert die Box automatisch\nauf die entsprechende H\u00F6he."
        },
        "attribute": "open",
        "reflect": false,
        "defaultValue": "true"
      },
      "slidecontent": {
        "type": "boolean",
        "mutable": false,
        "complexType": {
          "original": "boolean",
          "resolved": "boolean",
          "references": {}
        },
        "required": false,
        "optional": true,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "true: Die Kind-Elemente werden nach oben bzw. unten geschoben, wenn sich der `open`-State der Box ver\u00E4ndert."
            }, {
              "name": "value",
              "text": "false: Die Kind-Elemente bleiben immer an Ort und Stelle."
            }, {
              "name": "example",
              "text": "slide-content"
            }],
          "text": "Gibt an, ob die Kind-Elemente mitgeschoben werden, wenn sich die Box \u00F6ffnet oder schlie\u00DFt."
        },
        "attribute": "slidecontent",
        "reflect": false,
        "defaultValue": "true"
      },
      "animateoninit": {
        "type": "boolean",
        "mutable": false,
        "complexType": {
          "original": "boolean",
          "resolved": "boolean",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "true: Sofern das `open`-Attribute den Wert `true` hat, animiert die Box auf seine berechnete H\u00F6he."
            }, {
              "name": "value",
              "text": "false: Beim Initialisieren der Box wird keine Animation stattfinden."
            }, {
              "name": "example",
              "text": "animate-on-init"
            }],
          "text": "Gibt an, ob nach dem Initialisieren der Box bereits animiert werden soll."
        },
        "attribute": "animateoninit",
        "reflect": false,
        "defaultValue": "true"
      }
    };
  }
  static get states() {
    return {
      "childGrowboxIsGrowing": {},
      "contentIsVisible": {}
    };
  }
  static get events() {
    return [{
        "method": "growboxGrowStart",
        "name": "growboxGrowStart",
        "bubbles": true,
        "cancelable": true,
        "composed": true,
        "docs": {
          "tags": [{
              "name": "internal",
              "text": "Benutzt f\u00FCr Growbox zu Growbox Kommunikation"
            }],
          "text": ""
        },
        "complexType": {
          "original": "number",
          "resolved": "number",
          "references": {}
        }
      }, {
        "method": "growStart",
        "name": "growStart",
        "bubbles": true,
        "cancelable": true,
        "composed": true,
        "docs": {
          "tags": [],
          "text": "Event kennzeichnet den Abschluss einer Transition. Die Event-Payload (`event.detail`)\nenth\u00E4lt Status-Informationen zur Growbox."
        },
        "complexType": {
          "original": "GrowStartEvent",
          "resolved": "GrowStartEvent",
          "references": {
            "GrowStartEvent": {
              "location": "local"
            }
          }
        }
      }, {
        "method": "contentVisibilityChange",
        "name": "contentVisibilityChange",
        "bubbles": true,
        "cancelable": true,
        "composed": true,
        "docs": {
          "tags": [],
          "text": "Wirft Ergeignis, wenn sich die Sichtbarkeit des Contents \u00E4ndert.\nDie Event-Payload (`event.detail`) enth\u00E4lt einen boolean, ob der\nContent sichtbar ist."
        },
        "complexType": {
          "original": "boolean",
          "resolved": "boolean",
          "references": {}
        }
      }];
  }
  static get elementRef() { return "self"; }
  static get listeners() {
    return [{
        "name": "contentVisibilityChange",
        "method": "onContentVisibilityChange",
        "target": undefined,
        "capture": false,
        "passive": false
      }, {
        "name": "growboxGrowStart",
        "method": "onChildGrowboxGrowStart",
        "target": undefined,
        "capture": false,
        "passive": false
      }];
  }
}
