import { forceUpdate, h, Host, } from "@stencil/core";
import { SlotObserver } from "../../../classes/slot-observer";
import { Debounce } from "../../../classes/debounce";
import { sameArrayIgnoreOrder, sameArrayInOrder, } from "../../../classes/misc-util";
import { sameColumnSettings } from "../ds-table-header-item/same-column-settings";
import { assert } from "../../../classes/assert";
import { ElementIdGenerator } from "../../../classes/element-id-handling";
const DEFAULT_ROW_HEIGHT = 40;
/**
 * A table for visualizing data in columns and rows.
 *
 * It has the ability to sort and paginate it's content out of the box.
 * This feature can be disabled, if you want to realize data sorting and pagination manually.
 *
 * @name Table
 * @path /
 * @icon table
 * @stable
 *
 * @slot - Definition of the table data (rows) and data structure (columns) by using specialized sub-component (e.g.: `ds-table-header`, `ds-table-row`, etc.).
 * @slot title - This slot contains the title of the card, if a card layout is configured in the `view` attribute.
 */
export class DsTable {
  constructor() {
    this.currentSortSettings = { column: null, reverse: false };
    this.sortDebounce = new Debounce(50);
    this.rowDebounce = new Debounce(200);
    this.touchMoveDetected = false;
    this.scrollHintFadedOutHandler = () => {
      this.scrollHintNecessary = this.showScrollHint;
    };
    this.scrollHandler = () => {
      this.controlOpticalHints();
    };
    this.currentPage = 1;
    this.selectedRowKeys = [];
    this.showScrollHint = true;
    this.scrollHintNecessary = false;
    this.internalScrollable = false;
    /**
     * Defines the style of this table.
     *
     * @value default: Default table
     * @value paginated-card: Table within a card with pagination.
     * @value paginated-card-shadow: Table within a shadowed card with pagination.
     *
     * @example paginator
     */
    this.view = "default";
    /**
     * Defines the options for the page size that a user can pick from.
     * It only has an effect if the `view` attribute supports pagination.
     *
     * @value string: Comma seperated list of numbers (e.g: [25,50,100]).
     *
     * @example paginator
     */
    this.pagesizes = "[25,50,100]";
    /**
     * The initially selected option for the page size.
     * It only has an effect if the `view` attribute supports pagination.
     *
     * @value number: Number of rows per page.
     *
     * @example paginator
     */
    this.pagesize = 25;
    /**
     * Specifies the initial sort direction.
     *
     * @value asc: Ascending order.
     * @value desc: Descending order.
     *
     * @example initial-sort
     */
    this.initialsortdirection = "asc";
    /**
     * Specifies whether the table is self-managed or remote-controlled.
     *
     * @value managed: The table is responsible for sorting and pagination.
     * @value remote: The table relies on an external implementation for creating rows, sorting and pagination using the `tableStateChanged` event.
     *
     * @example remote
     * @example remote-complex
     */
    this.mode = "managed";
    /**
     * **Warning: This feature is highly experimental.**
     *
     * Enables the selection of rows.
     * A `key` for every row has to be specified.
     *
     * @value true: The selection-group will be opened.
     * @value false: The selection-group will be closed.
     *
     * @example selection
     */
    this.selectionenabled = false;
    /**
     * **Warning: This feature is highly experimental.**
     *
     * Specifies if only one or multiple rows can be selected.
     *
     * @value multi: Multiple rows can be selected.
     * @value single: One row can be selected at a time.
     *
     * @example selection-mode
     */
    this.selectionmode = "multi";
    /**
     * The data length this table should visualize. In case the table manages itself this attribute should not be set.
     * If the table is remote-controlled this attribute has to be set because the table needs to know the exact amount
     * of data to visualize the **paging** accordingly.
     *
     * @example remote
     * @example remote-complex
     */
    this.rowcount = 0;
    this.initialized = false;
  }
  onSideBarOpenChange() {
    if (!this.selectionenabled) {
      this.selectedRowKeys = [];
      if (this.selectionGroup != null) {
        this.selectionGroup.value = null;
        this.rowsSelected.emit(null);
      }
      else {
        this.rowsSelected.emit([]);
      }
    }
    else {
      const noRowIdsDefined = this.getRows().every((row) => row.rowid == null);
      if (noRowIdsDefined) {
        console.warn("To use table selection you have to define at least one <ds-table-row> with a valid 'rowid'!\n", this.self);
        this.selectionenabled = false;
      }
    }
    this.controlOpticalHints();
  }
  onScrollableChange() {
    var _a;
    this.setScrollable();
    this.controlOpticalHints();
    (_a = this.headerItemElements) === null || _a === void 0 ? void 0 : _a.forEach((headerItem) => {
      headerItem.usemaxwidth = this.internalScrollable;
    });
  }
  onTouchStart() {
    this.touchMoveDetected = false;
  }
  onTouchmove() {
    this.touchMoveDetected = true;
  }
  onTouchEnd(event) {
    if (this.touchMoveDetected) {
      event.stopImmediatePropagation();
      this.touchMoveDetected = false;
    }
  }
  connectedCallback() {
    this.initialized = false;
    this.observeHeaderItems();
    this.observeRows();
    this.setScrollable();
  }
  initResizeObserver() {
    this.tableResizeObserver = new ResizeObserver((entries) => {
      this.updateTableScroll(entries[0].contentRect.width);
      this.controlOpticalHints();
    });
  }
  setScrollable() {
    var _a;
    if (this.scrollable) {
      this.initResizeObserver();
    }
    else {
      (_a = this.tableResizeObserver) === null || _a === void 0 ? void 0 : _a.disconnect();
      this.tableResizeObserver = null;
      this.internalScrollable = this.scrollable;
      this.updateCellSettings().then();
    }
  }
  updateTableScroll(tableWidth) {
    if (this.headerItemElements == null ||
      this.headerItemElements.length === 0) {
      return;
    }
    const oneTimePaddingLeft = 16;
    const columnsSum = this.headerItemElements.reduce((acc, currentValue) => {
      var _a;
      const minWidth = parseInt((_a = currentValue.minwidth) === null || _a === void 0 ? void 0 : _a.toString());
      if (isNaN(minWidth)) {
        console.error(`ds-table:`, this.self, `Every <ds-table-header-item> in a scrollable table has to set a minwidth. At least one <ds-table-header-item> was not given a size.`);
      }
      const sideMargin = 16;
      return acc + currentValue.minwidth + sideMargin;
    }, 0) + oneTimePaddingLeft;
    const isScrollable = columnsSum > tableWidth;
    if (this.internalScrollable !== isScrollable) {
      this.internalScrollable = isScrollable;
      this.updateCellSettings().then();
      if (!isScrollable) {
        this.showLeftGradient = false;
        this.showRightGradient = false;
      }
    }
  }
  hideScrollHint() {
    this.showScrollHint = false;
  }
  controlOpticalHints() {
    if (!this.internalScrollable || this.scrollContainer == null) {
      return;
    }
    const scrollDistance = this.scrollContainer.scrollLeft;
    const maxScrollDistance = this.scrollContainer.scrollWidth - this.scrollContainer.clientWidth;
    requestAnimationFrame(() => {
      const isScrolledLeft = scrollDistance < maxScrollDistance;
      const isScrolledRight = scrollDistance > 0;
      this.showRightGradient = isScrolledLeft;
      this.showLeftGradient =
        this.isScrollingPossible() && this.selectionenabled;
      this.calculateShouldHideScrollHint(isScrolledRight);
    });
  }
  isScrollingPossible() {
    var _a, _b;
    return (this.internalScrollable &&
      ((_a = this.scrollContainer) === null || _a === void 0 ? void 0 : _a.scrollWidth) > ((_b = this.scrollContainer) === null || _b === void 0 ? void 0 : _b.clientWidth));
  }
  calculateScrollHintNecessary() {
    this.scrollHintNecessary = this.isScrollingPossible();
  }
  calculateShouldHideScrollHint(isScrolledRight) {
    if (isScrolledRight && this.showScrollHint) {
      this.hideScrollHint();
    }
  }
  disconnectedCallback() {
    var _a, _b, _c;
    (_a = this.headerItemObserver) === null || _a === void 0 ? void 0 : _a.disconnect();
    (_b = this.rowObserver) === null || _b === void 0 ? void 0 : _b.disconnect();
    this.rowDebounce.reset();
    this.sortDebounce.reset();
    (_c = this.tableResizeObserver) === null || _c === void 0 ? void 0 : _c.disconnect();
  }
  /**
   * @internal
   */
  async invokeSort(element, reverse) {
    if (!this.initialized) {
      this.invokeSortInputParamsBeforeInit = {
        element,
        reverse,
      };
      return;
    }
    return this.internalInvokeSort(element, reverse);
  }
  async internalInvokeSort(element, reverse) {
    var _a;
    const index = this.headerItemElements.indexOf(element);
    this.headerItemElements.forEach((el, i) => {
      if (index !== i) {
        el.setSortDirection("neutral");
      }
    });
    this.sortState = {
      column: (_a = element.columnid) !== null && _a !== void 0 ? _a : element.label,
      index: index,
      direction: reverse ? "desc" : "asc",
    };
    this.sortRows({ column: index, reverse: reverse });
  }
  reSort() {
    if (this.currentSortSettings.column !== null) {
      this.sortRows(this.currentSortSettings);
    }
  }
  isViewUsingPagination() {
    return this.view.includes("paginated");
  }
  observeRows() {
    this.rowObserver = new SlotObserver(this.self, "ds-table-row", () => {
      this.rowDebounce.run(async () => {
        // Disconnect to prevent further SlotObserver calls through DOM Manipulation
        this.rowObserver.disconnect();
        await this.updateCellSettings();
        const currentRows = this.getRows();
        this.checkForDuplicateRowKeys(currentRows);
        this.handleRemoteSelection(currentRows);
        if (!sameArrayIgnoreOrder(currentRows, this.rowElements)) {
          this.rowElements = currentRows;
          if (this.mode === "managed") {
            this.rowcount = currentRows.length;
            if (!hasAnySortableColumns(this.headerItemElements)) {
              this.manipulateDOMRows(this.rowElements);
            }
            else {
              this.reSort();
            }
          }
          this.updateVisibility();
        }
        else {
          forceUpdate(this.self);
        }
        // Reconnect SlotObserver
        this.rowObserver.connect();
        this.init();
      });
    });
  }
  handleRemoteSelection(currentRows) {
    requestAnimationFrame(() => {
      var _a;
      if (this.selectionmode === "single") {
        const previousSelectedRowId = this.selectedRowKeys[0];
        const newlySelectedRowID = (_a = currentRows
          .filter((row) => row.selected == true)
          .filter((row) => row.rowid !== previousSelectedRowId)[0]) === null || _a === void 0 ? void 0 : _a.rowid;
        if (newlySelectedRowID == undefined) {
          return;
        }
        this.selectionenabled = true;
        this.handleRadioSelection(newlySelectedRowID);
      }
      else {
        currentRows.forEach((row) => {
          this.selectionenabled || (this.selectionenabled = row.selected);
          this.handleCheckboxSelection(row.rowid, row.selected);
        });
      }
    });
  }
  init() {
    this.initialized = true;
    if (this.invokeSortInputParamsBeforeInit != null) {
      this.internalInvokeSort(this.invokeSortInputParamsBeforeInit.element, this.invokeSortInputParamsBeforeInit.reverse).then();
      this.invokeSortInputParamsBeforeInit = null;
    }
  }
  updateVisibility() {
    if (this.mode === "managed" && this.isViewUsingPagination()) {
      const currentRows = this.getRows();
      const visibleRowRange = this.getCurrentRowsRangeIndices();
      currentRows.forEach((row, index) => {
        row.setAttribute("visible", "" +
          (index >= visibleRowRange.fromIndex &&
            index <= visibleRowRange.toIndex));
      });
    }
    this.updateAlternatingRowHighlights();
  }
  getCurrentRowsRangeIndices() {
    var _a, _b;
    const fromIndex = ((_a = this.pagesize) !== null && _a !== void 0 ? _a : 0) * (this.currentPage - 1);
    const result = {
      fromIndex: fromIndex,
      toIndex: fromIndex,
    };
    if (this.mode === "managed") {
      result.toIndex += ((_b = this.pagesize) !== null && _b !== void 0 ? _b : this.rowcount) - 1;
    }
    else {
      result.toIndex += this.pagesize - 1;
    }
    // There could be fewer rows visible than the pagesize allows at the last page
    result.toIndex = Math.min(this.rowcount - 1, result.toIndex);
    return result;
  }
  updateAlternatingRowHighlights() {
    this.getRows().forEach((row, index) => {
      row.classList.remove("odd");
      if ((index % this.pagesize) % 2 == 0) {
        row.classList.add("odd");
      }
    });
  }
  emitTableStateChanged() {
    const currentRowsRangeIndices = this.getCurrentRowsRangeIndices();
    this.tableStateChanged.emit({
      page: this.currentPage,
      pageSize: this.pagesize,
      fromIndex: currentRowsRangeIndices.fromIndex,
      toIndex: currentRowsRangeIndices.toIndex,
      sortState: this.sortState,
    });
  }
  observeHeaderItems() {
    this.headerItemObserver = new SlotObserver(this.self, "ds-table-header-item", async (nodes) => {
      var _a, _b;
      const newSettings = await Promise.all(nodes.map((node) => {
        return node.toColumnSettings();
      }));
      if (!this.differentSettings(newSettings) &&
        sameArrayInOrder(this.headerItemElements, nodes)) {
        return;
      }
      this.settings = newSettings;
      //TODO check delete all columns and creating new ones triggers sort?
      const hadAnySortableColumnsBeforeChange = hasAnySortableColumns(this.headerItemElements);
      this.headerItemElements = nodes;
      if (!hadAnySortableColumnsBeforeChange) {
        const sortableHeaderColumns = await (nodes === null || nodes === void 0 ? void 0 : nodes.filter((headerItem) => headerItem.sortable));
        let sortedHeaderColumn = null;
        if (((_a = this.initialsort) === null || _a === void 0 ? void 0 : _a.length) > 0) {
          sortedHeaderColumn = sortableHeaderColumns === null || sortableHeaderColumns === void 0 ? void 0 : sortableHeaderColumns.find((headerItem) => {
            return (headerItem.columnid === this.initialsort ||
              headerItem.label === this.initialsort);
          });
          assert(sortedHeaderColumn != null, () => `Kein <ds-header-item-element> mit der 'columnid' oder dem 'label' "${this.initialsort}" gefunden`);
        }
        sortedHeaderColumn !== null && sortedHeaderColumn !== void 0 ? sortedHeaderColumn : (sortedHeaderColumn = sortableHeaderColumns === null || sortableHeaderColumns === void 0 ? void 0 : sortableHeaderColumns[0]);
        sortedHeaderColumn === null || sortedHeaderColumn === void 0 ? void 0 : sortedHeaderColumn.setSortDirection((_b = this.initialsortdirection) !== null && _b !== void 0 ? _b : "asc");
      }
      this.updateCellSettings().then();
    });
  }
  differentSettings(settings) {
    return (this.settings == null ||
      settings.find((setting, index) => {
        return !sameColumnSettings(setting, this.settings[index]);
      }) != null);
  }
  async updateCellSettings() {
    var _a;
    (_a = this.headerItemElements) === null || _a === void 0 ? void 0 : _a.forEach((headerItem) => {
      headerItem.usemaxwidth = this.internalScrollable;
    });
    return Promise.all(this.getRows().concat(this.getFooters()).flatMap((row) => {
      return Array.from(row.querySelectorAll("ds-table-cell"))
        .map((cell, index) => {
        var _a;
        if (index < ((_a = this.headerItemElements) === null || _a === void 0 ? void 0 : _a.length)) {
          return cell.obtainSettings(this.settings[index]);
        }
        return null;
      })
        .filter((promise) => promise != null);
    }));
  }
  getRows() {
    return Array.from(this.self.querySelectorAll("ds-table-row"));
  }
  getFooters() {
    return Array.from(this.self.querySelectorAll("ds-table-footer"));
  }
  compareColumns(firstRow, secondRow, columnIndex, type) {
    var _a;
    const columnSelector = "ds-table-cell:nth-child(" + (columnIndex + 1) + ")";
    if (type === "html") {
      const headerItem = this.headerItemElements[columnIndex];
      if (headerItem.customSort != null) {
        return headerItem.customSort(firstRow.querySelector(columnSelector), secondRow.querySelector(columnSelector));
      }
      return 0;
    }
    const valueA = firstRow.querySelector(columnSelector).getAttribute("value");
    const valueB = secondRow
      .querySelector(columnSelector)
      .getAttribute("value");
    if (type === "numeric" || type === "currency") {
      return parseFloat(valueA) - parseFloat(valueB);
    }
    return (_a = valueA === null || valueA === void 0 ? void 0 : valueA.localeCompare(valueB)) !== null && _a !== void 0 ? _a : (valueB ? -1 : 0);
  }
  sortRows(sortSettings) {
    if (!equalSortSettings(this.currentSortSettings, sortSettings)) {
      this.currentPage = 1;
      this.emitTableStateChanged();
    }
    if (this.mode === "remote") {
      return;
    }
    this.currentSortSettings.column = sortSettings.column;
    this.currentSortSettings.reverse = sortSettings.reverse;
    this.sortDebounce.run(() => {
      var _a, _b;
      const rows = [...((_a = this.getRows()) !== null && _a !== void 0 ? _a : [])];
      const type = (_b = this.settings[sortSettings.column]) === null || _b === void 0 ? void 0 : _b.type;
      const sortScale = sortSettings.reverse ? -1 : 1;
      const sortOrder = this.headerItemElements
        .filter((_, index) => index !== sortSettings.column)
        .filter((headerItem) => headerItem.sortable && headerItem.sortpriority != null)
        .sort((a, b) => b.sortpriority - a.sortpriority)
        .map((headerItem) => this.headerItemElements.indexOf(headerItem));
      rows.sort((a, b) => {
        var _a;
        let currentColumnIndex = sortSettings.column;
        let currentType = type;
        const sortOrderCpy = [...sortOrder];
        let result = this.compareColumns(a, b, currentColumnIndex, currentType) *
          sortScale;
        // Secondary sorting
        while (result === 0 && sortOrderCpy.length > 0) {
          currentColumnIndex = sortOrderCpy.pop();
          currentType = (_a = this.settings[currentColumnIndex]) === null || _a === void 0 ? void 0 : _a.type;
          // Do not apply scale because we want to always sort ascending for secondary sorting
          result = this.compareColumns(a, b, currentColumnIndex, currentType);
        }
        return result;
      });
      this.manipulateDOMRows(rows);
      this.updateVisibility();
    });
  }
  checkForDuplicateRowKeys(currentRows) {
    const duplicateMap = currentRows.reduce((map, row) => {
      var _a, _b;
      if (row.rowid != null) {
        map[row.rowid] = (_b = (_a = map[row.rowid]) === null || _a === void 0 ? void 0 : _a.concat(row)) !== null && _b !== void 0 ? _b : [row];
      }
      return map;
    }, {});
    Object.keys(duplicateMap).forEach((key) => {
      const rowList = duplicateMap[key];
      if (rowList.length > 1) {
        console.error(`Duplicate key "${key}" in rows:\n`, ...rowList);
      }
    });
  }
  manipulateDOMRows(rows) {
    let insertAfterElement = null;
    this.self.querySelectorAll(":scope > *").forEach((el) => {
      if (!["ds-table-row", "ds-table-footer"].includes(el.tagName.toLowerCase())) {
        insertAfterElement = el; // use last non-row element as insert point
      }
    });
    // Reverse is mutating an array so we have to copy the array
    [...rows].reverse().forEach((row) => {
      insertAfterElement.insertAdjacentElement("afterend", row);
    });
  }
  handlePaginationPageSizeChanged(e) {
    this.pagesize = e.detail;
    this.emitTableStateChanged();
    this.updateVisibility();
  }
  handlePaginationPageChanged(e) {
    const page = e.detail;
    if (this.currentPage !== page) {
      this.currentPage = page;
      this.emitTableStateChanged();
      this.updateVisibility();
    }
  }
  handleRadioSelection(key) {
    if (this.selectedRowKeys[0] === key) {
      return;
    }
    this.selectedRowKeys = [key];
    this.rowElements.forEach((row) => {
      row.selected = row.rowid == this.selectedRowKeys[0];
    });
    this.rowsSelected.emit([...this.selectedRowKeys]);
  }
  handleCheckboxSelection(key, checked) {
    const selectedRow = this.rowElements.filter((row) => row.rowid === key)[0];
    if (checked && !this.selectedRowKeys.includes(key)) {
      selectedRow.selected = true;
      this.selectedRowKeys.push(key);
    }
    else if (!checked) {
      selectedRow.selected = false;
      this.selectedRowKeys = this.selectedRowKeys.filter((rowKey) => {
        return rowKey !== key;
      });
    }
    this.rowsSelected.emit([...this.selectedRowKeys]);
  }
  componentDidRender() {
    var _a, _b;
    this.calculateScrollHintNecessary();
    this.controlOpticalHints();
    if (this.selectionmode === "multi") {
      const visibleRows = this.self.querySelectorAll("ds-table-row.visible");
      const selectionRows = (_b = (_a = this.self) === null || _a === void 0 ? void 0 : _a.shadowRoot) === null || _b === void 0 ? void 0 : _b.querySelectorAll(".row");
      selectionRows === null || selectionRows === void 0 ? void 0 : selectionRows.forEach((selectionRow, index) => {
        if (selectionRow.firstElementChild == null) {
          return;
        }
        const checkbox = selectionRow.querySelector("ds-checkbox");
        if (checkbox != null) {
          checkbox.checked = this.selectedRowKeys.includes(visibleRows[index].rowid);
        }
      });
    }
    else {
      this.selectionGroup.value = this.selectedRowKeys[0];
    }
  }
  render() {
    if (this.view === "default") {
      return this.renderDefault();
    }
    if (this.view === "paginated-card") {
      return this.renderPaginatedCard(false);
    }
    if (this.view === "paginated-card-shadow") {
      return this.renderPaginatedCard(true);
    }
  }
  renderSelectionGroup() {
    let referenceRows = this.getRows();
    if (this.mode === "managed") {
      const indexRange = this.getCurrentRowsRangeIndices();
      referenceRows = referenceRows.slice(indexRange.fromIndex, indexRange.toIndex + 1);
    }
    return this.selectionmode === "single"
      ? this.renderRadioSelection(referenceRows)
      : this.renderCheckboxSelection(referenceRows);
  }
  renderCheckboxSelection(rows) {
    return (h("div", null, rows.map((row, index) => {
      return (h("div", { class: {
          row: true,
          odd: index % 2 === 0,
        }, style: {
          height: row.offsetHeight < DEFAULT_ROW_HEIGHT
            ? `${DEFAULT_ROW_HEIGHT}px`
            : row.offsetHeight + "px",
        } }, row.rowid ? (h("ds-checkbox", { id: ElementIdGenerator.createId(this.self, `selection-button-${index}`), checked: this.selectedRowKeys.includes(row.rowid), onCheckedChange: (e) => this.handleCheckboxSelection(row.rowid, e.detail) })) : null));
    })));
  }
  renderRadioSelection(rows) {
    return (h("ds-radio-button-group", { id: ElementIdGenerator.createId(this.self, "selection-group"), ref: (ref) => (this.selectionGroup = ref), onValueChange: (e) => this.handleRadioSelection(e.detail) }, rows.map((row, index) => {
      return (h("div", { class: {
          row: true,
          odd: index % 2 === 0,
        }, style: {
          height: row.offsetHeight < DEFAULT_ROW_HEIGHT
            ? `${DEFAULT_ROW_HEIGHT}px`
            : row.offsetHeight + "px",
        } }, row.rowid ? (h("ds-radio-button", { id: ElementIdGenerator.createId(this.self, `selection-button-${index}`), value: row.rowid })) : null));
    })));
  }
  renderSidebarFooter() {
    return this.getFooters().map((footer) => {
      return (h("div", { style: {
          height: footer.offsetHeight - 4 + "px",
        }, class: { footer: true } }));
    });
  }
  getScrollWidth() {
    const oneTimePaddingLeft = 16;
    return (this.headerItemElements.reduce((acc, currentValue) => {
      var _a;
      const sideMargin = 16;
      return (acc +
        parseInt((_a = (currentValue.maxwidth || currentValue.minwidth)) === null || _a === void 0 ? void 0 : _a.toString()) +
        sideMargin);
    }, 0) + oneTimePaddingLeft);
  }
  renderSidebar() {
    var _a, _b;
    return (h("div", { class: {
        "sidebar-container": true,
        open: this.selectionenabled,
      } }, h("div", { class: "sidebar" }, h("div", { class: "header", style: {
        height: ((_b = (_a = this.headerItemElements) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.offsetHeight) + "px",
      } }), [this.renderSelectionGroup(), this.renderSidebarFooter()])));
  }
  setScrollContainer(scrollContainer) {
    var _a, _b;
    if (this.scrollContainer === scrollContainer) {
      return;
    }
    (_a = this.scrollContainer) === null || _a === void 0 ? void 0 : _a.removeEventListener("scroll", this.scrollHandler);
    this.scrollContainer = scrollContainer;
    (_b = this.scrollContainer) === null || _b === void 0 ? void 0 : _b.addEventListener("scroll", this.scrollHandler);
  }
  renderScrollableTableContent() {
    return (h("div", null, this.renderScrollHint(), h("ds-scroll-container", { scrollbarmargin: 8 }, h("div", { ref: (ref) => {
        this.setScrollContainer(ref);
      }, class: { scrollable: true }, style: {
        "--ds-table-row-width": this.internalScrollable
          ? `${this.getScrollWidth()}px`
          : "none",
      } }, h("slot", null)))));
  }
  renderScrollHint() {
    if (this.scrollHintNecessary) {
      return (h("div", { class: {
          "scroll-hint": true,
          show: this.showScrollHint,
        }, onTransitionEnd: () => this.scrollHintFadedOutHandler() }, h("ds-icon", { icon: "listenpfeil", color: "weiss", size: 32 })));
    }
    // By returning this we prevent the table from scrolling back after transition end is called
    return "";
  }
  renderTable() {
    return [
      this.renderSidebar(),
      h("div", { class: "table", style: {
          "--ds-row-border-left-radius": this.selectionenabled ? "0px" : "6px",
        }, ref: (ref) => {
          var _a;
          (_a = this.tableResizeObserver) === null || _a === void 0 ? void 0 : _a.observe(ref);
        } }, this.internalScrollable ? (this.renderScrollableTableContent()) : (h("slot", null)), h("div", { class: {
          "left-gradient": true,
          "show-gradient": this.showLeftGradient,
        }, style: {
          left: `${this.self.scrollLeft}`,
        } }, "\u00A0"), h("div", { class: {
          "right-gradient": true,
          "show-gradient": this.showRightGradient,
        } }, "\u00A0")),
    ];
  }
  renderDefault() {
    return h(Host, { role: "table" }, this.renderTable());
  }
  renderPaginatedCard(shadow) {
    return (h(Host, { role: "table", class: {
        paginated: true,
        "paginated-shadow": shadow,
      } }, h("ds-card", null, h("ds-card-header", null, h("div", null, h("slot", { name: "title" })), h("ds-table-page-size-picker", { value: this.pagesize, pagesizes: this.pagesizes, onPageSizeChanged: (e) => this.handlePaginationPageSizeChanged(e) })), h("ds-card-content", null, h("div", { class: "card-content-bottom-margin" }, this.renderTable())), h("ds-hr", null), h("div", { class: "footer" }, h("ds-paginator", { id: ElementIdGenerator.createId(this.self, "paginator"), onPageChanged: (e) => this.handlePaginationPageChanged(e), range: 1, current: this.currentPage, count: Math.ceil(this.rowcount / this.pagesize) })))));
  }
  static get is() { return "ds-table"; }
  static get encapsulation() { return "shadow"; }
  static get originalStyleUrls() {
    return {
      "$": ["ds-table.scss"]
    };
  }
  static get styleUrls() {
    return {
      "$": ["ds-table.css"]
    };
  }
  static get properties() {
    return {
      "view": {
        "type": "string",
        "mutable": false,
        "complexType": {
          "original": "\"default\" | \"paginated-card\" | \"paginated-card-shadow\"",
          "resolved": "\"default\" | \"paginated-card\" | \"paginated-card-shadow\"",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "default: Default table"
            }, {
              "name": "value",
              "text": "paginated-card: Table within a card with pagination."
            }, {
              "name": "value",
              "text": "paginated-card-shadow: Table within a shadowed card with pagination."
            }, {
              "name": "example",
              "text": "paginator"
            }],
          "text": "Defines the style of this table."
        },
        "attribute": "view",
        "reflect": false,
        "defaultValue": "\"default\""
      },
      "pagesizes": {
        "type": "string",
        "mutable": false,
        "complexType": {
          "original": "string",
          "resolved": "string",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "string: Comma seperated list of numbers (e.g: [25,50,100])."
            }, {
              "name": "example",
              "text": "paginator"
            }],
          "text": "Defines the options for the page size that a user can pick from.\nIt only has an effect if the `view` attribute supports pagination."
        },
        "attribute": "pagesizes",
        "reflect": false,
        "defaultValue": "\"[25,50,100]\""
      },
      "pagesize": {
        "type": "number",
        "mutable": true,
        "complexType": {
          "original": "number",
          "resolved": "number",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "number: Number of rows per page."
            }, {
              "name": "example",
              "text": "paginator"
            }],
          "text": "The initially selected option for the page size.\nIt only has an effect if the `view` attribute supports pagination."
        },
        "attribute": "pagesize",
        "reflect": false,
        "defaultValue": "25"
      },
      "initialsort": {
        "type": "string",
        "mutable": false,
        "complexType": {
          "original": "string",
          "resolved": "string",
          "references": {}
        },
        "required": false,
        "optional": true,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "string: The `columnId` or `label` of the column."
            }, {
              "name": "example",
              "text": "initial-sort"
            }],
          "text": "Defines the column that is used for initially sorting the table."
        },
        "attribute": "initialsort",
        "reflect": false
      },
      "initialsortdirection": {
        "type": "string",
        "mutable": false,
        "complexType": {
          "original": "\"asc\" | \"desc\"",
          "resolved": "\"asc\" | \"desc\"",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "asc: Ascending order."
            }, {
              "name": "value",
              "text": "desc: Descending order."
            }, {
              "name": "example",
              "text": "initial-sort"
            }],
          "text": "Specifies the initial sort direction."
        },
        "attribute": "initialsortdirection",
        "reflect": false,
        "defaultValue": "\"asc\""
      },
      "mode": {
        "type": "string",
        "mutable": false,
        "complexType": {
          "original": "\"managed\" | \"remote\"",
          "resolved": "\"managed\" | \"remote\"",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "managed: The table is responsible for sorting and pagination."
            }, {
              "name": "value",
              "text": "remote: The table relies on an external implementation for creating rows, sorting and pagination using the `tableStateChanged` event."
            }, {
              "name": "example",
              "text": "remote"
            }, {
              "name": "example",
              "text": "remote-complex"
            }],
          "text": "Specifies whether the table is self-managed or remote-controlled."
        },
        "attribute": "mode",
        "reflect": false,
        "defaultValue": "\"managed\""
      },
      "selectionenabled": {
        "type": "boolean",
        "mutable": true,
        "complexType": {
          "original": "boolean",
          "resolved": "boolean",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "true: The selection-group will be opened."
            }, {
              "name": "value",
              "text": "false: The selection-group will be closed."
            }, {
              "name": "example",
              "text": "selection"
            }],
          "text": "**Warning: This feature is highly experimental.**\n\nEnables the selection of rows.\nA `key` for every row has to be specified."
        },
        "attribute": "selectionenabled",
        "reflect": false,
        "defaultValue": "false"
      },
      "selectionmode": {
        "type": "string",
        "mutable": false,
        "complexType": {
          "original": "\"multi\" | \"single\"",
          "resolved": "\"multi\" | \"single\"",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "multi: Multiple rows can be selected."
            }, {
              "name": "value",
              "text": "single: One row can be selected at a time."
            }, {
              "name": "example",
              "text": "selection-mode"
            }],
          "text": "**Warning: This feature is highly experimental.**\n\nSpecifies if only one or multiple rows can be selected."
        },
        "attribute": "selectionmode",
        "reflect": false,
        "defaultValue": "\"multi\""
      },
      "rowcount": {
        "type": "number",
        "mutable": true,
        "complexType": {
          "original": "number",
          "resolved": "number",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "example",
              "text": "remote"
            }, {
              "name": "example",
              "text": "remote-complex"
            }],
          "text": "The data length this table should visualize. In case the table manages itself this attribute should not be set.\nIf the table is remote-controlled this attribute has to be set because the table needs to know the exact amount\nof data to visualize the **paging** accordingly."
        },
        "attribute": "rowcount",
        "reflect": false,
        "defaultValue": "0"
      },
      "scrollable": {
        "type": "boolean",
        "mutable": false,
        "complexType": {
          "original": "boolean",
          "resolved": "boolean",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "true: Table is scrollable."
            }, {
              "name": "value",
              "text": "false: Table is not scrollable."
            }, {
              "name": "example",
              "text": "scrollable"
            }],
          "text": "Specifies if the table should be scrollable. It is necessary to ensure that every `<ds-header-item>` has the width property set."
        },
        "attribute": "scrollable",
        "reflect": false
      }
    };
  }
  static get states() {
    return {
      "currentPage": {},
      "sortState": {},
      "selectedRowKeys": {},
      "showLeftGradient": {},
      "showRightGradient": {},
      "showScrollHint": {},
      "scrollHintNecessary": {},
      "internalScrollable": {},
      "scrollContainer": {}
    };
  }
  static get events() {
    return [{
        "method": "tableStateChanged",
        "name": "tableStateChanged",
        "bubbles": true,
        "cancelable": true,
        "composed": true,
        "docs": {
          "tags": [{
              "name": "example",
              "text": "table-state-changed"
            }],
          "text": "This event will be fired as soon as the table`s state changes (e.g. sorting, paging...)"
        },
        "complexType": {
          "original": "TableConfig",
          "resolved": "TableConfig",
          "references": {
            "TableConfig": {
              "location": "local"
            }
          }
        }
      }, {
        "method": "rowsSelected",
        "name": "rowsSelected",
        "bubbles": true,
        "cancelable": true,
        "composed": true,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "string: If the `selectionmode` allows a single selection the event will delegate one selected row key."
            }, {
              "name": "value",
              "text": "string[]: If the `selectionmode` allows a multi selection the event will delegate all selected row keys.\n**!!!Experimental feature!!!**"
            }],
          "text": "In case a row is selected this event will fire the key of the row."
        },
        "complexType": {
          "original": "string[]",
          "resolved": "string[]",
          "references": {}
        }
      }];
  }
  static get methods() {
    return {
      "invokeSort": {
        "complexType": {
          "signature": "(element: HTMLDsTableHeaderItemElement, reverse: boolean) => Promise<void>",
          "parameters": [{
              "tags": [],
              "text": ""
            }, {
              "tags": [],
              "text": ""
            }],
          "references": {
            "Promise": {
              "location": "global"
            },
            "HTMLDsTableHeaderItemElement": {
              "location": "global"
            }
          },
          "return": "Promise<void>"
        },
        "docs": {
          "text": "",
          "tags": [{
              "name": "internal",
              "text": undefined
            }]
        }
      }
    };
  }
  static get elementRef() { return "self"; }
  static get watchers() {
    return [{
        "propName": "selectionenabled",
        "methodName": "onSideBarOpenChange"
      }, {
        "propName": "scrollable",
        "methodName": "onScrollableChange"
      }];
  }
  static get listeners() {
    return [{
        "name": "touchstart",
        "method": "onTouchStart",
        "target": undefined,
        "capture": false,
        "passive": true
      }, {
        "name": "touchmove",
        "method": "onTouchmove",
        "target": undefined,
        "capture": false,
        "passive": true
      }, {
        "name": "touchend",
        "method": "onTouchEnd",
        "target": undefined,
        "capture": true,
        "passive": true
      }];
  }
}
function hasAnySortableColumns(headerItems) {
  return headerItems === null || headerItems === void 0 ? void 0 : headerItems.some((headerItem) => headerItem.sortable);
}
function equalSortSettings(first, second) {
  return first.column === second.column && first.reverse === second.reverse;
}
