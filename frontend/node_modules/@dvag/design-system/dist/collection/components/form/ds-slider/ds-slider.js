import { forceUpdate, h, Host, } from "@stencil/core";
import { assert } from "../../../classes/assert";
import { onNextFrame } from "../../../classes/render-util";
import { DragController } from "../../../classes/drag-controller";
import { ReadonlyTextElement } from "../../functional/base-elements";
import { clamp } from "../../../classes/math-util";
/**
 * Form element to select a numeric value within the range.
 * @path /Form
 * @name Slider
 * @icon sliders-h
 * @stable
 */
export class DsSlider {
  constructor() {
    this.isDragging = false;
    /**
     * Size of the Steps, the values can be selected.
     * @value number: Minimal possible change.
     * @example step
     */
    this.step = 0.01;
    /**
     * Text on top of the slider, that displays the current value.
     * A dollarsign followed by a number represents the value of the slider.
     * The amount of numbers determines the amount of decimal numbers.
     *
     * @value string: Formatting of the slider value, e.g. `$1 %` or `$2 €`
     * @example formattedvalue
     */
    this.formattedvalue = "$0";
    /**
     * Switches the input to the read-only mode.
     * The value of the element is shown in a simple way. The element is not usable anymore.
     * @value false: Formfield
     * @value true: Value as text
     * @example readonly
     */
    this.readonly = false;
  }
  valueChanged() {
    if (this.value != null && isNaN(this.value)) {
      console.error(`<ds-slider> hat einen ungültigen Zahlenwert für das Attribut 'value' gesetzt.`);
      this.value = null;
    }
  }
  componentWillLoad() {
    this.dragController = new DragController(() => this.value, (e) => {
      var _a;
      const boundingBox = this.self.getBoundingClientRect();
      const leftLimit = boundingBox.left;
      const rightLimit = boundingBox.right;
      const position = Math.max(0, Math.min((e.x - leftLimit) / (rightLimit - leftLimit), 1));
      const computedValue = Math.round((this.min + position * (this.max - this.min)) / this.step) * this.step;
      const fractionDigits = ((_a = this.step.toString().split(".")[1]) === null || _a === void 0 ? void 0 : _a.length) || 0;
      this.value = parseFloat(computedValue.toFixed(fractionDigits));
      this.valueChange.emit(this.value);
    }, () => (this.isDragging = true), () => (this.isDragging = false));
  }
  format(value) {
    if (this.formattedvalue) {
      if (this.formattedvalue.includes("$")) {
        try {
          const match = this.formattedvalue.match(/(.*)(\$\d)(.*)/); // capture 3 groups: before, digits indicator, after
          const digits = parseInt(match[2].substring(1));
          const formattedNumber = value.toFixed(digits).replace(".", ",");
          return match[1] + formattedNumber + match[3];
        }
        catch (e) {
          console.error("Fehler beim Interpretieren der Eigenschaft 'formattedvalue'");
        }
      }
      else {
        return this.formattedvalue;
      }
    }
    return value.toString();
  }
  valueTranslationX(position) {
    if (this.valueElement != null) {
      const valueWidth = this.valueElement.offsetWidth;
      let translateX = SLIDER_KNOB_SIZE / 2 + position * this.getHostWidth() - valueWidth / 2;
      translateX = clamp(translateX, 0, SLIDER_KNOB_SIZE + this.getHostWidth() - valueWidth);
      return translateX;
    }
    return 0;
  }
  getHostWidth() {
    return this.self.clientWidth - SLIDER_KNOB_SIZE;
  }
  render() {
    assert(this.min != null, () => "Für <ds-slider> ist die Angabe eines Min-Wertes erforderlich");
    assert(this.max != null, () => "Für <ds-slider> ist die Angabe eines Max-Wertes erforderlich");
    assert(this.min < this.max, () => "Für <ds-slider> muss der Min-Wert kleiner sein als der Max-Wert");
    assert(this.value >= this.min && this.value <= this.max, () => "Für <ds-slider> muss der Value zwischen Min-Wert und Max-Wert liegen");
    const usedValue = clamp(this.value, this.min, this.max);
    const position = (usedValue - this.min) / (this.max - this.min);
    const sliderWidth = this.getHostWidth(); // slider area - slider knob width
    if (!this.valueElement) {
      onNextFrame(() => forceUpdate(this)); // wait for label to be measurable
    }
    if (this.readonly) {
      return h(ReadonlyTextElement, { text: this.format(usedValue) });
    }
    return (h(Host, { class: {
        "is-dragging": this.isDragging,
      } }, h("div", { class: "form-control" }, h("div", { class: "outer-bar" }, h("div", { class: "inner-bar", style: {
        transform: `scaleX(${position})`,
      } })), h("div", { class: "knob", onPointerDown: (e) => this.dragController.onPointerDown(e), onTouchStart: (e) => this.dragController.onTouchStart(e), style: {
        transform: `translateX(${position * sliderWidth}px)`,
      } }), h("div", { class: {
        value: true,
        visible: this.valueElement != null,
      }, style: {
        transform: `translateX(${this.valueTranslationX(position)}px)`,
      }, ref: (el) => (this.valueElement = el) }, h("ds-text", { type: "fliesstext-fett", screensize: "small" }, this.format(usedValue)))), this.renderLabel()));
  }
  renderLabel() {
    if (this.label) {
      return (h("div", { class: "label" }, h("ds-text", { type: "infotext-klein", screensize: "small" }, this.label)));
    }
  }
  static get is() { return "ds-slider"; }
  static get encapsulation() { return "shadow"; }
  static get originalStyleUrls() {
    return {
      "$": ["ds-slider.scss"]
    };
  }
  static get styleUrls() {
    return {
      "$": ["ds-slider.css"]
    };
  }
  static get properties() {
    return {
      "min": {
        "type": "number",
        "mutable": false,
        "complexType": {
          "original": "number",
          "resolved": "number",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "number: Minimal value of the slider."
            }, {
              "name": "example",
              "text": "min-max-value"
            }],
          "text": "Minimal value of the range, the slider can have."
        },
        "attribute": "min",
        "reflect": false
      },
      "max": {
        "type": "number",
        "mutable": false,
        "complexType": {
          "original": "number",
          "resolved": "number",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "number: Maximum value of the slider."
            }, {
              "name": "example",
              "text": "min-max-value"
            }],
          "text": "Maximum value of the range, the slider can have."
        },
        "attribute": "max",
        "reflect": false
      },
      "step": {
        "type": "number",
        "mutable": false,
        "complexType": {
          "original": "number",
          "resolved": "number",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "number: Minimal possible change."
            }, {
              "name": "example",
              "text": "step"
            }],
          "text": "Size of the Steps, the values can be selected."
        },
        "attribute": "step",
        "reflect": false,
        "defaultValue": "0.01"
      },
      "value": {
        "type": "number",
        "mutable": true,
        "complexType": {
          "original": "number",
          "resolved": "number",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "number: Current value"
            }, {
              "name": "example",
              "text": "min-max-value"
            }],
          "text": "Current value of the slider."
        },
        "attribute": "value",
        "reflect": true
      },
      "formattedvalue": {
        "type": "string",
        "mutable": false,
        "complexType": {
          "original": "string",
          "resolved": "string",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "string: Formatting of the slider value, e.g. `$1 %` or `$2 \u20AC`"
            }, {
              "name": "example",
              "text": "formattedvalue"
            }],
          "text": "Text on top of the slider, that displays the current value.\nA dollarsign followed by a number represents the value of the slider.\nThe amount of numbers determines the amount of decimal numbers."
        },
        "attribute": "formattedvalue",
        "reflect": false,
        "defaultValue": "\"$0\""
      },
      "label": {
        "type": "string",
        "mutable": false,
        "complexType": {
          "original": "string",
          "resolved": "string",
          "references": {}
        },
        "required": false,
        "optional": true,
        "docs": {
          "tags": [{
              "name": "important",
              "text": undefined
            }, {
              "name": "value",
              "text": "string: Text, e.g. `Zinsatz`"
            }, {
              "name": "example",
              "text": "label"
            }],
          "text": "Text under the slider."
        },
        "attribute": "label",
        "reflect": false
      },
      "readonly": {
        "type": "boolean",
        "mutable": false,
        "complexType": {
          "original": "boolean",
          "resolved": "boolean",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "false: Formfield"
            }, {
              "name": "value",
              "text": "true: Value as text"
            }, {
              "name": "example",
              "text": "readonly"
            }],
          "text": "Switches the input to the read-only mode.\nThe value of the element is shown in a simple way. The element is not usable anymore."
        },
        "attribute": "readonly",
        "reflect": false,
        "defaultValue": "false"
      }
    };
  }
  static get states() {
    return {
      "isDragging": {}
    };
  }
  static get events() {
    return [{
        "method": "valueChange",
        "name": "valueChange",
        "bubbles": true,
        "cancelable": true,
        "composed": true,
        "docs": {
          "tags": [{
              "name": "example",
              "text": "value-change"
            }],
          "text": "User made changes. Contains the chosen value."
        },
        "complexType": {
          "original": "number",
          "resolved": "number",
          "references": {}
        }
      }];
  }
  static get elementRef() { return "self"; }
  static get watchers() {
    return [{
        "propName": "value",
        "methodName": "valueChanged"
      }];
  }
}
const SLIDER_KNOB_SIZE = 32;
