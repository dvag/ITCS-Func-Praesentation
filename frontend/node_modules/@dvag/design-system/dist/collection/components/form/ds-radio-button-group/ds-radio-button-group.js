import { h, Host, } from "@stencil/core";
import { SlotObserver } from "../../../classes/slot-observer";
import { findDuplicatedValues } from "../../../classes/value";
import { assert } from "../../../classes/assert";
import { ReadonlyTextElement } from "../../functional/base-elements";
import { ErrorPopup } from "../../functional/error-popup";
/**
 * Form element which offers multiple options in the form of `<ds-radio-button>` elements.
 * Only one option can be selected at a time.
 *
 * @path /Form
 * @name Radio-Button-Group
 * @shortname Radio
 * @icon object-group
 * @stable
 *
 * @slot - One or more `<ds-radio-button>` elements.
 */
export class DsRadioButtonGroup {
  constructor() {
    this.shouldEmitValueChange = false;
    this.radioButtons = [];
    this.inputFocused = false;
    /**
     * @internal
     */
    this.radiogroupid = `${++radioGroupCounter}`;
    /**
     * Defines if the group is in a read-only state.
     * The label of the current selected radio button will be displayed.
     *
     * @value false: The component is displayed normally.
     * @value true: The current selected option is displayed as text. If no option is selected no text will be displayed.
     * @example readonly
     */
    this.readonly = false;
    /**
     * Defines if the radio button group is a required form element.
     * @value false: It is not required to select an option.
     * @value true: To fulfill the requirement one option has to be selected.
     * @example required
     */
    this.required = false;
    /**
     * Sets the error state on the group.
     *
     * @value true: An error exists.
     * @value false: No error exists.
     * @example error
     */
    this.error = false;
    /**
     * Disables the ability to interact with this component.
     * Every option inside will also be set to `disabled`.
     *
     * @value false: User can select an option.
     * @value true: User cannot select an option.
     *
     * @example disabled
     */
    this.disabled = false;
  }
  onErrorMessageChange() {
    if (this.isConnectedToBorderedFormGroup()) {
      this.borderedFormGroup.errormessage = this.errormessage;
    }
  }
  onDisabledChange() {
    this.radioButtons.forEach((radioButton) => {
      if (this.disabled) {
        radioButton.classList.add("disabled");
      }
      else if (!radioButton.disabled) {
        radioButton.classList.remove("disabled");
      }
    });
  }
  valueChanged(newValue, oldValue) {
    if (newValue === oldValue) {
      return;
    }
    this.updateCheckedStates();
    this.emitValueChange();
    this.handleRequirement();
  }
  onKeyUp(e) {
    if (!this.disabled &&
      (e.code === "ArrowDown" ||
        e.code === "ArrowUp" ||
        e.code === "ArrowLeft" ||
        e.code === "ArrowRight") &&
      this.radioButtons.includes(e.target)) {
      e.preventDefault();
      const enabledRadioButtons = this.radioButtons.filter((radioButton) => !radioButton.disabled);
      if (enabledRadioButtons.length === 0) {
        return;
      }
      const currentValueIndex = enabledRadioButtons.findIndex((radioButton) => radioButton.value === this.value);
      const nextRadioButtonIndex = (e.code === "ArrowDown" || e.code === "ArrowRight"
        ? currentValueIndex + 1
        : currentValueIndex - 1 + enabledRadioButtons.length) %
        enabledRadioButtons.length;
      const newSelectedRadioButton = enabledRadioButtons[nextRadioButtonIndex];
      this.select(newSelectedRadioButton.value).then();
      newSelectedRadioButton.focusControl().then();
    }
  }
  onChildFocused() {
    this.inputFocused = true;
  }
  onChildBlurred() {
    this.inputFocused = false;
  }
  /**
   * Sets the focus on the radio group.
   *
   * If an option is selected it will be focused.
   * If no option is selected the first option will be focused.
   * @example focus
   */
  async focusControl() {
    var _a;
    if (this.radioButtons.length === 0) {
      return;
    }
    const radioButton = (_a = this.getSelectedRadioButton()) !== null && _a !== void 0 ? _a : this.radioButtons[0];
    radioButton.focusControl().then();
  }
  /**
   * @internal
   */
  async select(value) {
    this.shouldEmitValueChange = true;
    this.value = value;
  }
  connectedCallback() {
    this.init();
  }
  componentDidLoad() {
    this.init();
  }
  disconnectedCallback() {
    var _a;
    (_a = this.slotObserver) === null || _a === void 0 ? void 0 : _a.disconnect();
  }
  updateCheckedStates() {
    this.radioButtons.forEach((radioButton) => {
      radioButton.internalSetChecked(radioButton.value === this.value).then();
    });
  }
  emitValueChange() {
    if (this.shouldEmitValueChange) {
      this.valueChange.emit(this.value);
    }
    this.shouldEmitValueChange = false;
  }
  hasError() {
    var _a;
    return this.error || ((_a = this.errormessage) === null || _a === void 0 ? void 0 : _a.length) > 0;
  }
  injectStates() {
    this.radioButtons.forEach((radioButton) => {
      radioButton.setAttribute("required", this.required + "");
      radioButton.setAttribute("error", this.hasError() + "");
      radioButton.setAttribute("requirementfulfilled", "" + (this.value != null));
    });
  }
  getSelectedRadioButton() {
    return this.radioButtons.find((radioButton) => {
      return radioButton.value === this.value;
    });
  }
  init() {
    if (this.slotObserver == null) {
      this.slotObserver = new SlotObserver(this.self, "ds-radio-button", async (nodes) => {
        this.radioButtons = nodes;
        this.radioButtons.forEach((radioButton) => {
          if (this.disabled) {
            radioButton.classList.add("disabled");
          }
        });
        this.updateCheckedStates();
        this.injectStates();
        const duplicates = findDuplicatedValues(this.radioButtons);
        assert(duplicates.length == 0, () => `There should not be any duplicated values within <ds-radio-button-group> elements!\nFollowing duplicates were found: ${duplicates.join()}`, this.self);
        this.borderedFormGroup = this.self.querySelector("ds-bordered-form-group");
        this.handleRequirement();
        this.handleErrorMessage();
      });
    }
  }
  handleRequirement() {
    if (this.isConnectedToBorderedFormGroup()) {
      this.borderedFormGroup.requirementfulfilled = this.value != null;
    }
  }
  handleErrorMessage() {
    if (this.isConnectedToBorderedFormGroup()) {
      this.borderedFormGroup.errormessage = this.errormessage;
    }
  }
  isConnectedToBorderedFormGroup() {
    return this.borderedFormGroup != null;
  }
  renderErrorPopup() {
    if (this.errormessage && !this.isConnectedToBorderedFormGroup()) {
      return (h(ErrorPopup, { text: this.errormessage, show: this.inputFocused }));
    }
  }
  componentShouldUpdate(_, __, propName) {
    if (["required", "error", "errormessage", "disabled", "value"].includes(propName)) {
      this.injectStates();
    }
  }
  render() {
    var _a, _b;
    if (this.readonly) {
      return (h(ReadonlyTextElement, { text: (_b = (_a = this.getSelectedRadioButton()) === null || _a === void 0 ? void 0 : _a.label) !== null && _b !== void 0 ? _b : "" }));
    }
    return (h(Host, { class: {
        required: this.required,
        "requirement-fulfilled": !!this.value,
      } }, h("div", { class: { container: !this.isConnectedToBorderedFormGroup() } }, h("slot", null), this.renderErrorPopup(), h("ds-required-hint", { required: this.required && !this.isConnectedToBorderedFormGroup(), fulfilled: !!this.value }))));
  }
  static get is() { return "ds-radio-button-group"; }
  static get encapsulation() { return "shadow"; }
  static get originalStyleUrls() {
    return {
      "$": ["ds-radio-button-group.scss"]
    };
  }
  static get styleUrls() {
    return {
      "$": ["ds-radio-button-group.css"]
    };
  }
  static get properties() {
    return {
      "radiogroupid": {
        "type": "string",
        "mutable": false,
        "complexType": {
          "original": "string",
          "resolved": "string",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "internal",
              "text": undefined
            }],
          "text": ""
        },
        "attribute": "radiogroupid",
        "reflect": true,
        "defaultValue": "`${++radioGroupCounter}`"
      },
      "readonly": {
        "type": "boolean",
        "mutable": false,
        "complexType": {
          "original": "boolean",
          "resolved": "boolean",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "false: The component is displayed normally."
            }, {
              "name": "value",
              "text": "true: The current selected option is displayed as text. If no option is selected no text will be displayed."
            }, {
              "name": "example",
              "text": "readonly"
            }],
          "text": "Defines if the group is in a read-only state.\nThe label of the current selected radio button will be displayed."
        },
        "attribute": "readonly",
        "reflect": false,
        "defaultValue": "false"
      },
      "required": {
        "type": "boolean",
        "mutable": false,
        "complexType": {
          "original": "boolean",
          "resolved": "boolean",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "false: It is not required to select an option."
            }, {
              "name": "value",
              "text": "true: To fulfill the requirement one option has to be selected."
            }, {
              "name": "example",
              "text": "required"
            }],
          "text": "Defines if the radio button group is a required form element."
        },
        "attribute": "required",
        "reflect": false,
        "defaultValue": "false"
      },
      "errormessage": {
        "type": "string",
        "mutable": false,
        "complexType": {
          "original": "string",
          "resolved": "string",
          "references": {}
        },
        "required": false,
        "optional": true,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "string: Error text"
            }, {
              "name": "example",
              "text": "error"
            }],
          "text": "A text which is displayed in an error popup below the component."
        },
        "attribute": "errormessage",
        "reflect": false
      },
      "error": {
        "type": "boolean",
        "mutable": false,
        "complexType": {
          "original": "boolean",
          "resolved": "boolean",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "true: An error exists."
            }, {
              "name": "value",
              "text": "false: No error exists."
            }, {
              "name": "example",
              "text": "error"
            }],
          "text": "Sets the error state on the group."
        },
        "attribute": "error",
        "reflect": false,
        "defaultValue": "false"
      },
      "disabled": {
        "type": "boolean",
        "mutable": false,
        "complexType": {
          "original": "boolean",
          "resolved": "boolean",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "false: User can select an option."
            }, {
              "name": "value",
              "text": "true: User cannot select an option."
            }, {
              "name": "example",
              "text": "disabled"
            }],
          "text": "Disables the ability to interact with this component.\nEvery option inside will also be set to `disabled`."
        },
        "attribute": "disabled",
        "reflect": false,
        "defaultValue": "false"
      },
      "value": {
        "type": "string",
        "mutable": true,
        "complexType": {
          "original": "string",
          "resolved": "string",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "string: The value of an inner radio button."
            }, {
              "name": "example",
              "text": "value"
            }, {
              "name": "example",
              "text": "read-value"
            }, {
              "name": "example",
              "text": "write-value"
            }],
          "text": "This property mirrors the current selected option.\nIf set, an inner radio button with the same `value` has to exist."
        },
        "attribute": "value",
        "reflect": true
      }
    };
  }
  static get states() {
    return {
      "radioButtons": {},
      "inputFocused": {}
    };
  }
  static get events() {
    return [{
        "method": "valueChange",
        "name": "valueChange",
        "bubbles": true,
        "cancelable": true,
        "composed": true,
        "docs": {
          "tags": [{
              "name": "example",
              "text": "read-value"
            }],
          "text": "Delegates the current selected `<ds-radio-button>` element's value.\nThis event will not trigger when setting the `value` in JavaScript."
        },
        "complexType": {
          "original": "string",
          "resolved": "string",
          "references": {}
        }
      }];
  }
  static get methods() {
    return {
      "focusControl": {
        "complexType": {
          "signature": "() => Promise<void>",
          "parameters": [],
          "references": {
            "Promise": {
              "location": "global"
            }
          },
          "return": "Promise<void>"
        },
        "docs": {
          "text": "Sets the focus on the radio group.\n\nIf an option is selected it will be focused.\nIf no option is selected the first option will be focused.",
          "tags": [{
              "name": "example",
              "text": "focus"
            }]
        }
      },
      "select": {
        "complexType": {
          "signature": "(value: string) => Promise<void>",
          "parameters": [{
              "tags": [],
              "text": ""
            }],
          "references": {
            "Promise": {
              "location": "global"
            }
          },
          "return": "Promise<void>"
        },
        "docs": {
          "text": "",
          "tags": [{
              "name": "internal",
              "text": undefined
            }]
        }
      }
    };
  }
  static get elementRef() { return "self"; }
  static get watchers() {
    return [{
        "propName": "errormessage",
        "methodName": "onErrorMessageChange"
      }, {
        "propName": "disabled",
        "methodName": "onDisabledChange"
      }, {
        "propName": "value",
        "methodName": "valueChanged"
      }];
  }
  static get listeners() {
    return [{
        "name": "keydown",
        "method": "onKeyUp",
        "target": undefined,
        "capture": false,
        "passive": false
      }, {
        "name": "focus",
        "method": "onChildFocused",
        "target": undefined,
        "capture": true,
        "passive": false
      }, {
        "name": "blur",
        "method": "onChildBlurred",
        "target": undefined,
        "capture": true,
        "passive": false
      }];
  }
}
let radioGroupCounter = 0;
