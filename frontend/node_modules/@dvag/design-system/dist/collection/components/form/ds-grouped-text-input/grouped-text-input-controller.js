import { numberToConfig } from "./configConverter";
import { characterMaskIndicator, numberMaskIndicator, } from "./input-group";
export class GroupedTextInputController {
  constructor(inputGroup) {
    this.inputGroup = inputGroup;
    this.inputElement = null;
    this.lastValue = "";
  }
  setInputElement(el) {
    if (this.inputElement !== el) {
      this.inputElement = el;
    }
  }
  getInputGroup() {
    return this.inputGroup;
  }
  getInputElement() {
    return this.inputElement;
  }
  getInputValue() {
    var _a;
    return (_a = this.inputElement) === null || _a === void 0 ? void 0 : _a.value;
  }
  extractCharacters(amount, inputType) {
    const extracted = this.inputElement.value.substring(0, amount);
    this.inputElement.value = this.inputElement.value.slice(amount);
    this.onDeleteEvent(this, inputType);
    return extracted;
  }
  appendExtractedToValue(toBeSet, inputType) {
    this.inputElement.value += toBeSet;
    const newCaretPosition = inputType == "deleteContentBackward"
      ? this.caretPosition - 1
      : this.caretPosition;
    this.inputElement.selectionStart = newCaretPosition;
    this.inputElement.selectionEnd = newCaretPosition;
    this.caretPosition = newCaretPosition;
  }
  clearInput() {
    this.inputElement.value = "";
    this.lastValue = "";
    this.recomputeTextInputWidth();
  }
  checkIsFulfilled() {
    var _a;
    return ((_a = this.inputElement) === null || _a === void 0 ? void 0 : _a.value.length) == this.inputGroup.pattern.length;
  }
  focus() {
    this.inputElement.focus();
  }
  focusAndSetCaretPosition(selectionStart, selectionEnd) {
    this.inputElement.focus();
    this.inputElement.selectionStart = selectionStart;
    this.inputElement.selectionEnd = selectionEnd;
  }
  saveCurrentValue() {
    this.lastValue = this.inputElement.value;
  }
  resetToLastValue() {
    this.inputElement.value = this.lastValue;
  }
  checkPreventInput(e) {
    if (this.inputGroup.pattern[0] === characterMaskIndicator) {
      if (!e.data[0].match(/[a-zA-Z\W_]/)) {
        return true;
      }
    }
    else {
      if (!e.data[0].match(/\d/)) {
        return true;
      }
    }
    return false;
  }
  onInput(e) {
    e.preventDefault();
    if (!e.isTrusted) {
      if (this.shouldPrefixValue(e)) {
        this.inputElement.value = e.data + this.inputElement.value;
      }
      else {
        this.inputElement.value += e.data;
      }
    }
    const eventProps = numberToConfig(Number(e.detail));
    this.handleDeleteEvent(e);
    const overflow = this.handlePaste(e, eventProps.focusNext);
    this.handleOverflow(overflow, e.isTrusted, eventProps.focusNext);
    if (e.data != null && this.checkPreventInput(e)) {
      this.resetToLastValue();
      return;
    }
    this.saveCurrentValue();
    this.recomputeTextInputWidth();
    this.onValueChanged();
  }
  handleOverflow(overflow, currentlyFocused, shouldFocusNext = true) {
    const caretPosition = currentlyFocused
      ? this.inputElement.selectionStart - 1
      : null;
    const overflowsFromPaste = overflow.length > 0;
    const inputElementValue = this.getInputValue();
    const isOverflowing = overflowsFromPaste ||
      inputElementValue.length >= this.inputGroup.width + 1;
    if (isOverflowing) {
      if (overflowsFromPaste) {
        this.inputInNextGroupedInput(overflow, true, true, shouldFocusNext, 0);
      }
      else {
        const pushedChar = inputElementValue.slice(-1);
        this.inputElement.value = this.inputElement.value.slice(0, this.inputGroup.width);
        if (caretPosition != null) {
          this.inputElement.selectionStart = caretPosition + 1;
          this.inputElement.selectionEnd = caretPosition + 1;
        }
        const gotoNextInput = this.inputGroup.width == caretPosition;
        this.inputInNextGroupedInput(pushedChar, false, true, gotoNextInput, 1);
      }
    }
  }
  handlePaste(e, shouldFocusNext = true) {
    if (e.inputType === "insertFromPaste") {
      const inputValue = this.getInputValue();
      const remaining = inputValue.substring(0, this.inputGroup.width);
      this.acceptPasteOrReset(remaining, shouldFocusNext);
      const overflow = inputValue.substring(this.inputGroup.width, inputValue.length);
      return overflow;
    }
    return "";
  }
  handleDeleteEvent(e) {
    if (this.isDeleteEvent(e)) {
      const inputValue = this.getInputValue();
      this.onDeleteEvent(this, e.inputType);
      if (inputValue == undefined || inputValue.length == 0) {
        this.saveCurrentValue();
        this.focusPrevController();
      }
      this.recomputeTextInputWidth();
      this.caretPosition = this.inputElement.selectionStart;
    }
  }
  shouldPrefixValue(e) {
    const result = numberToConfig(Number(e.detail));
    return result.prefix;
  }
  acceptPasteOrReset(remaining, shouldFocus = true) {
    if (this.checkPattern(remaining)) {
      this.inputElement.value = remaining;
      if (shouldFocus) {
        this.inputElement.focus();
      }
    }
    else {
      this.resetToLastValue();
    }
  }
  isDeleteEvent(e) {
    return (e.inputType === "deleteContentBackward" ||
      e.inputType === "deleteContentForward");
  }
  handleKeyDown(event) {
    if (event.code === "Backspace") {
      this.saveCurrentValue();
      if (this.inputElement.selectionStart == 0) {
        this.focusPrevController();
      }
    }
  }
  checkPattern(actualValue) {
    const pattern = this.inputGroup.pattern;
    return !actualValue.split("").some((char, index) => {
      if (pattern[index] === characterMaskIndicator) {
        if (/\d/.test(char)) {
          return true;
        }
      }
      else if (pattern[index] === numberMaskIndicator) {
        if (!/\d/.test(char)) {
          return true;
        }
      }
      else if (pattern[index] !== char) {
        return true;
      }
      return false;
    });
  }
  inputInNextGroupedInput(data, paste, prefix = false, focusNext, caretPosition) {
    this.onOverflow({
      data: data,
      input: this,
      paste: paste,
      shouldPrefix: prefix,
      focusNext: focusNext,
      caretPosition: caretPosition,
    });
  }
  focusPrevController() {
    this.onGotoGroup(this, true);
  }
  focusNextController() {
    this.onGotoGroup(this, false);
  }
  handleArrowKey(e) {
    e.preventDefault();
    const position = this.inputElement.selectionStart;
    const valueLength = this.inputElement.value.length;
    if (valueLength == undefined) {
      return;
    }
    if (this.caretPosition === position) {
      if (e.key === "ArrowLeft") {
        if (position === 0 || valueLength === 0) {
          this.focusPrevController();
        }
      }
      else if (e.key === "ArrowRight") {
        if (position === valueLength || valueLength === 0) {
          this.focusNextController();
        }
      }
    }
    this.caretPosition = position;
  }
  onBlur() {
    this.caretPosition = null;
  }
  recomputeTextInputWidth() {
    const textWidthPlaceholderSpace = 8;
    // width calculation needs an extra tweaking.
    const span = document.createElement("span");
    span.style.fontFamily = "Helvetica Neue LT W01";
    span.style.height = "auto";
    span.style.width = "auto";
    span.style.position = "absolute";
    span.style.whiteSpace = "no-wrap";
    span.style.top = "-10000px";
    span.style.opacity = "0";
    span.innerHTML =
      this.inputElement.value.length > 0
        ? this.inputElement.value
        : this.inputGroup.pattern;
    document.body.appendChild(span);
    const width = Math.max(span.clientWidth, this.inputGroup.width * textWidthPlaceholderSpace);
    document.body.removeChild(span);
    this.inputElement.style.width = `${width}px`;
  }
}
