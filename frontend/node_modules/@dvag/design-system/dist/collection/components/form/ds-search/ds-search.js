import { h, Host, } from "@stencil/core";
import { ElementIdGenerator, verifyElementId, } from "../../../classes/element-id-handling";
import { Debounce } from "../../../classes/debounce";
import { SearchAutoCompleteHandler } from "./auto-complete-value";
import { onNextFrame } from "../../../classes/render-util";
import { isIos } from "../../../classes/platform.util";
import { InputContainer } from "../../functional/input-container";
/**
 * Searchbar
 *
 * If the user makes an entry in the search field, the `search` event is triggered.
 * This enables the asynchronous supply of search suggestions. If the user selects
 * a search suggestion, a searchSelect event will be triggered.
 *
 * @path /Form
 * @name Search Input
 * @shortname Search
 * @icon search
 * @experimental
 */
export class DsSearch {
  constructor() {
    this.searchDebounce = new Debounce(500);
    this.categories = new Map();
    this.navigatableListItems = [];
    this.inputFocused = false;
    this.internalValue = "";
    this.waitForSearchValues = false;
    this.popupopen = false;
    /**
     * Specifies the search term.
     * @value string: Search term
     */
    this.value = "";
    /**
     * Specifies the placeholder text of this component.
     * @value string: Text used as the placeholder.
     */
    this.placeholder = "Bitte eingeben ...";
    /**
     * Specifies how many entries are visible when the popup is open.
     *
     * @value number: a number like 2.5 or 4.5
     * @example example
     */
    this.visibleentries = 2.5;
    /**
     * Specifies the text that will be shown when there are no search results.
     * @value string: Text which will be displayed.
     * @example no-results-text
     */
    this.noresultstext = "Ihre Suche ergab leider keine Treffer.";
    /**
     * Component will call the browsers `scrollIntoView()` method on the form
     * component after each search request. So the user can easily see the popup to choose from.
     *
     * @value true: Component will scroll popup list into view.
     * @value false: Component won't touch scrolling at all.
     * @example autoscrollintoview
     */
    this.autoscrollintoview = false;
  }
  valueChanged() {
    this.obtainValueChangesFromOutside();
  }
  /**
   * Focuses this search.
   */
  async focusControl() {
    this.inputElement.focus();
  }
  componentWillLoad() {
    verifyElementId(this.self);
    this.obtainValueChangesFromOutside();
  }
  componentDidRender() {
    if (this.selectedOption != undefined && this.popupopen)
      this.scrollIntoView(this.selectedOption);
  }
  disconnectedCallback() {
    this.searchDebounce.reset();
  }
  obtainValueChangesFromOutside() {
    if (this.value !== this.internalValue) {
      this.internalValue = this.value;
      this.lastEmittedCompleteValue = this.value;
      this.selectedOption = this.createDummySelectedOptionWithCurrentValue();
    }
  }
  createDummySelectedOptionWithCurrentValue() {
    var _a;
    return ((_a = this.value) === null || _a === void 0 ? void 0 : _a.length) > 0
      ? {
        id: null,
        label: this.value,
        prelabel: null,
        sublabel: null,
        category: null,
        data: null,
      }
      : null;
  }
  onInputFocused() {
    this.popupopen = true;
    this.inputFocused = true;
    this.emitSearchEvent();
  }
  onInputBlurred() {
    onNextFrame(() => {
      this.waitForSearchValues = false;
      this.popupopen = false;
      this.emitValueChange();
      this.emitValueComplete();
      // If we already set inputFocused to false we don't want to
      if (this.inputFocused) {
        this.inputFocused = false;
        this.selectSearchValue(this.selectedOption);
      }
    });
  }
  clearInput() {
    this.inputElement.value = "";
    this.internalValue = "";
    this.selectedOption = null;
    this.searchValues = null;
    this.popupopen = false;
    this.selectSearch.emit(null);
    this.emitValueChange();
  }
  blurInput() {
    var _a;
    this.inputFocused = false;
    (_a = this.inputElement) === null || _a === void 0 ? void 0 : _a.blur();
  }
  getCurrentSearchValue() {
    var _a, _b, _c;
    if (!this.popupopen) {
      return null;
    }
    return ((_b = (_a = this.searchValues) === null || _a === void 0 ? void 0 : _a.find((searchValue) => searchValue.label.toLowerCase() === this.internalValue.toLowerCase())) !== null && _b !== void 0 ? _b : (_c = this.searchValues) === null || _c === void 0 ? void 0 : _c[0]);
  }
  onInputKeyUp(event) {
    if (this.handleUpAndDownNavigation(event)) {
      //NO-OP
    }
    else if (["Enter", "Escape"].includes(event.key)) {
      if ("Enter".includes(event.key)) {
        const directMatch = this.getCurrentSearchValue();
        if (directMatch == null) {
          this.clearInput();
          this.blurInput();
          return;
        }
        this.selectedOption = directMatch;
        this.selectSearchValue(this.selectedOption);
      }
      if ("Escape".includes(event.code) && this.popupopen) {
        this.popupopen = false;
      }
    }
  }
  handleUpAndDownNavigation(event) {
    var _a;
    if (["ArrowDown", "ArrowUp"].includes(event.code)) {
      if (((_a = this.navigatableListItems) === null || _a === void 0 ? void 0 : _a.length) > 0 && this.popupopen) {
        // no searchvalues present-> prevent select actions
        this.selectEntryWithArrowDownOrUp(event.code);
        event.preventDefault();
        event.stopImmediatePropagation();
        return true;
      }
      else if (this.internalValue === "") {
        //keep the popup closed no text in the input
        return;
      }
      else if (!this.popupopen) {
        this.emitSearchEvent();
        this.popupopen = true;
      }
    }
    return false;
  }
  selectEntryWithArrowDownOrUp(keyCode) {
    let selectedIndex = this.navigatableListItems.findIndex((option) => {
      var _a;
      if (instanceOfSearchAutocompleteValue(option)) {
        return option.id === ((_a = this.selectedOption) === null || _a === void 0 ? void 0 : _a.id);
      }
    });
    if (keyCode === "ArrowDown") {
      if (selectedIndex === -1 ||
        selectedIndex === this.navigatableListItems.length - 1) {
        this.selectOption(this.navigatableListItems.find((o) => instanceOfSearchAutocompleteValue(o)));
      }
      else {
        selectedIndex++;
        if (!instanceOfSearchAutocompleteValue(this.navigatableListItems[selectedIndex])) {
          selectedIndex++;
        }
        this.selectOption(this.navigatableListItems[selectedIndex]);
      }
    }
    else if (keyCode === "ArrowUp") {
      if (selectedIndex <= 0) {
        this.selectOption(this.navigatableListItems[this.navigatableListItems.length - 1]);
      }
      else {
        selectedIndex--;
        if (selectedIndex <= 0) {
          selectedIndex = this.navigatableListItems.length - 1;
        }
        if (!instanceOfSearchAutocompleteValue(this.navigatableListItems[selectedIndex])) {
          selectedIndex--;
        }
        if (selectedIndex > 0) {
          this.selectOption(this.navigatableListItems[selectedIndex]);
        }
      }
    }
  }
  selectOption(option) {
    this.selectedOption = option;
    this.internalValue = this.selectedOption.label;
    this.emitValueChange();
    this.scrollIntoView(this.selectedOption);
  }
  selectSearchValue(value) {
    if (value == undefined) {
      return;
    }
    this.selectedOption = value;
    this.internalValue = value.label;
    this.searchValues = null;
    this.selectSearch.emit(value);
    this.popupopen = false;
    this.blurInput();
  }
  scrollIntoView(optionToView) {
    var _a, _b, _c;
    if (this.popupopen) {
      const selectedIndex = this.navigatableListItems.findIndex((option) => option.id === (optionToView === null || optionToView === void 0 ? void 0 : optionToView.id));
      if (selectedIndex > -1) {
        const list = this.self.shadowRoot.querySelector(".autocomplete-popup");
        const items = Array.from(this.self.shadowRoot.querySelectorAll(".autocomplete-item"));
        const listHeight = (_a = list === null || list === void 0 ? void 0 : list.offsetHeight) !== null && _a !== void 0 ? _a : 0;
        const itemHeight = (_c = (_b = items[0]) === null || _b === void 0 ? void 0 : _b.offsetHeight) !== null && _c !== void 0 ? _c : 0;
        list.scrollTop =
          itemHeight * selectedIndex - listHeight / 2 + itemHeight / 2;
      }
    }
  }
  onInputInput() {
    var _a;
    this.internalValue = this.inputElement.value;
    if (((_a = this.internalValue) === null || _a === void 0 ? void 0 : _a.length) > 0) {
      this.popupopen = true;
      this.emitValueChange();
    }
    else {
      this.popupopen = false;
      this.searchValues = null;
    }
    this.searchDebounce.run(() => {
      this.emitSearchEvent();
    });
  }
  emitSearchEvent() {
    this.waitForSearchValues = true;
    const searchId = dsSearchIdCounter++;
    const handler = new SearchAutoCompleteHandler(searchId, this.internalValue);
    handler.waitForValues().then((id) => {
      if (this.lastSearchId === id) {
        this.searchValues = handler.getValues();
        this.extractCategories();
        this.waitForSearchValues = false;
        if (this.autoscrollintoview && this.searchValues.length > 0) {
          onNextFrame(() => onNextFrame(() => this.inputElement.scrollIntoView({
            block: "start",
            behavior: "smooth",
          })));
        }
      }
    });
    this.lastSearchId = searchId;
    this.search.emit(handler);
  }
  extractCategories() {
    this.categories.clear();
    this.navigatableListItems = [];
    if (this.searchValues == undefined) {
      return;
    }
    this.populateCategoriesFromSearchResults();
    this.fillNavigatableListFromCategories();
  }
  populateCategoriesFromSearchResults() {
    this.searchValues.forEach((value) => {
      var _a, _b;
      if (value.category == undefined || value.category == "") {
        this.categories.set(null, [
          ...((_a = this.categories.get(null)) !== null && _a !== void 0 ? _a : []),
          value,
        ]);
      }
      else {
        this.categories.set(value.category, [
          ...((_b = this.categories.get(value.category)) !== null && _b !== void 0 ? _b : []),
          value,
        ]);
      }
    });
  }
  fillNavigatableListFromCategories() {
    Array.from(this.categories.keys()).map((headline) => {
      this.navigatableListItems.push({
        label: headline,
      });
      this.categories.get(headline).forEach((v) => {
        this.navigatableListItems.push(v);
      });
    });
  }
  emitValueComplete() {
    if (this.lastEmittedCompleteValue !== this.internalValue) {
      this.valueComplete.emit(this.internalValue);
      this.value = this.internalValue;
      this.lastEmittedCompleteValue = this.internalValue;
    }
  }
  emitValueChange() {
    if (this.lastEmittedChangeValue !== this.internalValue) {
      this.lastEmittedChangeValue = this.internalValue;
      this.value = this.internalValue;
      this.valueChange.emit(this.internalValue);
    }
  }
  render() {
    return h(Host, null, this.renderInput());
  }
  renderInput() {
    const popupHeight = this.visibleentries * POPUP_ENTRY_HEIGHT;
    return (h("dx-overlay", { position: "bottom", offsety: 4, disabled: !this.popupopen }, h(InputContainer, { active: this.inputFocused, title: this.value }, h("ds-icon", { icon: "suchen", size: 24 }), h("input", { id: ElementIdGenerator.createId(this.self, "control"), ref: (el) => (this.inputElement = el), onInput: () => this.onInputInput(), onKeyUp: (event) => this.onInputKeyUp(event), onFocus: () => this.onInputFocused(), onBlur: () => this.onInputBlurred(), type: "text", placeholder: this.placeholder, value: this.internalValue }), this.renderClearButton()), this.renderAutocompleteValues(popupHeight)));
  }
  renderClearButton() {
    const isClearButtonVisible = this.internalValue !== "" && this.inputFocused;
    return (h("ds-function-icon-button", { id: ElementIdGenerator.createId(this.self, "clear-button"), unfocusable: true, class: {
        "clear-button": true,
        visible: isClearButtonVisible,
      }, onPointerDown: () => this.clearInput() }, h("ds-icon", { icon: "schliessen-input", size: 16 })));
  }
  renderAutocompleteValues(popupHeight) {
    if (!this.popupopen) {
      return;
    }
    return (h("div", { class: "autocomplete-container", slot: "overlay" }, h("div", { class: "autocomplete-popup", style: {
        "--ds-search-popup-height": `${popupHeight}px`,
      } }, this.renderPopupContent())));
  }
  renderPopupContent() {
    if (this.waitForSearchValues) {
      return this.renderWaitingSpinner();
    }
    if (this.searchValues == undefined) {
      return;
    }
    if (this.searchValues.length === 0) {
      return this.renderEmptySearchResults();
    }
    return this.renderCategories();
  }
  renderCategories() {
    return Array.from(this.categories.keys()).map((key) => {
      return (h("div", { class: "category-container" }, this.renderCategoryHeadline(key), h("div", null, Array.from(this.categories.get(key)).map((entry) => {
        var _a, _b;
        return (h("div", { class: {
            "autocomplete-item": true,
            selected: (entry === null || entry === void 0 ? void 0 : entry.label) == ((_a = this.selectedOption) === null || _a === void 0 ? void 0 : _a.label) &&
              entry.category == ((_b = this.selectedOption) === null || _b === void 0 ? void 0 : _b.category),
          }, onPointerDown: () => {
            // because autocomplete list is attached to input's focus state
            // it's too late to wait for a click's mouseup part.
            if (!isIos()) {
              this.selectSearchValue(entry);
            }
          }, onClick: () => {
            // we can't use pointerdown at ios because of scrolling behavior
            if (isIos()) {
              this.selectSearchValue(entry);
            }
          } }, this.renderAutoCompleteItem(entry)));
      }))));
    });
  }
  renderCategoryHeadline(key) {
    if (key != undefined && key != "") {
      return (h("div", { class: "category-headline-container" }, h("ds-text", { class: "category-headline", type: "ftf" }, key)));
    }
  }
  renderWaitingSpinner() {
    return (h("div", { class: "wait-for-search-results" }, h("ds-spinner", { size: "medium" })));
  }
  renderEmptySearchResults() {
    return (h("div", { class: "no-hits" }, h("ds-text", { type: "it" }, this.noresultstext)));
  }
  renderAutoCompleteItem(value) {
    const renderText = (text, type = undefined) => {
      return (text === null || text === void 0 ? void 0 : text.length) > 0 ? h("ds-text", { type: type }, text) : null;
    };
    return (h("ds-column", null, [
      renderText(value.prelabel, "itk"),
      renderText(value.label),
      renderText(value.sublabel, "itk"),
    ]));
  }
  static get is() { return "ds-search"; }
  static get encapsulation() { return "shadow"; }
  static get originalStyleUrls() {
    return {
      "$": ["ds-search.scss"]
    };
  }
  static get styleUrls() {
    return {
      "$": ["ds-search.css"]
    };
  }
  static get properties() {
    return {
      "value": {
        "type": "string",
        "mutable": true,
        "complexType": {
          "original": "string",
          "resolved": "string",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "string: Search term"
            }],
          "text": "Specifies the search term."
        },
        "attribute": "value",
        "reflect": true,
        "defaultValue": "\"\""
      },
      "placeholder": {
        "type": "string",
        "mutable": false,
        "complexType": {
          "original": "string",
          "resolved": "string",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "string: Text used as the placeholder."
            }],
          "text": "Specifies the placeholder text of this component."
        },
        "attribute": "placeholder",
        "reflect": false,
        "defaultValue": "\"Bitte eingeben ...\""
      },
      "visibleentries": {
        "type": "number",
        "mutable": false,
        "complexType": {
          "original": "number",
          "resolved": "number",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "number: a number like 2.5 or 4.5"
            }, {
              "name": "example",
              "text": "example"
            }],
          "text": "Specifies how many entries are visible when the popup is open."
        },
        "attribute": "visibleentries",
        "reflect": false,
        "defaultValue": "2.5"
      },
      "noresultstext": {
        "type": "string",
        "mutable": false,
        "complexType": {
          "original": "string",
          "resolved": "string",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "string: Text which will be displayed."
            }, {
              "name": "example",
              "text": "no-results-text"
            }],
          "text": "Specifies the text that will be shown when there are no search results."
        },
        "attribute": "noresultstext",
        "reflect": false,
        "defaultValue": "\"Ihre Suche ergab leider keine Treffer.\""
      },
      "autoscrollintoview": {
        "type": "boolean",
        "mutable": false,
        "complexType": {
          "original": "boolean",
          "resolved": "boolean",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "true: Component will scroll popup list into view."
            }, {
              "name": "value",
              "text": "false: Component won't touch scrolling at all."
            }, {
              "name": "example",
              "text": "autoscrollintoview"
            }],
          "text": "Component will call the browsers `scrollIntoView()` method on the form\ncomponent after each search request. So the user can easily see the popup to choose from."
        },
        "attribute": "autoscrollintoview",
        "reflect": false,
        "defaultValue": "false"
      }
    };
  }
  static get states() {
    return {
      "inputFocused": {},
      "internalValue": {},
      "searchValues": {},
      "waitForSearchValues": {},
      "selectedOption": {},
      "popupopen": {}
    };
  }
  static get events() {
    return [{
        "method": "search",
        "name": "search",
        "bubbles": true,
        "cancelable": true,
        "composed": true,
        "docs": {
          "tags": [{
              "name": "example",
              "text": "example"
            }],
          "text": "\nWhile the user is typing, this event is triggered and returns a controller in the event payload (`event.detail`).\nThis controller can be used to send input field values for autocompletion.\nThe user entered value can be determined using `event.detail.value`.\n\nThe generated search suggestions are passed as an array to the `event.detail.provideValues()`\nmethod. A search suggestion is an object with the properties:\n\n- `label`: Primary search suggestion text, which will be transferred to the input field when it is accepted\n- `prelabel`: Optional text above the label that describes the search suggestion in more detail.\n- `sublabel`: Optional text under the label that describes the search suggestion in more detail\n- `category`: Optional categorization\n- `data`: Optional field for any data.\n\nA search suggestion object can contain further properties, which can be evaluated with the `searchSelect`\nevent."
        },
        "complexType": {
          "original": "SearchAutoCompleteHandler",
          "resolved": "SearchAutoCompleteHandler",
          "references": {
            "SearchAutoCompleteHandler": {
              "location": "import",
              "path": "./auto-complete-value"
            }
          }
        }
      }, {
        "method": "selectSearch",
        "name": "selectSearch",
        "bubbles": true,
        "cancelable": true,
        "composed": true,
        "docs": {
          "tags": [{
              "name": "example",
              "text": "example"
            }],
          "text": "Fired when the user selects a search suggestion.\nAs event payload (`event.detail`) the object is supplied,\nwhich created the search suggestion."
        },
        "complexType": {
          "original": "any",
          "resolved": "any",
          "references": {}
        }
      }, {
        "method": "valueChange",
        "name": "valueChange",
        "bubbles": true,
        "cancelable": true,
        "composed": true,
        "docs": {
          "tags": [],
          "text": "Fired when the user changes the search term."
        },
        "complexType": {
          "original": "string",
          "resolved": "string",
          "references": {}
        }
      }, {
        "method": "valueComplete",
        "name": "valueComplete",
        "bubbles": true,
        "cancelable": true,
        "composed": true,
        "docs": {
          "tags": [],
          "text": "Confirmation of the entered value by the user. Event is triggered by\npressing the Enter key or by leaving the input field."
        },
        "complexType": {
          "original": "string",
          "resolved": "string",
          "references": {}
        }
      }];
  }
  static get methods() {
    return {
      "focusControl": {
        "complexType": {
          "signature": "() => Promise<void>",
          "parameters": [],
          "references": {
            "Promise": {
              "location": "global"
            }
          },
          "return": "Promise<void>"
        },
        "docs": {
          "text": "Focuses this search.",
          "tags": []
        }
      }
    };
  }
  static get elementRef() { return "self"; }
  static get watchers() {
    return [{
        "propName": "value",
        "methodName": "valueChanged"
      }];
  }
}
function instanceOfSearchAutocompleteValue(object) {
  if (object != undefined) {
    return "id" in object && "label" in object;
  }
  return false;
}
let dsSearchIdCounter = 0;
const POPUP_ENTRY_HEIGHT = 76;
