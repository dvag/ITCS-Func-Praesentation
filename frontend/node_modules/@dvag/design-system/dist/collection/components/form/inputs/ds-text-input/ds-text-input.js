import { h, Host, } from "@stencil/core";
import { ElementIdGenerator, verifyElementId, } from "../../../../classes/element-id-handling";
import { maskedToRawValue, rawToMaskedValue } from "./masked-strings";
import { ReadonlyTextElement } from "../../../functional/base-elements";
import { isIos } from "../../../../classes/platform.util";
import { InputContainer } from "../../../functional/input-container";
import { ErrorPopup } from "../../../functional/error-popup";
import { onNextFrame } from "../../../../classes/render-util";
/**
 * Formelement for text input.
 *
 * @path /Form/TextInput
 * @name Text Input
 * @shortname Text
 * @icon font
 * @stable
 */
export class DsTextInput {
  constructor() {
    this.preventAutocomplete = false;
    this.inputFocused = false;
    this.internalValue = "";
    this.currentFocusedIndex = 0;
    /**
     * Indicates that the form is synced with the KI.
     * @value true: Synchronized.
     * @value false: Not synchronized.
     * @example kisynced
     */
    this.kisynced = false;
    /**
     * Input has a red outline.
     * @value true: red outlined.
     * @value false: gray outlined.
     * @example error
     */
    this.error = false;
    /**
     * The value of this input.
     * @important
     * @value string: value of this input.
     * @example value
     */
    this.value = "";
    /**
     * Placeholder for this input field.
     * @value string: The placeholder.
     */
    this.placeholder = "Bitte eingeben ...";
    /**
     * Defines if the input field is enabled or not.
     * @value true: Input ist disabled
     * @value false: Input is not disabled
     * @example disabled
     */
    this.disabled = false;
    /**
     * Input field is in readonly mode.
     * The value of this input is displaey in an simplified manner.
     * The input field is not interactable.
     * @value false: input is not editable.
     * @value true: input is read-only.
     * @example readonly
     */
    this.readonly = false;
    /**
     * Input is marked as required. And the user needs to fulfill the input's requirements.
     * @value true: Input field is required and draws a yellow outline and displays an icon beneath the input.
     * @value false: Input field is not required.
     * @example required
     */
    this.required = false;
  }
  valueChanged() {
    this.obtainValueChangesFromOutside();
  }
  /**
   * Focuses this input field.
   * @example focus
   */
  async focusControl() {
    this.inputElement.focus();
  }
  componentWillLoad() {
    verifyElementId(this.self);
    this.obtainValueChangesFromOutside(true);
  }
  obtainValueChangesFromOutside(force = false) {
    const maskedValue = rawToMaskedValue(this.mask, this.value);
    if (force ||
      (this.value !== this.internalValue && maskedValue !== this.internalValue)) {
      this.internalValue = maskedValue;
      this.lastEmittedChangeValue = this.value;
      this.lastEmittedCompleteValue = this.value;
      this.emitAutocompleteEvent();
    }
  }
  onInputFocused() {
    this.inputFocused = true;
    this.emitAutocompleteEvent();
  }
  onInputBlurred() {
    this.inputFocused = false;
    this.autocompleteValues = null;
    this.emitValueChange();
    this.emitValueComplete();
  }
  clearInput() {
    this.inputElement.value = "";
    this.internalValue = "";
    this.emitValueChange();
  }
  onInputKeyDown(event) {
    if (this.shouldShowAutocompleteValues() &&
      (event.key === "ArrowUp" || event.key === "ArrowDown")) {
      event.preventDefault();
    }
  }
  shouldShowAutocompleteValues() {
    var _a;
    const autocompleteValuesAreAvailable = ((_a = this.autocompleteValues) === null || _a === void 0 ? void 0 : _a.length) > 0;
    return this.inputFocused && autocompleteValuesAreAvailable;
  }
  onInputKeyUp(event) {
    var _a, _b, _c, _d;
    if (event.key == "Enter") {
      if (((_a = this.autocompleteValues) === null || _a === void 0 ? void 0 : _a.length) > 0) {
        this.selectAutocompleteValue(this.autocompleteValues[this.currentFocusedIndex]);
      }
      this.inputElement.blur();
    }
    //TODO home taste abfangen
    if (((_b = this.mask) === null || _b === void 0 ? void 0 : _b.length) > 0 && ((_c = event.key) === null || _c === void 0 ? void 0 : _c.includes("Arrow"))) {
      this.moveTextCursorToEnd();
    }
    if (((_d = this.autocompleteValues) === null || _d === void 0 ? void 0 : _d.length) > 0) {
      this.updateCurrentFocusedIndexAndScrollIntoView(event);
    }
  }
  updateCurrentFocusedIndexAndScrollIntoView(event) {
    if (event.key === "ArrowDown") {
      this.currentFocusedIndex =
        (this.currentFocusedIndex + 1) % this.autocompleteValues.length;
      this.scrollIntoView(this.currentFocusedIndex);
    }
    else if (event.key === "ArrowUp") {
      this.currentFocusedIndex =
        (this.currentFocusedIndex + this.autocompleteValues.length - 1) %
          this.autocompleteValues.length;
      this.scrollIntoView(this.currentFocusedIndex);
    }
  }
  scrollIntoView(selectedIndex) {
    onNextFrame(() => {
      if (selectedIndex > -1) {
        const autocompletePopup = this.self.shadowRoot.querySelector(".autocomplete-popup");
        if (autocompletePopup == null) {
          return;
        }
        const items = Array.from(this.self.shadowRoot.querySelectorAll(".autocomplete-item"));
        const listHeight = autocompletePopup.offsetHeight;
        const itemHeight = items[0].offsetHeight;
        autocompletePopup.scrollTop =
          itemHeight * selectedIndex - listHeight / 2 + itemHeight / 2;
      }
    });
  }
  onInputClicked() {
    var _a;
    if (((_a = this.mask) === null || _a === void 0 ? void 0 : _a.length) > 0) {
      this.moveTextCursorToEnd();
    }
  }
  moveTextCursorToEnd() {
    this.inputElement.setSelectionRange(this.internalValue.length, this.internalValue.length);
  }
  onInputInput(e) {
    var _a;
    if (((_a = this.mask) === null || _a === void 0 ? void 0 : _a.length) > 0) {
      this.handleMaskedInput(e);
    }
    else {
      this.internalValue = this.inputElement.value;
    }
    this.emitAutocompleteEvent();
    this.emitValueChange();
  }
  selectAutocompleteValue(value) {
    this.internalValue = value.value;
    this.autocompleteValues = null;
    this.emitValueChange();
    this.selectAutocomplete.emit(value.data);
  }
  emitAutocompleteEvent() {
    if (this.preventAutocomplete) {
      return;
    }
    this.autocomplete.emit({
      value: maskedToRawValue(this.mask, this.internalValue),
      provideValues: (values) => {
        this.autocompleteValues = values;
        this.currentFocusedIndex = 0;
      },
    });
  }
  emitValueChange() {
    const valueCandidate = maskedToRawValue(this.mask, this.internalValue);
    if (this.lastEmittedChangeValue !== valueCandidate) {
      this.value = valueCandidate;
      this.valueChange.emit(this.value);
      this.lastEmittedChangeValue = this.value;
    }
  }
  emitValueComplete() {
    if (this.lastEmittedCompleteValue !== this.value) {
      this.valueComplete.emit(this.value);
      this.lastEmittedCompleteValue = this.value;
    }
  }
  handleMaskedInput(event) {
    const previousValue = this.internalValue;
    const nextValue = this.inputElement.value;
    const newChar = event.data;
    let result;
    if (event.inputType === "insertFromPaste") {
      // copy/paste
      if (nextValue.length === this.mask.length) {
        result = nextValue; // paste masked
      }
      else {
        result = rawToMaskedValue(this.mask, nextValue); // paste raw values
      }
    }
    else if (previousValue.length < nextValue.length) {
      // add char
      const currentValue = newChar == undefined ? nextValue : previousValue;
      const rawNewValue = maskedToRawValue(this.mask, currentValue) + (newChar !== null && newChar !== void 0 ? newChar : "");
      result = rawToMaskedValue(this.mask, rawNewValue);
    }
    else if (event.inputType === "deleteContentBackward") {
      // delete
      let rawNewValue = maskedToRawValue(this.mask, previousValue);
      rawNewValue = rawNewValue.substring(0, rawNewValue.length - 1);
      result = rawToMaskedValue(this.mask, rawNewValue);
    }
    else {
      // anything else
      result = rawToMaskedValue(this.mask, maskedToRawValue(this.mask, nextValue));
    }
    this.inputElement.value = result;
    this.internalValue = result;
    this.moveTextCursorToEnd();
  }
  render() {
    if (this.readonly) {
      return (h(ReadonlyTextElement, { text: this.value, label: this.label, kisynced: this.kisynced }));
    }
    return h(Host, null, this.renderInput());
  }
  renderInput() {
    var _a, _b, _c, _d;
    const isErrorOutline = ((_a = this.errormessage) === null || _a === void 0 ? void 0 : _a.length) > 0 || this.error;
    return (h("label", null, h("ds-input-label", { disabled: this.disabled, kisynced: this.kisynced, label: this.label }), h("dx-overlay", { position: "bottom", offsety: 4, disabled: !this.shouldShowAutocompleteValues() }, h(InputContainer, { active: this.inputFocused, error: isErrorOutline, required: this.required, requirementFulfilled: ((_b = this.value) === null || _b === void 0 ? void 0 : _b.length) > 0, disabled: this.disabled, title: this.value }, h("input", { id: ElementIdGenerator.createId(this.self, "control"), ref: (el) => (this.inputElement = el), onInput: (event) => this.onInputInput(event), onKeyUp: (event) => this.onInputKeyUp(event), onKeyDown: (event) => this.onInputKeyDown(event), onFocus: () => this.onInputFocused(), onBlur: () => this.onInputBlurred(), onClick: () => this.onInputClicked(), type: "text", placeholder: this.placeholder, value: this.internalValue, maxLength: ((_c = this.mask) === null || _c === void 0 ? void 0 : _c.length) || this.limitlength, disabled: this.disabled }), this.renderClearButton(), h(ErrorPopup, { text: this.errormessage, show: this.inputFocused })), this.renderAutocompleteValues()), h("ds-required-hint", { required: this.required, fulfilled: ((_d = this.value) === null || _d === void 0 ? void 0 : _d.length) > 0 })));
  }
  renderAutocompleteValues() {
    if (!this.shouldShowAutocompleteValues()) {
      return;
    }
    return (h("div", { slot: "overlay", class: "autocomplete-popup" }, this.autocompleteValues.map((value, index) => {
      return (h("div", { onPointerDown: () => {
          // because autocomplete list is attached to input's focus state
          // it's too late to wait for a click's mouseup part.
          if (!isIos()) {
            this.selectAutocompleteValue(value);
          }
        }, onClick: () => {
          // we can't use pointerdown at ios because of scrolling behavior
          if (isIos()) {
            this.selectAutocompleteValue(value);
            // prevent autocomplete event firing for a short amount of time
            this.preventAutocomplete = true;
            setTimeout(() => (this.preventAutocomplete = false), 200);
          }
        }, class: {
          "autocomplete-item": true,
          active: this.currentFocusedIndex === index,
        } }, h("ds-text", null, value.label)));
    })));
  }
  renderClearButton() {
    const isClearButtonVisible = this.internalValue !== "" && this.inputFocused;
    return (h("ds-function-icon-button", { id: ElementIdGenerator.createId(this.self, "clear-button"), unfocusable: true, class: {
        "clear-button": true,
        visible: isClearButtonVisible,
      }, onPointerDown: () => this.clearInput() }, h("ds-icon", { icon: "schliessen-input", size: 16 })));
  }
  static get is() { return "ds-text-input"; }
  static get encapsulation() { return "shadow"; }
  static get originalStyleUrls() {
    return {
      "$": ["ds-text-input.scss"]
    };
  }
  static get styleUrls() {
    return {
      "$": ["ds-text-input.css"]
    };
  }
  static get properties() {
    return {
      "label": {
        "type": "string",
        "mutable": false,
        "complexType": {
          "original": "string",
          "resolved": "string",
          "references": {}
        },
        "required": false,
        "optional": true,
        "docs": {
          "tags": [{
              "name": "important",
              "text": undefined
            }, {
              "name": "value",
              "text": "string: Label e.g `first name`"
            }, {
              "name": "example",
              "text": "label"
            }],
          "text": "Label which is displayed above the input field."
        },
        "attribute": "label",
        "reflect": false
      },
      "errormessage": {
        "type": "string",
        "mutable": false,
        "complexType": {
          "original": "string",
          "resolved": "string",
          "references": {}
        },
        "required": false,
        "optional": true,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "string: error message"
            }, {
              "name": "example",
              "text": "error"
            }],
          "text": "Text, which is displayed within a red dialog beneath the input."
        },
        "attribute": "errormessage",
        "reflect": false
      },
      "kisynced": {
        "type": "boolean",
        "mutable": false,
        "complexType": {
          "original": "boolean",
          "resolved": "boolean",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "true: Synchronized."
            }, {
              "name": "value",
              "text": "false: Not synchronized."
            }, {
              "name": "example",
              "text": "kisynced"
            }],
          "text": "Indicates that the form is synced with the KI."
        },
        "attribute": "kisynced",
        "reflect": false,
        "defaultValue": "false"
      },
      "error": {
        "type": "boolean",
        "mutable": false,
        "complexType": {
          "original": "boolean",
          "resolved": "boolean",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "true: red outlined."
            }, {
              "name": "value",
              "text": "false: gray outlined."
            }, {
              "name": "example",
              "text": "error"
            }],
          "text": "Input has a red outline."
        },
        "attribute": "error",
        "reflect": false,
        "defaultValue": "false"
      },
      "value": {
        "type": "string",
        "mutable": true,
        "complexType": {
          "original": "string",
          "resolved": "string",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "important",
              "text": undefined
            }, {
              "name": "value",
              "text": "string: value of this input."
            }, {
              "name": "example",
              "text": "value"
            }],
          "text": "The value of this input."
        },
        "attribute": "value",
        "reflect": true,
        "defaultValue": "\"\""
      },
      "limitlength": {
        "type": "number",
        "mutable": false,
        "complexType": {
          "original": "number",
          "resolved": "number",
          "references": {}
        },
        "required": false,
        "optional": true,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "number: Amount of possible characters."
            }, {
              "name": "example",
              "text": "limitlength"
            }],
          "text": "Limits the amount of characters a user can enter."
        },
        "attribute": "limitlength",
        "reflect": false
      },
      "placeholder": {
        "type": "string",
        "mutable": false,
        "complexType": {
          "original": "string",
          "resolved": "string",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "string: The placeholder."
            }],
          "text": "Placeholder for this input field."
        },
        "attribute": "placeholder",
        "reflect": false,
        "defaultValue": "\"Bitte eingeben ...\""
      },
      "mask": {
        "type": "string",
        "mutable": false,
        "complexType": {
          "original": "string",
          "resolved": "string",
          "references": {}
        },
        "required": false,
        "optional": true,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "string: Pattern for the mask."
            }, {
              "name": "example",
              "text": "mask"
            }, {
              "name": "example",
              "text": "mask-iban"
            }, {
              "name": "example",
              "text": "mask-complex"
            }],
          "text": "Assists the user with a masking.\nThe mask is defined as a pattern. The character `X` represents an alphanumeric character and `0` represents\nnumerals.\nThe user can only enter characters that are marked with `X` and `0`.\nAll other delimiters will be replaced automatically by the text input.\nThe delimiters will be removed, when the content is get programmatic.\n\nBeispiel: `XX00 0000 0000 0000 0000 00` (Deutsche IBAN)"
        },
        "attribute": "mask",
        "reflect": false
      },
      "disabled": {
        "type": "boolean",
        "mutable": false,
        "complexType": {
          "original": "boolean",
          "resolved": "boolean",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "true: Input ist disabled"
            }, {
              "name": "value",
              "text": "false: Input is not disabled"
            }, {
              "name": "example",
              "text": "disabled"
            }],
          "text": "Defines if the input field is enabled or not."
        },
        "attribute": "disabled",
        "reflect": false,
        "defaultValue": "false"
      },
      "readonly": {
        "type": "boolean",
        "mutable": false,
        "complexType": {
          "original": "boolean",
          "resolved": "boolean",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "false: input is not editable."
            }, {
              "name": "value",
              "text": "true: input is read-only."
            }, {
              "name": "example",
              "text": "readonly"
            }],
          "text": "Input field is in readonly mode.\nThe value of this input is displaey in an simplified manner.\nThe input field is not interactable."
        },
        "attribute": "readonly",
        "reflect": false,
        "defaultValue": "false"
      },
      "required": {
        "type": "boolean",
        "mutable": false,
        "complexType": {
          "original": "boolean",
          "resolved": "boolean",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "true: Input field is required and draws a yellow outline and displays an icon beneath the input."
            }, {
              "name": "value",
              "text": "false: Input field is not required."
            }, {
              "name": "example",
              "text": "required"
            }],
          "text": "Input is marked as required. And the user needs to fulfill the input's requirements."
        },
        "attribute": "required",
        "reflect": false,
        "defaultValue": "false"
      }
    };
  }
  static get states() {
    return {
      "inputFocused": {},
      "internalValue": {},
      "autocompleteValues": {},
      "currentFocusedIndex": {}
    };
  }
  static get events() {
    return [{
        "method": "valueChange",
        "name": "valueChange",
        "bubbles": true,
        "cancelable": true,
        "composed": true,
        "docs": {
          "tags": [{
              "name": "example",
              "text": "change-events"
            }],
          "text": "Emits this event when the user changes the value of this input."
        },
        "complexType": {
          "original": "string",
          "resolved": "string",
          "references": {}
        }
      }, {
        "method": "valueComplete",
        "name": "valueComplete",
        "bubbles": true,
        "cancelable": true,
        "composed": true,
        "docs": {
          "tags": [{
              "name": "example",
              "text": "change-events"
            }],
          "text": "This Event is emitted when the user accepts the value.\nThe user accepts the value by pressing the Enter Key or when the user leave the input."
        },
        "complexType": {
          "original": "string",
          "resolved": "string",
          "references": {}
        }
      }, {
        "method": "autocomplete",
        "name": "autocomplete",
        "bubbles": true,
        "cancelable": true,
        "composed": true,
        "docs": {
          "tags": [{
              "name": "example",
              "text": "autocomplete-plz"
            }],
          "text": "This event is fired, when the user fills out this input.\nThe event paylod contains an controller which can be used to submit autocomplete values."
        },
        "complexType": {
          "original": "TextInputAutocompleteController",
          "resolved": "TextInputAutocompleteController",
          "references": {
            "TextInputAutocompleteController": {
              "location": "local"
            }
          }
        }
      }, {
        "method": "selectAutocomplete",
        "name": "selectAutocomplete",
        "bubbles": true,
        "cancelable": true,
        "composed": true,
        "docs": {
          "tags": [{
              "name": "example",
              "text": "autocomplete-plz-ort"
            }],
          "text": "This event is fired when the user selects an autocomplete value from the list.\nThe event payload contains the `data` of the selected AutoCompleteOption."
        },
        "complexType": {
          "original": "any",
          "resolved": "any",
          "references": {}
        }
      }];
  }
  static get methods() {
    return {
      "focusControl": {
        "complexType": {
          "signature": "() => Promise<void>",
          "parameters": [],
          "references": {
            "Promise": {
              "location": "global"
            }
          },
          "return": "Promise<void>"
        },
        "docs": {
          "text": "Focuses this input field.",
          "tags": [{
              "name": "example",
              "text": "focus"
            }]
        }
      }
    };
  }
  static get elementRef() { return "self"; }
  static get watchers() {
    return [{
        "propName": "value",
        "methodName": "valueChanged"
      }];
  }
}
