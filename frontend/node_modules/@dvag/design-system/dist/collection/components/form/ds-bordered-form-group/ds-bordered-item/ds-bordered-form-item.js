import { h, Host, } from "@stencil/core";
import { SlotObserver } from "../../../../classes/slot-observer";
import { PreciseCssSetter } from "../../../../classes/precise-css-setter";
import { DISABLED_CLASS, ERROR_CLASS, FOCUS_CLASS, READONLY_CLASS, REQUIRED_CLASS, REQUIREMENT_FULFILLED_CLASS, } from "../bordered-form-commons";
import { BaselineElement } from "../../../functional/base-elements";
import { ErrorPopup } from "../../../functional/error-popup";
const FORM_COMPONENT_TAGS = ["ds-radio-button", "ds-checkbox"];
/**
 * Element zum Umschließen eines Formular-Elements, welches für
 * [`<ds-bordered-form-group>`](#/component/ds-bordered-form-group) genutzt wird.
 *
 * @path /Form/Layout/Bordered
 * @name Bordered Form Item
 * @shortname Item
 * @stable
 */
export class DsBorderedFormItem {
  constructor() {
    this.inputFocused = false;
  }
  connectedCallback() {
    var _a;
    this.slotObserver = new SlotObserver(this.self, "*", (nodes) => {
      this.formComponent = nodes.find((node) => {
        return (FORM_COMPONENT_TAGS.includes(node.tagName.toLowerCase()) &&
          node.classList.contains("hydrated"));
      });
      this.errormessage = this.getFormComponentAttribute("errormessage");
      this.configureStates();
    });
    (_a = this.resizeObserver) === null || _a === void 0 ? void 0 : _a.observe(this.contentElement);
  }
  componentDidLoad() {
    this.resizeObserver = new ResizeObserver(() => {
      this.widthChanged.emit(this.contentElement.offsetWidth);
    });
    this.resizeObserver.observe(this.contentElement);
  }
  disconnectedCallback() {
    var _a, _b;
    (_a = this.slotObserver) === null || _a === void 0 ? void 0 : _a.disconnect();
    (_b = this.resizeObserver) === null || _b === void 0 ? void 0 : _b.disconnect();
  }
  getFormComponentAttribute(attributeName, fallback = null) {
    var _a, _b, _c, _d;
    if ((_a = this.formComponent) === null || _a === void 0 ? void 0 : _a[attributeName]) {
      return (_b = this.formComponent) === null || _b === void 0 ? void 0 : _b[attributeName];
    }
    const value = (_c = this.formComponent) === null || _c === void 0 ? void 0 : _c.getAttribute(attributeName);
    if (typeof fallback === "boolean") {
      return (value === "true");
    }
    else if (typeof fallback === "number") {
      return (isNaN(+value) ? null : +value);
    }
    return (_d = value) !== null && _d !== void 0 ? _d : fallback;
  }
  configureStates() {
    var _a, _b, _c;
    this.inputFocused = !!((_a = this.formComponent) === null || _a === void 0 ? void 0 : _a.classList.contains(FOCUS_CLASS));
    new PreciseCssSetter(this.self)
      .set(ERROR_CLASS, ((_b = this.errormessage) === null || _b === void 0 ? void 0 : _b.length) > 0 ||
      this.getFormComponentAttribute("error", false))
      .set(FOCUS_CLASS, this.inputFocused)
      .set(DISABLED_CLASS, this.getFormComponentAttribute("disabled", false) ||
      ((_c = this.formComponent) === null || _c === void 0 ? void 0 : _c.classList.contains("disabled")))
      .set(READONLY_CLASS, this.getFormComponentAttribute("readonly", false))
      .set(REQUIRED_CLASS, this.getFormComponentAttribute("required", false))
      .set(REQUIREMENT_FULFILLED_CLASS, this.getFormComponentAttribute("requirementfulfilled", false))
      .set("has-form-component", this.formComponent != null)
      .execute();
  }
  /**
   * @internal
   */
  async getContentWidth() {
    var _a;
    return (_a = this.contentElement) === null || _a === void 0 ? void 0 : _a.offsetWidth;
  }
  delegateEvent(srcEvent) {
    var _a, _b;
    if (this.formComponent == null ||
      this.getFormComponentAttribute("disabled", false) ||
      this.getFormComponentAttribute("readonly", false)) {
      return;
    }
    const anyChildGotEvent = srcEvent
      .composedPath()
      .includes(this.formComponent);
    if (!anyChildGotEvent) {
      (_b = (_a = this.formComponent.shadowRoot) === null || _a === void 0 ? void 0 : _a.querySelector(".event-delegate-receiver")) === null || _b === void 0 ? void 0 : _b.dispatchEvent(new srcEvent.constructor(srcEvent.type, srcEvent));
    }
    if (["click", "mousedown"].includes(srcEvent.type)) {
      const abstractComponent = this.formComponent;
      if (abstractComponent.focusControl != null) {
        abstractComponent.focusControl();
      }
    }
  }
  render() {
    return (h(Host, { onClick: (e) => this.delegateEvent(e), onMouseDown: (e) => this.delegateEvent(e), onMouseEnter: (e) => this.delegateEvent(e), onMouseLeave: (e) => this.delegateEvent(e) }, 
    // TODO: Find better solution
    !window["chrome"] ? h(BaselineElement, { onlyDiv: true }) : null, h("div", { ref: (el) => (this.contentElement = el), class: "content-container" }, h("slot", null)), h(ErrorPopup, { text: this.errormessage, show: this.inputFocused })));
  }
  static get is() { return "ds-bordered-form-item"; }
  static get encapsulation() { return "shadow"; }
  static get originalStyleUrls() {
    return {
      "$": ["ds-bordered-form-item.scss"]
    };
  }
  static get styleUrls() {
    return {
      "$": ["ds-bordered-form-item.css"]
    };
  }
  static get states() {
    return {
      "errormessage": {},
      "inputFocused": {}
    };
  }
  static get events() {
    return [{
        "method": "widthChanged",
        "name": "widthChanged",
        "bubbles": true,
        "cancelable": true,
        "composed": true,
        "docs": {
          "tags": [{
              "name": "internal",
              "text": undefined
            }],
          "text": ""
        },
        "complexType": {
          "original": "number",
          "resolved": "number",
          "references": {}
        }
      }];
  }
  static get methods() {
    return {
      "getContentWidth": {
        "complexType": {
          "signature": "() => Promise<number>",
          "parameters": [],
          "references": {
            "Promise": {
              "location": "global"
            }
          },
          "return": "Promise<number>"
        },
        "docs": {
          "text": "",
          "tags": [{
              "name": "internal",
              "text": undefined
            }]
        }
      }
    };
  }
  static get elementRef() { return "self"; }
}
