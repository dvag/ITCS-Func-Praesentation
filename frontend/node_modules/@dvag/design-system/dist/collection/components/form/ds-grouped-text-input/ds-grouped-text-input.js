import { h, Host, } from "@stencil/core";
import { GroupedTextInputController, } from "./grouped-text-input-controller";
import { computeGroups, Delimiter, delimiterExp, InputGroup, } from "./input-group";
import { ElementIdGenerator } from "../../../classes/element-id-handling";
import { onNextFrame } from "../../../classes/render-util";
import { isActiveElement } from "../../../classes/misc-util";
import { InputContainer } from "../../functional/input-container";
import { ReadonlyTextElement } from "../../functional/base-elements";
import { ErrorPopup } from "../../functional/error-popup";
import { configToNumber } from "./configConverter";
// TODO fix internal-errorpopup.md later because the active/isFocused mechanism isn't working as intended. so we can't take a screenshot of a errormessage popup. that's why the prepared test is ignored. you can unignore it if the issue is resolved.
/**
 * Formelement which only accepts characters in a defined order.
 *
 * @path /Form/Textfeld
 * @name Grouped-Text-Input
 * @shortname Grouped-input
 * @icon font
 */
export class DsGroupedTextInput {
  constructor() {
    this.allGroupedTextInputController = [];
    this.groups = [];
    this.active = false;
    this.userInputed = false;
    /**
     * Label which is displayed above the input field.
     * @important
     * @value string: Label e.g `first name`
     * @example label
     */
    this.label = "";
    /**
     * @important
     * @value string: value of this input.
     * @example value
     */
    this.value = "";
    /**
     * Colors the frame of the input field red.
     * @value true: Red outline
     * @value false: Gray outline
     * @example error
     */
    this.error = false;
    /**
     * Input is no longer operable.
     * Label and frame are gray.
     * @value true: Input is disabled
     * @value false: Input ist not disabled
     * @example disabled
     */
    this.disabled = false;
    /**
     * Marks this form field as mandatory
     * @value false: Required form field (default)
     * @value true: Reguired form field
     * @example required
     */
    this.required = false;
    /**
     * Input field is in readonly mode.
     * The value of this input is displaey in an simplified manner.
     * The input field is not interactable.
     * @value false: input is not editable.
     * @value true: input is read-only.
     */
    this.readonly = false;
  }
  onMaskChanged() {
    this.reConstructInputsAndDelimiter();
  }
  onValueChanged() {
    this.obtainValueFromOutside();
  }
  connectedCallback() {
    this.reConstructInputsAndDelimiter();
  }
  componentWillLoad() {
    this.internalValue = this.computeNewValue();
  }
  componentDidRender() {
    this.obtainValueFromOutside();
  }
  obtainValueFromOutside() {
    if (this.value === this.computeNewValue() || this.value.length === 0) {
      return;
    }
    const extracted = this.normalizeValue();
    this.clearAllInputs();
    const event = new InputEvent("input", {
      data: extracted,
      inputType: "insertFromPaste",
      detail: configToNumber({
        prefix: true,
        focusNext: false,
      }),
    });
    onNextFrame(() => {
      this.getFirstController().getInputElement().dispatchEvent(event);
    });
  }
  checkFilledOut() {
    return this.allGroupedTextInputController
      .filter((ic) => ic != undefined)
      .every((ic) => {
      return ic.checkIsFulfilled();
    });
  }
  normalizeValue() {
    if (this.value.length <= 0) {
      return "";
    }
    const valueArray = [...this.value];
    const maskArray = [...this.mask];
    maskArray.forEach((char, index) => {
      if (char.match(delimiterExp)) {
        if (index <= valueArray.length) {
          if (valueArray[index] == char) {
            valueArray[index] = "";
          }
        }
        else {
          return;
        }
      }
    });
    return valueArray.reduce((prev, curr) => {
      return prev + curr;
    });
  }
  findInnerInputElement(e) {
    return e.composedPath().find((target) => {
      const element = target;
      return /input-[\d]+/.test(element === null || element === void 0 ? void 0 : element.id);
    });
  }
  focusFirstUnfulfilledInput() {
    const firstUnfullfilled = this.allGroupedTextInputController
      .filter((ic) => {
      return ic != undefined;
    })
      .find((ic) => !ic.checkIsFulfilled());
    if (firstUnfullfilled) {
      firstUnfullfilled.focus();
    }
    else {
      this.focusFirstInput();
    }
  }
  focusFirstInput() {
    var _a;
    (_a = this.allGroupedTextInputController
      .filter((ic) => {
      return ic != undefined;
    })[0]) === null || _a === void 0 ? void 0 : _a.focus();
  }
  blurAllInputs() {
    this.allGroupedTextInputController
      .filter((controller) => controller != undefined)
      .forEach((controller) => {
      controller.getInputElement().blur();
    });
  }
  blurWhenInactive() {
    setTimeout(() => {
      if (this.forceBlur || !isActiveElement(this.self)) {
        this.active = false;
        this.forceBlur = false;
        this.valueComplete.emit(this.internalValue);
      }
    }, 200);
  }
  checkUserInputed() {
    this.userInputed = this.allGroupedTextInputController
      .filter((ic) => ic != undefined)
      .some((ic) => {
      var _a;
      return ((_a = ic.getInputValue()) === null || _a === void 0 ? void 0 : _a.length) > 0;
    });
  }
  clearAllInputs() {
    onNextFrame(() => {
      this.allGroupedTextInputController
        .filter((controller) => controller != undefined)
        .forEach((controller) => {
        controller.clearInput();
      });
      this.value = "";
      this.internalValue = "";
      this.valueChanged();
    });
    this.userInputed = false;
  }
  reConstructInputsAndDelimiter() {
    this.groups = computeGroups(this.mask);
    this.allGroupedTextInputController = this.groups.map((g) => {
      if (g instanceof InputGroup) {
        const c = new GroupedTextInputController(g);
        g.controller = c;
        return c;
      }
    });
  }
  handleInput(e, inputController) {
    this.checkUserInputed();
    inputController.onInput(e);
  }
  handleKeyDown(event, groupInputController) {
    groupInputController.handleKeyDown(event);
  }
  getFirstController() {
    const candidates = this.allGroupedTextInputController.filter((ic) => {
      return ic != undefined;
    });
    return candidates.length > 0 ? candidates[0] : null;
  }
  getNextController(ic) {
    let index = this.allGroupedTextInputController.indexOf(ic);
    let nextController = undefined;
    let found = false;
    while (index <= this.allGroupedTextInputController.length && !found) {
      index = index + 1;
      if (this.allGroupedTextInputController[index] != undefined) {
        nextController = this.allGroupedTextInputController[index];
        found = true;
      }
    }
    return nextController;
  }
  getPreviousController(ic) {
    let index = this.allGroupedTextInputController.indexOf(ic);
    let previousController = undefined;
    let found = false;
    while (index >= 0 && !found) {
      index = index - 1;
      if (this.allGroupedTextInputController[index] != undefined) {
        previousController = this.allGroupedTextInputController[index];
        found = true;
      }
    }
    return previousController;
  }
  focusPreviousController(ic) {
    const prevController = this.getPreviousController(ic);
    if (prevController != undefined) {
      const caretPosition = prevController.getInputValue().length;
      prevController.focusAndSetCaretPosition(caretPosition, caretPosition);
    }
  }
  focusNextController(ic) {
    var _a;
    (_a = this.getNextController(ic)) === null || _a === void 0 ? void 0 : _a.focusAndSetCaretPosition(0, 0);
  }
  writeOverflowToNextInputController(data) {
    const nextController = this.getNextController(data.input);
    if (nextController != undefined || !this.checkFilledOut()) {
      if (!data.paste) {
        const event = new InputEvent("input", {
          data: data.data,
          inputType: "insertText",
          detail: configToNumber({
            prefix: data.shouldPrefix,
            focusNext: data.focusNext,
          }),
        });
        const inputElement = nextController === null || nextController === void 0 ? void 0 : nextController.getInputElement();
        if (inputElement == null) {
          return;
        }
        inputElement.dispatchEvent(event);
        if (data.focusNext) {
          nextController.focusAndSetCaretPosition(data.caretPosition, data.caretPosition);
        }
      }
      else {
        const event = new InputEvent("input", {
          data: data.data,
          inputType: "insertFromPaste",
          detail: configToNumber({
            prefix: data.shouldPrefix,
            focusNext: data.focusNext,
          }),
        });
        nextController.getInputElement().dispatchEvent(event);
      }
    }
  }
  computeNewValue() {
    return this.groups
      .filter((groupOrDelimiter) => {
      return (groupOrDelimiter instanceof InputGroup ||
        groupOrDelimiter instanceof Delimiter);
    })
      .map((groupOrDelimiter) => {
      var _a;
      if (groupOrDelimiter instanceof Delimiter) {
        return groupOrDelimiter.delimiter;
      }
      if (groupOrDelimiter instanceof InputGroup) {
        return (_a = groupOrDelimiter.controller.getInputValue()) !== null && _a !== void 0 ? _a : "";
      }
    })
      .reduce((previousValue, currentValue) => {
      return previousValue + currentValue;
    });
  }
  valueChanged() {
    const newValue = this.computeNewValue();
    if (this.internalValue !== newValue) {
      this.internalValue = newValue;
      this.value = this.internalValue;
      this.valueChange.emit(newValue);
    }
  }
  handleOnKeyUp(event, controller) {
    if (event.key == "Enter") {
      this.forceBlur = true;
      this.blurAllInputs();
      this.self.blur();
    }
    else if (event.key === "ArrowLeft" || event.key === "ArrowRight") {
      this.handleArrowKeys(event, controller);
    }
    else {
      this.handleKeyDown(event, controller);
    }
  }
  handleArrowKeys(e, ic) {
    ic.handleArrowKey(e);
  }
  onDeleteBackwards(input, inputType) {
    const nextController = this.getNextController(input);
    if (nextController != undefined &&
      nextController.getInputGroup().pattern[0] ===
        input.getInputGroup().pattern[0] &&
      nextController.getInputValue().length > 0) {
      const amountTObeExtracted = input.getInputGroup().width - input.getInputValue().length;
      input.appendExtractedToValue(nextController.extractCharacters(amountTObeExtracted, inputType), inputType);
    }
    return;
  }
  initalizeGroupedTextInputController(groupInputController, el) {
    groupInputController.setInputElement(el);
    groupInputController.onGotoGroup = (ic, previous) => {
      if (previous) {
        this.focusPreviousController(ic);
      }
      else {
        this.focusNextController(ic);
      }
    };
    groupInputController.onOverflow = (data) => {
      this.writeOverflowToNextInputController(data);
    };
    groupInputController.onValueChanged = () => {
      this.valueChanged();
    };
    groupInputController.onDeleteEvent = (input, inputType) => {
      this.onDeleteBackwards(input, inputType);
    };
  }
  render() {
    var _a;
    const isErrorOutline = ((_a = this.errormessage) === null || _a === void 0 ? void 0 : _a.length) > 0 || this.error;
    return (h(Host, { title: this.mask, onClick: (e) => {
        if (this.findInnerInputElement(e) == undefined) {
          this.focusFirstUnfulfilledInput();
        }
      }, onBlur: () => {
        this.blurWhenInactive();
      } }, h("ds-input-label", { disabled: this.disabled, label: this.label, kisynced: false }), h("div", { class: { "input-readonly": this.readonly } }, h(InputContainer, { active: this.active, error: isErrorOutline, required: this.required, requirementFulfilled: this.checkFilledOut(), disabled: this.disabled, title: this.internalValue }, this.renderReadonly(), this.renderGroups(), this.renderClearButton(), h(ErrorPopup, { text: this.errormessage, show: this.active })), h("ds-required-hint", { required: this.required, fulfilled: this.checkFilledOut() }))));
  }
  renderGroups() {
    return this.groups.map((groupOrDelimiter, index) => {
      if (groupOrDelimiter instanceof InputGroup) {
        const inputWidthInCharacters = groupOrDelimiter.width;
        const groupedTextInputController = this.allGroupedTextInputController[index];
        return (h("input", { id: `input-${index}`, ref: (el) => {
            this.initalizeGroupedTextInputController(groupedTextInputController, el);
          }, disabled: this.disabled, placeholder: groupOrDelimiter.pattern, style: {
            "--ds-grouped-text-input-width": `${inputWidthInCharacters}ch`,
          }, onFocus: () => {
            this.active = true;
          }, onBlur: () => {
            groupedTextInputController.onBlur();
          }, onKeyUp: (event) => {
            this.handleOnKeyUp(event, groupedTextInputController);
          }, onInput: (event) => this.handleInput(event, groupedTextInputController) }));
      }
      else {
        return groupOrDelimiter.delimiter === " " ? (h("ds-text", { type: "ft", screensize: "small" }, "\u00A0")) : (h("ds-text", { type: "ft", screensize: "small" }, groupOrDelimiter.delimiter));
      }
    });
  }
  renderReadonly() {
    if (this.readonly) {
      this.computeNewValue();
      return (h("div", { class: "readonly-text" }, h(ReadonlyTextElement, { text: this.internalValue, kisynced: false })));
    }
    return null;
  }
  renderClearButton() {
    const isClearButtonVisible = this.active && this.userInputed && !this.readonly;
    return (h("ds-function-icon-button", { id: ElementIdGenerator.createId(this.self, "clear-button"), unfocusable: true, class: {
        "clear-button": true,
        visible: isClearButtonVisible,
      }, onPointerDown: () => this.clearAllInputs() }, h("ds-icon", { icon: "schliessen-input", size: 16 })));
  }
  static get is() { return "ds-grouped-text-input"; }
  static get encapsulation() { return "shadow"; }
  static get originalStyleUrls() {
    return {
      "$": ["ds-grouped-text-input.scss"]
    };
  }
  static get styleUrls() {
    return {
      "$": ["ds-grouped-text-input.css"]
    };
  }
  static get properties() {
    return {
      "mask": {
        "type": "string",
        "mutable": false,
        "complexType": {
          "original": "string",
          "resolved": "string",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "string: Pattern"
            }, {
              "name": "example",
              "text": "german-iban"
            }, {
              "name": "example",
              "text": "common-iban"
            }],
          "text": "Define your mask using :\n\n\u00A7 Defines a character like a-zA-Z\n\n\\# Defines a number like 0-9\n\na-zA-Z0-9 in your pattern will render these characters as placeholders.\n\nany non-word character will be used as 'delemiter'.\n\nExample: `DE## #### #### #### #### ####` (German IBAN)"
        },
        "attribute": "mask",
        "reflect": false
      },
      "label": {
        "type": "string",
        "mutable": false,
        "complexType": {
          "original": "string",
          "resolved": "string",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "important",
              "text": undefined
            }, {
              "name": "value",
              "text": "string: Label e.g `first name`"
            }, {
              "name": "example",
              "text": "label"
            }],
          "text": "Label which is displayed above the input field."
        },
        "attribute": "label",
        "reflect": false,
        "defaultValue": "\"\""
      },
      "value": {
        "type": "string",
        "mutable": true,
        "complexType": {
          "original": "string",
          "resolved": "string",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "important",
              "text": undefined
            }, {
              "name": "value",
              "text": "string: value of this input."
            }, {
              "name": "example",
              "text": "value"
            }],
          "text": ""
        },
        "attribute": "value",
        "reflect": true,
        "defaultValue": "\"\""
      },
      "errormessage": {
        "type": "string",
        "mutable": false,
        "complexType": {
          "original": "string",
          "resolved": "string",
          "references": {}
        },
        "required": false,
        "optional": true,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "string: Errormessage"
            }, {
              "name": "example",
              "text": "error"
            }],
          "text": "Text displayed below the input field in a red dialog."
        },
        "attribute": "errormessage",
        "reflect": false
      },
      "error": {
        "type": "boolean",
        "mutable": false,
        "complexType": {
          "original": "boolean",
          "resolved": "boolean",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "true: Red outline"
            }, {
              "name": "value",
              "text": "false: Gray outline"
            }, {
              "name": "example",
              "text": "error"
            }],
          "text": "Colors the frame of the input field red."
        },
        "attribute": "error",
        "reflect": false,
        "defaultValue": "false"
      },
      "disabled": {
        "type": "boolean",
        "mutable": false,
        "complexType": {
          "original": "boolean",
          "resolved": "boolean",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "true: Input is disabled"
            }, {
              "name": "value",
              "text": "false: Input ist not disabled"
            }, {
              "name": "example",
              "text": "disabled"
            }],
          "text": "Input is no longer operable.\nLabel and frame are gray."
        },
        "attribute": "disabled",
        "reflect": false,
        "defaultValue": "false"
      },
      "required": {
        "type": "boolean",
        "mutable": false,
        "complexType": {
          "original": "boolean",
          "resolved": "boolean",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "false: Required form field (default)"
            }, {
              "name": "value",
              "text": "true: Reguired form field"
            }, {
              "name": "example",
              "text": "required"
            }],
          "text": "Marks this form field as mandatory"
        },
        "attribute": "required",
        "reflect": false,
        "defaultValue": "false"
      },
      "readonly": {
        "type": "boolean",
        "mutable": false,
        "complexType": {
          "original": "boolean",
          "resolved": "boolean",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "false: input is not editable."
            }, {
              "name": "value",
              "text": "true: input is read-only."
            }],
          "text": "Input field is in readonly mode.\nThe value of this input is displaey in an simplified manner.\nThe input field is not interactable."
        },
        "attribute": "readonly",
        "reflect": false,
        "defaultValue": "false"
      }
    };
  }
  static get states() {
    return {
      "active": {},
      "userInputed": {}
    };
  }
  static get events() {
    return [{
        "method": "valueChange",
        "name": "valueChange",
        "bubbles": true,
        "cancelable": true,
        "composed": true,
        "docs": {
          "tags": [{
              "name": "example",
              "text": "change-events"
            }],
          "text": "Change of the entered value during the user's input."
        },
        "complexType": {
          "original": "string",
          "resolved": "string",
          "references": {}
        }
      }, {
        "method": "valueComplete",
        "name": "valueComplete",
        "bubbles": true,
        "cancelable": true,
        "composed": true,
        "docs": {
          "tags": [{
              "name": "example",
              "text": "change-events"
            }],
          "text": "Confirmation of the entered value by the user. Event is triggered by\nPressing the Enter key or by leaving the input field."
        },
        "complexType": {
          "original": "string",
          "resolved": "string",
          "references": {}
        }
      }];
  }
  static get elementRef() { return "self"; }
  static get watchers() {
    return [{
        "propName": "mask",
        "methodName": "onMaskChanged"
      }, {
        "propName": "value",
        "methodName": "onValueChanged"
      }];
  }
}
