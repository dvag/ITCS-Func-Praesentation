/**
 * Converts a raw value into masked value.
 * See unit tests for examples.
 *
 * @param mask pattern with `0` (numeric) and `X` (alphanumeric) as placeholders
 * @param value value that should be masked
 */
export function rawToMaskedValue(mask, value) {
  if ((mask === null || mask === void 0 ? void 0 : mask.length) > 0) {
    // only do something if mask defined
    let index = 0; // tracks position in raw value string
    let result = ""; // will contain the mask value we are building here
    let lastValidLength = 0; // last string length of result without any errors on applying placeholders
    if ((value === null || value === void 0 ? void 0 : value.length) > 0) {
      for (const char of mask.split("")) {
        // iterate over pattern
        if (MASK_CHARS.includes(char)) {
          // char in pattern is placeholder
          if (value.length === index) {
            // stop iteration when there are no more raw value to process
            break;
          }
          const valueToInsert = value[index++]; // obtain raw value char and increase index counter
          if (char === MASK_CHAR_NUMERIC && !NUM_CHAR.test(valueToInsert)) {
            // found non-numeric on numeric placeholder
            return result.substring(0, lastValidLength); // resolve error case by returning the latest working string
          }
          result += valueToInsert; // take value char
          lastValidLength = result.length;
        }
        else {
          // char in pattern is not placeholder
          result += char; // just take char
          // TODO: Felix review. Do this because the mask char should be valid
          lastValidLength = result.length;
        }
      }
    }
    return result;
  }
  return value;
}
/**
 * Converts a masked value into a raw value.
 * See unit tests for examples.
 *
 * @param mask pattern with `0` (numeric) and `X` (alphanumeric) as placeholders
 * @param masked value in masked form
 */
export function maskedToRawValue(mask, masked) {
  if ((mask === null || mask === void 0 ? void 0 : mask.length) > 0) {
    // only do something if mask defined
    return mask
      .split("")
      .map((char, index) => {
      var _a;
      // iterate over pattern
      return MASK_CHARS.includes(char) ? (_a = masked[index]) !== null && _a !== void 0 ? _a : "" : ""; // only take chars from masked input on positions where pattern has placeholders
    })
      .join("");
  }
  return masked;
}
const MASK_CHAR_ALPHANUMERIC = "X";
const MASK_CHAR_NUMERIC = "0";
const MASK_CHARS = [MASK_CHAR_ALPHANUMERIC, MASK_CHAR_NUMERIC];
const NUM_CHAR = /\d/;
