import { h, Host, } from "@stencil/core";
import { unawaited } from "../../../classes/async";
import { PreciseCssSetter } from "../../../classes/precise-css-setter";
import { onNextFrame } from "../../../classes/render-util";
import { SlotObserver } from "../../../classes/slot-observer";
import { ErrorPopup } from "../../functional/error-popup";
import { ERROR_CLASS, FOCUS_CLASS, READONLY_CLASS, REQUIRED_CLASS, REQUIREMENT_FULFILLED_CLASS, } from "./bordered-form-commons";
const FOCUSED_CLASS = "focused";
const NOT_FOCUSED_CLASS = "not-focused";
// TODO Die Breite der Bordered-Form-Item können unterschiedlich sein, wenn size === 'parent'.
// Hier könnte man noch weiter gehen und der BorderedFormGroup als FlexBox rendern und overflow:hidden setzen, damit alle Items immer gleich groß sind.
// Dadurch wird ggf. der Text der inneren Items geclippt. Hier müssen wir uns überlegen was das beste wäre.
/**
 * Box to wrap form elements. All elements have the same width.
 *
 * Every child element must be wrapped in a `<ds-bordered-form-item>`.
 *
 * @path /Form/Layout
 * @name Bordered Form Group
 * @shortname Bordered
 * @stable
 */
export class DsBorderedFormGroup {
  constructor() {
    this.blurTimeout = null;
    this.currentFocusedIndex = -1;
    this.containsRequiredField = false;
    /**
     * The direction the elements are aligned.
     *
     * @value row: Elements are displayed in a row
     * @value column: Elements are displayed in a column
     * @example column
     * @example row
     */
    this.direction = "row";
    /**
     * The way how the component computes the width of the child elements.
     *
     * @value parent: Fits the width of the parent element.
     * @value max-content: The largest child element defines the width.
     *
     * @example size-parent
     */
    this.size = "max-content";
    /**
     * @internal
     */
    this.requirementfulfilled = false;
    this.internalRequirementFulfilled = false;
  }
  onDirectionChange() {
    onNextFrame(() => {
      this.computeBorders();
      unawaited(this.refreshWidth());
    });
  }
  onRequirementFulfilled() {
    var _a;
    this.internalRequirementFulfilled = this.isRequirementFulfilled();
    (_a = this.getRequiredNodes()) === null || _a === void 0 ? void 0 : _a.forEach((item) => {
      new PreciseCssSetter(item)
        .set(REQUIREMENT_FULFILLED_CLASS, this.internalRequirementFulfilled)
        .execute();
    });
  }
  connectedCallback() {
    this.slotObserver = new SlotObserver(this.self, "ds-bordered-form-item", (nodes) => {
      this.nodes = nodes;
      this.containsRequiredField = this.nodes.some((node) => node.classList.contains(REQUIRED_CLASS));
      this.internalRequirementFulfilled = this.isRequirementFulfilled();
      const focusedElement = this.nodes.find((node) => node.classList.contains(FOCUS_CLASS));
      if (this.nodes.indexOf(focusedElement) !== this.currentFocusedIndex) {
        this.blurCurrent();
        this.focusElement(focusedElement);
      }
      this.computeBorders();
      this.refreshWidth().then();
    });
  }
  disconnectedCallback() {
    var _a;
    (_a = this.slotObserver) === null || _a === void 0 ? void 0 : _a.disconnect();
  }
  onChildWidthChanged(e) {
    var _a;
    if ((_a = this.nodes) === null || _a === void 0 ? void 0 : _a.includes(e.target)) {
      e.stopPropagation();
      this.refreshWidth().then();
    }
  }
  blurCurrent() {
    const currentFocusedElement = this.nodes[this.currentFocusedIndex];
    if (currentFocusedElement === null || currentFocusedElement === void 0 ? void 0 : currentFocusedElement.classList.contains(FOCUSED_CLASS)) {
      currentFocusedElement === null || currentFocusedElement === void 0 ? void 0 : currentFocusedElement.classList.remove(FOCUSED_CLASS);
    }
    if (!(currentFocusedElement === null || currentFocusedElement === void 0 ? void 0 : currentFocusedElement.classList.contains(NOT_FOCUSED_CLASS))) {
      currentFocusedElement === null || currentFocusedElement === void 0 ? void 0 : currentFocusedElement.classList.add(NOT_FOCUSED_CLASS);
    }
    const currentFocusedNeighborElement = this.nodes[this.currentFocusedIndex - 1];
    if (currentFocusedNeighborElement === null || currentFocusedNeighborElement === void 0 ? void 0 : currentFocusedNeighborElement.classList.contains(FOCUSED_CLASS)) {
      currentFocusedNeighborElement === null || currentFocusedNeighborElement === void 0 ? void 0 : currentFocusedNeighborElement.classList.remove(FOCUSED_CLASS);
    }
    if (!(currentFocusedNeighborElement === null || currentFocusedNeighborElement === void 0 ? void 0 : currentFocusedNeighborElement.classList.contains(NOT_FOCUSED_CLASS))) {
      currentFocusedNeighborElement === null || currentFocusedNeighborElement === void 0 ? void 0 : currentFocusedNeighborElement.classList.add(NOT_FOCUSED_CLASS);
    }
    this.currentFocusedIndex = -1;
  }
  focusElement(element) {
    clearTimeout(this.blurTimeout);
    const indexOfElement = this.nodes.indexOf(element);
    if (indexOfElement != this.currentFocusedIndex) {
      this.blurCurrent();
      const newFocusedElement = this.nodes[indexOfElement];
      newFocusedElement === null || newFocusedElement === void 0 ? void 0 : newFocusedElement.classList.remove(NOT_FOCUSED_CLASS);
      newFocusedElement === null || newFocusedElement === void 0 ? void 0 : newFocusedElement.classList.add(FOCUSED_CLASS);
      const newFocusedNeighborElement = this.nodes[indexOfElement - 1];
      newFocusedNeighborElement === null || newFocusedNeighborElement === void 0 ? void 0 : newFocusedNeighborElement.classList.remove(NOT_FOCUSED_CLASS);
      newFocusedNeighborElement === null || newFocusedNeighborElement === void 0 ? void 0 : newFocusedNeighborElement.classList.add(FOCUSED_CLASS);
      this.currentFocusedIndex = indexOfElement;
    }
  }
  async refreshWidth() {
    if (this.wrapperElement != null) {
      if (this.direction === "row") {
        if (this.size === "parent") {
          this.wrapperElement.style.width = "100%";
        }
        else {
          let maxWidth = 0;
          this.wrapperElement.style.width = `auto`; // layout trashing intended
          for (const item of this.nodes) {
            const formItemRightPadding = 24;
            const formItemLeftPadding = 12;
            const paddingPx = formItemRightPadding + formItemLeftPadding;
            const width = (await item.getContentWidth()) + paddingPx;
            maxWidth = Math.max(width, maxWidth);
          }
          if (maxWidth > 0) {
            const border = this.nodes.length + 1;
            this.wrapperElement.style.width = `${this.nodes.length * maxWidth + border}px`;
          }
        }
      }
      else {
        this.wrapperElement.style.width = null;
      }
    }
    this.nodes.forEach((node) => {
      const classList = node.classList;
      if (!classList.contains(FOCUSED_CLASS) &&
        !classList.contains(NOT_FOCUSED_CLASS)) {
        classList.add(NOT_FOCUSED_CLASS);
      }
    });
  }
  computeBorders() {
    const nodes = this.nodes.filter((node) => !node.hasAttribute("hidden"));
    nodes.forEach((node, index) => {
      const isFirst = index === 0;
      const isLast = index === nodes.length - 1;
      const isPreviousOf = (className) => !isLast && nodes[index + 1].classList.contains(className);
      const isNextOf = (className) => !isFirst && nodes[index - 1].classList.contains(className);
      const markFirst = isFirst || isNextOf(READONLY_CLASS);
      const markLast = isLast || isPreviousOf(READONLY_CLASS);
      const prevOfFocused = isPreviousOf(FOCUS_CLASS);
      const prevOfError = isPreviousOf(ERROR_CLASS);
      const prevOfRequired = isPreviousOf(REQUIRED_CLASS);
      const nextOfFocused = isNextOf(FOCUS_CLASS);
      const nextOfError = isNextOf(ERROR_CLASS);
      const nextOfRequired = isNextOf(REQUIRED_CLASS);
      new PreciseCssSetter(node)
        .set("first", markFirst)
        .set("last", markLast)
        .set("prev-of-focused", prevOfFocused)
        .set("prev-of-error", prevOfError)
        .set("prev-of-required", prevOfRequired)
        .set("next-of-focused", nextOfFocused)
        .set("next-of-error", nextOfError)
        .set("next-of-required", nextOfRequired)
        .set("in-column", this.direction === "column")
        .set("in-row", this.direction === "row")
        .set("parent-size", this.size === "parent")
        .execute();
    });
  }
  getRequiredNodes() {
    var _a;
    return (_a = this.nodes) === null || _a === void 0 ? void 0 : _a.filter((node) => node.classList.contains(REQUIRED_CLASS));
  }
  isRequirementFulfilled() {
    var _a;
    return (this.requirementfulfilled ||
      ((_a = this.getRequiredNodes()) === null || _a === void 0 ? void 0 : _a.every((node) => node.classList.contains(REQUIREMENT_FULFILLED_CLASS))));
  }
  render() {
    const directionClass = {};
    directionClass[this.direction] = true;
    return (h(Host, { class: Object.assign(Object.assign({}, directionClass), { "parent-size": this.size === "parent", required: this.containsRequiredField }) }, h("div", { class: "container" }, h("div", { class: "wrapper", ref: (el) => (this.wrapperElement = el) }, h("slot", null), h(ErrorPopup, { text: this.errormessage, show: this.currentFocusedIndex !== -1 })), h("ds-required-hint", { required: this.containsRequiredField, fulfilled: this.internalRequirementFulfilled }))));
  }
  static get is() { return "ds-bordered-form-group"; }
  static get encapsulation() { return "shadow"; }
  static get originalStyleUrls() {
    return {
      "$": ["ds-bordered-form-group.scss"]
    };
  }
  static get styleUrls() {
    return {
      "$": ["ds-bordered-form-group.css"]
    };
  }
  static get properties() {
    return {
      "direction": {
        "type": "string",
        "mutable": false,
        "complexType": {
          "original": "\"row\" | \"column\"",
          "resolved": "\"column\" | \"row\"",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "row: Elements are displayed in a row"
            }, {
              "name": "value",
              "text": "column: Elements are displayed in a column"
            }, {
              "name": "example",
              "text": "column"
            }, {
              "name": "example",
              "text": "row"
            }],
          "text": "The direction the elements are aligned."
        },
        "attribute": "direction",
        "reflect": false,
        "defaultValue": "\"row\""
      },
      "size": {
        "type": "string",
        "mutable": false,
        "complexType": {
          "original": "\"parent\" | \"max-content\"",
          "resolved": "\"max-content\" | \"parent\"",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "parent: Fits the width of the parent element."
            }, {
              "name": "value",
              "text": "max-content: The largest child element defines the width."
            }, {
              "name": "example",
              "text": "size-parent"
            }],
          "text": "The way how the component computes the width of the child elements."
        },
        "attribute": "size",
        "reflect": false,
        "defaultValue": "\"max-content\""
      },
      "requirementfulfilled": {
        "type": "boolean",
        "mutable": false,
        "complexType": {
          "original": "boolean",
          "resolved": "boolean",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "internal",
              "text": undefined
            }],
          "text": ""
        },
        "attribute": "requirementfulfilled",
        "reflect": false,
        "defaultValue": "false"
      },
      "errormessage": {
        "type": "string",
        "mutable": false,
        "complexType": {
          "original": "string",
          "resolved": "string",
          "references": {}
        },
        "required": false,
        "optional": true,
        "docs": {
          "tags": [{
              "name": "internal",
              "text": undefined
            }],
          "text": ""
        },
        "attribute": "errormessage",
        "reflect": false
      }
    };
  }
  static get states() {
    return {
      "currentFocusedIndex": {},
      "containsRequiredField": {},
      "internalRequirementFulfilled": {}
    };
  }
  static get elementRef() { return "self"; }
  static get watchers() {
    return [{
        "propName": "direction",
        "methodName": "onDirectionChange"
      }, {
        "propName": "requirementfulfilled",
        "methodName": "onRequirementFulfilled"
      }];
  }
  static get listeners() {
    return [{
        "name": "widthChanged",
        "method": "onChildWidthChanged",
        "target": undefined,
        "capture": false,
        "passive": false
      }];
  }
}
