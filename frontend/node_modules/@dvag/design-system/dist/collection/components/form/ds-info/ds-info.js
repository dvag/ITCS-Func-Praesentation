import { h, Host, } from "@stencil/core";
import { ElementIdGenerator, verifyElementId, } from "../../../classes/element-id-handling";
import { SlotObserver } from "../../../classes/slot-observer";
import { isSlotDefined } from "../../../classes/render-util";
import { isActiveElement } from "../../../classes/misc-util";
/**
 * Adds an info button to components. Shows a popover-dialog, when the button is clicked.
 * The content of the popover is variable. Please pay attention to the Design-Patterns.
 * Der Inhalt des Popovers kann frei gewählt werden. Hierfür sind die Designvorgaben zu beachten.
 *
 * @path /Form/Layout
 * @name Infobutton
 * @shortname Info
 * @icon font
 * @slot - Child elements that get wrapped by the info button.
 * @slot modal - Slot to add a modal dialog. This must be defined, if the info-text is larger than 180 characters, to display the whole text or additional informations.
 * @slot content - content of the popover. If the slot is empty, no popover is shown.
 * @stable
 */
export class DsInfo {
  constructor() {
    /**
     * Defines which width the info element takes
     * @value string: max-width
     * @value string: content
     * @important
     */
    this.size = "max-width";
    /**
     * Hide the Infobutton
     * @value true: Infobutton hidden
     * @value false: Infobutton visible
     * @example hidebutton
     */
    this.hidebutton = false;
    /**
     * Manually controls the visiblity of the popup that contains
     * the explaination text.
     * @value false: Popup is not visible.
     * @value true: Popup is visible.
     * @example popupvisible
     */
    this.popupvisible = false;
    this.infoButtonOffsetX = "0px";
    this.infoButtonOffsetY = "0px";
    this.handleModalOpened = () => {
      this.popupvisible = false;
    };
  }
  /**
   * Sets a modal for the info-I
   *
   * Should not be used with the modal-slot. The slotted modal is more important.
   *
   * @example remote-modal
   */
  async setModal(modal) {
    var _a, _b;
    if (this.modal === modal) {
      return;
    }
    (_a = this.modal) === null || _a === void 0 ? void 0 : _a.removeEventListener("modalOpened", this.handleModalOpened);
    this.modal = modal;
    (_b = this.modal) === null || _b === void 0 ? void 0 : _b.addEventListener("modalOpened", this.handleModalOpened);
  }
  windowClicked(e) {
    this.closePopupOnClickOutside(e);
  }
  onWindowKeyDown() {
    var _a;
    if (this.popupvisible) {
      const isActiveElementInLightDom = ((_a = document.activeElement) === null || _a === void 0 ? void 0 : _a.closest("ds-info")) === this.self;
      if (!(isActiveElementInLightDom || isActiveElement(this.self))) {
        this.popupvisible = false;
      }
    }
  }
  componentWillLoad() {
    // TODO: Watch auf hideButton to verifyElementId when hideButton is set to true?
    if (!this.hidebutton) {
      verifyElementId(this.self);
    }
    this.contentResizeObserver = new ResizeObserver(() => {
      requestAnimationFrame(() => {
        this.centerContentAndInfo = this.content.offsetHeight <= 28;
        this.computeInfoButtonOffset();
      });
    });
  }
  connectedCallback() {
    this.modalObserver = new SlotObserver(this.self, "ds-modal", async (nodes) => {
      if (nodes.length > 0) {
        await this.setModal(nodes[0]);
      }
    });
  }
  disconnectedCallback() {
    this.modalObserver.disconnect();
    this.contentResizeObserver.disconnect();
  }
  togglePopUp() {
    if (isSlotDefined(this.self, "content")) {
      this.popupvisible = !this.popupvisible;
    }
  }
  closePopupOnClickOutside(e) {
    var _a;
    if (!((_a = this.modal) === null || _a === void 0 ? void 0 : _a.visible) &&
      this.popupvisible &&
      !e.composedPath().includes(this.popup)) {
      this.popupvisible = false;
      e.stopPropagation();
    }
  }
  setContent(ref) {
    var _a, _b;
    if (ref === this.content) {
      this.computeInfoButtonOffset();
      return;
    }
    if (this.content != null) {
      (_a = this.contentResizeObserver) === null || _a === void 0 ? void 0 : _a.unobserve(this.content);
    }
    this.content = ref;
    (_b = this.contentResizeObserver) === null || _b === void 0 ? void 0 : _b.observe(this.content);
  }
  computeInfoButtonOffset() {
    let offsetX, offsetY;
    const contentSlot = this.content
      .firstElementChild;
    const slottedElements = contentSlot === null || contentSlot === void 0 ? void 0 : contentSlot.assignedElements();
    if (slottedElements != null) {
      for (let i = 0; i < slottedElements.length; ++i) {
        const computedStyle = getComputedStyle(slottedElements[i]);
        offsetX = computedStyle.getPropertyValue("--ds-info-button-offset-x");
        offsetY = computedStyle.getPropertyValue("--ds-info-button-offset-y");
        if (offsetX || offsetY) {
          break;
        }
      }
    }
    this.infoButtonOffsetX = offsetX || "0px";
    this.infoButtonOffsetY = offsetY || "0px";
  }
  render() {
    return (h(Host, { class: {
        "full-width": this.size === "max-width",
        "content-width": this.size === "content",
        "center-content": this.centerContentAndInfo,
      }, style: {
        "--ds-info-button-offset-x": this.infoButtonOffsetX,
        "--ds-info-button-offset-y": this.infoButtonOffsetY,
      } }, h("div", { class: "content", ref: (ref) => this.setContent(ref) }, h("slot", null)), h("div", { class: {
        "info-container": true,
      } }, h("button", { id: ElementIdGenerator.createId(this.self, "info-icon"), onClick: () => this.togglePopUp(), class: {
        "info-button": true,
        hidden: this.hidebutton,
      } }, h("ds-icon", { icon: "info", size: 24 })), h("dx-popup", { dstheme: true, ref: (r) => (this.popup = r), arrowposition: "left", show: this.popupvisible, contentwidth: "unconstrained" }, h("slot", { name: "content" }))), h("slot", { name: "modal" })));
  }
  static get is() { return "ds-info"; }
  static get encapsulation() { return "shadow"; }
  static get originalStyleUrls() {
    return {
      "$": ["ds-info.scss"]
    };
  }
  static get styleUrls() {
    return {
      "$": ["ds-info.css"]
    };
  }
  static get properties() {
    return {
      "size": {
        "type": "string",
        "mutable": false,
        "complexType": {
          "original": "\"max-width\" | \"content\"",
          "resolved": "\"content\" | \"max-width\"",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "string: max-width"
            }, {
              "name": "value",
              "text": "string: content"
            }, {
              "name": "important",
              "text": undefined
            }],
          "text": "Defines which width the info element takes"
        },
        "attribute": "size",
        "reflect": false,
        "defaultValue": "\"max-width\""
      },
      "hidebutton": {
        "type": "boolean",
        "mutable": false,
        "complexType": {
          "original": "boolean",
          "resolved": "boolean",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "true: Infobutton hidden"
            }, {
              "name": "value",
              "text": "false: Infobutton visible"
            }, {
              "name": "example",
              "text": "hidebutton"
            }],
          "text": "Hide the Infobutton"
        },
        "attribute": "hidebutton",
        "reflect": false,
        "defaultValue": "false"
      },
      "popupvisible": {
        "type": "boolean",
        "mutable": true,
        "complexType": {
          "original": "boolean",
          "resolved": "boolean",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "false: Popup is not visible."
            }, {
              "name": "value",
              "text": "true: Popup is visible."
            }, {
              "name": "example",
              "text": "popupvisible"
            }],
          "text": "Manually controls the visiblity of the popup that contains\nthe explaination text."
        },
        "attribute": "popupvisible",
        "reflect": true,
        "defaultValue": "false"
      }
    };
  }
  static get states() {
    return {
      "centerContentAndInfo": {},
      "infoButtonOffsetX": {},
      "infoButtonOffsetY": {}
    };
  }
  static get methods() {
    return {
      "setModal": {
        "complexType": {
          "signature": "(modal: HTMLDsModalElement) => Promise<void>",
          "parameters": [{
              "tags": [],
              "text": ""
            }],
          "references": {
            "Promise": {
              "location": "global"
            },
            "HTMLDsModalElement": {
              "location": "global"
            }
          },
          "return": "Promise<void>"
        },
        "docs": {
          "text": "Sets a modal for the info-I\n\nShould not be used with the modal-slot. The slotted modal is more important.",
          "tags": [{
              "name": "example",
              "text": "remote-modal"
            }]
        }
      }
    };
  }
  static get elementRef() { return "self"; }
  static get listeners() {
    return [{
        "name": "click",
        "method": "windowClicked",
        "target": "window",
        "capture": true,
        "passive": false
      }, {
        "name": "focus",
        "method": "onWindowKeyDown",
        "target": "window",
        "capture": true,
        "passive": false
      }];
  }
}
