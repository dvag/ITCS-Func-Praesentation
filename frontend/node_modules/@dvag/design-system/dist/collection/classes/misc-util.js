export async function waitAnimationFrames(frames) {
  for (let i = 0; i < frames; ++i) {
    await waitAnimationFrame();
  }
}
export async function waitAnimationFrame() {
  return new Promise((resolve) => {
    requestAnimationFrame(() => {
      resolve();
    });
  });
}
/**
 * Returns the lower cased tagName of an HTMLElement
 * @param element The element to get the tag name of or a tagName itself.
 */
export function tagOf(element) {
  var _a;
  return (_a = element === null || element === void 0 ? void 0 : element.tagName) === null || _a === void 0 ? void 0 : _a.toLowerCase();
}
/**
 * Use for elements that are rendered inside the Shadow DOM.
 * For everything else use Element.closest<TYPE>(selector).
 */
export function findUpperElement(of, tagName) {
  const lowerCaseTagName = tagName.toLowerCase();
  return findUpperElementByPredicate(of, (upperElement) => lowerCaseTagName === tagOf(upperElement));
}
/**
 * Use for elements that are rendered inside the Shadow DOM.
 * For everything else use Element.closest<TYPE>(selector).
 */
export function findUpperElementByPredicate(of, predicate, breakCondition) {
  let parent = parentElement(of);
  while (parent != null && !predicate(parent)) {
    if (breakCondition === null || breakCondition === void 0 ? void 0 : breakCondition(parent)) {
      return null;
    }
    parent = parentElement(parent);
  }
  return parent;
}
/**
 * Returns closest parent scroll element.
 */
export function findClosestScrollElement(element) {
  return (findUpperElementByPredicate(element, (elem) => {
    if (!(elem instanceof HTMLElement || elem instanceof SVGElement)) {
      return false;
    }
    const computedStyle = getComputedStyle(elem, null);
    const style = (prop) => computedStyle.getPropertyValue(prop);
    const overflowValues = style("overflow") + style("overflow-x") + style("overflow-y");
    const scrollRegex = /(auto|scroll)/;
    return scrollRegex.test(overflowValues);
  }) || document.documentElement);
}
export function isActiveElement(element) {
  var _a;
  if (document.activeElement === element) {
    return true;
  }
  const upperElement = findUpperElementByPredicate(element, (elem) => {
    return elem.shadowRoot != null && elem.shadowRoot.contains(element);
  });
  return ((_a = upperElement === null || upperElement === void 0 ? void 0 : upperElement.shadowRoot) === null || _a === void 0 ? void 0 : _a.activeElement) === element;
}
export function getInnerActiveElement(element) {
  if (!isActiveElement(element)) {
    return null;
  }
  function _internalGetInnerActiveElement(element) {
    var _a;
    if (element == null) {
      return null;
    }
    return (_internalGetInnerActiveElement((_a = element.shadowRoot) === null || _a === void 0 ? void 0 : _a.activeElement) || element);
  }
  return _internalGetInnerActiveElement(element);
}
/**
 * Use for elements that are rendered inside the Shadow DOM.
 * For everything else use Element.closest<TYPE>(selector).
 */
export function isInnerElement(element, of) {
  let parent = parentElement(element);
  while (parent != null && parent !== of) {
    parent = parentElement(parent);
  }
  return parent === of;
}
export function parentElement(el) {
  var _a, _b, _c;
  return ((_b = (_a = el === null || el === void 0 ? void 0 : el.assignedSlot) !== null && _a !== void 0 ? _a : el === null || el === void 0 ? void 0 : el.parentElement) !== null && _b !== void 0 ? _b : (_c = el === null || el === void 0 ? void 0 : el.getRootNode()) === null || _c === void 0 ? void 0 : _c.host);
}
/**
 * Checks if two arrays contain the same items with the same indices within the array.
 * @param first: First array
 * @param second: Second array
 */
export function sameArrayInOrder(first, second) {
  if ((first === null || first === void 0 ? void 0 : first.length) === (second === null || second === void 0 ? void 0 : second.length)) {
    return first === null || first === void 0 ? void 0 : first.every((data, index) => {
      return data === second[index];
    });
  }
  return false;
}
/**
 * Checks if two arrays contain the same items.
 * @param first: First array
 * @param second: Second array
 */
export function sameArrayIgnoreOrder(first, second) {
  if ((first === null || first === void 0 ? void 0 : first.length) === (second === null || second === void 0 ? void 0 : second.length)) {
    const refMap = new Map();
    // Fill map and track each ref/value
    first === null || first === void 0 ? void 0 : first.forEach((value) => {
      var _a;
      const newValue = ((_a = refMap.get(value)) !== null && _a !== void 0 ? _a : 0) + 1;
      refMap.set(value, newValue);
    });
    // Decrement refs/values and check if there is no over decrement (< 0)
    const firstContainsSecond = second === null || second === void 0 ? void 0 : second.every((value) => {
      var _a;
      const newValue = ((_a = refMap.get(value)) !== null && _a !== void 0 ? _a : 0) - 1;
      refMap.set(value, newValue);
      return newValue >= 0;
    });
    return (firstContainsSecond &&
      Array.from(refMap.values()).every((value) => value === 0));
  }
  return false;
}
/**
 * Filters nodes by tag name
 */
export function filterElementsByTagPrefix(nodes, tagName) {
  return nodes.filter((node) => node.tagName.toLocaleLowerCase().startsWith(tagName));
}
export function getSlottedContent(element) {
  return Array.from(element.querySelectorAll(":scope > *"))
    .map((element) => getContentFromSlot(element))
    .flat();
}
export function getNamedSlottedContent(element, slot) {
  const query = slot ? `:scope > *[slot="${slot}"]` : ":scope > *:not([slot])";
  return Array.from(element.querySelectorAll(query))
    .map((element) => getContentFromSlot(element))
    .flat();
}
/**
 * Returns all contents within a slot element recursively. If the provided element is not a slot element it returns
 * the element itself.
 * @param element: The slot element
 */
export function getContentFromSlot(element) {
  var _a, _b;
  const assignedElements = (_b = (_a = element).assignedElements) === null || _b === void 0 ? void 0 : _b.call(_a);
  if (assignedElements != null) {
    return assignedElements
      .map((assignedElement) => getContentFromSlot(assignedElement))
      .flat();
  }
  return element;
}
/**
 * Checks whether an element could has overflowing content.
 * @param element: The element which should be checked. Normally this would be an element which has the corresponding styles applied to it (text-overflow, overflow, etc.)
 *
 * @return Whether the element is overflowing.
 */
export function isOverflown(element) {
  // 8 is half of the minimum line-height of 16px. This is used as a bias because the scrollHeight is not always completely equal to the offsetHeight.
  const pxBias = 8;
  return (element === null || element === void 0 ? void 0 : element.offsetHeight) + pxBias < (element === null || element === void 0 ? void 0 : element.scrollHeight);
}
/**
 * Generates initials for a person's full name.
 * @param fullname The name to generate the initials from. The fullname has to begin with the firstname and has to end with
 * the lastname with all names separated by a space.
 */
export function generateInitialsForName(fullname) {
  const split = fullname.trim().split(" ");
  if (split.length >= 2) {
    return `${split[0][0]}${split[split.length - 1][0]}`.toUpperCase();
  }
  if (split.length === 1) {
    return `${split[0][0]}`.toUpperCase();
  }
  return "";
}
export function createNumberArray(from, to) {
  return Array.from(Array(to - from + 1)).map((_, index) => index + from);
}
/* Replace a comma with a period */
export function replaceCommaWithDot(value) {
  return value.replace(",", ".");
}
/**
 * Thanks to the never type this function throws a compile error, when the program can reach the function call.
 * @param never
 * Use this in the default case of a switch that swtiches on a enum type, to make it typesafe-ish.
 * @example switch(weekday) {
 *  case Weekday.Sunday:
 * return "Free";
 * default:
 *  throwCompileErrorIfReachable(weekday);
 * }
 *
 */
export const throwCompileErrorIfReachable = (never) => {
  never;
  //thanks to the never type this function throws a compile error, when the program can reach the function call.
};
// Objects have to have a getter and setter for the function to work properly
export function hookToUpdateProperty(obj, prop, onSetProperty) {
  try {
    const descriptor = Object.getOwnPropertyDescriptor(Object.getPrototypeOf(obj), prop);
    if (descriptor != undefined) {
      // Throws an error when a property is redefined
      Object.defineProperty(obj, prop, {
        set: function (newValue) {
          const oldValue = descriptor.get.apply(this);
          const setter = descriptor.set.apply(this, [newValue]);
          if (newValue !== oldValue) {
            onSetProperty === null || onSetProperty === void 0 ? void 0 : onSetProperty(newValue);
          }
          return setter;
        },
        get: function () {
          return descriptor.get.apply(this);
        },
      });
    }
  }
  catch (e) { }
}
