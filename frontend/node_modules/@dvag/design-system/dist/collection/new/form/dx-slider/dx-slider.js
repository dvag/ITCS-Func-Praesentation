import { forceUpdate, h, Host, } from "@stencil/core";
import { assert } from "../../../classes/assert";
import { DragController } from "../../../classes/drag-controller";
import { clamp } from "../../../classes/math-util";
import { PreciseCssSetter } from "../../../classes/precise-css-setter";
import { onNextFrame } from "../../../classes/render-util";
import { formatValue, roundByStep } from "./slider-util";
/**
 * Form element that displays a selectable range of numeric values.
 * @path /Form/Inputs
 * @name Slider
 * @icon sliders-h
 * @stable
 */
export class DxSlider {
  constructor() {
    this.ticksOfKeyDown = 0;
    /**
     * Step size of the slider values. Possible values are always multiples of
     * the step size. Values are automatically rounded to match the step size.
     * @value number: step size.
     * @example step
     */
    this.step = 0.01;
    /**
     * If enabled, it displays labels for the minimum and maximum values.
     * @value false: labels are hidden (default)
     * @value true: labels are shown
     * @example show-min-max-label
     */
    this.showminmaxlabel = false;
    /**
     * If enabled, it displays a label with the current value above the knob.
     * @value true: label is shown (default)
     * @value false: label is hidden
     * @example show-value-label
     */
    this.showvaluelabel = true;
    /**
     * Pattern used to format the current value.
     * A '$' followed by a digit represents the value of the slider.
     * The value of digits determines the amount of decimal numbers.
     *
     * @value string: formatting of the slider value, e.g. `$1 %` or `$2 â‚¬`
     * @example formattingpattern
     */
    this.formattingpattern = "$0";
    /**
     * Turns the input into the read-only mode.
     * @value false: value can be modified by the user (default)
     * @value true: value can not be modified by the user
     * @example readonly
     */
    this.readonly = false;
    /**
     * Defines if the input field is enabled or not.
     * @value true: Input ist disabled
     * @value false: Input is not disabled
     * @example disabled
     */
    this.disabled = false;
  }
  valueChanged() {
    if (this.value != null && isNaN(this.value)) {
      console.error(`<dx-slider> has an invalid value set for property 'value'.`);
      // Stencil's implicit type conversion interpreted some input for 'value' as NaN.
      // We need to fix this immediately.
      this.value = null;
    }
  }
  componentDidRender() {
    onNextFrame(() => this.updatePosition());
  }
  componentWillLoad() {
    this.dragController = new DragController(() => this.value, (e) => {
      const boundingBox = this.lineElement.getBoundingClientRect();
      const leftLimit = boundingBox.left;
      const rightLimit = boundingBox.right;
      const relativeValue = Math.max(0, Math.min((e.x - leftLimit) / (rightLimit - leftLimit), 1));
      this.applyNewValue(relativeValue);
    });
  }
  connectedCallback() {
    this.resizeObserver = new ResizeObserver(() => forceUpdate(this));
    this.resizeObserver.observe(this.self);
  }
  disconnectedCallback() {
    var _a;
    (_a = this.resizeObserver) === null || _a === void 0 ? void 0 : _a.disconnect();
  }
  updatePosition() {
    const lineWidth = this.lineElement.offsetWidth;
    // Position of the knob
    const knobLeft = (lineWidth - KNOB_WIDTH) * this.relativeValue;
    this.knobElement.style.transform = `translateX(${knobLeft}px)`;
    // Position the value label above the knob
    if (this.showvaluelabel) {
      this.updateValueLabelPosition(lineWidth);
    }
    // Show / hide the min max label, if they overlap with knob
    if (this.showminmaxlabel) {
      this.updateMinMaxLabelVisibility(knobLeft);
    }
  }
  updateValueLabelPosition(lineWidth) {
    const labelTextWidth = this.labelTextElement.offsetWidth;
    this.valueElement.style.transform = `translateX(${clamp((lineWidth - KNOB_WIDTH) * this.relativeValue -
      labelTextWidth / 2 +
      KNOB_WIDTH / 2, 0, Math.max(0, lineWidth - labelTextWidth))}px)`;
  }
  updateMinMaxLabelVisibility(knobLeft) {
    const minRect = this.minLabelElement.getBoundingClientRect();
    const maxRect = this.maxLabelElement.getBoundingClientRect();
    const knobRectLeft = minRect.left + knobLeft;
    const knobRectRight = knobRectLeft + KNOB_WIDTH;
    new PreciseCssSetter(this.minLabelElement)
      .set("visible", knobRectLeft > minRect.right)
      .execute();
    new PreciseCssSetter(this.maxLabelElement)
      .set("visible", knobRectRight < maxRect.left)
      .execute();
    // After first rendering (therefore we need onNextFrame), we make this animating
    if (!this.minLabelElement.classList.contains("animated")) {
      onNextFrame(() => {
        this.minLabelElement.classList.add("animated");
        this.maxLabelElement.classList.add("animated");
      });
    }
  }
  clickOnSlider(e) {
    const lineRect = this.lineElement.getBoundingClientRect();
    const left = lineRect.left + KNOB_WIDTH * 0.5;
    const right = lineRect.right - KNOB_WIDTH * 0.5;
    const relativeValue = clamp((e.clientX - left) / (right - left), 0, 1);
    this.applyNewValue(relativeValue);
  }
  applyNewValue(relativeValue) {
    this.value = roundByStep(relativeValue, this.min, this.max, this.step);
    this.valueChange.emit(this.value);
  }
  eventCanControlValueByKey(e) {
    return (!this.readonly &&
      !this.disabled &&
      (e.key === "ArrowLeft" || e.key === "ArrowRight"));
  }
  keyDownOnSlider(e) {
    if (!this.eventCanControlValueByKey(e)) {
      return;
    }
    // Count each key down event as a tick
    this.ticksOfKeyDown++;
    // Compute delta
    const sign = e.key === "ArrowLeft" ? -1 : 1;
    const delta = sign *
      (!e.shiftKey
        ? // by default: increase step size a magnitude (10^n) each 10 ticks
          this.step * Math.pow(10, Math.floor(this.ticksOfKeyDown / 10))
        : // with shift-key: step by 1/10th of the range
          (this.max - this.min) / 10);
    // Convert to a relative value, so we can apply it by our default roundByStep function
    const relativeValue = clamp((this.value + delta - this.min) / (this.max - this.min), 0, 1);
    this.applyNewValue(relativeValue);
    e.preventDefault(); // prevents scrolling
  }
  keyUpOnSlider(e) {
    if (!this.eventCanControlValueByKey(e)) {
      return;
    }
    // If a key is released, reset time information
    this.ticksOfKeyDown = 0;
    e.preventDefault(); // prevents scrolling
  }
  checkAsserts() {
    assert(this.min != null, () => "<dx-slider> requires the property 'min'");
    assert(this.max != null, () => "<dx-slider> requires the property 'max'");
    assert(this.min < this.max, () => "<dx-slider> requires 'min' to be lower then 'max'");
    assert(this.value >= this.min && this.value <= this.max, () => "<dx-slider> requires 'value' to be between 'min' and 'max'");
  }
  get usedValue() {
    return clamp(this.value, this.min, this.max);
  }
  /**
   * The relative value represents the [value] within the [min] and [max] range
   * as a value between 0.0 and 1.0.
   */
  get relativeValue() {
    return (this.usedValue - this.min) / (this.max - this.min);
  }
  renderLabel() {
    var _a;
    if (((_a = this.label) === null || _a === void 0 ? void 0 : _a.length) > 0) {
      return (h("div", { class: "label" }, h("dx-text", { type: "Infotext-Standard", color: "headline" }, this.label)));
    }
  }
  renderMinMaxLabels() {
    if (this.showminmaxlabel) {
      return (h("div", { class: "min-max-labels" }, h("dx-text", { type: "Infotext-Small", color: "tags", ref: (el) => (this.minLabelElement = el) }, formatValue(this.min, this.formattingpattern)), h("dx-text", { type: "Infotext-Small", color: "tags", ref: (el) => (this.maxLabelElement = el) }, formatValue(this.max, this.formattingpattern))));
    }
  }
  renderValue() {
    if (this.showvaluelabel) {
      return (h("div", { class: "value", ref: (el) => (this.valueElement = el) }, h("dx-text", { type: "Paragraph-Big", color: "headline", ref: (el) => (this.labelTextElement = el) }, formatValue(this.usedValue, this.formattingpattern))));
    }
  }
  render() {
    this.checkAsserts();
    const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
    return (h(Host, { class: {
        readonly: this.readonly,
        disabled: this.disabled,
        "is-safari": isSafari,
      }, tabIndex: 0, onKeyDown: (e) => this.keyDownOnSlider(e), onKeyUp: (e) => this.keyUpOnSlider(e) }, this.renderValue(), h("div", { class: "slider", onClick: (e) => this.clickOnSlider(e) }, h("div", { class: "line", ref: (el) => (this.lineElement = el) }, h("div", { class: "filled", style: { transform: `scaleX(${this.relativeValue})` } })), this.renderMinMaxLabels(), h("div", { class: "knob", ref: (el) => (this.knobElement = el), onClick: (e) => e.stopPropagation(), onPointerDown: (e) => this.dragController.onPointerDown(e), onTouchStart: (e) => this.dragController.onTouchStart(e) })), this.renderLabel(), h("div", { class: "keyboard-focus" })));
  }
  static get is() { return "dx-slider"; }
  static get encapsulation() { return "shadow"; }
  static get originalStyleUrls() {
    return {
      "$": ["dx-slider.scss"]
    };
  }
  static get styleUrls() {
    return {
      "$": ["dx-slider.css"]
    };
  }
  static get properties() {
    return {
      "min": {
        "type": "number",
        "mutable": false,
        "complexType": {
          "original": "number",
          "resolved": "number",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "number: minimal value of the slider."
            }, {
              "name": "example",
              "text": "min-max-value"
            }],
          "text": "Lower bounds of the slider range."
        },
        "attribute": "min",
        "reflect": false
      },
      "max": {
        "type": "number",
        "mutable": false,
        "complexType": {
          "original": "number",
          "resolved": "number",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "number: maximum value of the slider."
            }, {
              "name": "example",
              "text": "min-max-value"
            }],
          "text": "Upper bounds of the slider range."
        },
        "attribute": "max",
        "reflect": false
      },
      "step": {
        "type": "number",
        "mutable": false,
        "complexType": {
          "original": "number",
          "resolved": "number",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "number: step size."
            }, {
              "name": "example",
              "text": "step"
            }],
          "text": "Step size of the slider values. Possible values are always multiples of\nthe step size. Values are automatically rounded to match the step size."
        },
        "attribute": "step",
        "reflect": false,
        "defaultValue": "0.01"
      },
      "value": {
        "type": "number",
        "mutable": true,
        "complexType": {
          "original": "number",
          "resolved": "number",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "number: current value"
            }, {
              "name": "example",
              "text": "min-max-value"
            }],
          "text": "Current value of the slider."
        },
        "attribute": "value",
        "reflect": true
      },
      "showminmaxlabel": {
        "type": "boolean",
        "mutable": false,
        "complexType": {
          "original": "boolean",
          "resolved": "boolean",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "false: labels are hidden (default)"
            }, {
              "name": "value",
              "text": "true: labels are shown"
            }, {
              "name": "example",
              "text": "show-min-max-label"
            }],
          "text": "If enabled, it displays labels for the minimum and maximum values."
        },
        "attribute": "showminmaxlabel",
        "reflect": false,
        "defaultValue": "false"
      },
      "showvaluelabel": {
        "type": "boolean",
        "mutable": false,
        "complexType": {
          "original": "boolean",
          "resolved": "boolean",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "true: label is shown (default)"
            }, {
              "name": "value",
              "text": "false: label is hidden"
            }, {
              "name": "example",
              "text": "show-value-label"
            }],
          "text": "If enabled, it displays a label with the current value above the knob."
        },
        "attribute": "showvaluelabel",
        "reflect": false,
        "defaultValue": "true"
      },
      "formattingpattern": {
        "type": "string",
        "mutable": false,
        "complexType": {
          "original": "string",
          "resolved": "string",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "string: formatting of the slider value, e.g. `$1 %` or `$2 \u20AC`"
            }, {
              "name": "example",
              "text": "formattingpattern"
            }],
          "text": "Pattern used to format the current value.\nA '$' followed by a digit represents the value of the slider.\nThe value of digits determines the amount of decimal numbers."
        },
        "attribute": "formattingpattern",
        "reflect": false,
        "defaultValue": "\"$0\""
      },
      "label": {
        "type": "string",
        "mutable": false,
        "complexType": {
          "original": "string",
          "resolved": "string",
          "references": {}
        },
        "required": false,
        "optional": true,
        "docs": {
          "tags": [{
              "name": "important",
              "text": undefined
            }, {
              "name": "value",
              "text": "string: Text, e.g. `Amount`"
            }, {
              "name": "example",
              "text": "label"
            }],
          "text": "Label text below the slider."
        },
        "attribute": "label",
        "reflect": false
      },
      "readonly": {
        "type": "boolean",
        "mutable": false,
        "complexType": {
          "original": "boolean",
          "resolved": "boolean",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "false: value can be modified by the user (default)"
            }, {
              "name": "value",
              "text": "true: value can not be modified by the user"
            }, {
              "name": "example",
              "text": "readonly"
            }],
          "text": "Turns the input into the read-only mode."
        },
        "attribute": "readonly",
        "reflect": false,
        "defaultValue": "false"
      },
      "disabled": {
        "type": "boolean",
        "mutable": false,
        "complexType": {
          "original": "boolean",
          "resolved": "boolean",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "true: Input ist disabled"
            }, {
              "name": "value",
              "text": "false: Input is not disabled"
            }, {
              "name": "example",
              "text": "disabled"
            }],
          "text": "Defines if the input field is enabled or not."
        },
        "attribute": "disabled",
        "reflect": false,
        "defaultValue": "false"
      }
    };
  }
  static get events() {
    return [{
        "method": "valueChange",
        "name": "valueChange",
        "bubbles": true,
        "cancelable": true,
        "composed": true,
        "docs": {
          "tags": [{
              "name": "example",
              "text": "value-change"
            }],
          "text": "User made changes. Contains the chosen value."
        },
        "complexType": {
          "original": "number",
          "resolved": "number",
          "references": {}
        }
      }];
  }
  static get elementRef() { return "self"; }
  static get watchers() {
    return [{
        "propName": "value",
        "methodName": "valueChanged"
      }];
  }
}
const KNOB_WIDTH = 40;
