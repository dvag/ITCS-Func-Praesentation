import { h, Host, } from "@stencil/core";
import { assert } from "../../../../classes/assert";
import { ElementIdGenerator, verifyElementId, } from "../../../../classes/element-id-handling";
import { hasError } from "../../../../classes/error";
import { hookToUpdateProperty, isActiveElement, } from "../../../../classes/misc-util";
import { notHidden } from "../../../../classes/query-util";
import { onNextFrame } from "../../../../classes/render-util";
import { createMetaComponentsSlotObserver, } from "../../../../classes/slot-observer";
import { findDuplicatedValues } from "../../../../classes/value";
import { ReadonlyTextElement } from "../../../functional/base-elements";
import { ErrorMessage } from "../../../functional/error-elements";
import { LabeledInputContainer } from "../../../functional/input-container";
/**
 * Form element for selecting multiple options in a list.
 *
 * @path /Form/Dropdown
 * @name Multi-Dropdown
 * @shortname Multi
 * @icon caret-square-down
 * @stable
 *
 * @slot error-message - This slot can be defined with a `<dx-error-message>` element.
 */
export class DxMultiDropdown {
  constructor() {
    this.lastEmittedChangeValue = null;
    this.lastEmittedCompleteValue = null;
    this.preventReFocus = false;
    this.selectScanningEnabled = true;
    this.options = [];
    this.inputFocused = false;
    this.listOpen = false;
    this.internalValue = [];
    this.showMouseHoverEffectOnList = true;
    this.activeIndex = null;
    /**
     * The size of the dropdown.
     *
     * @value s: A small dropdown is displayed.
     * @value m: A medium sized dropdown is displayed.
     */
    this.size = "m";
    /**
     * The selection label will be displayed when at least one option is selected.
     *
     * @value string: The text which is displayed next to the amount of selected options.
     */
    this.selectionlabel = "Gewählte Kategorien";
    /**
     * Whether the selection is readonly or editable.
     * If true the value of this component will be visualized as a normal text.
     * @value false: Input is editable.
     * @value true: Input is read-only.
     *
     * @example readonly
     */
    this.readonly = false;
    /**
     * Marks this input field as a required form element.
     * @value false: Not required
     * @value true: It is necessary to select an option to fulfill the requirement.
     * @example required
     */
    this.required = false;
    /**
     * Indicates that the form is synced with the KI.
     * @value true: Synchronized.
     * @value false: Not synchronized.
     * @example kisynced
     */
    this.kisynced = false;
    /**
     * Placeholder text which is displayed when no option is currently selected.
     * @value string: Placeholder text
     * @example placeholder
     */
    this.placeholder = "Bitte auswählen ...";
    /**
     * Defines the text alignment.
     * @value left: Text is left aligned.
     * @value right: Text is right aligned.
     * @example text-align
     */
    this.textalign = "left";
    /**
     * Defines the position of the dropdown list.
     * @value top: The list is displayed at the top of the input field.
     * @value bottom: The list is displayed at the bottom of the input field.
     * @example popup-position
     */
    this.popupposition = "bottom";
    /**
     * Defines whether the dropdown is enabled or not.
     * @value true: Dropdown is not editable.
     * @value false: Dropdown is editable.
     * @example disabled
     */
    this.disabled = false;
  }
  componentWillLoad() {
    this.internalPopupPosition = this.popupposition;
    verifyElementId(this.self);
  }
  connectedCallback() {
    this.optionsObserver =
      createMetaComponentsSlotObserver(this.self, "dx-dropdown-option", async (nodes) => {
        await this.collectOptions(nodes);
        const duplicates = findDuplicatedValues(this.options);
        assert(duplicates.length == 0, () => `It is not allowed for multiple 'dx-dropdown-option' elements to share the same value!\nFollowing duplicated value were found: ${duplicates.join()}`, this.self);
      });
  }
  disconnectedCallback() {
    var _a;
    (_a = this.optionsObserver) === null || _a === void 0 ? void 0 : _a.disconnect();
    clearInterval(this.observeSelectElementIntervalHandle);
  }
  onForceUpdateOnChange(e) {
    e.detail(this.self);
  }
  /**
   * Sets the focus on this element.
   *
   * @example focus
   */
  async focusControl() {
    this.inputElement.focus();
  }
  async collectOptions(nodes) {
    this.options = await Promise.all(nodes.map((node) => {
      return node.toOption();
    }));
  }
  onInputFocused() {
    this.inputFocused = true;
  }
  onInputBlurred() {
    onNextFrame(() => {
      if (this.preventReFocus || !isActiveElement(this.self)) {
        this.inputFocused = false;
        this.setOpenListStatus(false);
        this.emitValueChange();
        this.emitValueComplete();
      }
      else {
        this.inputElement.focus();
      }
      this.preventReFocus = false;
    });
  }
  toggleList() {
    this.setOpenListStatus(!this.listOpen);
  }
  onInputKeyUp(event) {
    if (["Enter", "Escape"].includes(event.code)) {
      this.setOpenListStatus(false);
      this.emitValueComplete();
    }
  }
  /**
   * Delegates keyboard events to the underlying list element.
   * The list element itself cannot receive keyboard events because it has a tabIndex of -1.
   */
  onInputKeyDown(event) {
    const listFlyoutElement = this.self.shadowRoot.querySelector("dx-list-flyout");
    if (event.target === listFlyoutElement) {
      return;
    }
    if (["ArrowDown", "ArrowUp", "Space"].includes(event.code)) {
      event.preventDefault();
    }
    if (this.listOpen) {
      listFlyoutElement === null || listFlyoutElement === void 0 ? void 0 : listFlyoutElement.dispatchEvent(new event.constructor(event.type, event));
    }
    else if (event.code === "ArrowDown" || event.code === "ArrowUp") {
      this.setOpenListStatus(true);
    }
  }
  onInputClicked() {
    if (!this.disabled) {
      this.toggleList();
    }
  }
  setOpenListStatus(isOpen) {
    this.listOpen = isOpen;
    if (this.listOpen) {
      this.inputElement.focus();
    }
  }
  /**
   * Used by the hidden native <select> to react to changes.
   */
  selectOptionsByValue(text) {
    if (text === NULL_STRING) {
      if (this.internalValue.length > 0) {
        this.internalValue = [];
        this.emitValueChange();
      }
    }
    else {
      const optionsWithValueMatchingText = this.options.filter((option) => JSON.stringify(option.value) === text);
      if (optionsWithValueMatchingText != null) {
        this.emitValueChange();
      }
    }
  }
  get selectedDropdownOptions() {
    return this.options.filter((option) => option.selected);
  }
  get selectedOptions() {
    return this.selectedDropdownOptions.map((option) => option.value);
  }
  get selectedDropdownOptionElements() {
    return Array.from(this.getInnerDropdownOptionElements()).filter((option) => option.selected);
  }
  compareArray(valuesA, valuesB) {
    return ((valuesA === null || valuesA === void 0 ? void 0 : valuesA.length) === (valuesB === null || valuesB === void 0 ? void 0 : valuesB.length) &&
      (valuesA === null || valuesA === void 0 ? void 0 : valuesA.every((value) => valuesB === null || valuesB === void 0 ? void 0 : valuesB.includes(value))));
  }
  emitValueChange() {
    const selectedOptions = this.selectedDropdownOptionElements;
    if (!this.compareArray(this.lastEmittedChangeValue, selectedOptions)) {
      this.valueChange.emit(selectedOptions);
      this.lastEmittedChangeValue = selectedOptions;
    }
  }
  emitValueComplete() {
    const selectedOptions = this.selectedDropdownOptionElements;
    if (!this.compareArray(this.lastEmittedCompleteValue, selectedOptions)) {
      this.valueComplete.emit(selectedOptions);
      this.lastEmittedCompleteValue = selectedOptions;
    }
  }
  superviseSelectElement(el) {
    clearInterval(this.observeSelectElementIntervalHandle);
    // When the value of the select changes we want to run the code below
    hookToUpdateProperty(el, "value", () => {
      const areAllOptionsScanned = () => {
        // +1 because native select includes a null option
        const nativeSelectOptionLength = this.options.length + 1;
        return el.querySelectorAll("option").length >= nativeSelectOptionLength;
      };
      const selectedOptions = Array.from(el.options)
        .filter((option) => option.selected)
        .join(",");
      if (this.selectScanningEnabled &&
        !this.readonly &&
        areAllOptionsScanned()) {
        this.selectOptionsByValue(selectedOptions);
      }
    });
  }
  onItemSelectionChanged(e) {
    this.getInnerDropdownOptionElements().forEach((option) => {
      var _a;
      option.selected =
        ((_a = e.detail.selectedItems) === null || _a === void 0 ? void 0 : _a.indexOf(option.value || option.label)) !== -1;
    });
    this.emitValueChange();
  }
  onPopupPositionChanged(e) {
    this.internalPopupPosition = e.detail;
  }
  getInnerDropdownOptionElements() {
    return this.self.querySelectorAll(notHidden("dx-dropdown-option"));
  }
  isChevronRotated() {
    // If list is open rotate chevron icon
    let rotated = this.listOpen;
    // If popupposition is at the top, invert current rotation
    if (this.internalPopupPosition === "top") {
      rotated = !rotated;
    }
    return rotated;
  }
  render() {
    var _a, _b, _c, _d;
    if (this.readonly) {
      return (h(ReadonlyTextElement, { text: (_a = this.selectedDropdownOptions
          .map((option) => option.label)
          .join(", ")) !== null && _a !== void 0 ? _a : "", label: this.label }));
    }
    return (h(Host, { class: {
        disabled: this.disabled,
      } }, h("div", { class: {
        input: true,
        "size-s": this.size === "s",
        "size-m": this.size === "m",
      }, ref: (el) => (this.inputElement = el), id: ElementIdGenerator.createId(this.self, "user-interaction"), tabIndex: this.disabled ? -1 : 0, onKeyDown: (event) => this.onInputKeyDown(event), onKeyUp: (event) => this.onInputKeyUp(event), onFocus: () => this.onInputFocused(), onBlur: () => this.onInputBlurred(), onClick: () => this.onInputClicked() }, h("dx-list-flyout", { open: this.listOpen, position: this.popupposition, direction: this.textalign === "left" ? "right" : "left", itemsvisible: 5.5, size: "m", selectionmode: "multi", stopclickpropagationonpopup: true, class: {
        "respect-label-height": ((_b = this.label) === null || _b === void 0 ? void 0 : _b.length) > 0,
      } }, h(LabeledInputContainer, { slot: "base", containerProperties: {
        active: this.inputFocused,
        size: this.size,
        error: hasError(this.self),
        title: (_d = (_c = this.selectedDropdownOptions) === null || _c === void 0 ? void 0 : _c.map((selectedOption) => {
          var _a;
          return (_a = selectedOption === null || selectedOption === void 0 ? void 0 : selectedOption.label) !== null && _a !== void 0 ? _a : selectedOption.value;
        })) === null || _d === void 0 ? void 0 : _d.join(","),
      }, labelProperties: {
        label: this.label,
        disabled: this.disabled,
        required: this.required,
        kisynced: this.kisynced,
      } }, this.renderNativeSelect(), this.renderCurrentValue(), this.renderOpenListButton()), this.renderItemList())), h(ErrorMessage, { self: this.self, message: this.errormessage, custom: {
        onFocus: () => {
          this.preventReFocus = true;
        },
        onBlur: () => {
          this.preventReFocus = false;
        },
      } })));
  }
  renderNativeSelect() {
    // The native select can be used for test automation tools to
    // change and read values from the select box.
    const nativeOptions = [
      {
        label: "-",
        value: NULL_STRING,
        icon: null,
        selected: this.selectedOptions.length === 0,
      },
      ...this.options,
    ];
    return (h("select", { id: ElementIdGenerator.createId(this.self, "control"), ref: (el) => this.superviseSelectElement(el), tabIndex: -1, onChange: (e) => {
        const value = e.target.value;
        this.selectOptionsByValue(value);
      }, multiple: true }, nativeOptions.map((option) => {
      return (h("option", { selected: option.value === this.internalValue ||
          (this.internalValue === null && option.value === NULL_STRING), value: JSON.stringify(option.value) }, option.label));
    })));
  }
  renderOpenListButton() {
    return (h("div", { id: ElementIdGenerator.createId(this.self, "open-list-button"), class: {
        "open-list-button": true,
      } }, h("dx-chevron", { directiontop: this.isChevronRotated(), active: this.inputFocused })));
  }
  renderItemList() {
    return this.options.map((option, index) => {
      return (h("dx-list-item", { id: ElementIdGenerator.createId(this.self, `list-item-${index}`), type: "checkbox", value: option.value, label: option.label, icon: option.icon, textalign: this.textalign, selected: option.selected }));
    });
  }
  renderOption(option, isPlaceholder = false) {
    return (h("div", { id: !isPlaceholder
        ? ElementIdGenerator.createId(this.self, `item-list-value-${option.value}`)
        : undefined, class: {
        item: true,
        "is-placeholder": isPlaceholder,
        right: this.textalign == "right",
        selected: option.selected,
        disabled: this.disabled === true,
      } }, option.icon != null ? h("dx-icon", { size: 24, icon: option.icon }) : null, h("dx-text", { key: option.label, class: { label: true, "align-right": this.textalign === "right" } }, option.label)));
  }
  renderCurrentValue() {
    const className = "current-value";
    const selectedOptions = this.selectedOptions;
    if (selectedOptions.length > 0) {
      return (h("div", { class: className }, this.renderOption({
        label: `${this.selectionlabel} (${selectedOptions.length})`,
        value: selectedOptions,
        icon: this.icon,
        selected: true,
      }, false)));
    }
    return (h("div", { class: className }, this.renderOption({
      label: this.placeholder,
      icon: this.icon,
      value: "",
      selected: false,
    }, true)));
  }
  static get is() { return "dx-multi-dropdown"; }
  static get encapsulation() { return "shadow"; }
  static get originalStyleUrls() {
    return {
      "$": ["dx-multi-dropdown.scss"]
    };
  }
  static get styleUrls() {
    return {
      "$": ["dx-multi-dropdown.css"]
    };
  }
  static get properties() {
    return {
      "size": {
        "type": "string",
        "mutable": false,
        "complexType": {
          "original": "\"s\" | \"m\"",
          "resolved": "\"m\" | \"s\"",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "s: A small dropdown is displayed."
            }, {
              "name": "value",
              "text": "m: A medium sized dropdown is displayed."
            }],
          "text": "The size of the dropdown."
        },
        "attribute": "size",
        "reflect": false,
        "defaultValue": "\"m\""
      },
      "selectionlabel": {
        "type": "string",
        "mutable": false,
        "complexType": {
          "original": "string",
          "resolved": "string",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "string: The text which is displayed next to the amount of selected options."
            }],
          "text": "The selection label will be displayed when at least one option is selected."
        },
        "attribute": "selectionlabel",
        "reflect": false,
        "defaultValue": "\"Gew\u00E4hlte Kategorien\""
      },
      "label": {
        "type": "string",
        "mutable": false,
        "complexType": {
          "original": "string",
          "resolved": "string",
          "references": {}
        },
        "required": false,
        "optional": true,
        "docs": {
          "tags": [{
              "name": "important",
              "text": undefined
            }, {
              "name": "value",
              "text": "string: Label text e.g. `First name`"
            }, {
              "name": "example",
              "text": "label"
            }],
          "text": "Label which is displayed above the selection input field."
        },
        "attribute": "label",
        "reflect": false
      },
      "errormessage": {
        "type": "string",
        "mutable": false,
        "complexType": {
          "original": "string",
          "resolved": "string",
          "references": {}
        },
        "required": false,
        "optional": true,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "string: Error text."
            }, {
              "name": "example",
              "text": "error"
            }],
          "text": "Text, which is displayed in a red error popup at the bottom of the input field."
        },
        "attribute": "errormessage",
        "reflect": false
      },
      "readonly": {
        "type": "boolean",
        "mutable": false,
        "complexType": {
          "original": "boolean",
          "resolved": "boolean",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "false: Input is editable."
            }, {
              "name": "value",
              "text": "true: Input is read-only."
            }, {
              "name": "example",
              "text": "readonly"
            }],
          "text": "Whether the selection is readonly or editable.\nIf true the value of this component will be visualized as a normal text."
        },
        "attribute": "readonly",
        "reflect": false,
        "defaultValue": "false"
      },
      "required": {
        "type": "boolean",
        "mutable": false,
        "complexType": {
          "original": "boolean",
          "resolved": "boolean",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "false: Not required"
            }, {
              "name": "value",
              "text": "true: It is necessary to select an option to fulfill the requirement."
            }, {
              "name": "example",
              "text": "required"
            }],
          "text": "Marks this input field as a required form element."
        },
        "attribute": "required",
        "reflect": false,
        "defaultValue": "false"
      },
      "kisynced": {
        "type": "boolean",
        "mutable": false,
        "complexType": {
          "original": "boolean",
          "resolved": "boolean",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "true: Synchronized."
            }, {
              "name": "value",
              "text": "false: Not synchronized."
            }, {
              "name": "example",
              "text": "kisynced"
            }],
          "text": "Indicates that the form is synced with the KI."
        },
        "attribute": "kisynced",
        "reflect": false,
        "defaultValue": "false"
      },
      "placeholder": {
        "type": "string",
        "mutable": false,
        "complexType": {
          "original": "string",
          "resolved": "string",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "string: Placeholder text"
            }, {
              "name": "example",
              "text": "placeholder"
            }],
          "text": "Placeholder text which is displayed when no option is currently selected."
        },
        "attribute": "placeholder",
        "reflect": false,
        "defaultValue": "\"Bitte ausw\u00E4hlen ...\""
      },
      "icon": {
        "type": "string",
        "mutable": false,
        "complexType": {
          "original": "string",
          "resolved": "string",
          "references": {}
        },
        "required": false,
        "optional": true,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "string: The name of an icon."
            }, {
              "name": "example",
              "text": "icon"
            }],
          "text": "An icon which is displayed next to the placeholder text."
        },
        "attribute": "icon",
        "reflect": false
      },
      "textalign": {
        "type": "string",
        "mutable": false,
        "complexType": {
          "original": "HorizontalDirection",
          "resolved": "\"left\" | \"right\"",
          "references": {
            "HorizontalDirection": {
              "location": "import",
              "path": "../../../../classes/common-types"
            }
          }
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "left: Text is left aligned."
            }, {
              "name": "value",
              "text": "right: Text is right aligned."
            }, {
              "name": "example",
              "text": "text-align"
            }],
          "text": "Defines the text alignment."
        },
        "attribute": "textalign",
        "reflect": false,
        "defaultValue": "\"left\""
      },
      "popupposition": {
        "type": "string",
        "mutable": false,
        "complexType": {
          "original": "\"top\" | \"bottom\"",
          "resolved": "\"bottom\" | \"top\"",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "top: The list is displayed at the top of the input field."
            }, {
              "name": "value",
              "text": "bottom: The list is displayed at the bottom of the input field."
            }, {
              "name": "example",
              "text": "popup-position"
            }],
          "text": "Defines the position of the dropdown list."
        },
        "attribute": "popupposition",
        "reflect": false,
        "defaultValue": "\"bottom\""
      },
      "disabled": {
        "type": "boolean",
        "mutable": false,
        "complexType": {
          "original": "boolean",
          "resolved": "boolean",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "true: Dropdown is not editable."
            }, {
              "name": "value",
              "text": "false: Dropdown is editable."
            }, {
              "name": "example",
              "text": "disabled"
            }],
          "text": "Defines whether the dropdown is enabled or not."
        },
        "attribute": "disabled",
        "reflect": false,
        "defaultValue": "false"
      }
    };
  }
  static get states() {
    return {
      "options": {},
      "inputFocused": {},
      "listOpen": {},
      "internalValue": {},
      "showMouseHoverEffectOnList": {},
      "internalPopupPosition": {},
      "activeIndex": {}
    };
  }
  static get events() {
    return [{
        "method": "valueChange",
        "name": "valueChange",
        "bubbles": true,
        "cancelable": true,
        "composed": true,
        "docs": {
          "tags": [{
              "name": "example",
              "text": "complex"
            }],
          "text": "Delegates the current selection while the user is still editing."
        },
        "complexType": {
          "original": "HTMLDxDropdownOptionElement[]",
          "resolved": "HTMLDxDropdownOptionElement[]",
          "references": {
            "HTMLDxDropdownOptionElement": {
              "location": "global"
            }
          }
        }
      }, {
        "method": "valueComplete",
        "name": "valueComplete",
        "bubbles": true,
        "cancelable": true,
        "composed": true,
        "docs": {
          "tags": [{
              "name": "example",
              "text": "complex"
            }],
          "text": "Delegates the final selection.\nThe event is fired when the dropdown loses focus or pushing the 'Enter' key."
        },
        "complexType": {
          "original": "HTMLDxDropdownOptionElement[]",
          "resolved": "HTMLDxDropdownOptionElement[]",
          "references": {
            "HTMLDxDropdownOptionElement": {
              "location": "global"
            }
          }
        }
      }];
  }
  static get methods() {
    return {
      "focusControl": {
        "complexType": {
          "signature": "() => Promise<void>",
          "parameters": [],
          "references": {
            "Promise": {
              "location": "global"
            }
          },
          "return": "Promise<void>"
        },
        "docs": {
          "text": "Sets the focus on this element.",
          "tags": [{
              "name": "example",
              "text": "focus"
            }]
        }
      }
    };
  }
  static get elementRef() { return "self"; }
  static get listeners() {
    return [{
        "name": "forceUpdateOnChange",
        "method": "onForceUpdateOnChange",
        "target": undefined,
        "capture": false,
        "passive": false
      }, {
        "name": "itemSelectionChange",
        "method": "onItemSelectionChanged",
        "target": undefined,
        "capture": false,
        "passive": false
      }, {
        "name": "positionChange",
        "method": "onPopupPositionChanged",
        "target": undefined,
        "capture": false,
        "passive": false
      }];
  }
}
const NULL_STRING = "null";
