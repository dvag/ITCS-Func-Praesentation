import { h, Host, } from "@stencil/core";
import { ElementIdGenerator, verifyElementId, } from "../../../classes/element-id-handling";
import { hasError } from "../../../classes/error";
import { extractPath } from "../../../classes/event.util";
import { isActiveElement } from "../../../classes/misc-util";
import { onNextFrame } from "../../../classes/render-util";
import { ReadonlyTextElement } from "../../functional/base-elements";
import { ErrorMessage } from "../../functional/error-elements";
import { LabeledInputContainer } from "../../functional/input-container";
/**
 * Form element for capturing text input.
 *
 * @path /Form/Inputs
 * @name Text Input
 * @shortname Text
 * @icon font
 * @stable
 *
 * @slot error-message - This slot can be defined with a `<dx-error-message>` element.
 */
export class DxTextInput {
  constructor() {
    this.preventReFocus = false;
    this.inputFocused = false;
    this.internalValue = "";
    /**
     * Defines the size of this input.
     *
     * @value m: medium size text-input
     * @value s: small sized input. Should only be used in special cases.
     */
    this.size = "m";
    /**
     * The value of this input.
     * @important
     * @value string: Value of this input.
     * @example value
     */
    this.value = "";
    /**
     * Displays an icon when the input is not active or empty.
     * @value string: the name of the icon.
     * @example icon
     */
    this.icon = undefined;
    /**
     * Placeholder for this input field.
     * @value string: The placeholder.
     */
    this.placeholder = "Bitte eingeben ...";
    /**
     * Defines if the input field is enabled or not.
     * @value true: Input ist disabled
     * @value false: Input is not disabled
     * @example disabled
     */
    this.disabled = false;
    /**
     * Input field is in readonly mode.
     * The value of this input is display in an simplified manner.
     * The input field is not interactable.
     * @value false: input is not editable.
     * @value true: input is read-only.
     * @example readonly
     */
    this.readonly = false;
    /**
     * Indicates that the form is synced with the KI.
     * @value true: Synchronized.
     * @value false: Not synchronized.
     * @example kisynced
     */
    this.kisynced = false;
  }
  valueChanged() {
    this.obtainValueChangesFromOutside();
  }
  onItemSelectionChanged(e) {
    const option = this.autocompleteValues.find((option) => { var _a, _b; return option.value === ((_b = (_a = e.detail) === null || _a === void 0 ? void 0 : _a.selectedItems) === null || _b === void 0 ? void 0 : _b[0]); });
    this.selectOption(option);
  }
  /**
   * Focuses this input field.
   * @example focus
   */
  async focusControl() {
    this.inputElement.focus();
  }
  componentWillLoad() {
    verifyElementId(this.self);
    this.obtainValueChangesFromOutside(true);
  }
  onForceUpdateOnChange(e) {
    e.detail(this.self);
  }
  obtainValueChangesFromOutside(force = false) {
    if (force || this.value !== this.internalValue) {
      this.internalValue = this.value;
      this.lastEmittedChangeValue = this.value;
      this.lastEmittedCompleteValue = this.value;
      this.emitAutocompleteEvent();
    }
  }
  onInputFocused() {
    this.inputFocused = true;
    this.emitAutocompleteEvent();
  }
  onInputBlurred() {
    onNextFrame(() => {
      if (this.preventReFocus || !isActiveElement(this.self)) {
        this.inputFocused = false;
        this.autocompleteValues = null;
        this.emitValueChange();
        this.emitValueComplete();
      }
    });
  }
  onListFlyoutClicked(event) {
    const clickedOnListItem = extractPath(event).some((el) => { var _a; return ((_a = el.tagName) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === "dx-list-item"; });
    if (clickedOnListItem) {
      this.autocompleteValues = null;
      this.emitValueComplete();
    }
  }
  clearInput() {
    this.inputElement.value = "";
    this.internalValue = "";
    this.emitValueChange();
  }
  onInputKeyDown(event) {
    var _a;
    if (event.key == "Enter") {
      if (((_a = this.autocompleteValues) === null || _a === void 0 ? void 0 : _a.length) > 0 && this.selectedOption) {
        this.selectAutocompleteValue(this.selectedOption);
      }
      this.inputElement.blur();
      this.enterPress.emit();
    }
    const listFlyoutElement = this.self.shadowRoot.querySelector("dx-list-flyout");
    if (event.target === listFlyoutElement) {
      return;
    }
    if (listFlyoutElement === null || listFlyoutElement === void 0 ? void 0 : listFlyoutElement.open) {
      listFlyoutElement === null || listFlyoutElement === void 0 ? void 0 : listFlyoutElement.dispatchEvent(new event.constructor(event.type, event));
    }
  }
  onInputInput() {
    this.internalValue = this.inputElement.value;
    this.emitAutocompleteEvent();
    this.emitValueChange();
  }
  selectOption(option) {
    this.selectedOption = option;
    this.internalValue = option.value;
    this.emitValueChange();
  }
  selectAutocompleteValue(value) {
    this.internalValue = value.value;
    this.autocompleteValues = null;
    this.emitValueChange();
    this.emitValueComplete();
    this.selectAutocomplete.emit(value.data);
  }
  emitAutocompleteEvent() {
    this.autocomplete.emit({
      value: this.internalValue,
      provideValues: (values) => {
        this.autocompleteValues = values;
      },
    });
  }
  emitValueChange() {
    const valueCandidate = this.internalValue;
    if (this.lastEmittedChangeValue !== valueCandidate) {
      this.value = valueCandidate;
      this.valueChange.emit(this.value);
      this.lastEmittedChangeValue = this.value;
    }
  }
  emitValueComplete() {
    if (this.lastEmittedCompleteValue !== this.value) {
      this.valueComplete.emit(this.value);
      this.lastEmittedCompleteValue = this.value;
    }
  }
  render() {
    if (this.readonly) {
      return h(ReadonlyTextElement, { text: this.value, label: this.label });
    }
    return (h(Host, { class: { disabled: this.disabled } }, this.renderInput(), h(ErrorMessage, { self: this.self, message: this.errormessage, custom: {
        onFocus: () => {
          this.preventReFocus = true;
        },
        onBlur: () => {
          this.preventReFocus = false;
        },
      } })));
  }
  renderInput() {
    return (h("label", null, h(LabeledInputContainer, { containerProperties: {
        active: this.inputFocused,
        size: this.size,
        title: this.value,
        error: hasError(this.self),
      }, labelProperties: {
        disabled: this.disabled,
        label: this.label,
        required: this.required,
        kisynced: this.kisynced,
      } }, h("input", { id: ElementIdGenerator.createId(this.self, "control"), ref: (el) => (this.inputElement = el), onInput: () => this.onInputInput(), onKeyDown: (event) => this.onInputKeyDown(event), onFocus: () => this.onInputFocused(), onBlur: () => this.onInputBlurred(), type: "text", placeholder: this.placeholder, value: this.internalValue, maxLength: this.limitlength, disabled: this.disabled }), this.renderIconOrClearButton()), this.renderAutocompleteValues()));
  }
  renderAutocompleteValues() {
    var _a, _b;
    const isOpen = this.inputFocused &&
      this.autocompleteValues != null &&
      this.autocompleteValues.length > 0;
    return (h("dx-list-flyout", { open: isOpen, position: "bottom", direction: "right", itemsvisible: 5.5, size: "m", selectionmode: "single", onClick: (event) => this.onListFlyoutClicked(event), class: {
        "respect-label-height": ((_a = this.label) === null || _a === void 0 ? void 0 : _a.length) > 0,
      } }, h("div", { slot: "base" }), (_b = this.autocompleteValues) === null || _b === void 0 ? void 0 :
      _b.map((value) => {
        return (h("dx-list-item", { value: value.value, label: value.label, type: "selectable", selected: this.selectedOption === value, onClick: () => this.selectAutocompleteValue(value) }));
      })));
  }
  renderIconOrClearButton() {
    var _a;
    const isClearButtonVisible = this.internalValue !== "" && this.inputFocused;
    if (isClearButtonVisible) {
      return (h("dx-clear-button", { onClearInput: () => this.clearInput(), id: ElementIdGenerator.createId(this.self, "clear-button") }));
    }
    else {
      if (((_a = this.icon) === null || _a === void 0 ? void 0 : _a.length) > 0) {
        return (h("dx-icon", { size: 24, icon: this.icon, color: "default", class: "display-icon" }));
      }
      else {
        return h("div", { class: "display-icon" }, "\u00A0");
      }
    }
  }
  static get is() { return "dx-text-input"; }
  static get encapsulation() { return "shadow"; }
  static get originalStyleUrls() {
    return {
      "$": ["dx-text-input.scss"]
    };
  }
  static get styleUrls() {
    return {
      "$": ["dx-text-input.css"]
    };
  }
  static get properties() {
    return {
      "label": {
        "type": "string",
        "mutable": false,
        "complexType": {
          "original": "string",
          "resolved": "string",
          "references": {}
        },
        "required": false,
        "optional": true,
        "docs": {
          "tags": [{
              "name": "important",
              "text": undefined
            }, {
              "name": "value",
              "text": "string: Label e.g `first name`"
            }, {
              "name": "example",
              "text": "label"
            }],
          "text": "Label which is displayed above the input field."
        },
        "attribute": "label",
        "reflect": false
      },
      "size": {
        "type": "string",
        "mutable": false,
        "complexType": {
          "original": "\"s\" | \"m\"",
          "resolved": "\"m\" | \"s\"",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "m: medium size text-input"
            }, {
              "name": "value",
              "text": "s: small sized input. Should only be used in special cases."
            }],
          "text": "Defines the size of this input."
        },
        "attribute": "size",
        "reflect": false,
        "defaultValue": "\"m\""
      },
      "errormessage": {
        "type": "string",
        "mutable": false,
        "complexType": {
          "original": "string",
          "resolved": "string",
          "references": {}
        },
        "required": false,
        "optional": true,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "string: error message"
            }, {
              "name": "example",
              "text": "error"
            }],
          "text": "Error text which is displayed within a red dialog beneath the input."
        },
        "attribute": "errormessage",
        "reflect": false
      },
      "value": {
        "type": "string",
        "mutable": true,
        "complexType": {
          "original": "string",
          "resolved": "string",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "important",
              "text": undefined
            }, {
              "name": "value",
              "text": "string: Value of this input."
            }, {
              "name": "example",
              "text": "value"
            }],
          "text": "The value of this input."
        },
        "attribute": "value",
        "reflect": true,
        "defaultValue": "\"\""
      },
      "icon": {
        "type": "string",
        "mutable": false,
        "complexType": {
          "original": "string",
          "resolved": "string",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "string: the name of the icon."
            }, {
              "name": "example",
              "text": "icon"
            }],
          "text": "Displays an icon when the input is not active or empty."
        },
        "attribute": "icon",
        "reflect": false,
        "defaultValue": "undefined"
      },
      "limitlength": {
        "type": "number",
        "mutable": false,
        "complexType": {
          "original": "number",
          "resolved": "number",
          "references": {}
        },
        "required": false,
        "optional": true,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "number: Amount of possible characters."
            }, {
              "name": "example",
              "text": "limitlength"
            }],
          "text": "Limits the amount of characters a user can enter."
        },
        "attribute": "limitlength",
        "reflect": false
      },
      "placeholder": {
        "type": "string",
        "mutable": false,
        "complexType": {
          "original": "string",
          "resolved": "string",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "string: The placeholder."
            }],
          "text": "Placeholder for this input field."
        },
        "attribute": "placeholder",
        "reflect": false,
        "defaultValue": "\"Bitte eingeben ...\""
      },
      "disabled": {
        "type": "boolean",
        "mutable": false,
        "complexType": {
          "original": "boolean",
          "resolved": "boolean",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "true: Input ist disabled"
            }, {
              "name": "value",
              "text": "false: Input is not disabled"
            }, {
              "name": "example",
              "text": "disabled"
            }],
          "text": "Defines if the input field is enabled or not."
        },
        "attribute": "disabled",
        "reflect": false,
        "defaultValue": "false"
      },
      "readonly": {
        "type": "boolean",
        "mutable": false,
        "complexType": {
          "original": "boolean",
          "resolved": "boolean",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "false: input is not editable."
            }, {
              "name": "value",
              "text": "true: input is read-only."
            }, {
              "name": "example",
              "text": "readonly"
            }],
          "text": "Input field is in readonly mode.\nThe value of this input is display in an simplified manner.\nThe input field is not interactable."
        },
        "attribute": "readonly",
        "reflect": false,
        "defaultValue": "false"
      },
      "required": {
        "type": "boolean",
        "mutable": false,
        "complexType": {
          "original": "boolean",
          "resolved": "boolean",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "false: Not required."
            }, {
              "name": "value",
              "text": "true: Input field is required, and an icon is displayed below the input field."
            }, {
              "name": "example",
              "text": "required"
            }],
          "text": "Input is marked as required."
        },
        "attribute": "required",
        "reflect": false
      },
      "kisynced": {
        "type": "boolean",
        "mutable": false,
        "complexType": {
          "original": "boolean",
          "resolved": "boolean",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "true: Synchronized."
            }, {
              "name": "value",
              "text": "false: Not synchronized."
            }, {
              "name": "example",
              "text": "kisynced"
            }],
          "text": "Indicates that the form is synced with the KI."
        },
        "attribute": "kisynced",
        "reflect": false,
        "defaultValue": "false"
      }
    };
  }
  static get states() {
    return {
      "inputFocused": {},
      "internalValue": {},
      "selectedOption": {},
      "autocompleteValues": {}
    };
  }
  static get events() {
    return [{
        "method": "valueChange",
        "name": "valueChange",
        "bubbles": true,
        "cancelable": true,
        "composed": true,
        "docs": {
          "tags": [{
              "name": "example",
              "text": "change-events"
            }],
          "text": "Emits this event when the user changes the value of this input."
        },
        "complexType": {
          "original": "string",
          "resolved": "string",
          "references": {}
        }
      }, {
        "method": "valueComplete",
        "name": "valueComplete",
        "bubbles": true,
        "cancelable": true,
        "composed": true,
        "docs": {
          "tags": [{
              "name": "example",
              "text": "change-events"
            }],
          "text": "This event is emitted when the user accepts the value.\nThe user accepts the value by pressing the Enter key or when the user leave the input."
        },
        "complexType": {
          "original": "string",
          "resolved": "string",
          "references": {}
        }
      }, {
        "method": "autocomplete",
        "name": "autocomplete",
        "bubbles": true,
        "cancelable": true,
        "composed": true,
        "docs": {
          "tags": [{
              "name": "example",
              "text": "autocomplete-plz"
            }],
          "text": "This event is fired, when the user fills out this input.\nThe event paylod contains an controller which can be used to submit autocomplete options."
        },
        "complexType": {
          "original": "TextInputAutocompleteController",
          "resolved": "TextInputAutocompleteController",
          "references": {
            "TextInputAutocompleteController": {
              "location": "local"
            }
          }
        }
      }, {
        "method": "selectAutocomplete",
        "name": "selectAutocomplete",
        "bubbles": true,
        "cancelable": true,
        "composed": true,
        "docs": {
          "tags": [{
              "name": "example",
              "text": "autocomplete-plz-ort"
            }],
          "text": "This event is fired when the user selects an autocomplete options from the list.\nThe event payload contains the `data` of the selected AutoCompleteOption."
        },
        "complexType": {
          "original": "any",
          "resolved": "any",
          "references": {}
        }
      }, {
        "method": "enterPress",
        "name": "enterPress",
        "bubbles": true,
        "cancelable": true,
        "composed": true,
        "docs": {
          "tags": [{
              "name": "example",
              "text": "enter-press"
            }],
          "text": "Trigger when the user presses the \"Enter\" key while editing the input field."
        },
        "complexType": {
          "original": "void",
          "resolved": "void",
          "references": {}
        }
      }];
  }
  static get methods() {
    return {
      "focusControl": {
        "complexType": {
          "signature": "() => Promise<void>",
          "parameters": [],
          "references": {
            "Promise": {
              "location": "global"
            }
          },
          "return": "Promise<void>"
        },
        "docs": {
          "text": "Focuses this input field.",
          "tags": [{
              "name": "example",
              "text": "focus"
            }]
        }
      }
    };
  }
  static get elementRef() { return "self"; }
  static get watchers() {
    return [{
        "propName": "value",
        "methodName": "valueChanged"
      }];
  }
  static get listeners() {
    return [{
        "name": "itemSelectionChange",
        "method": "onItemSelectionChanged",
        "target": undefined,
        "capture": false,
        "passive": false
      }, {
        "name": "forceUpdateOnChange",
        "method": "onForceUpdateOnChange",
        "target": undefined,
        "capture": false,
        "passive": false
      }];
  }
}
