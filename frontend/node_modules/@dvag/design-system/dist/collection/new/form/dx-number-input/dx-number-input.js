import { h, Host, } from "@stencil/core";
import { displayNumberAsCurrency } from "../../../classes/currency-util";
import { ElementIdGenerator, verifyElementId, } from "../../../classes/element-id-handling";
import { hasError } from "../../../classes/error";
import { clamp, cutValueToPrecision } from "../../../classes/math-util";
import { replaceCommaWithDot } from "../../../classes/misc-util";
import { ReadonlyTextElement } from "../../functional/base-elements";
import { ErrorMessage } from "../../functional/error-elements";
import { LabeledInputContainer } from "../../functional/input-container";
/**
 * Form element for capturing number input.
 *
 * @path /Form/Inputs
 * @name Number-Input
 * @shortname Numbers
 * @icon square-root-alt
 * @stable
 *
 * @slot error-message - This slot can be defined with a `<dx-error-message>` element.
 */
export class DxNumberInput {
  constructor() {
    this.formattedValue = undefined;
    this.preventObtainValueChanges = false;
    this.lastUnpreventedInputElementValue = null;
    this.inputFocused = false;
    this.active = false;
    /**
     * Value of the input field.
     * @important
     * @value string: Value of the input.
     * @example value
     */
    this.value = null;
    /**
     * Defines the size of this input.
     *
     * @value m: medium size text-input
     * @value s: small sized input. Should only be used in special cases.
     */
    this.size = "m";
    /**
     * Determines the amount of pre-decimal numbers.
     * The element prevents all inputs higher than this value.
     *
     * @value number: Maximum amount of pre-decimal numbers.
     * @example limit-length
     */
    this.limitlength = null;
    /**
     * Determines the minimal value. The minimal value is **within** the possible input.
     * @value number: The minimal value the input field can have.
     */
    this.min = Number.NEGATIVE_INFINITY;
    /**
     * Determines the maximum value. The maximum value is **within** the possible input.
     * @value number: The maximum value the input field can have.
     */
    this.max = Number.POSITIVE_INFINITY;
    /**
     * Displays a unit next to the input.
     * @value string: A unit text (e.g: "€", "$", "qm").
     * @example custom
     */
    this.unit = undefined;
    /**
     * Input is not interactable.
     * Label and border are grey.
     * @value true: Input is disabled.
     * @value false: Input is not disabled.
     * @example disabled
     */
    this.disabled = false;
    /**
     * Input is in read only mode.
     * The content of the input is displayed in a simple way. The input is not interactable.
     * @value false: Formfield.
     * @value true: Text of the value.
     * @example readonly
     */
    this.readonly = false;
    /**
     * Marks the formfield as mandatory.
     * @value false: Not mandatory (default).
     * @value true: Mandatory.
     * @example required
     */
    this.required = false;
    /**
     * Indicates that the form is synced with the KI.
     * @value true: Synchronized.
     * @value false: Not synchronized.
     * @example kisynced
     */
    this.kisynced = false;
  }
  valueChanged() {
    this.obtainValueChangesFromOutside();
  }
  /**
   * Sets the tab-focus to the form element.
   */
  async focusControl() {
    this.inputElement.focus();
  }
  componentWillLoad() {
    verifyElementId(this.self);
    this.obtainValueChangesFromOutside(true);
  }
  // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
  componentShouldUpdate(_, __, propName) {
    if (["min", "max"].includes(propName)) {
      this.obtainValueChangesFromOutside();
    }
  }
  onForceUpdateOnChange(e) {
    e.detail(this.self);
  }
  getUnformattedValue() {
    return this.formattedValue
      ? parseFloat(replaceCommaWithDot(this.formattedValue.replace(/\./g, "")))
      : null;
  }
  obtainValueChangesFromOutside(force = false) {
    var _a;
    if (!this.preventObtainValueChanges) {
      this.value = this.sanitizeValue(this.value);
      if (force || this.value !== this.getUnformattedValue()) {
        this.formattedValue = this.getDisplayValue();
        this.lastEmittedChangeValue = this.value;
        this.lastEmittedCompleteValue = this.value;
        this.lastUnpreventedInputElementValue = (_a = this.value) === null || _a === void 0 ? void 0 : _a.toString();
      }
    }
    this.preventObtainValueChanges = false;
  }
  sanitizeValue(value) {
    if (isNaN(value) || value == null) {
      return null;
    }
    return clamp(value, this.min, this.max);
  }
  onInputFocused() {
    this.inputFocused = true;
  }
  onInputBlurred() {
    this.inputFocused = false;
    this.setValueInternal(this.value != null ? clamp(this.value, this.min, this.max) : this.value);
    this.emitValueChange();
    this.emitValueComplete();
  }
  clearInput() {
    this.inputElement.value = "";
    this.setValueInternal(null);
    this.formattedValue = null;
    this.lastUnpreventedInputElementValue = "";
    this.emitValueChange();
  }
  setValueInternal(newValue) {
    if (isNaN(newValue)) {
      newValue = null;
    }
    if (this.value !== newValue) {
      this.preventObtainValueChanges = true;
      this.formattedValue = this.getDisplayValue(newValue);
      this.value = newValue;
    }
  }
  onInputKeyUp(event) {
    if (event.key === "Enter") {
      this.inputElement.blur();
    }
  }
  preventInput() {
    var _a;
    if (!this.inputElement.value || this.inputElement.value === "-") {
      return false;
    }
    const inputTypeDefinition = this.inputTypeDefinition;
    const zeroPrecision = inputTypeDefinition.decimalDigits === 0;
    const stripTooManyDigits = new RegExp(zeroPrecision ? `^-?[\\d]+$` : `^-?[\\d]+[\,|\.]?[\\d]*$`);
    if (!stripTooManyDigits.test(this.inputElement.value)) {
      return true;
    }
    if (this.limitlength > 0) {
      const stripPreCommaDigits = new RegExp(`^-?([\\d]+)([,.][\\d]*)?$`);
      const preCommaDigits = (_a = this.inputElement.value) === null || _a === void 0 ? void 0 : _a.match(stripPreCommaDigits)[1];
      if (preCommaDigits.length > this.limitlength) {
        return true;
      }
    }
    return false;
  }
  computeDisplayValue(value) {
    var _a, _b;
    return ((_b = (_a = cutValueToPrecision(clamp(value, this.min, this.max), this.inputTypeDefinition.decimalDigits)) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : "");
  }
  onInput() {
    var _a;
    if (this.preventInput()) {
      const cursorPosition = this.inputElement.selectionStart - 1;
      const value = this.lastUnpreventedInputElementValue || this.inputElement.value;
      const lastUnpreventedInputElementValueNumber = parseFloat(replaceCommaWithDot(this.lastUnpreventedInputElementValue));
      const inputElementValueNumber = parseFloat(replaceCommaWithDot(this.inputElement.value));
      if (inputElementValueNumber !== lastUnpreventedInputElementValueNumber) {
        this.inputElement.value =
          (_a = this.computeDisplayValue(parseFloat(replaceCommaWithDot(value)))) !== null && _a !== void 0 ? _a : "";
      }
      else {
        this.inputElement.value = this.lastUnpreventedInputElementValue;
      }
      this.inputElement.selectionStart = cursorPosition;
      this.inputElement.selectionEnd = cursorPosition;
      return;
    }
    this.lastUnpreventedInputElementValue = this.inputElement.value;
    this.setValueInternal(cutValueToPrecision(parseFloat(replaceCommaWithDot(this.inputElement.value)), this.inputTypeDefinition.decimalDigits));
    this.formattedValue = this.getDisplayValue();
    this.emitValueChange();
  }
  emitValueChange() {
    if (this.value !== this.lastEmittedChangeValue) {
      this.setValueInternal(this.getUnformattedValue());
      this.lastEmittedChangeValue = this.value;
      this.valueChange.emit(this.value);
    }
  }
  emitValueComplete() {
    if (this.lastEmittedCompleteValue !== this.value) {
      this.valueComplete.emit(this.value);
      this.lastEmittedCompleteValue = this.value;
    }
  }
  get inputTypeDefinition() {
    let unit = null;
    let decimalDigits = 0;
    let placeholder = "0";
    let thousandsSeparator = true;
    if (this.profile === "currency-euro") {
      unit = "€";
      decimalDigits = 2;
    }
    else if (this.profile === "percent") {
      unit = "%";
      decimalDigits = 0;
    }
    if (this.precision != null) {
      decimalDigits = this.precision;
    }
    if (decimalDigits > 0) {
      placeholder += ",";
      for (let i = 0; i < decimalDigits; i++) {
        placeholder += "0";
      }
    }
    if (this.placeholder != null) {
      placeholder = this.placeholder;
    }
    if (this.unit != null) {
      unit = this.unit;
    }
    if (this.thousandseparator != null) {
      thousandsSeparator = this.thousandseparator;
    }
    return { unit: unit, placeholder, decimalDigits, thousandsSeparator };
  }
  getDisplayValue(value = null) {
    return displayNumberAsCurrency(cutValueToPrecision(value !== null && value !== void 0 ? value : this.value, this.inputTypeDefinition.decimalDigits), this.inputTypeDefinition.decimalDigits, this.inputTypeDefinition.thousandsSeparator);
  }
  isClearButtonVisible() {
    return this.inputFocused && this.formattedValue != null;
  }
  render() {
    if (this.readonly) {
      const unit = this.inputTypeDefinition.unit;
      const readonlyText = this.formattedValue + ((unit === null || unit === void 0 ? void 0 : unit.length) > 0 ? ` ${unit}` : "");
      return h(ReadonlyTextElement, { text: readonlyText, label: this.label });
    }
    return (h(Host, { class: { disabled: this.disabled } }, this.renderInput(), h(ErrorMessage, { self: this.self, message: this.errormessage })));
  }
  handleArrows(e) {
    if (["ArrowUp", "ArrowDown"].includes(e.key)) {
      this.setValueInternal(this.inputElement.valueAsNumber);
      this.emitValueChange();
    }
  }
  renderInput() {
    var _a;
    const inputTypeDefinition = this.inputTypeDefinition;
    return (h("label", null, h(LabeledInputContainer, { containerProperties: {
        size: this.size,
        active: this.inputFocused,
        error: hasError(this.self),
        title: (_a = this.value) === null || _a === void 0 ? void 0 : _a.toString(),
      }, labelProperties: {
        label: this.label,
        disabled: this.disabled,
        required: this.required,
        kisynced: this.kisynced,
      } }, h("div", { class: "input-container" }, h("input", Object.assign({ id: ElementIdGenerator.createId(this.self, "control"), ref: (el) => (this.inputElement = el), onKeyUp: (event) => this.onInputKeyUp(event), onInput: () => this.onInput(), onFocus: () => this.onInputFocused(), onBlur: () => this.onInputBlurred(), onKeyDown: (e) => this.handleArrows(e), type: this.inputFocused ? "number" : "text", inputMode: "numeric" }, (this.inputFocused
      ? {
        step: this.step,
        min: this.min,
        max: this.max,
        value: this.value,
      }
      : {
        value: this.formattedValue,
      }), { placeholder: inputTypeDefinition.placeholder, class: {
        animatable: inputTypeDefinition.unit == null,
        "clear-button-visible": this.isClearButtonVisible(),
      }, lang: "de-DE", disabled: this.disabled })), this.renderUnit(), this.renderClearButton()))));
  }
  renderUnit() {
    const unit = this.inputTypeDefinition.unit;
    if (unit == null) {
      return;
    }
    return (h("dx-text", { class: {
        unit: true,
        "valid-value": !this.inputFocused && this.value != null,
      } }, unit));
  }
  renderClearButton() {
    return (h("dx-clear-button", { onClearInput: () => this.clearInput(), visible: this.isClearButtonVisible(), id: ElementIdGenerator.createId(this.self, "clear-button") }));
  }
  static get is() { return "dx-number-input"; }
  static get encapsulation() { return "shadow"; }
  static get originalStyleUrls() {
    return {
      "$": ["dx-number-input.scss"]
    };
  }
  static get styleUrls() {
    return {
      "$": ["dx-number-input.css"]
    };
  }
  static get properties() {
    return {
      "label": {
        "type": "string",
        "mutable": false,
        "complexType": {
          "original": "string",
          "resolved": "string",
          "references": {}
        },
        "required": false,
        "optional": true,
        "docs": {
          "tags": [{
              "name": "important",
              "text": undefined
            }, {
              "name": "value",
              "text": "string: description e.g `Vorname`"
            }, {
              "name": "example",
              "text": "value"
            }],
          "text": "Text on top of the input field."
        },
        "attribute": "label",
        "reflect": false
      },
      "step": {
        "type": "number",
        "mutable": false,
        "complexType": {
          "original": "number",
          "resolved": "number",
          "references": {}
        },
        "required": false,
        "optional": true,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "number: The step size."
            }, {
              "name": "example",
              "text": "step"
            }],
          "text": "The step size defines the steps you can access when pressing the arrow up or arrow down key. The possible numbers are dependent on the `step` and the `min` value of this component.\n\nExample: if step=3 and min=undefined, possible numbers are [..., -6, -3, 0, 3, 6, 9, ...].\nExample: if step=3 and min=2 the possible numbers shift by 2: [..., -4, -1, 2, 5, 8, 11, ...]."
        },
        "attribute": "step",
        "reflect": false
      },
      "profile": {
        "type": "string",
        "mutable": false,
        "complexType": {
          "original": "\"currency-euro\" | \"percent\"",
          "resolved": "\"currency-euro\" | \"percent\"",
          "references": {}
        },
        "required": false,
        "optional": true,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "currency-euro: Euro"
            }, {
              "name": "value",
              "text": "percent: percent value"
            }, {
              "name": "example",
              "text": "profile"
            }],
          "text": "Formatting templates for number inputs. Profiles can be personalised by changing the properties `precision`\n`placeholder` or `unit`"
        },
        "attribute": "profile",
        "reflect": false
      },
      "errormessage": {
        "type": "string",
        "mutable": false,
        "complexType": {
          "original": "string",
          "resolved": "string",
          "references": {}
        },
        "required": false,
        "optional": true,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "string: Errormessage."
            }, {
              "name": "example",
              "text": "error-message"
            }],
          "text": "Text under the input field, that is shown in a red dialog."
        },
        "attribute": "errormessage",
        "reflect": false
      },
      "value": {
        "type": "number",
        "mutable": true,
        "complexType": {
          "original": "number",
          "resolved": "number",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "important",
              "text": undefined
            }, {
              "name": "value",
              "text": "string: Value of the input."
            }, {
              "name": "example",
              "text": "value"
            }],
          "text": "Value of the input field."
        },
        "attribute": "value",
        "reflect": true,
        "defaultValue": "null"
      },
      "size": {
        "type": "string",
        "mutable": false,
        "complexType": {
          "original": "\"s\" | \"m\"",
          "resolved": "\"m\" | \"s\"",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "m: medium size text-input"
            }, {
              "name": "value",
              "text": "s: small sized input. Should only be used in special cases."
            }],
          "text": "Defines the size of this input."
        },
        "attribute": "size",
        "reflect": false,
        "defaultValue": "\"m\""
      },
      "limitlength": {
        "type": "number",
        "mutable": false,
        "complexType": {
          "original": "number",
          "resolved": "number",
          "references": {}
        },
        "required": false,
        "optional": true,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "number: Maximum amount of pre-decimal numbers."
            }, {
              "name": "example",
              "text": "limit-length"
            }],
          "text": "Determines the amount of pre-decimal numbers.\nThe element prevents all inputs higher than this value."
        },
        "attribute": "limitlength",
        "reflect": false,
        "defaultValue": "null"
      },
      "min": {
        "type": "number",
        "mutable": false,
        "complexType": {
          "original": "number",
          "resolved": "number",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "number: The minimal value the input field can have."
            }],
          "text": "Determines the minimal value. The minimal value is **within** the possible input."
        },
        "attribute": "min",
        "reflect": false,
        "defaultValue": "Number.NEGATIVE_INFINITY"
      },
      "max": {
        "type": "number",
        "mutable": false,
        "complexType": {
          "original": "number",
          "resolved": "number",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "number: The maximum value the input field can have."
            }],
          "text": "Determines the maximum value. The maximum value is **within** the possible input."
        },
        "attribute": "max",
        "reflect": false,
        "defaultValue": "Number.POSITIVE_INFINITY"
      },
      "precision": {
        "type": "number",
        "mutable": false,
        "complexType": {
          "original": "number",
          "resolved": "number",
          "references": {}
        },
        "required": false,
        "optional": true,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "number: Amount of decimal values (e.g. 2 => xx,00 or 3 => xx,000)"
            }, {
              "name": "example",
              "text": "custom"
            }],
          "text": "Determines the amount of decimal numbers."
        },
        "attribute": "precision",
        "reflect": false
      },
      "unit": {
        "type": "string",
        "mutable": false,
        "complexType": {
          "original": "string",
          "resolved": "string",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "string: A unit text (e.g: \"\u20AC\", \"$\", \"qm\")."
            }, {
              "name": "example",
              "text": "custom"
            }],
          "text": "Displays a unit next to the input."
        },
        "attribute": "unit",
        "reflect": false,
        "defaultValue": "undefined"
      },
      "thousandseparator": {
        "type": "boolean",
        "mutable": false,
        "complexType": {
          "original": "boolean",
          "resolved": "boolean",
          "references": {}
        },
        "required": false,
        "optional": true,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "true: Usses thousandseparator (default)."
            }, {
              "name": "value",
              "text": "false: No grouping."
            }, {
              "name": "example",
              "text": "thousandseparator"
            }],
          "text": "Controls the visualization of the pre-deciaml thousandseparator."
        },
        "attribute": "thousandseparator",
        "reflect": false
      },
      "placeholder": {
        "type": "string",
        "mutable": false,
        "complexType": {
          "original": "string",
          "resolved": "string",
          "references": {}
        },
        "required": false,
        "optional": true,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "string: Placeholder."
            }, {
              "name": "example",
              "text": "custom"
            }],
          "text": "Placeholder that is shown, when the input is empty."
        },
        "attribute": "placeholder",
        "reflect": false
      },
      "disabled": {
        "type": "boolean",
        "mutable": false,
        "complexType": {
          "original": "boolean",
          "resolved": "boolean",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "true: Input is disabled."
            }, {
              "name": "value",
              "text": "false: Input is not disabled."
            }, {
              "name": "example",
              "text": "disabled"
            }],
          "text": "Input is not interactable.\nLabel and border are grey."
        },
        "attribute": "disabled",
        "reflect": false,
        "defaultValue": "false"
      },
      "readonly": {
        "type": "boolean",
        "mutable": false,
        "complexType": {
          "original": "boolean",
          "resolved": "boolean",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "false: Formfield."
            }, {
              "name": "value",
              "text": "true: Text of the value."
            }, {
              "name": "example",
              "text": "readonly"
            }],
          "text": "Input is in read only mode.\nThe content of the input is displayed in a simple way. The input is not interactable."
        },
        "attribute": "readonly",
        "reflect": false,
        "defaultValue": "false"
      },
      "required": {
        "type": "boolean",
        "mutable": false,
        "complexType": {
          "original": "boolean",
          "resolved": "boolean",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "false: Not mandatory (default)."
            }, {
              "name": "value",
              "text": "true: Mandatory."
            }, {
              "name": "example",
              "text": "required"
            }],
          "text": "Marks the formfield as mandatory."
        },
        "attribute": "required",
        "reflect": false,
        "defaultValue": "false"
      },
      "kisynced": {
        "type": "boolean",
        "mutable": false,
        "complexType": {
          "original": "boolean",
          "resolved": "boolean",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "true: Synchronized."
            }, {
              "name": "value",
              "text": "false: Not synchronized."
            }, {
              "name": "example",
              "text": "kisynced"
            }],
          "text": "Indicates that the form is synced with the KI."
        },
        "attribute": "kisynced",
        "reflect": false,
        "defaultValue": "false"
      }
    };
  }
  static get states() {
    return {
      "inputFocused": {},
      "active": {}
    };
  }
  static get events() {
    return [{
        "method": "valueChange",
        "name": "valueChange",
        "bubbles": true,
        "cancelable": true,
        "composed": true,
        "docs": {
          "tags": [{
              "name": "example",
              "text": "change-events"
            }],
          "text": "Changes of the input value during the input of the user."
        },
        "complexType": {
          "original": "number",
          "resolved": "number",
          "references": {}
        }
      }, {
        "method": "valueComplete",
        "name": "valueComplete",
        "bubbles": true,
        "cancelable": true,
        "composed": true,
        "docs": {
          "tags": [{
              "name": "example",
              "text": "change-events"
            }],
          "text": "Confirmation of the input value. Event is triggered, when the user presses return or leaving the input field."
        },
        "complexType": {
          "original": "number",
          "resolved": "number",
          "references": {}
        }
      }];
  }
  static get methods() {
    return {
      "focusControl": {
        "complexType": {
          "signature": "() => Promise<void>",
          "parameters": [],
          "references": {
            "Promise": {
              "location": "global"
            }
          },
          "return": "Promise<void>"
        },
        "docs": {
          "text": "Sets the tab-focus to the form element.",
          "tags": []
        }
      }
    };
  }
  static get elementRef() { return "self"; }
  static get watchers() {
    return [{
        "propName": "value",
        "methodName": "valueChanged"
      }];
  }
  static get listeners() {
    return [{
        "name": "forceUpdateOnChange",
        "method": "onForceUpdateOnChange",
        "target": undefined,
        "capture": false,
        "passive": false
      }];
  }
}
