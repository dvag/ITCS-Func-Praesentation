import { forceUpdate, h, Host, } from "@stencil/core";
import { clamp } from "../../../classes/math-util";
import { assert } from "../../../classes/assert";
import { isOverflown } from "../../../classes/misc-util";
import { ElementIdGenerator } from "../../../classes/element-id-handling";
import { onNextFrame } from "../../../classes/render-util";
/**
 * An element which is placed within form elements to display an error to the user.
 *
 * @path /Form/Other
 * @name Error Message
 * @shortname Error
 * @icon exclamation
 * @stable
 * @slot - The error message.
 */
export class DxErrorMessage {
  constructor() {
    /**
     * The number of lines the error message should display.
     *
     * @value 1, 2, 3: The number of lines the text can display simultaneously.
     * @value all: The error message will not be clipped. This mode should only be used in important cases.
     *
     * @example lines
     */
    this.lines = 1;
    this.showCompleteMessage = false;
    this.showLink = false;
  }
  onLinesChanged() {
    this.checkLines();
  }
  connectedCallback() {
    this.initializeMutationObserver();
    this.resizeObserver = new ResizeObserver(() => {
      this.updateView();
    });
    // connectedCallback does not trigger a re-render (which updates the resizeObserver)
    // when the element is deattached and attached again so we have to explicitly observe the
    // textElement if it is not null
    if (this.textElement) {
      this.resizeObserver.observe(this.textElement);
    }
    this.forceUpdateOnChange.emit((ref) => {
      this.forceUpdateReference = ref;
      if (ref) {
        forceUpdate(ref);
      }
    });
  }
  disconnectedCallback() {
    var _a, _b;
    (_a = this.resizeObserver) === null || _a === void 0 ? void 0 : _a.disconnect();
    (_b = this.mutationObserver) === null || _b === void 0 ? void 0 : _b.disconnect();
    if (this.forceUpdateReference) {
      forceUpdate(this.forceUpdateReference);
      this.forceUpdateReference = null;
    }
  }
  initializeMutationObserver() {
    this.mutationObserver = new MutationObserver(() => {
      // We want to reset the showCompleteMessage state because we want to check if the current text is ellipsed.
      const tmpShowCompleteMessage = this.showCompleteMessage;
      this.showCompleteMessage = false;
      forceUpdate(this);
      if (this.forceUpdateReference) {
        forceUpdate(this.forceUpdateReference);
      }
      onNextFrame(() => {
        this.updateView();
        // If the text is ellipsed (showLink => true) we want to reset the showCompleteMessage property to it's former state.
        // Otherwise there is no link and showCompleteMessage has to be false.
        this.showCompleteMessage = tmpShowCompleteMessage && this.showLink;
      });
    });
    this.mutationObserver.observe(this.self, {
      subtree: true,
      characterData: true,
      childList: true,
    });
  }
  updateView() {
    // When the text is cut we want to show the "more"-link
    this.showLink =
      this.lines !== "all" &&
        (this.showCompleteMessage ||
          (this.self.textContent && isOverflown(this.textElement)));
  }
  checkLines() {
    var _a;
    if (this.lines === "all") {
      return;
    }
    const clampedLines = clamp((_a = this.lines) !== null && _a !== void 0 ? _a : 1, 1, 3);
    assert(clampedLines === this.lines, () => `The 'lines' has to be 1, 2 or 3. Current value: ${this.lines}`, this.self);
    this.lines = clampedLines;
  }
  setTextElement(element) {
    this.textElement = element;
    if (this.textElement) {
      this.resizeObserver.observe(this.textElement);
    }
  }
  renderLink() {
    if (!this.showLink) {
      return;
    }
    const linkText = this.showCompleteMessage
      ? "Weniger anzeigen"
      : "Mehr anzeigen";
    return (h("dx-link", { id: ElementIdGenerator.createId(this.self, "show-more"), class: "link", onClick: () => {
        this.showCompleteMessage = !this.showCompleteMessage;
      } }, h("dx-text", { type: "its" }, linkText)));
  }
  render() {
    if (this.self.textContent.length <= 0) {
      return;
    }
    return (h(Host, { style: {
        "--dx-error-message-lines": this.lines.toString(),
      } }, h("div", { class: "error-container" }, h("dx-icon", { class: "error-icon", icon: "state-error", color: "error", size: 16 }), h("dx-text", { type: "its-bold", color: "error", class: {
        "error-message": true,
        ellipse: !this.showCompleteMessage && this.lines !== "all",
      }, ref: (ref) => this.setTextElement(ref) }, h("slot", null))), this.renderLink()));
  }
  static get is() { return "dx-error-message"; }
  static get encapsulation() { return "shadow"; }
  static get originalStyleUrls() {
    return {
      "$": ["dx-error-message.scss"]
    };
  }
  static get styleUrls() {
    return {
      "$": ["dx-error-message.css"]
    };
  }
  static get properties() {
    return {
      "lines": {
        "type": "any",
        "mutable": true,
        "complexType": {
          "original": "NumberOfLines",
          "resolved": "\"all\" | 1 | 2 | 3",
          "references": {
            "NumberOfLines": {
              "location": "local"
            }
          }
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "1, 2, 3: The number of lines the text can display simultaneously."
            }, {
              "name": "value",
              "text": "all: The error message will not be clipped. This mode should only be used in important cases."
            }, {
              "name": "example",
              "text": "lines"
            }],
          "text": "The number of lines the error message should display."
        },
        "attribute": "lines",
        "reflect": false,
        "defaultValue": "1"
      }
    };
  }
  static get states() {
    return {
      "showCompleteMessage": {},
      "showLink": {}
    };
  }
  static get events() {
    return [{
        "method": "forceUpdateOnChange",
        "name": "forceUpdateOnChange",
        "bubbles": true,
        "cancelable": true,
        "composed": true,
        "docs": {
          "tags": [],
          "text": ""
        },
        "complexType": {
          "original": "(ref: any) => void",
          "resolved": "(ref: any) => void",
          "references": {}
        }
      }];
  }
  static get elementRef() { return "self"; }
  static get watchers() {
    return [{
        "propName": "lines",
        "methodName": "onLinesChanged"
      }];
  }
}
