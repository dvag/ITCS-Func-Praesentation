import { forceUpdate, h, Host, } from "@stencil/core";
import { findDuplicatedValues } from "../../../classes/value";
import { assert } from "../../../classes/assert";
import { ReadonlyTextElement } from "../../../components/functional/base-elements";
import { extractRadioButtonOutOfEventPath } from "./radio.util";
import { ElementIdGenerator, verifyElementId, } from "../../../classes/element-id-handling";
import { tagOf } from "../../../classes/misc-util";
/**
 * Form element which offers multiple options in the form of `<dx-radio-button>` elements.
 * Only one option can be selected at a time.
 *
 * @path /Form
 * @name Radio-Button-Group
 * @shortname Radio
 * @icon object-group
 * @stable
 *
 * @slot - One or more `<dx-radio-button>` elements.
 * @slot error-message - This slot can be defined with a `<dx-error-message>` element.
 */
export class DxRadioButtonGroup {
  constructor() {
    this.shouldEmitValueChange = false;
    this.radioButtons = [];
    /**
     * @internal
     */
    this.radiogroupid = null;
    /**
     * Defines if the group is in a read-only state.
     * The label of the current selected radio button will be displayed.
     *
     * @value false: The component is displayed normally.
     * @value true: The current selected option is displayed as text. If no option is selected no text will be displayed.
     * @example readonly
     */
    this.readonly = false;
    /**
     * Defines if the radio button group is a required form element.
     * @value false: It is not required to select an option.
     * @value true: To fulfill the requirement one option has to be selected.
     * @example required
     */
    this.required = false;
    /**
     * Indicates that the form is synced with the KI.
     * @value true: Synchronized.
     * @value false: Not synchronized.
     * @example kisynced
     */
    this.kisynced = false;
    /**
     * Disables the ability to interact with this component.
     * Every option inside will also be set to `disabled`.
     *
     * @value false: User can select an option.
     * @value true: User cannot select an option.
     *
     * @example disabled
     */
    this.disabled = false;
  }
  onDisabledChange() {
    this.radioButtons.forEach((radioButton) => {
      if (this.disabled) {
        radioButton.classList.add("disabled");
      }
      else if (!radioButton.disabled) {
        radioButton.classList.remove("disabled");
      }
      radioButton.forceUpdate();
    });
  }
  valueChanged(newValue, oldValue) {
    if (newValue === oldValue) {
      return;
    }
    this.updateCheckedStates();
    this.emitValueChange();
  }
  componentWillLoad() {
    verifyElementId(this.self);
  }
  async onKeyUp(e) {
    if (this.shouldHandleKeyboardEvent(e)) {
      const radioButton = await extractRadioButtonOutOfEventPath(e);
      if (this.radioButtons.includes(radioButton)) {
        this.handleKeyboardArrows(e);
      }
    }
  }
  onForceUpdateOnChange(e) {
    e.stopPropagation();
    e.detail(this);
  }
  /**
   * Sets the focus on the radio group.
   *
   * If an option is selected it will be focused.
   * If no option is selected the first option will be focused.
   * @example focus
   */
  async focusControl() {
    var _a;
    if (this.radioButtons.length === 0) {
      return;
    }
    const radioButton = (_a = this.getSelectedRadioButton()) !== null && _a !== void 0 ? _a : this.radioButtons[0];
    radioButton.focusControl().then();
  }
  /**
   * @internal
   */
  async select(value) {
    this.shouldEmitValueChange = true;
    this.value = value;
  }
  async connectRadioButton(connectedRadioButton) {
    const insertBeforeIndex = this.getRadioButtonsInsertIndex(connectedRadioButton);
    if (insertBeforeIndex === -1) {
      this.radioButtons = this.radioButtons.concat(connectedRadioButton);
    }
    else {
      this.radioButtons.splice(insertBeforeIndex, 0, connectedRadioButton);
    }
    this.postRadioButtonConnect();
  }
  async disconnectRadioButton(disconnectedRadioButton) {
    this.radioButtons = this.radioButtons.filter((radioButton) => disconnectedRadioButton !== radioButton);
  }
  postRadioButtonConnect() {
    this.updateCheckedStates();
    this.injectStates();
    const duplicates = findDuplicatedValues(this.radioButtons);
    assert(duplicates.length == 0, () => `There should not be any duplicated values within <dx-radio-button-group> elements!\nFollowing duplicates were found: ${duplicates.join()}`, this.self);
  }
  // Returns the index of the radio-button dependent on the DOM-Structure
  getRadioButtonsInsertIndex(element) {
    var _a;
    const parentElementBelowRadioButtonGroup = (_a = this.getRadioButtonHolderBeforeSelf(element)) !== null && _a !== void 0 ? _a : this.self;
    // We need to find the correct order of the radio-buttons to be able to focus them correctly when pressing the arrow keys.
    return this.radioButtons
      .map((radioButton) => this.getRadioButtonHolderBeforeSelf(radioButton))
      .findIndex((radioOwner) => parentElementBelowRadioButtonGroup.compareDocumentPosition(radioOwner) & Node.DOCUMENT_POSITION_FOLLOWING);
  }
  shouldHandleKeyboardEvent(e) {
    return (!this.disabled &&
      ["ArrowDown", "ArrowUp", "ArrowLeft", "ArrowRight"].includes(e.code));
  }
  handleKeyboardArrows(e) {
    e.preventDefault();
    const enabledRadioButtons = this.radioButtons.filter((radioButton) => !radioButton.disabled);
    if (enabledRadioButtons.length === 0) {
      return;
    }
    const currentValueIndex = enabledRadioButtons.findIndex((radioButton) => radioButton.value === this.value);
    const nextRadioButtonIndex = (e.code === "ArrowDown" || e.code === "ArrowRight"
      ? currentValueIndex + 1
      : currentValueIndex - 1 + enabledRadioButtons.length) %
      enabledRadioButtons.length;
    const newSelectedRadioButton = enabledRadioButtons[nextRadioButtonIndex];
    this.select(newSelectedRadioButton.value).then();
    newSelectedRadioButton.focusControl().then();
  }
  getRadioButtonHolderBeforeSelf(element) {
    var _a, _b;
    let parent = element;
    let before = null;
    let radioOwner = null;
    while (parent != null && parent !== this.self) {
      before = parent;
      // If we find a radio-button or radioOwner we update the radioOwner to reference it
      if (tagOf(before) === "dx-radio-button" ||
        "getRadioElement" in before) {
        radioOwner = before;
      }
      parent = (_a = parent.parentElement) !== null && _a !== void 0 ? _a : (_b = parent.getRootNode()) === null || _b === void 0 ? void 0 : _b.host;
    }
    return radioOwner !== null && radioOwner !== void 0 ? radioOwner : before;
  }
  updateCheckedStates() {
    this.radioButtons.forEach((radioButton) => {
      radioButton.internalSetChecked(radioButton.value === this.value).then();
    });
  }
  emitValueChange() {
    if (this.shouldEmitValueChange) {
      this.valueChange.emit(this.value);
    }
    this.shouldEmitValueChange = false;
  }
  injectStates() {
    this.radioButtons.forEach((radioButton) => {
      var _a;
      radioButton.setAttribute("required", (_a = this.required) === null || _a === void 0 ? void 0 : _a.toString());
    });
  }
  getSelectedRadioButton() {
    return this.radioButtons.find((radioButton) => {
      return radioButton.value === this.value;
    });
  }
  render() {
    var _a, _b;
    if (this.readonly) {
      return (h(ReadonlyTextElement, { text: (_b = (_a = this.getSelectedRadioButton()) === null || _a === void 0 ? void 0 : _a.label) !== null && _b !== void 0 ? _b : "" }));
    }
    return (h(Host, null, h("dx-form-wrapper", { id: ElementIdGenerator.createId(this.self, `form-wrapper`), label: this.label, required: this.required, kisynced: this.kisynced, errormessage: this.errormessage, ref: (ref) => {
        if (ref) {
          forceUpdate(ref);
        }
      } }, h("slot", null), h("slot", { name: "error-message", slot: "error-message" }))));
  }
  static get is() { return "dx-radio-button-group"; }
  static get encapsulation() { return "shadow"; }
  static get originalStyleUrls() {
    return {
      "$": ["dx-radio-button-group.scss"]
    };
  }
  static get styleUrls() {
    return {
      "$": ["dx-radio-button-group.css"]
    };
  }
  static get properties() {
    return {
      "label": {
        "type": "string",
        "mutable": false,
        "complexType": {
          "original": "string",
          "resolved": "string",
          "references": {}
        },
        "required": false,
        "optional": true,
        "docs": {
          "tags": [{
              "name": "important",
              "text": undefined
            }, {
              "name": "value",
              "text": "string: Label e.g `Choose an option`"
            }, {
              "name": "example",
              "text": "label"
            }],
          "text": "Label which is displayed above the radio group."
        },
        "attribute": "label",
        "reflect": false
      },
      "radiogroupid": {
        "type": "string",
        "mutable": false,
        "complexType": {
          "original": "string",
          "resolved": "string",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "internal",
              "text": undefined
            }],
          "text": ""
        },
        "attribute": "radiogroupid",
        "reflect": true,
        "defaultValue": "null"
      },
      "readonly": {
        "type": "boolean",
        "mutable": false,
        "complexType": {
          "original": "boolean",
          "resolved": "boolean",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "false: The component is displayed normally."
            }, {
              "name": "value",
              "text": "true: The current selected option is displayed as text. If no option is selected no text will be displayed."
            }, {
              "name": "example",
              "text": "readonly"
            }],
          "text": "Defines if the group is in a read-only state.\nThe label of the current selected radio button will be displayed."
        },
        "attribute": "readonly",
        "reflect": false,
        "defaultValue": "false"
      },
      "required": {
        "type": "boolean",
        "mutable": false,
        "complexType": {
          "original": "boolean",
          "resolved": "boolean",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "false: It is not required to select an option."
            }, {
              "name": "value",
              "text": "true: To fulfill the requirement one option has to be selected."
            }, {
              "name": "example",
              "text": "required"
            }],
          "text": "Defines if the radio button group is a required form element."
        },
        "attribute": "required",
        "reflect": false,
        "defaultValue": "false"
      },
      "kisynced": {
        "type": "boolean",
        "mutable": false,
        "complexType": {
          "original": "boolean",
          "resolved": "boolean",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "true: Synchronized."
            }, {
              "name": "value",
              "text": "false: Not synchronized."
            }, {
              "name": "example",
              "text": "kisynced"
            }],
          "text": "Indicates that the form is synced with the KI."
        },
        "attribute": "kisynced",
        "reflect": false,
        "defaultValue": "false"
      },
      "errormessage": {
        "type": "string",
        "mutable": false,
        "complexType": {
          "original": "string",
          "resolved": "string",
          "references": {}
        },
        "required": false,
        "optional": true,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "string: Error text"
            }, {
              "name": "example",
              "text": "error"
            }],
          "text": "A text which is displayed in an error popup below the component."
        },
        "attribute": "errormessage",
        "reflect": false
      },
      "disabled": {
        "type": "boolean",
        "mutable": false,
        "complexType": {
          "original": "boolean",
          "resolved": "boolean",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "false: User can select an option."
            }, {
              "name": "value",
              "text": "true: User cannot select an option."
            }, {
              "name": "example",
              "text": "disabled"
            }],
          "text": "Disables the ability to interact with this component.\nEvery option inside will also be set to `disabled`."
        },
        "attribute": "disabled",
        "reflect": false,
        "defaultValue": "false"
      },
      "value": {
        "type": "string",
        "mutable": true,
        "complexType": {
          "original": "string",
          "resolved": "string",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "string: The value of an inner radio button."
            }, {
              "name": "example",
              "text": "value"
            }, {
              "name": "example",
              "text": "read-value"
            }, {
              "name": "example",
              "text": "write-value"
            }],
          "text": "This property mirrors the current selected option.\nIf set, an inner radio button with the same `value` has to exist."
        },
        "attribute": "value",
        "reflect": true
      }
    };
  }
  static get states() {
    return {
      "radioButtons": {}
    };
  }
  static get events() {
    return [{
        "method": "valueChange",
        "name": "valueChange",
        "bubbles": true,
        "cancelable": true,
        "composed": true,
        "docs": {
          "tags": [{
              "name": "example",
              "text": "read-value"
            }],
          "text": "Delegates the current selected `<dx-radio-button>` element's value.\nThis event will not trigger when setting the `value` in JavaScript."
        },
        "complexType": {
          "original": "string",
          "resolved": "string",
          "references": {}
        }
      }];
  }
  static get methods() {
    return {
      "focusControl": {
        "complexType": {
          "signature": "() => Promise<void>",
          "parameters": [],
          "references": {
            "Promise": {
              "location": "global"
            }
          },
          "return": "Promise<void>"
        },
        "docs": {
          "text": "Sets the focus on the radio group.\n\nIf an option is selected it will be focused.\nIf no option is selected the first option will be focused.",
          "tags": [{
              "name": "example",
              "text": "focus"
            }]
        }
      },
      "select": {
        "complexType": {
          "signature": "(value: string) => Promise<void>",
          "parameters": [{
              "tags": [],
              "text": ""
            }],
          "references": {
            "Promise": {
              "location": "global"
            }
          },
          "return": "Promise<void>"
        },
        "docs": {
          "text": "",
          "tags": [{
              "name": "internal",
              "text": undefined
            }]
        }
      },
      "connectRadioButton": {
        "complexType": {
          "signature": "(connectedRadioButton: HTMLDxRadioButtonElement) => Promise<void>",
          "parameters": [{
              "tags": [],
              "text": ""
            }],
          "references": {
            "Promise": {
              "location": "global"
            },
            "HTMLDxRadioButtonElement": {
              "location": "global"
            }
          },
          "return": "Promise<void>"
        },
        "docs": {
          "text": "",
          "tags": []
        }
      },
      "disconnectRadioButton": {
        "complexType": {
          "signature": "(disconnectedRadioButton: HTMLDxRadioButtonElement) => Promise<void>",
          "parameters": [{
              "tags": [],
              "text": ""
            }],
          "references": {
            "Promise": {
              "location": "global"
            },
            "HTMLDxRadioButtonElement": {
              "location": "global"
            }
          },
          "return": "Promise<void>"
        },
        "docs": {
          "text": "",
          "tags": []
        }
      }
    };
  }
  static get elementRef() { return "self"; }
  static get watchers() {
    return [{
        "propName": "disabled",
        "methodName": "onDisabledChange"
      }, {
        "propName": "value",
        "methodName": "valueChanged"
      }];
  }
  static get listeners() {
    return [{
        "name": "keydown",
        "method": "onKeyUp",
        "target": undefined,
        "capture": false,
        "passive": false
      }, {
        "name": "forceUpdateOnChange",
        "method": "onForceUpdateOnChange",
        "target": undefined,
        "capture": true,
        "passive": false
      }];
  }
}
