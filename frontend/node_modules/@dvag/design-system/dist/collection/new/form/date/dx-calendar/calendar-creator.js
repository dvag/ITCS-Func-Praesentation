import { DateUtils, MONTH_NAMES, MONTH_NAMES_SHORT, } from "../../../../classes/date.utils";
function createRowEntry(date, outOfBoundsDateMin, outOfBoundsDateMax, constructDateEntry) {
  if (DateUtils.isBeforeDate(date, outOfBoundsDateMin) ||
    DateUtils.isAfterDate(date, outOfBoundsDateMax)) {
    return null;
  }
  if (DateUtils.isSameDate(date, outOfBoundsDateMin)) {
    return "min";
  }
  if (DateUtils.isSameDate(date, outOfBoundsDateMax)) {
    return "max";
  }
  return constructDateEntry();
}
function getOutOfBoundsDateMax(maxDate, mode) {
  const outOfBoundsDateMax = new Date(maxDate !== null && maxDate !== void 0 ? maxDate : NaN);
  if (mode === "day") {
    outOfBoundsDateMax.setDate(outOfBoundsDateMax.getDate() + 1);
  }
  else if (mode === "month") {
    outOfBoundsDateMax.setMonth(outOfBoundsDateMax.getMonth() + 1, 1);
  }
  else if (mode === "year") {
    outOfBoundsDateMax.setFullYear(outOfBoundsDateMax.getFullYear() + 1, 0, 1);
  }
  outOfBoundsDateMax.setHours(0, 0, 0, 0);
  return outOfBoundsDateMax;
}
function getOutOfBoundsDateMin(minDate, mode) {
  const outOfBoundsDateMin = new Date(minDate !== null && minDate !== void 0 ? minDate : NaN);
  if (mode === "day") {
    outOfBoundsDateMin.setDate(outOfBoundsDateMin.getDate() - 1);
  }
  else if (mode === "month") {
    outOfBoundsDateMin.setMonth(outOfBoundsDateMin.getMonth() - 1, 1);
  }
  else if (mode === "year") {
    outOfBoundsDateMin.setFullYear(outOfBoundsDateMin.getFullYear() - 1, 0, 1);
  }
  outOfBoundsDateMin.setHours(0, 0, 0, 0);
  return outOfBoundsDateMin;
}
window["callIt"] = () => {
  return createSimpleDayCalendar({
    date: DateUtils.newDateFromString("2021-01-01"),
    selectedRange: {
      from: DateUtils.newDateFromString("2021-01-01"),
      to: undefined,
    },
  });
};
function getWithYearToZero(date) {
  if (date == null) {
    return null;
  }
  const result = new Date(date);
  result.setFullYear(0);
  return result;
}
export function createSimpleDayCalendar(calendarInputParams) {
  const date = getWithYearToZero(calendarInputParams.date);
  const selectedRange = {
    from: getWithYearToZero(calendarInputParams.selectedRange.from),
    to: getWithYearToZero(calendarInputParams.selectedRange.to),
  };
  const minDate = getWithYearToZero(calendarInputParams.minDate);
  const maxDate = getWithYearToZero(calendarInputParams.maxDate);
  const outOfBoundsDateMin = getOutOfBoundsDateMin(minDate, "day");
  const outOfBoundsDateMax = getOutOfBoundsDateMax(maxDate, "day");
  const calendarLabel = MONTH_NAMES[date.getMonth()];
  const amountOfDays = {
    Januar: 31,
    Februar: 29,
    MÃ¤rz: 31,
    April: 30,
    Mai: 31,
    Juni: 30,
    Juli: 31,
    August: 31,
    September: 30,
    Oktober: 31,
    November: 30,
    Dezember: 31,
  }[calendarLabel];
  const rowEntries = [];
  for (let day = 1; day <= 36; ++day) {
    const newDate = DateUtils.newDate(0, date.getMonth(), day);
    if (day <= amountOfDays) {
      rowEntries.push(createRowEntry(newDate, outOfBoundsDateMin, outOfBoundsDateMax, () => {
        return {
          label: day.toString(),
          date: new Date(newDate),
          bright: false,
          active: DateUtils.isSameDate(newDate, selectedRange.from) ||
            DateUtils.isSameDate(newDate, selectedRange.to),
          highlightedLeft: DateUtils.isAfterDate(newDate, selectedRange.from) &&
            DateUtils.isBeforeOrSameDate(newDate, selectedRange.to),
          highlightedRight: DateUtils.isAfterOrSameDate(newDate, selectedRange.from) &&
            DateUtils.isBeforeDate(newDate, selectedRange.to),
          interactable: true,
        };
      }));
    }
    else {
      rowEntries.push(null);
    }
  }
  const rows = [];
  rowEntries.forEach((value, index) => {
    var _a, _b;
    const rowIndex = Math.floor(index / 6);
    rows[rowIndex] = (_b = (_a = rows[rowIndex]) === null || _a === void 0 ? void 0 : _a.concat(value)) !== null && _b !== void 0 ? _b : [value];
  });
  const firstOfMonth = DateUtils.getFirstDayOfMonth(date);
  const lastOfMonth = DateUtils.getLastDayOfMonth(firstOfMonth);
  return {
    headerLabel: calendarLabel,
    headerRow: null,
    rows: rows,
    canNavigateLeft: date.getMonth() > 0 &&
      (!DateUtils.isValidDate(minDate) ||
        DateUtils.isBeforeDate(minDate, firstOfMonth)),
    canNavigateRight: date.getMonth() < 11 &&
      (!DateUtils.isValidDate(maxDate) ||
        DateUtils.isAfterDate(maxDate, lastOfMonth)),
  };
}
export function createDayCalendar(calendarInputParams) {
  const date = calendarInputParams.date;
  const selectedRange = calendarInputParams.selectedRange;
  const minDate = calendarInputParams.minDate;
  const maxDate = calendarInputParams.maxDate;
  const outOfBoundsDateMin = getOutOfBoundsDateMin(minDate, "day");
  const outOfBoundsDateMax = getOutOfBoundsDateMax(maxDate, "day");
  const calendarLabel = MONTH_NAMES[date.getMonth()] + " " + date.getFullYear();
  const firstOfMonth = DateUtils.getFirstDayOfMonth(date);
  const start = DateUtils.getMondayOfWeek(firstOfMonth);
  const lastOfMonth = DateUtils.getLastDayOfMonth(firstOfMonth);
  const end = DateUtils.getSundayOfWeek(lastOfMonth);
  const iterator = new Date(start);
  const rowEntries = [];
  while (DateUtils.isBeforeOrSameDate(iterator, end)) {
    rowEntries.push(createRowEntry(iterator, outOfBoundsDateMin, outOfBoundsDateMax, () => {
      return {
        label: iterator.getDate().toString(),
        date: new Date(iterator),
        bright: iterator.getMonth() !== firstOfMonth.getMonth(),
        active: DateUtils.isSameDate(iterator, selectedRange.from) ||
          DateUtils.isSameDate(iterator, selectedRange.to),
        highlightedLeft: DateUtils.isAfterDate(iterator, selectedRange.from) &&
          DateUtils.isBeforeOrSameDate(iterator, selectedRange.to),
        highlightedRight: DateUtils.isAfterOrSameDate(iterator, selectedRange.from) &&
          DateUtils.isBeforeDate(iterator, selectedRange.to),
        interactable: true,
      };
    }));
    DateUtils.addDays(iterator, 1);
  }
  const headerEntries = DateUtils.getShortWeekdayNames().map((weekDayName) => {
    return {
      label: weekDayName,
      date: undefined,
      textType: "its",
    };
  });
  const rows = [];
  rowEntries.forEach((value, index) => {
    var _a, _b;
    const rowIndex = Math.floor(index / 7);
    rows[rowIndex] = (_b = (_a = rows[rowIndex]) === null || _a === void 0 ? void 0 : _a.concat(value)) !== null && _b !== void 0 ? _b : [value];
  });
  return {
    headerLabel: calendarLabel,
    headerRow: headerEntries,
    rows: rows,
    canNavigateLeft: !DateUtils.isValidDate(minDate) ||
      DateUtils.isBeforeDate(minDate, firstOfMonth),
    canNavigateRight: !DateUtils.isValidDate(maxDate) ||
      DateUtils.isAfterDate(maxDate, lastOfMonth),
  };
}
export function createMonthCalendar(calendarInputParams) {
  const date = calendarInputParams.date;
  const selectedRange = calendarInputParams.selectedRange;
  const minDate = calendarInputParams.minDate;
  const maxDate = calendarInputParams.maxDate;
  const outOfBoundsDateMin = getOutOfBoundsDateMin(minDate, "month");
  const outOfBoundsDateMax = getOutOfBoundsDateMax(maxDate, "month");
  const monthEntries = MONTH_NAMES_SHORT.map((monthName, index) => {
    const monthDate = DateUtils.newDate(date.getFullYear(), index);
    return createRowEntry(monthDate, outOfBoundsDateMin, outOfBoundsDateMax, () => {
      return {
        label: monthName,
        bright: false,
        active: DateUtils.isSameMonth(monthDate, selectedRange.from) ||
          DateUtils.isSameMonth(monthDate, selectedRange.to),
        date: monthDate,
        highlightedLeft: DateUtils.isAfterMonth(monthDate, selectedRange.from) &&
          DateUtils.isBeforeOrSameMonth(monthDate, selectedRange.to),
        highlightedRight: DateUtils.isAfterOrSameMonth(monthDate, selectedRange.from) &&
          DateUtils.isBeforeMonth(monthDate, selectedRange.to),
        interactable: true,
      };
    });
  });
  const rows = [
    monthEntries.slice(0, 4),
    monthEntries.slice(4, 8),
    monthEntries.slice(8, 12),
  ];
  const firstOfYear = DateUtils.newDate(date.getFullYear());
  const lastOfYear = DateUtils.newDate(date.getFullYear(), 11, 31);
  return {
    headerLabel: date.getFullYear().toString(),
    headerRow: undefined,
    rows: rows,
    canNavigateLeft: !DateUtils.isValidDate(minDate) ||
      DateUtils.isBeforeDate(minDate, firstOfYear),
    canNavigateRight: !DateUtils.isValidDate(maxDate) ||
      DateUtils.isAfterDate(maxDate, lastOfYear),
  };
}
export function createYearCalendar(calendarInputParams) {
  var _a, _b;
  const date = calendarInputParams.date;
  const selectedRange = calendarInputParams.selectedRange;
  const minDate = calendarInputParams.minDate;
  const maxDate = calendarInputParams.maxDate;
  const outOfBoundsDateMin = getOutOfBoundsDateMin(minDate, "year");
  const outOfBoundsDateMax = getOutOfBoundsDateMax(maxDate, "year");
  const currentYear = date.getFullYear().toString();
  const currentYearInDecade = parseInt(currentYear[currentYear.length - 1]);
  const firstYearOfDecade = date.getFullYear() -
    (currentYearInDecade - 1) -
    (currentYearInDecade % 10 == 0 ? 10 : 0);
  const firstYearOfDecadeDate = DateUtils.newDate(firstYearOfDecade, 0);
  const lastYearOfDecadeDate = DateUtils.newDate(firstYearOfDecadeDate.getFullYear() + 9, 0);
  const iterator = new Date(firstYearOfDecadeDate);
  const yearEntries = [];
  while (DateUtils.isBeforeOrSameDate(iterator, lastYearOfDecadeDate)) {
    const fromYear = (_a = selectedRange.from) === null || _a === void 0 ? void 0 : _a.getFullYear();
    const toYear = (_b = selectedRange.to) === null || _b === void 0 ? void 0 : _b.getFullYear();
    const iteratorYear = iterator.getFullYear();
    yearEntries.push(createRowEntry(new Date(iterator), outOfBoundsDateMin, outOfBoundsDateMax, () => {
      return {
        label: iteratorYear.toString(),
        date: new Date(iterator),
        bright: false,
        active: iteratorYear === fromYear || iteratorYear === toYear,
        highlightedLeft: iteratorYear > fromYear && iteratorYear <= toYear,
        highlightedRight: iteratorYear >= fromYear && iteratorYear < toYear,
        interactable: true,
      };
    }));
    iterator.setTime(DateUtils.newDate(iterator.getFullYear() + 1, 0).getTime());
  }
  const lastDayOfDecade = DateUtils.getLastDayOfYear(lastYearOfDecadeDate);
  return {
    headerLabel: `${firstYearOfDecadeDate.getFullYear()} - ${lastYearOfDecadeDate.getFullYear()}`,
    headerRow: undefined,
    rows: [yearEntries.slice(0, 5), yearEntries.slice(5, 10)],
    canNavigateLeft: !DateUtils.isValidDate(minDate) ||
      DateUtils.isBeforeDate(minDate, firstYearOfDecadeDate),
    canNavigateRight: !DateUtils.isValidDate(maxDate) ||
      DateUtils.isAfterDate(maxDate, lastDayOfDecade),
  };
}
export function isDateEntry(entry) {
  var _a;
  return ((_a = entry === null || entry === void 0 ? void 0 : entry.label) !== null && _a !== void 0 ? _a : undefined) !== undefined;
}
export function isBoundingEntry(entry) {
  return entry === "min" || entry === "max";
}
export function isNullEntry(entry) {
  return entry === null;
}
