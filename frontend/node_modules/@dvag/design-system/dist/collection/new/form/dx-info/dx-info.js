import { h, Host, } from "@stencil/core";
import { ElementIdGenerator, verifyElementId, } from "../../../classes/element-id-handling";
import { isSlotDefined } from "../../../classes/render-util";
import { SlotObserver } from "../../../classes/slot-observer";
/**
 * Shows an info button next to elements. It is used to show information about a specific element within a modal.
 *
 * @path /Form/Layout
 * @name Info button
 * @shortname Info
 * @icon font
 * @slot - Child elements that get wrapped by the info button.
 * @slot modal - Slot to add a modal dialog.
 * @stable
 */
export class DxInfo {
  constructor() {
    /**
     * Defines the width the info element gets.
     * @value max-width: The info element takes the available space independant of the width of it's inner element.
     * @value content: The info button is displayed right next to the content.
     * @important
     *
     * @example example
     */
    this.size = "max-width";
    /**
     * Defines whether the info button is visible or hidden.
     *
     * @value true: The info button is not visible.
     * @value false: The info button is visible.
     * @example hidebutton
     */
    this.hidebutton = false;
  }
  /**
   * Sets a modal for the info element.
   * This function has no effect when there is a slotted modal within this element.
   *
   * @example remote-modal
   */
  async setModal(modal) {
    if (isSlotDefined(this.self, "modal")) {
      console.warn("'setModal' does not have an effect.\nThere is already a slotted modal within this info element!\n", this.self);
      return;
    }
    this.modal = modal;
  }
  componentWillLoad() {
    this.contentResizeObserver = new ResizeObserver(() => {
      requestAnimationFrame(() => {
        this.centerContentAndInfo = this.content.offsetHeight < 40;
      });
    });
  }
  connectedCallback() {
    this.modalObserver = new SlotObserver(this.self, "dx-modal", (nodes) => {
      if (nodes.length > 0) {
        this.modal = nodes[0];
      }
    });
  }
  componentWillRender() {
    if (!this.hidebutton) {
      verifyElementId(this.self);
    }
  }
  disconnectedCallback() {
    this.modalObserver.disconnect();
    this.contentResizeObserver.disconnect();
  }
  setContent(ref) {
    var _a, _b;
    if (ref === this.content) {
      return;
    }
    if (this.content != null) {
      (_a = this.contentResizeObserver) === null || _a === void 0 ? void 0 : _a.unobserve(this.content);
    }
    this.content = ref;
    (_b = this.contentResizeObserver) === null || _b === void 0 ? void 0 : _b.observe(this.content);
  }
  openModal() {
    if (this.modal != null) {
      this.modal.visible = true;
    }
  }
  render() {
    return (h(Host, { class: {
        "full-width": this.size === "max-width",
        "content-width": this.size === "content",
        "center-content": this.centerContentAndInfo,
      } }, h("div", { class: "content", ref: (ref) => this.setContent(ref) }, h("slot", null)), h("dx-button", { id: ElementIdGenerator.createId(this.self, "info-icon"), type: "text", icon: "information", onClick: () => this.openModal(), class: {
        "info-button": true,
        hidden: this.hidebutton,
      } }), h("slot", { name: "modal" })));
  }
  static get is() { return "dx-info"; }
  static get encapsulation() { return "shadow"; }
  static get originalStyleUrls() {
    return {
      "$": ["dx-info.scss"]
    };
  }
  static get styleUrls() {
    return {
      "$": ["dx-info.css"]
    };
  }
  static get properties() {
    return {
      "size": {
        "type": "string",
        "mutable": false,
        "complexType": {
          "original": "\"max-width\" | \"content\"",
          "resolved": "\"content\" | \"max-width\"",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "max-width: The info element takes the available space independant of the width of it's inner element."
            }, {
              "name": "value",
              "text": "content: The info button is displayed right next to the content."
            }, {
              "name": "important",
              "text": undefined
            }, {
              "name": "example",
              "text": "example"
            }],
          "text": "Defines the width the info element gets."
        },
        "attribute": "size",
        "reflect": false,
        "defaultValue": "\"max-width\""
      },
      "hidebutton": {
        "type": "boolean",
        "mutable": false,
        "complexType": {
          "original": "boolean",
          "resolved": "boolean",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "true: The info button is not visible."
            }, {
              "name": "value",
              "text": "false: The info button is visible."
            }, {
              "name": "example",
              "text": "hidebutton"
            }],
          "text": "Defines whether the info button is visible or hidden."
        },
        "attribute": "hidebutton",
        "reflect": false,
        "defaultValue": "false"
      }
    };
  }
  static get states() {
    return {
      "centerContentAndInfo": {}
    };
  }
  static get methods() {
    return {
      "setModal": {
        "complexType": {
          "signature": "(modal: HTMLDxModalElement) => Promise<void>",
          "parameters": [{
              "tags": [],
              "text": ""
            }],
          "references": {
            "Promise": {
              "location": "global"
            },
            "HTMLDxModalElement": {
              "location": "global"
            }
          },
          "return": "Promise<void>"
        },
        "docs": {
          "text": "Sets a modal for the info element.\nThis function has no effect when there is a slotted modal within this element.",
          "tags": [{
              "name": "example",
              "text": "remote-modal"
            }]
        }
      }
    };
  }
  static get elementRef() { return "self"; }
}
