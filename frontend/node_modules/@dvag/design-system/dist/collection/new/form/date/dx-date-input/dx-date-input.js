import { h, Host, } from "@stencil/core";
import { DateUtils, formatToYear } from "../../../../classes/date.utils";
import { ElementIdGenerator } from "../../../../classes/element-id-handling";
import { hasError } from "../../../../classes/error";
import { isActiveElement } from "../../../../classes/misc-util";
import { onNextFrame } from "../../../../classes/render-util";
import { ReadonlyTextElement } from "../../../functional/base-elements";
import { ErrorMessage } from "../../../functional/error-elements";
import { LabeledInputContainer } from "../../../functional/input-container";
import { DateErrorType } from "../date";
import { InputController } from "./input-controller";
// TODO: Copy paste?
// TODO: Buggy in years > 9999
// TODO: Render calendar above input when not enough space at the bottom
/**
 * Form Element which holds a date.
 * Spawns a calendar to pick a date from when focused.
 *
 * @name Date-Input
 * @shortname Date
 * @path /Form/Inputs
 * @icon calendar-alt
 * @stable
 *
 * @slot error-message - This slot can be defined with a `<dx-error-message>` element.
 *
 */
export class DxDateInput {
  constructor() {
    this.preventReFocus = false;
    this.dayEmpty = true;
    this.monthEmpty = true;
    this.yearEmpty = true;
    this.currentlyEditing = false;
    this.inputFocused = false;
    this.internalValue = null;
    /**
     * The current displayed date.
     *
     * @important
     * @value string: A date in following format: YYYY-MM-dd
     * @example value
     */
    this.value = null;
    /**
     * Whether the input is interactable or not.
     * The label and border are grey to indicate the disabled state.
     * @value false: Input is not disabled.
     * @value true: Input is disabled.
     *
     * @example disabled
     */
    this.disabled = false;
    /**
     * Whether the input is readonly or editable.
     * If true the value of this component will be visualized as a normal text.
     * @value false: Input is editable.
     * @value true: Input is read-only.
     *
     * @example readonly
     */
    this.readonly = false;
    /**
     * Marks this input as required.
     * @value false: Input is not required
     * @value true: Input is required
     *
     * @example required
     */
    this.required = false;
    /**
     * Indicates that the form is synced with the KI.
     * @value true: Synchronized.
     * @value false: Not synchronized.
     * @example kisynced
     */
    this.kisynced = false;
    /**
     * Defines the size of this input.
     *
     * @value m: medium size text-input
     * @value s: small sized input. Should only be used in special cases.
     *
     * @example size
     */
    this.size = "m";
    /**
     * Defines how a date can be selected or edited.
     *
     * @value "day-month-year": The user can edit three input fields: day (TT), month (MM) and year (JJJJ).
     * The calendar shows all three views (month, year and decade) for selecting a date.
     * @value "month-year": The user can edit two input fields: month (MM) and year (JJJJ).
     * The calendar shows two views (year and decade) for selecting a month.
     * @value "day-month": The user can edit two input fields: day(TT) and month (MM).
     * The calendar shows two views (month and year) for selecting a date.
     * @example mode
     */
    this.mode = "day-month-year";
    /**
     * Indicates whether a calendar is shown when focusing this component.
     *
     * @value true: The calendar is displayed when the date input is focused.
     * @value false: There is no calendar displayed when the date input is focused.
     *
     * @internal
     */
    this.calendarenabled = true;
    this.dayInputController = null;
    this.monthInputController = null;
    this.yearInputController = null;
    this.currentFocusedIndex = null;
  }
  valueChanged() {
    this.obtainValueChangesFromOutside();
  }
  readonlyChanged() {
    onNextFrame(() => {
      this.updateInputSegments();
      this.checkInputs();
    });
  }
  onModeChange() {
    this.updateInputControllerDisableStates();
  }
  /**
   * Sets the focus on the day-input element.
   * @example focus
   */
  async focusControl() {
    this.getInputController(InputControllerType.DAY).focus();
  }
  /**
   * Remotely triggered by parent date range component
   * @internal
   */
  async internalForceEmitChangeEvent() {
    this.valueChange.emit(this.value);
    this.valueComplete.emit(this.value);
    this.lastEmittedChangeValue = this.value;
    this.lastEmittedCompleteValue = this.value;
  }
  connectedCallback() {
    this.initalizeInputController();
  }
  componentWillLoad() {
    const focusNextHandle = () => {
      this.focusNext();
    };
    this.dayInputController.onFinished = focusNextHandle;
    this.monthInputController.onFinished = this.isYearEnabled
      ? focusNextHandle
      : null;
    this.yearInputController.onFinished = null;
    this.checkInputs();
  }
  componentDidLoad() {
    this.updateInputSegments();
    this.updateCalendarValue();
    requestAnimationFrame(() => {
      this.checkInputs();
    });
  }
  initalizeInputController() {
    this.yearInputController = new InputController(0, 9999, !this.isYearEnabled(), formatToYear, 4);
    this.monthInputController = new InputController(1, 12, !this.isMonthEnabled(), formatWithLeadingZero, 2);
    this.dayInputController = new InputController(1, 31, !this.isDateEnabled(), formatWithLeadingZero, 2);
  }
  updateInputControllerDisableStates() {
    this.dayInputController.setDisabled(!this.isDateEnabled());
    this.monthInputController.setDisabled(!this.isMonthEnabled());
    this.yearInputController.setDisabled(!this.isYearEnabled());
  }
  checkInputs() {
    this.dayEmpty = !this.isDateEnabled() || this.dayInputController.isEmpty();
    this.monthEmpty =
      !this.isMonthEnabled() || this.monthInputController.isEmpty();
    this.yearEmpty =
      !this.isYearEnabled() || this.yearInputController.isEmpty();
    this.checkValueValidity();
  }
  isDateEnabled() {
    return this.mode !== "month-year";
  }
  isMonthEnabled() {
    return true;
  }
  isYearEnabled() {
    return this.mode !== "day-month";
  }
  updateInputSegments() {
    this.dayInputController.setValue(this.day);
    this.monthInputController.setValue(this.month);
    this.yearInputController.setValue(this.year);
  }
  focusNext() {
    var _a;
    const newFocusedIndex = (((_a = this.currentFocusedIndex) !== null && _a !== void 0 ? _a : -1) + 1) % 3;
    this.focus(newFocusedIndex);
  }
  focusPrevious() {
    var _a;
    const newFocusedIndex = (((_a = this.currentFocusedIndex) !== null && _a !== void 0 ? _a : 0) + 3 - 1) % 3;
    this.focus(
    // If newFocusedIndex is 0 and we dont have a date selection we want to focus the last segment
    !this.isDateEnabled() && newFocusedIndex === 0 ? 2 : newFocusedIndex);
  }
  focus(index) {
    var _a;
    (_a = this.getInputController(index)) === null || _a === void 0 ? void 0 : _a.focus();
  }
  obtainValueChangesFromOutside() {
    var _a;
    const newValue = (_a = this.formatToDateString(this.value)) !== null && _a !== void 0 ? _a : "";
    if (this.value !== this.internalValue) {
      this.internalValue = newValue;
      this.lastEmittedChangeValue = this.value;
      this.lastEmittedCompleteValue = this.value;
      this.updateInputSegments();
      this.checkInputs();
    }
    this.checkValueValidity();
  }
  checkValueValidity() {
    let errorType = DateErrorType.NO_ERROR;
    if (this.value == null) {
      if (this.isInputValid()) {
        errorType = DateErrorType.INVALID_DATE;
      }
    }
    else if (this.min &&
      DateUtils.isBeforeDate(new Date(this.value), new Date(this.min))) {
      errorType = DateErrorType.UNDER_MIN;
    }
    else if (this.max &&
      DateUtils.isAfterDate(new Date(this.value), new Date(this.max))) {
      errorType = DateErrorType.OVER_MAX;
    }
    const newErrorMessage = this.getErrorMessage(errorType);
    if (errorType !== this.lastErrorType ||
      newErrorMessage !== this.internalErrorMessage) {
      this.internalErrorMessage = newErrorMessage;
      this.errorFound.emit({
        type: errorType,
        message: this.internalErrorMessage,
      });
      this.lastErrorType = errorType;
    }
  }
  getErrorMessage(errorType) {
    const errorToMessageMap = {
      [DateErrorType.INVALID_DATE]: () => {
        const day = this.dayInputController.formattedValue;
        const month = this.monthInputController.formattedValue;
        const year = this.yearInputController.formattedValue;
        return `Das eingegebene Datum ${day}.${month}.${year} ist nicht valide.`;
      },
      [DateErrorType.UNDER_MIN]: () => `Das eingegebene Datum muss nach dem ${this.getFormattedDisplayDate(this.min)} liegen.`,
      [DateErrorType.OVER_MAX]: () => `Das eingegebene Datum muss vor dem ${this.getFormattedDisplayDate(this.max)} liegen.`,
      [DateErrorType.NO_ERROR]: () => "",
    };
    return errorToMessageMap[errorType]();
  }
  getFormattedDisplayDate(date) {
    const formattedDate = DateUtils.getFormattedDisplayDate(date);
    if (this.mode === "day-month-year") {
      return formattedDate;
    }
    const result = formattedDate.split(".");
    if (this.mode === "day-month") {
      return `${result[0]}.${result[1]}`;
    }
    else if (this.mode === "month-year") {
      return `${result[1]}.${result[2]}`;
    }
  }
  emitValueChange() {
    if (this.lastEmittedChangeValue !== this.internalValue) {
      this.value = this.internalValue;
      this.valueChange.emit(this.value);
      this.lastEmittedChangeValue = this.value;
      this.checkInputs();
    }
  }
  emitValueComplete() {
    if (this.lastEmittedCompleteValue !== this.value) {
      this.updateCalendarValue();
      this.valueComplete.emit(this.value);
      this.lastEmittedCompleteValue = this.value;
      this.checkInputs();
    }
  }
  updateCalendarValue() {
    if (this.calendar != null) {
      this.calendar.value = this.value;
    }
  }
  isInputValid() {
    const day = parseFloat(this.dayInputController.formattedValue);
    const month = parseFloat(this.monthInputController.formattedValue);
    const year = parseFloat(this.yearInputController.formattedValue);
    return day * month * year > 0;
  }
  formatToDateString(value) {
    if (value == null) {
      return null;
    }
    const date = new Date(value);
    if (isNaN(date.getTime())) {
      return null;
    }
    else {
      // Chrome translates "2021-31-02 into 02.03.2021 instead of returning an "Invalid Date"
      const splittedValue = value.split("-").map((val) => parseFloat(val));
      if (splittedValue[2] !== date.getDate() ||
        splittedValue[1] !== date.getMonth() + 1 ||
        splittedValue[0] !== date.getFullYear()) {
        return null;
      }
      return DateUtils.dateToString(date);
    }
  }
  onFocusInput() {
    this.inputFocused = true;
  }
  handleKeyInput(e) {
    if (e.code === "Enter") {
      e.target.blur();
    }
    else if (!e.code.startsWith("Arrow")) {
      if (e.code !== "Tab" &&
        !e.code.startsWith("Shift") &&
        !this.currentlyEditing) {
        this.currentlyEditing = true;
        this.currentFocusedIndex = 0;
        const inputController = this.getInputController(this.currentFocusedIndex);
        inputController.focus();
        inputController.sendInput(e.key);
        e.preventDefault();
      }
      return;
    }
    if (e.code.includes("Arrow")) {
      e.preventDefault();
      if (e.code === "ArrowLeft") {
        this.focusPrevious();
      }
      else if (e.code === "ArrowRight") {
        this.focusNext();
      }
      else if (e.code === "ArrowUp") {
        this.incrementCurrentSegment();
      }
      else if (e.code === "ArrowDown") {
        this.decrementCurrentSegment();
      }
    }
  }
  incrementCurrentSegment() {
    var _a;
    (_a = this.getInputController(this.currentFocusedIndex)) === null || _a === void 0 ? void 0 : _a.incrementValue();
    this.updateInternalValue();
  }
  decrementCurrentSegment() {
    var _a;
    (_a = this.getInputController(this.currentFocusedIndex)) === null || _a === void 0 ? void 0 : _a.decrementValue();
    this.updateInternalValue();
  }
  getInputController(inputControllerType) {
    switch (inputControllerType) {
      case InputControllerType.DAY:
        return this.isDateEnabled()
          ? this.dayInputController
          : this.monthInputController;
      case InputControllerType.MONTH:
        return this.monthInputController;
      case InputControllerType.YEAR:
        return this.yearInputController;
    }
  }
  clearInput() {
    this.dayInputController.clearInput();
    this.monthInputController.clearInput();
    this.yearInputController.clearInput();
    this.dayEmpty = true;
    this.monthEmpty = true;
    this.yearEmpty = true;
    this.updateInternalValue();
  }
  onBlur() {
    this.updateInternalValue();
    this.updateCalendarValue();
    this.segmentBlur.emit();
    onNextFrame(() => {
      if (this.preventReFocus || !isActiveElement(this.self)) {
        this.currentlyEditing = false;
        this.currentFocusedIndex = null;
        this.inputFocused = false;
        this.emitValueComplete();
      }
      this.preventReFocus = false;
    });
  }
  setFocusedIndex(index) {
    this.currentFocusedIndex = index;
    this.currentlyEditing = true;
  }
  get day() {
    if (this.value == null) {
      return null;
    }
    const day = new Date(this.value).getDate();
    return DateUtils.withMultipleLeadingZeros(day, 2);
  }
  get month() {
    if (this.value == null) {
      return null;
    }
    const month = new Date(this.value).getMonth() + 1;
    return DateUtils.withMultipleLeadingZeros(month, 2);
  }
  get year() {
    if (this.value == null) {
      return null;
    }
    const year = new Date(this.value).getFullYear();
    return DateUtils.withMultipleLeadingZeros(year, 4);
  }
  handleInput(e, inputController) {
    inputController.onInput(e);
    this.updateInternalValue();
  }
  updateInternalValue() {
    const newDay = !this.dayInputController.getDisabled()
      ? this.dayInputController.formattedValue
      : "01";
    const newMonth = !this.monthInputController.getDisabled()
      ? this.monthInputController.formattedValue
      : "01";
    const newYear = !this.yearInputController.getDisabled()
      ? this.yearInputController.formattedValue
      : "0000";
    // We have to check every input because 'YYYY-MM-' is a valid date for chrome. Firefox is invalid in this case.
    const newValue = newDay !== "" && newMonth !== "" && newYear !== ""
      ? this.formatToDateString(`${newYear}-${newMonth}-${newDay}`)
      : null;
    if (newValue !== this.value) {
      this.internalValue = newValue;
      this.emitValueChange();
    }
    this.checkInputs();
  }
  selectDate(date) {
    var _a;
    this.internalValue = DateUtils.dateToString(date);
    this.emitValueChange();
    const splittedValue = (_a = this.value) === null || _a === void 0 ? void 0 : _a.split("-");
    if (splittedValue != null) {
      this.dayInputController.setValue(splittedValue === null || splittedValue === void 0 ? void 0 : splittedValue[2]);
      this.monthInputController.setValue(splittedValue === null || splittedValue === void 0 ? void 0 : splittedValue[1]);
      this.yearInputController.setValue(splittedValue === null || splittedValue === void 0 ? void 0 : splittedValue[0]);
    }
    else {
      this.clearInput();
    }
    this.checkInputs();
    this.dayInputController.focus();
  }
  setCalendar(calendar) {
    if (this.calendar !== calendar) {
      this.calendar = calendar;
      this.updateCalendarValue();
    }
  }
  renderHiddenFallbackInput(inputController) {
    return (h("input", { hidden: true, tabIndex: -1, ref: (el) => {
        inputController.setInputElement(el);
      }, type: "text", disabled: true }));
  }
  renderDayInput() {
    if (this.isDateEnabled()) {
      return [
        h("input", { id: ElementIdGenerator.createId(this.self, "day-control"), tabIndex: this.currentlyEditing ? 0 : -1, ref: (el) => {
            this.dayInputController.setInputElement(el);
          }, type: "text", class: {
            day: true,
          }, onFocus: () => {
            this.setFocusedIndex(InputControllerType.DAY);
            this.dayInputController.onFocus();
            this.onFocusInput();
          }, onBlur: () => {
            this.dayInputController.onBlur();
            this.onBlur();
          }, placeholder: "TT", maxLength: 2, onChange: () => this.updateInternalValue(), onInput: (event) => this.handleInput(event, this.dayInputController), disabled: this.disabled }),
        h("dx-text", { class: {
            dot: true,
            disabled: this.dayInputController.isEmpty(),
          } }, "."),
      ];
    }
    else {
      return this.renderHiddenFallbackInput(this.dayInputController);
    }
  }
  renderMonthInput() {
    if (this.isMonthEnabled()) {
      return [
        h("input", { id: ElementIdGenerator.createId(this.self, "month-control"), tabIndex: this.currentlyEditing ? 0 : -1, ref: (el) => {
            this.monthInputController.setInputElement(el);
          }, type: "text", class: {
            month: true,
            empty: this.monthEmpty,
          }, onFocus: () => {
            this.setFocusedIndex(1);
            this.monthInputController.onFocus();
            this.onFocusInput();
          }, onBlur: () => {
            this.monthInputController.onBlur();
            this.onBlur();
          }, placeholder: "MM", maxLength: 2, onChange: () => this.updateInternalValue(), onInput: (event) => this.handleInput(event, this.monthInputController), disabled: this.disabled }),
        h("dx-text", { class: {
            dot: true,
            disabled: this.monthInputController.isEmpty(),
          } }, "."),
      ];
    }
    else {
      return this.renderHiddenFallbackInput(this.monthInputController);
    }
  }
  renderYearInput() {
    if (this.isYearEnabled()) {
      return (h("input", { id: ElementIdGenerator.createId(this.self, "year-control"), tabIndex: this.currentlyEditing ? 0 : -1, class: {
          year: true,
          empty: this.yearEmpty,
        }, ref: (el) => {
          this.yearInputController.setInputElement(el);
        }, type: "text", onFocus: () => {
          this.setFocusedIndex(2);
          this.yearInputController.onFocus();
          this.onFocusInput();
        }, onBlur: () => {
          this.onBlur();
          this.yearInputController.onBlur();
        }, placeholder: "JJJJ", maxLength: 4, onChange: () => this.updateInternalValue(), onInput: (event) => this.handleInput(event, this.yearInputController), disabled: this.disabled }));
    }
    else {
      return this.renderHiddenFallbackInput(this.yearInputController);
    }
  }
  renderInput() {
    var _a;
    const error = ((_a = this.internalErrorMessage) === null || _a === void 0 ? void 0 : _a.length) > 0 || hasError(this.self);
    return (h("label", { id: ElementIdGenerator.createId(this.self, "control") }, h(LabeledInputContainer, { containerProperties: {
        active: this.inputFocused,
        size: this.size,
        error: error,
        custom: {
          tabIndex: this.currentlyEditing || this.disabled ? -1 : 0,
          onFocus: () => this.onFocusInput(),
          onBlur: () => this.onBlur(),
          onInput: () => this.checkInputs(),
          onKeyDown: (e) => this.handleKeyInput(e),
        },
        title: this.getFormattedDisplayDate(this.value),
      }, labelProperties: {
        label: this.label,
        disabled: this.disabled,
        required: this.required,
        kisynced: this.kisynced,
      } }, h("dx-flyout", { open: this.inputFocused, offsety: 4, hideoverlay: !this.calendarenabled }, h("div", { class: {
        "inner-container": true,
        "size-s": this.size === "s",
        "size-m": this.size === "m",
        active: this.inputFocused,
        error: error,
      } }, h("div", { class: "input-container" }, this.renderDayInput(), this.renderMonthInput(), this.renderYearInput()), this.renderIconOrClearButton()), this.renderCalendar()))));
  }
  renderClearButton() {
    return (h("dx-clear-button", { onClearInput: () => this.clearInput(), id: ElementIdGenerator.createId(this.self, "clear-button") }));
  }
  renderIconOrClearButton() {
    const anyInputContainsCharacter = !(this.dayEmpty &&
      this.monthEmpty &&
      this.yearEmpty);
    const isClearButtonVisible = this.inputFocused && anyInputContainsCharacter;
    return (h("div", { class: "right-side" }, isClearButtonVisible ? (this.renderClearButton()) : (h("dx-icon", { icon: "kalender", size: 24 }))));
  }
  renderCalendar() {
    var _a, _b;
    if (!this.calendarenabled) {
      return;
    }
    return (h("dx-calendar", { slot: "overlay", id: ElementIdGenerator.createId(this.self, "calendar"), ref: (ref) => this.setCalendar(ref), mode: this.mode, tabindex: -1, min: (_a = this.min) !== null && _a !== void 0 ? _a : "", max: (_b = this.max) !== null && _b !== void 0 ? _b : "", errormessage: this.internalErrorMessage, onBlur: () => {
        this.onBlur();
        this.dayInputController.onBlur();
      }, onRangeSelected: (e) => {
        this.selectDate(e.detail.from);
      } }));
  }
  render() {
    var _a;
    if (this.readonly) {
      const date = new Date(this.value);
      return (h(ReadonlyTextElement, { text: ((_a = this.value) === null || _a === void 0 ? void 0 : _a.length) > 0 ? this.getFormattedDisplayDate(date) : "n.a.", label: this.label }));
    }
    return (h(Host, { class: { disabled: this.disabled } }, this.renderInput(), h(ErrorMessage, { self: this.self, message: this.errormessage, custom: {
        onFocus: () => {
          this.preventReFocus = true;
        },
        onBlur: () => {
          this.preventReFocus = false;
        },
      } })));
  }
  static get is() { return "dx-date-input"; }
  static get encapsulation() { return "shadow"; }
  static get originalStyleUrls() {
    return {
      "$": ["dx-date-input.scss"]
    };
  }
  static get styleUrls() {
    return {
      "$": ["dx-date-input.css"]
    };
  }
  static get properties() {
    return {
      "value": {
        "type": "string",
        "mutable": true,
        "complexType": {
          "original": "string",
          "resolved": "string",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "important",
              "text": undefined
            }, {
              "name": "value",
              "text": "string: A date in following format: YYYY-MM-dd"
            }, {
              "name": "example",
              "text": "value"
            }],
          "text": "The current displayed date."
        },
        "attribute": "value",
        "reflect": true,
        "defaultValue": "null"
      },
      "label": {
        "type": "string",
        "mutable": false,
        "complexType": {
          "original": "string",
          "resolved": "string",
          "references": {}
        },
        "required": false,
        "optional": true,
        "docs": {
          "tags": [{
              "name": "important",
              "text": undefined
            }, {
              "name": "value",
              "text": "string: label text"
            }, {
              "name": "example",
              "text": "label"
            }],
          "text": "Label text, which is displayed on the top of the input field."
        },
        "attribute": "label",
        "reflect": true
      },
      "errormessage": {
        "type": "string",
        "mutable": false,
        "complexType": {
          "original": "string",
          "resolved": "string",
          "references": {}
        },
        "required": false,
        "optional": true,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "string: Error text"
            }, {
              "name": "example",
              "text": "error"
            }],
          "text": "Text, which is displayed in a red popup at the bottom of the input field."
        },
        "attribute": "errormessage",
        "reflect": false
      },
      "disabled": {
        "type": "boolean",
        "mutable": false,
        "complexType": {
          "original": "boolean",
          "resolved": "boolean",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "false: Input is not disabled."
            }, {
              "name": "value",
              "text": "true: Input is disabled."
            }, {
              "name": "example",
              "text": "disabled"
            }],
          "text": "Whether the input is interactable or not.\nThe label and border are grey to indicate the disabled state."
        },
        "attribute": "disabled",
        "reflect": false,
        "defaultValue": "false"
      },
      "readonly": {
        "type": "boolean",
        "mutable": false,
        "complexType": {
          "original": "boolean",
          "resolved": "boolean",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "false: Input is editable."
            }, {
              "name": "value",
              "text": "true: Input is read-only."
            }, {
              "name": "example",
              "text": "readonly"
            }],
          "text": "Whether the input is readonly or editable.\nIf true the value of this component will be visualized as a normal text."
        },
        "attribute": "readonly",
        "reflect": false,
        "defaultValue": "false"
      },
      "required": {
        "type": "boolean",
        "mutable": false,
        "complexType": {
          "original": "boolean",
          "resolved": "boolean",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "false: Input is not required"
            }, {
              "name": "value",
              "text": "true: Input is required"
            }, {
              "name": "example",
              "text": "required"
            }],
          "text": "Marks this input as required."
        },
        "attribute": "required",
        "reflect": false,
        "defaultValue": "false"
      },
      "kisynced": {
        "type": "boolean",
        "mutable": false,
        "complexType": {
          "original": "boolean",
          "resolved": "boolean",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "true: Synchronized."
            }, {
              "name": "value",
              "text": "false: Not synchronized."
            }, {
              "name": "example",
              "text": "kisynced"
            }],
          "text": "Indicates that the form is synced with the KI."
        },
        "attribute": "kisynced",
        "reflect": false,
        "defaultValue": "false"
      },
      "size": {
        "type": "string",
        "mutable": false,
        "complexType": {
          "original": "\"s\" | \"m\"",
          "resolved": "\"m\" | \"s\"",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "m: medium size text-input"
            }, {
              "name": "value",
              "text": "s: small sized input. Should only be used in special cases."
            }, {
              "name": "example",
              "text": "size"
            }],
          "text": "Defines the size of this input."
        },
        "attribute": "size",
        "reflect": false,
        "defaultValue": "\"m\""
      },
      "min": {
        "type": "string",
        "mutable": false,
        "complexType": {
          "original": "string",
          "resolved": "string",
          "references": {}
        },
        "required": false,
        "optional": true,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "string: A date in following format: YYYY-MM-dd"
            }, {
              "name": "example",
              "text": "minmax"
            }],
          "text": "Defines the minimal allowed date."
        },
        "attribute": "min",
        "reflect": false
      },
      "max": {
        "type": "string",
        "mutable": false,
        "complexType": {
          "original": "string",
          "resolved": "string",
          "references": {}
        },
        "required": false,
        "optional": true,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "string: A date in following format: YYYY-MM-dd"
            }, {
              "name": "example",
              "text": "minmax"
            }],
          "text": "Defines the maximal allowed date."
        },
        "attribute": "max",
        "reflect": false
      },
      "mode": {
        "type": "string",
        "mutable": false,
        "complexType": {
          "original": "DateSelectionMode",
          "resolved": "\"day-month\" | \"day-month-year\" | \"month-year\"",
          "references": {
            "DateSelectionMode": {
              "location": "import",
              "path": "../date"
            }
          }
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "\"day-month-year\": The user can edit three input fields: day (TT), month (MM) and year (JJJJ).\nThe calendar shows all three views (month, year and decade) for selecting a date."
            }, {
              "name": "value",
              "text": "\"month-year\": The user can edit two input fields: month (MM) and year (JJJJ).\nThe calendar shows two views (year and decade) for selecting a month."
            }, {
              "name": "value",
              "text": "\"day-month\": The user can edit two input fields: day(TT) and month (MM).\nThe calendar shows two views (month and year) for selecting a date."
            }, {
              "name": "example",
              "text": "mode"
            }],
          "text": "Defines how a date can be selected or edited."
        },
        "attribute": "mode",
        "reflect": false,
        "defaultValue": "\"day-month-year\""
      },
      "calendarenabled": {
        "type": "boolean",
        "mutable": false,
        "complexType": {
          "original": "boolean",
          "resolved": "boolean",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "true: The calendar is displayed when the date input is focused."
            }, {
              "name": "value",
              "text": "false: There is no calendar displayed when the date input is focused."
            }, {
              "name": "internal",
              "text": undefined
            }],
          "text": "Indicates whether a calendar is shown when focusing this component."
        },
        "attribute": "calendarenabled",
        "reflect": false,
        "defaultValue": "true"
      }
    };
  }
  static get states() {
    return {
      "dayEmpty": {},
      "monthEmpty": {},
      "yearEmpty": {},
      "currentlyEditing": {},
      "inputFocused": {},
      "internalValue": {},
      "internalErrorMessage": {}
    };
  }
  static get events() {
    return [{
        "method": "valueChange",
        "name": "valueChange",
        "bubbles": true,
        "cancelable": true,
        "composed": true,
        "docs": {
          "tags": [{
              "name": "example",
              "text": "change-events"
            }],
          "text": "Delegates the current value while the user is editing the input."
        },
        "complexType": {
          "original": "string",
          "resolved": "string",
          "references": {}
        }
      }, {
        "method": "valueComplete",
        "name": "valueComplete",
        "bubbles": true,
        "cancelable": true,
        "composed": true,
        "docs": {
          "tags": [{
              "name": "example",
              "text": "change-events"
            }],
          "text": "Delegates the final value when the user submits the result by pressing 'Enter' or unfocusing this component."
        },
        "complexType": {
          "original": "string",
          "resolved": "string",
          "references": {}
        }
      }, {
        "method": "errorFound",
        "name": "errorFound",
        "bubbles": true,
        "cancelable": true,
        "composed": true,
        "docs": {
          "tags": [{
              "name": "example",
              "text": "error-found"
            }],
          "text": "Delegates an error payload which consists of a message and an error type."
        },
        "complexType": {
          "original": "DateError",
          "resolved": "DateError",
          "references": {
            "DateError": {
              "location": "import",
              "path": "../date"
            }
          }
        }
      }, {
        "method": "segmentBlur",
        "name": "segmentBlur",
        "bubbles": true,
        "cancelable": true,
        "composed": true,
        "docs": {
          "tags": [{
              "name": "internal",
              "text": undefined
            }],
          "text": ""
        },
        "complexType": {
          "original": "string",
          "resolved": "string",
          "references": {}
        }
      }];
  }
  static get methods() {
    return {
      "focusControl": {
        "complexType": {
          "signature": "() => Promise<void>",
          "parameters": [],
          "references": {
            "Promise": {
              "location": "global"
            }
          },
          "return": "Promise<void>"
        },
        "docs": {
          "text": "Sets the focus on the day-input element.",
          "tags": [{
              "name": "example",
              "text": "focus"
            }]
        }
      },
      "internalForceEmitChangeEvent": {
        "complexType": {
          "signature": "() => Promise<void>",
          "parameters": [],
          "references": {
            "Promise": {
              "location": "global"
            }
          },
          "return": "Promise<void>"
        },
        "docs": {
          "text": "Remotely triggered by parent date range component",
          "tags": [{
              "name": "internal",
              "text": undefined
            }]
        }
      }
    };
  }
  static get elementRef() { return "self"; }
  static get watchers() {
    return [{
        "propName": "value",
        "methodName": "valueChanged"
      }, {
        "propName": "readonly",
        "methodName": "readonlyChanged"
      }, {
        "propName": "mode",
        "methodName": "onModeChange"
      }];
  }
}
function formatWithLeadingZero(value) {
  if (!value) {
    return value;
  }
  return DateUtils.withLeadingZero(parseInt(value));
}
var InputControllerType;
(function (InputControllerType) {
  InputControllerType[InputControllerType["DAY"] = 0] = "DAY";
  InputControllerType[InputControllerType["MONTH"] = 1] = "MONTH";
  InputControllerType[InputControllerType["YEAR"] = 2] = "YEAR";
})(InputControllerType || (InputControllerType = {}));
