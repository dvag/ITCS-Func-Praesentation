import { h, Host, } from "@stencil/core";
import { extractDateRange } from "../date-range.util";
import { createDayCalendar, createMonthCalendar, createSimpleDayCalendar, createYearCalendar, isBoundingEntry, isDateEntry, isNullEntry, } from "./calendar-creator";
import { findUpperElementByPredicate, throwCompileErrorIfReachable, } from "../../../../classes/misc-util";
import { DateUtils } from "../../../../classes/date.utils";
import { ElementIdGenerator } from "../../../../classes/element-id-handling";
//TODO: Select range bug: from and to must not be equal
/**
 * @experimental
 * @internal
 */
export class DxCalendar {
  constructor() {
    this.preventNextDateViewChange = false;
    this.currentView = "day" /* CalendarView.DAY */;
    this.internalView = "day" /* CalendarView.DAY */;
    this.selectedRange = { from: undefined, to: undefined };
    /**
     * Defines how a date can be selected.
     *
     * @value "day-month-year": The month calendar view is the main view to select a date in.
     * You can click on days within a month to select them.
     * @value "month-year": The year calendar view is the main view to select a date in.
     * You can click on months within a year to select them.
     * @value "day-month": The month calendar view is the main view to select a date in.
     * You can click on days within a month to select them. The year information is irrelevant in this mode.
     * Selected date's years are always 0.
     */
    this.mode = "day-month-year";
  }
  onValueChange() {
    this.updateInternalState();
  }
  connectedCallback() {
    this.parent = findUpperElementByPredicate(this.self, (elem) => {
      const tag = elem.tagName.toLowerCase();
      return tag === "dx-date-input" || tag === "dx-date-range";
    });
  }
  componentWillLoad() {
    const initView = this.getInitializedView();
    this.currentView = initView;
    this.internalView = initView;
    this.updateInternalState();
  }
  getInitializedView() {
    if (this.isDateSelectionEnabled()) {
      return "day" /* CalendarView.DAY */;
    }
    if (this.isMonthSelectionEnabled()) {
      return "month" /* CalendarView.MONTH */;
    }
    if (this.isYearSelectionEnabled()) {
      return "year" /* CalendarView.YEAR */;
    }
  }
  /**
   * Sets the date dependant on the current mode
   * E.g: If the current mode is "day-month" we have to set every date's year in this context to 0
   */
  adjustDateDependantOnCurrentMode(date) {
    if (DateUtils.isValidDate(date) && !this.isYearSelectionEnabled()) {
      const result = new Date(date);
      result.setFullYear(0);
      return result;
    }
    return date;
  }
  updateInternalState() {
    var _a;
    const range = extractDateRange(this.value);
    this.selectedRange = {
      from: range.from,
      to: this.rangeenabled ? range.to : null,
    };
    if (this.preventNextDateViewChange) {
      this.preventNextDateViewChange = false;
      return;
    }
    const minDate = !DateUtils.isValidDate(this.minDate) ? null : this.minDate;
    const maxDate = !DateUtils.isValidDate(this.maxDate) ? null : this.maxDate;
    const today = this.adjustDateDependantOnCurrentMode(DateUtils.today);
    if (DateUtils.isBeforeDate(this.selectedRange.from, minDate)) {
      this.currentDate = new Date(minDate);
      this.internalDate = new Date(minDate);
    }
    else if (DateUtils.isAfterDate(this.selectedRange.from, maxDate)) {
      this.currentDate = new Date(maxDate);
      this.internalDate = new Date(maxDate);
    }
    else {
      const newCurrentDate = (_a = this.selectedRange.from) !== null && _a !== void 0 ? _a : DateUtils.clamp(today, minDate, maxDate);
      this.currentDate = this.adjustDateDependantOnCurrentMode(new Date(newCurrentDate));
      this.internalDate = this.adjustDateDependantOnCurrentMode(new Date(newCurrentDate));
    }
  }
  isDateSelectionEnabled() {
    return this.mode !== "month-year";
  }
  /**
   * Currently no mode disables the month selection.
   * This method exists in case a mode appears which doesn't need a month selection.
   */
  isMonthSelectionEnabled() {
    return true;
  }
  isYearSelectionEnabled() {
    return this.mode !== "day-month";
  }
  onAnimationStart() {
    this.isAnimating = true;
  }
  onAnimationEnd(e) {
    if (e.animationName === "fade-out") {
      this.internalDate = new Date(this.currentDate);
      this.internalView = this.currentView;
    }
    else if (e.animationName === "fade-in") {
      this.addSlidingAnimation(this.calendarContainer, null);
      this.addSlidingAnimation(this.headerLabel, null);
      this.isAnimating = false;
    }
  }
  addSlidingAnimation(element, mode) {
    element.classList.remove("slide-left", "slide-right", "slide-in", "slide-out");
    if (mode != null) {
      element.classList.add(`slide-${mode}`);
    }
  }
  slide(mode) {
    this.addSlidingAnimation(this.calendarContainer, mode);
    this.addSlidingAnimation(this.headerLabel, mode);
  }
  navigate(direction) {
    var _a;
    if (direction === "left") {
      this.previous();
    }
    else if (direction === "right") {
      this.next();
    }
    // The focus will be lost, when clicking on a button which is disabled in the next or previous month/year/decade.
    // So we have to prevent the calendar from close by focusing it here.
    (_a = this.parent) === null || _a === void 0 ? void 0 : _a.focusControl();
  }
  previous() {
    if (!this.isAnimating) {
      switch (this.internalView) {
        case "day" /* CalendarView.DAY */:
          this.currentDate = DateUtils.getPreviousMonth(this.currentDate);
          break;
        case "month" /* CalendarView.MONTH */:
          this.currentDate.setFullYear(this.currentDate.getFullYear() - 1, 0, 1);
          break;
        case "year" /* CalendarView.YEAR */:
          this.currentDate.setFullYear(this.currentDate.getFullYear() - 10, 0, 1);
          break;
        default:
          throwCompileErrorIfReachable(this.internalView);
      }
      this.slide("left" /* SlideMode.LEFT */);
    }
  }
  next() {
    if (!this.isAnimating) {
      switch (this.internalView) {
        case "day" /* CalendarView.DAY */:
          this.currentDate = DateUtils.getNextMonth(this.currentDate);
          break;
        case "month" /* CalendarView.MONTH */:
          this.currentDate.setFullYear(this.currentDate.getFullYear() + 1, 0, 1);
          break;
        case "year" /* CalendarView.YEAR */:
          this.currentDate.setFullYear(this.currentDate.getFullYear() + 10, 0, 1);
          break;
        default:
          throwCompileErrorIfReachable(this.internalView);
      }
      this.slide("right" /* SlideMode.RIGHT */);
    }
  }
  onClickHeaderLabel() {
    this.currentView = this.getAboveView();
    if (this.currentView !== this.internalView) {
      this.slide("in" /* SlideMode.IN */);
    }
  }
  get maxDate() {
    const maxDate = this.max ? new Date(this.max) : new Date(NaN);
    maxDate.setHours(0, 0, 0, 0);
    if (!DateUtils.isValidDate(maxDate) && !this.isYearSelectionEnabled()) {
      maxDate.setTime(DateUtils.newDate(0, 11, 31).getTime());
    }
    return this.adjustDateDependantOnCurrentMode(maxDate);
  }
  get minDate() {
    const minDate = this.min ? new Date(this.min) : new Date(NaN);
    minDate.setHours(0, 0, 0, 0);
    if (!DateUtils.isValidDate(minDate) && !this.isYearSelectionEnabled()) {
      minDate.setTime(DateUtils.newDate(0, 0, 1).getTime());
    }
    return this.adjustDateDependantOnCurrentMode(minDate);
  }
  handleRowEntryClick(date) {
    var _a, _b, _c, _d, _e;
    this.currentView = this.getBelowView();
    // Because entries will be destroyed on rerendering we have to focus self. Otherwise the input would lose focus completely
    (_a = this.parent) === null || _a === void 0 ? void 0 : _a.focusControl();
    const oldSelectedRange = Object.assign({}, this.selectedRange);
    if (this.currentView !== this.internalView) {
      this.currentDate = date;
      this.slide("out" /* SlideMode.OUT */);
    }
    else {
      // Update internals here in case no animation is triggered
      const clickedDate = new Date(date);
      if (this.rangeenabled) {
        this.selectRange(clickedDate);
      }
      else {
        this.selectedRange.from = clickedDate;
      }
      // Updating reference to trigger render
      this.selectedRange = Object.assign({}, this.selectedRange);
      if (((_b = oldSelectedRange.from) === null || _b === void 0 ? void 0 : _b.getTime()) !==
        ((_c = this.selectedRange.from) === null || _c === void 0 ? void 0 : _c.getTime()) ||
        ((_d = oldSelectedRange.to) === null || _d === void 0 ? void 0 : _d.getTime()) !== ((_e = this.selectedRange.to) === null || _e === void 0 ? void 0 : _e.getTime())) {
        this.rangeSelected.emit(Object.assign({}, this.selectedRange));
      }
    }
  }
  componentShouldUpdate(_, __, propName) {
    if (propName === "min" || propName === "max") {
      const minDate = this.minDate;
      const maxDate = this.maxDate;
      if (DateUtils.isBeforeDate(this.selectedRange.from, minDate)) {
        this.selectedRange.from = minDate;
      }
      if (DateUtils.isAfterDate(this.selectedRange.to, maxDate)) {
        this.selectedRange.to = maxDate;
      }
    }
  }
  selectRange(date) {
    this.preventNextDateViewChange = true;
    if (this.selectedRange.from == null) {
      this.selectedRange.from = date;
    }
    else if (this.selectedRange.to == null) {
      if (DateUtils.isBeforeDate(date, this.selectedRange.from)) {
        this.selectedRange.from = date;
      }
      else {
        this.selectedRange.to = date;
      }
    }
    else {
      this.selectedRange.from = date;
      this.selectedRange.to = undefined;
    }
  }
  getAboveView() {
    const order = this.getViews();
    const currentIndex = order.indexOf(this.internalView);
    const newIndex = Math.min(currentIndex + 1, order.length - 1);
    return order[newIndex];
  }
  getBelowView() {
    const order = this.getViews();
    const currentIndex = order.indexOf(this.internalView);
    const newIndex = Math.max(currentIndex - 1, 0);
    return order[newIndex];
  }
  getViews() {
    const views = [];
    if (this.isDateSelectionEnabled()) {
      views.push("day" /* CalendarView.DAY */);
    }
    if (this.isMonthSelectionEnabled()) {
      views.push("month" /* CalendarView.MONTH */);
    }
    if (this.isYearSelectionEnabled()) {
      views.push("year" /* CalendarView.YEAR */);
    }
    return views;
  }
  createCalendar() {
    const calendarInputParams = {
      date: this.internalDate,
      selectedRange: Object.assign({}, this.selectedRange),
      minDate: this.minDate,
      maxDate: this.maxDate,
    };
    switch (this.internalView) {
      case "day" /* CalendarView.DAY */:
        if (this.isYearSelectionEnabled()) {
          return createDayCalendar(calendarInputParams);
        }
        return createSimpleDayCalendar(calendarInputParams);
      case "month" /* CalendarView.MONTH */:
        const monthCalendar = createMonthCalendar(calendarInputParams);
        if (!this.isYearSelectionEnabled()) {
          monthCalendar.headerLabel = "Monate";
        }
        return monthCalendar;
      case "year" /* CalendarView.YEAR */:
        return createYearCalendar(calendarInputParams);
      default:
        throwCompileErrorIfReachable(this.internalView);
    }
  }
  renderRowEntry(rowEntry) {
    var _a, _b;
    if (isDateEntry(rowEntry)) {
      return (h("div", { class: {
          "calendar-entry-container": true,
          highlighted: rowEntry.highlightedLeft && rowEntry.highlightedRight,
          "highlighted-left": rowEntry.highlightedLeft && !rowEntry.highlightedRight,
          "highlighted-right": rowEntry.highlightedRight && !rowEntry.highlightedLeft,
        } }, rowEntry.interactable ? (h("button", { key: `${DateUtils.dateToString(rowEntry.date)}-${this.currentView}`, id: ElementIdGenerator.createId(this.self, `row-entry-${DateUtils.dateToString(rowEntry.date)}`), tabIndex: -1, class: {
          "calendar-entry": true,
          "bright-color": rowEntry.bright,
          selected: rowEntry.active,
        }, onClick: () => this.handleRowEntryClick(rowEntry.date) }, h("dx-text", { type: (_a = rowEntry.textType) !== null && _a !== void 0 ? _a : "ps" }, rowEntry.label))) : (h("dx-text", { type: (_b = rowEntry.textType) !== null && _b !== void 0 ? _b : "ps" }, rowEntry.label))));
    }
    if (isBoundingEntry(rowEntry)) {
      return (h("div", { class: {
          "calendar-entry-container": true,
        } }, h("dx-icon", { size: 24, icon: rowEntry === "min" ? "chevron-rechts" : "chevron-links", color: "default", class: {
          "calendar-entry": true,
          bound: true,
        } })));
    }
    if (isNullEntry(rowEntry)) {
      return (h("div", { class: {
          "calendar-entry-container": true,
        } }));
    }
  }
  renderErrorMessage() {
    var _a;
    if (((_a = this.errormessage) === null || _a === void 0 ? void 0 : _a.length) > 0) {
      return (h("dx-text", { class: "error-message", type: "its" }, this.errormessage));
    }
  }
  renderCalendar(calendar) {
    return (h("div", { class: {
        calendar: true,
        "day-view": this.internalView === "day" /* CalendarView.DAY */,
        "month-view": this.internalView === "month" /* CalendarView.MONTH */,
        "year-view": this.internalView === "year" /* CalendarView.YEAR */,
      } }, calendar.headerRow ? (h("div", { class: {
        "calendar-row": true,
        "header-labels": true,
      } }, calendar.headerRow.map((headerEntry) => {
      return this.renderRowEntry(headerEntry);
    }))) : null, calendar.rows.map((rowEntry) => {
      return (h("div", { class: "calendar-row" }, rowEntry.map((dayEntry) => {
        return this.renderRowEntry(dayEntry);
      })));
    })));
  }
  renderHeader(label, leftButtonEnabled, rightButtonEnabled) {
    const isYearView = this.currentView === "year" /* CalendarView.YEAR */;
    return (h("div", { class: "header-container" }, h("div", { class: {
        header: true,
      } }, h("dx-button", { unfocusable: true, onClick: () => this.navigate("left"), disabled: !leftButtonEnabled, id: ElementIdGenerator.createId(this.self, `right-button`), icon: "chevron-links", type: "text" }), h("div", { class: "label-container", ref: (ref) => (this.headerLabel = ref), tabIndex: -1 }, h("dx-text", { style: {
        overflow: "hidden",
        width: isYearView ? "unset" : "0",
      } }, label), h("div", { style: {
        flex: isYearView ? "0" : "1",
        overflow: "hidden",
      } }, h("dx-button", { class: "label", id: ElementIdGenerator.createId(this.self, `header-label-button`), onClick: () => this.onClickHeaderLabel(), type: "text", label: label, unfocusable: true, stretch: true }))), h("dx-button", { unfocusable: true, onClick: () => this.navigate("right"), disabled: !rightButtonEnabled, id: ElementIdGenerator.createId(this.self, `right-button`), icon: "chevron-rechts", type: "text" }))));
  }
  render() {
    const calendar = this.createCalendar();
    return (h(Host, null, [
      this.renderHeader(calendar.headerLabel, calendar.canNavigateLeft, calendar.canNavigateRight),
      h("div", { class: {
          "calendar-container": true,
        }, onAnimationEnd: (e) => this.onAnimationEnd(e), onAnimationStart: () => this.onAnimationStart(), ref: (ref) => (this.calendarContainer = ref) }, this.renderErrorMessage(), this.renderCalendar(calendar)),
    ]));
  }
  static get is() { return "dx-calendar"; }
  static get encapsulation() { return "shadow"; }
  static get originalStyleUrls() {
    return {
      "$": ["dx-calendar.scss"]
    };
  }
  static get styleUrls() {
    return {
      "$": ["dx-calendar.css"]
    };
  }
  static get properties() {
    return {
      "value": {
        "type": "string",
        "mutable": false,
        "complexType": {
          "original": "string",
          "resolved": "string",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [],
          "text": ""
        },
        "attribute": "value",
        "reflect": false
      },
      "min": {
        "type": "string",
        "mutable": false,
        "complexType": {
          "original": "string",
          "resolved": "string",
          "references": {}
        },
        "required": false,
        "optional": true,
        "docs": {
          "tags": [],
          "text": "Defines the minimal allowed date."
        },
        "attribute": "min",
        "reflect": false
      },
      "max": {
        "type": "string",
        "mutable": false,
        "complexType": {
          "original": "string",
          "resolved": "string",
          "references": {}
        },
        "required": false,
        "optional": true,
        "docs": {
          "tags": [],
          "text": "Defines the maximal allow date."
        },
        "attribute": "max",
        "reflect": false
      },
      "errormessage": {
        "type": "string",
        "mutable": false,
        "complexType": {
          "original": "string",
          "resolved": "string",
          "references": {}
        },
        "required": false,
        "optional": true,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "string: Error message."
            }],
          "text": "Error message which is displayed above the calendar view."
        },
        "attribute": "errormessage",
        "reflect": false
      },
      "rangeenabled": {
        "type": "boolean",
        "mutable": false,
        "complexType": {
          "original": "boolean",
          "resolved": "boolean",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "true: Two separate dates can be selected. All dates between them are highlighted."
            }, {
              "name": "value",
              "text": "false: Only one date can be selected at a time."
            }],
          "text": "Whether we can select a range of two dates or only one date."
        },
        "attribute": "rangeenabled",
        "reflect": false
      },
      "mode": {
        "type": "string",
        "mutable": false,
        "complexType": {
          "original": "DateSelectionMode",
          "resolved": "\"day-month\" | \"day-month-year\" | \"month-year\"",
          "references": {
            "DateSelectionMode": {
              "location": "import",
              "path": "../date"
            }
          }
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "\"day-month-year\": The month calendar view is the main view to select a date in.\nYou can click on days within a month to select them."
            }, {
              "name": "value",
              "text": "\"month-year\": The year calendar view is the main view to select a date in.\nYou can click on months within a year to select them."
            }, {
              "name": "value",
              "text": "\"day-month\": The month calendar view is the main view to select a date in.\nYou can click on days within a month to select them. The year information is irrelevant in this mode.\nSelected date's years are always 0."
            }],
          "text": "Defines how a date can be selected."
        },
        "attribute": "mode",
        "reflect": false,
        "defaultValue": "\"day-month-year\""
      }
    };
  }
  static get states() {
    return {
      "internalDate": {},
      "internalView": {},
      "selectedRange": {}
    };
  }
  static get events() {
    return [{
        "method": "rangeSelected",
        "name": "rangeSelected",
        "bubbles": true,
        "cancelable": true,
        "composed": true,
        "docs": {
          "tags": [],
          "text": "Fires a date range when the user selects a new date.\nThe payload is dependant on the `rangeenabled` property.\nWhen false the payload only consists of a `from` date and an undefined `to` date.\nWhen true the payload consists of a `from` and `to` date."
        },
        "complexType": {
          "original": "DateRange",
          "resolved": "DateRange",
          "references": {
            "DateRange": {
              "location": "import",
              "path": "../date-range.util"
            }
          }
        }
      }];
  }
  static get elementRef() { return "self"; }
  static get watchers() {
    return [{
        "propName": "value",
        "methodName": "onValueChange"
      }];
  }
}
