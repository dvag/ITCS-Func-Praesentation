import { DateUtils } from "../../../../classes/date.utils";
import { clamp } from "../../../../classes/math-util";
import { onNextFrame } from "../../../../classes/render-util";
export class InputController {
  constructor(minValue, maxValue, disabled, formatter, maxCharacters) {
    this.minValue = minValue;
    this.maxValue = maxValue;
    this.disabled = disabled;
    this.formatter = formatter;
    this.maxCharacters = maxCharacters;
    this.inputElement = null;
    this.lastValue = "";
    this.valueBeforeFocus = "";
  }
  focus() {
    var _a, _b;
    this.lastValue = (_a = this.inputElement) === null || _a === void 0 ? void 0 : _a.value;
    this.valueBeforeFocus = this.lastValue;
    (_b = this.inputElement) === null || _b === void 0 ? void 0 : _b.focus();
  }
  setValue(value) {
    if (this.disabled) {
      value = DateUtils.withMultipleLeadingZeros(this.minValue, 4);
    }
    this.internalSetValue(value == null || isNaN(+value) ? "" : value.toString());
    this.format();
  }
  setInputElementValue(value) {
    if (this.inputElement != null) {
      this.inputElement.value = value;
    }
  }
  internalSetValue(value) {
    this.setInputElementValue(value);
    this.lastValue = value;
  }
  sendInput(input) {
    var _a;
    // Does not set lastValue because input event is dispatched
    this.setInputElementValue(input);
    const evt = new Event("input", {
      bubbles: true,
      cancelable: true,
    });
    evt["data"] = input;
    evt["insertType"] = "insertText";
    (_a = this.inputElement) === null || _a === void 0 ? void 0 : _a.dispatchEvent(evt);
  }
  preventInput(input, inputType) {
    if (/delete|history/.test(inputType)) {
      return false;
    }
    // "." doesn't do anything before the user didn't make his first input
    if (input === ".") {
      if (this.lastValue !== this.valueBeforeFocus) {
        this.finish();
      }
      return true;
    }
    const inputNumber = Number(input);
    if (isNaN(inputNumber)) {
      return true;
    }
  }
  onInput(e) {
    e.preventDefault();
    const currentValue = this.inputElement.value;
    if (this.preventInput(e.data, e.inputType)) {
      // In case there was no input we want to keep the previous selection
      if (this.lastValue === this.valueBeforeFocus) {
        requestAnimationFrame(() => {
          this.inputElement.select();
        });
      }
      this.internalSetValue(this.lastValue);
      return;
    }
    const newValue = currentValue.substr(0, this.maxCharacters);
    this.internalSetValue(newValue);
    if (newValue.length === this.maxCharacters) {
      this.finish();
    }
  }
  get formattedValue() {
    var _a, _b;
    return (_b = this.formatter((_a = this.inputElement) === null || _a === void 0 ? void 0 : _a.value)) !== null && _b !== void 0 ? _b : "";
  }
  getDisabled() {
    return this.disabled;
  }
  setDisabled(disabled) {
    this.disabled = !!disabled;
  }
  finish() {
    var _a;
    (_a = this.onFinished) === null || _a === void 0 ? void 0 : _a.call(this);
    this.format();
  }
  format() {
    var _a, _b, _c, _d, _e;
    const currentValue = parseInt((_a = this.inputElement) === null || _a === void 0 ? void 0 : _a.value);
    if (isNaN(currentValue)) {
      this.internalSetValue("");
      return;
    }
    const newValue = clamp(currentValue, this.minValue, this.maxValue);
    if (newValue === currentValue) {
      this.internalSetValue((_b = this.formatter) === null || _b === void 0 ? void 0 : _b.call(this, (_c = this.inputElement) === null || _c === void 0 ? void 0 : _c.value));
    }
    else {
      this.internalSetValue((_e = (_d = this.formatter) === null || _d === void 0 ? void 0 : _d.call(this, newValue.toString())) !== null && _e !== void 0 ? _e : "");
    }
  }
  isEmpty() {
    var _a, _b, _c;
    return this.disabled || ((_c = (_b = (_a = this.inputElement) === null || _a === void 0 ? void 0 : _a.value) === null || _b === void 0 ? void 0 : _b.length) !== null && _c !== void 0 ? _c : 0) === 0;
  }
  clearInput() {
    if (!this.disabled && this.inputElement != null) {
      this.internalSetValue(null);
    }
  }
  onFocus() {
    if (this.inputElement.value.length > 0) {
      this.focus();
      this.inputElement.select();
    }
  }
  onBlur() {
    this.valueBeforeFocus = this.lastValue;
    this.format();
  }
  setInputElement(el) {
    if (this.inputElement !== el) {
      this.inputElement = el;
      onNextFrame(() => {
        this.format();
      });
    }
  }
  incrementValue() {
    const currentValue = this.inputElement.value;
    const newValue = currentValue === ""
      ? this.minValue
      : parseInt(this.inputElement.value) + 1;
    this.setValue(newValue % (this.maxValue + 1));
    requestAnimationFrame(() => {
      this.inputElement.select();
    });
  }
  decrementValue() {
    const currentValue = this.inputElement.value;
    const newValue = currentValue === ""
      ? this.maxValue
      : parseInt(this.inputElement.value) - 1;
    const lessThanMin = newValue - this.minValue < 0;
    const newComputedValue = lessThanMin
      ? this.maxValue + (newValue - this.minValue) + 1
      : newValue % (this.maxValue + 1);
    this.setValue(newComputedValue);
    requestAnimationFrame(() => {
      this.inputElement.select();
    });
  }
}
