import { h, Host, } from "@stencil/core";
import { assert } from "../../../../classes/assert";
import { DateUtils } from "../../../../classes/date.utils";
import { ElementIdGenerator } from "../../../../classes/element-id-handling";
import { isActiveElement } from "../../../../classes/misc-util";
import { onNextFrame } from "../../../../classes/render-util";
import { SlotObserver } from "../../../../classes/slot-observer";
import { DateErrorType } from "../date";
import { extractDateRange } from "../date-range.util";
// TODO: Min max error Meldung implementieren. (onError Event in dx-date-input und hier abfangen)
/**
 * Allows to pick a date-range by inputing two date-input components.
 *
 * @name Date-Range-Picker
 * @shortname Range
 * @path /Form/Inputs/Date
 * @icon calendar-plus
 * @stable
 *
 */
export class DxDateRange {
  constructor() {
    this.errors = {
      from: DateErrorType.NO_ERROR,
      to: DateErrorType.NO_ERROR,
    };
    this.currentlyFocused = false;
    this.internalErrorMessage = "";
    /**
     * Defines how a date range can be selected or edited.
     *
     * @value "day-month-year": The user can select a specific date range.
     * The calendar shows all three views (month, year and decade) for selecting a date range.
     * @value "month-year": The user can select a month range.
     * The calendar shows two views (year and decade) for selecting a month range.
     * @value "day-month": The user can select two possible dates within a year.
     * The calendar shows two views (month and year) for selecting a date range.
     */
    this.mode = "day-month-year";
    /**
     * The current displayed date range.
     *
     * @important
     * @value string: Two comma seperated dates in following format: YYYY-MM-dd (e.g.: 2021-01-01,2021-12-31)
     * @example value
     */
    this.value = null;
    this.onFocus = () => (this.currentlyFocused = true);
    this.onBlur = () => this.handleBlur();
    this.onError = (e) => this.handleError(e);
    this.onDateValueChange = (e) => this.handleDateValueChange(e);
  }
  onValueChange() {
    const range = extractDateRange(this.value);
    this.selectRange(range);
  }
  connectedCallback() {
    this.slotObserver = new SlotObserver(this.self, "dx-date-input", (dateInputs) => {
      assert(dateInputs.length === 2, () => "You have to define exactly two dx-date-inputs within this component");
      const rangeFromDateInputs = {
        from: null,
        to: null,
      };
      dateInputs.forEach((dateInput) => {
        dateInput.removeEventListener("focus", this.onFocus);
        dateInput.addEventListener("focus", this.onFocus);
        dateInput.removeEventListener("blur", this.onBlur);
        dateInput.addEventListener("blur", this.onBlur);
        dateInput.removeEventListener("errorFound", this.onError);
        dateInput.addEventListener("errorFound", this.onError);
        dateInput.removeEventListener("valueChange", this.onDateValueChange);
        dateInput.addEventListener("valueChange", this.onDateValueChange);
        // Override date-input properties
        dateInput.min = this.min;
        dateInput.max = this.max;
        dateInput.mode = this.mode;
        // Show custom calendar for date-range and disable calendars of inner date inputs
        dateInput.calendarenabled = false;
        rangeFromDateInputs[dateInput.slot] = DateUtils.stringToDate(dateInput.value);
      });
      if (this.value != null) {
        this.selectRange(extractDateRange(this.value));
      }
      else {
        this.selectRange(rangeFromDateInputs);
      }
    });
  }
  componentDidLoad() {
    this.updateCalendarValue();
  }
  disconnectedCallback() {
    this.slotObserver.disconnect();
  }
  onSegmentBlurred() {
    this.updateCalendarValue();
  }
  /**
   * Sets the focus on the first date input element.
   */
  async focusControl() {
    var _a;
    (_a = this.self.querySelector("dx-date-input")) === null || _a === void 0 ? void 0 : _a.focusControl();
  }
  handleBlur() {
    onNextFrame(() => {
      const loseFocus = !isActiveElement(this.self) &&
        // Check if any inner dx-date-input elements have focus
        !Array.from(this.self.querySelectorAll("dx-date-input[slot]")).some((elem) => isActiveElement(elem));
      if (loseFocus) {
        this.currentlyFocused = false;
      }
    });
  }
  handleError(e) {
    const error = e.detail;
    const slot = e.target.slot;
    this.errors[slot] = error.type;
    const errorType = this.errors.from !== DateErrorType.NO_ERROR
      ? this.errors.from
      : this.errors.to;
    // Record makes this type-safe. If a new DateError appears, the compiler will complain here.
    const errorToMessageMap = {
      [DateErrorType.INVALID_DATE]: () => "Invalides Datum gefunden!",
      [DateErrorType.UNDER_MIN]: () => `Die eingegeben Daten müssen nach dem ${DateUtils.getFormattedDisplayDate(this.min)} liegen.`,
      [DateErrorType.OVER_MAX]: () => `Die eingegeben Daten müssen vor dem ${DateUtils.getFormattedDisplayDate(this.max)} liegen.`,
      [DateErrorType.NO_ERROR]: () => "",
    };
    this.internalErrorMessage = errorToMessageMap[errorType]();
  }
  handleDateValueChange(e) {
    const dateInput = e.target;
    if (!dateInput.slot) {
      return;
    }
    const range = extractDateRange(this.value);
    // Slot == from or to. So we set from or to property dependant of slot
    range[dateInput.slot] = e.detail ? new Date(e.detail) : null;
    this.selectRange(range);
  }
  getDateInputs() {
    return Array.from(this.self.querySelectorAll("dx-date-input"));
  }
  selectRange(range, source = "other") {
    // TODO: ... Check for range validity with min and max
    var _a, _b;
    this.value = `${(_a = DateUtils.dateToString(range.from)) !== null && _a !== void 0 ? _a : ""},${(_b = DateUtils.dateToString(range.to)) !== null && _b !== void 0 ? _b : ""}`;
    const dateInputs = this.getDateInputs();
    if (dateInputs[0]) {
      dateInputs[0].value = DateUtils.dateToString(range.from);
      if (source === "calendar-widget") {
        dateInputs[0].internalForceEmitChangeEvent();
      }
    }
    if (dateInputs[1]) {
      dateInputs[1].value = DateUtils.dateToString(range.to);
      if (source === "calendar-widget") {
        dateInputs[1].internalForceEmitChangeEvent();
      }
    }
  }
  updateCalendarValue() {
    if (this.calendar != null) {
      this.calendar.value = this.value;
    }
  }
  setCalendar(calendar) {
    if (this.calendar !== calendar) {
      this.calendar = calendar;
      this.updateCalendarValue();
    }
  }
  renderCalendar() {
    return (h("dx-calendar", { slot: "overlay", id: ElementIdGenerator.createId(this.self, "calendar"), ref: (ref) => this.setCalendar(ref), tabindex: -1, errormessage: this.internalErrorMessage, rangeenabled: true, onBlur: () => {
        this.onBlur();
      }, min: this.min, max: this.max, onRangeSelected: (e) => {
        this.selectRange(e.detail, "calendar-widget");
      }, mode: this.mode }));
  }
  render() {
    return (h(Host, null, h("dx-flyout", { open: this.currentlyFocused, offsety: 4 }, h("div", { class: "date-container" }, h("div", { class: "date-input-container" }, h("slot", { name: "from" })), h("div", { class: "date-input-container" }, h("slot", { name: "to" }))), this.renderCalendar())));
  }
  static get is() { return "dx-date-range"; }
  static get encapsulation() { return "shadow"; }
  static get originalStyleUrls() {
    return {
      "$": ["dx-date-range.scss"]
    };
  }
  static get styleUrls() {
    return {
      "$": ["dx-date-range.css"]
    };
  }
  static get properties() {
    return {
      "min": {
        "type": "string",
        "mutable": false,
        "complexType": {
          "original": "string",
          "resolved": "string",
          "references": {}
        },
        "required": false,
        "optional": true,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "string: A date in following format: YYYY-MM-dd"
            }, {
              "name": "example",
              "text": "min-max"
            }],
          "text": "Defines the minimal allowed date."
        },
        "attribute": "min",
        "reflect": false
      },
      "max": {
        "type": "string",
        "mutable": false,
        "complexType": {
          "original": "string",
          "resolved": "string",
          "references": {}
        },
        "required": false,
        "optional": true,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "string: A date in following format: YYYY-MM-dd"
            }, {
              "name": "example",
              "text": "min-max"
            }],
          "text": "Defines the maximal allowed date."
        },
        "attribute": "max",
        "reflect": false
      },
      "mode": {
        "type": "string",
        "mutable": false,
        "complexType": {
          "original": "DateSelectionMode",
          "resolved": "\"day-month\" | \"day-month-year\" | \"month-year\"",
          "references": {
            "DateSelectionMode": {
              "location": "import",
              "path": "../date"
            }
          }
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "\"day-month-year\": The user can select a specific date range.\nThe calendar shows all three views (month, year and decade) for selecting a date range."
            }, {
              "name": "value",
              "text": "\"month-year\": The user can select a month range.\nThe calendar shows two views (year and decade) for selecting a month range."
            }, {
              "name": "value",
              "text": "\"day-month\": The user can select two possible dates within a year.\nThe calendar shows two views (month and year) for selecting a date range."
            }],
          "text": "Defines how a date range can be selected or edited."
        },
        "attribute": "mode",
        "reflect": false,
        "defaultValue": "\"day-month-year\""
      },
      "value": {
        "type": "string",
        "mutable": true,
        "complexType": {
          "original": "string",
          "resolved": "string",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "important",
              "text": undefined
            }, {
              "name": "value",
              "text": "string: Two comma seperated dates in following format: YYYY-MM-dd (e.g.: 2021-01-01,2021-12-31)"
            }, {
              "name": "example",
              "text": "value"
            }],
          "text": "The current displayed date range."
        },
        "attribute": "value",
        "reflect": true,
        "defaultValue": "null"
      }
    };
  }
  static get states() {
    return {
      "currentlyFocused": {},
      "internalErrorMessage": {}
    };
  }
  static get methods() {
    return {
      "focusControl": {
        "complexType": {
          "signature": "() => Promise<void>",
          "parameters": [],
          "references": {
            "Promise": {
              "location": "global"
            }
          },
          "return": "Promise<void>"
        },
        "docs": {
          "text": "Sets the focus on the first date input element.",
          "tags": []
        }
      }
    };
  }
  static get elementRef() { return "self"; }
  static get watchers() {
    return [{
        "propName": "value",
        "methodName": "onValueChange"
      }];
  }
  static get listeners() {
    return [{
        "name": "segmentBlur",
        "method": "onSegmentBlurred",
        "target": undefined,
        "capture": false,
        "passive": false
      }];
  }
}
