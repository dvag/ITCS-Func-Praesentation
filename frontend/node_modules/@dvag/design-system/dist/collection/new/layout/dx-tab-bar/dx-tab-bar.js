import { Fragment, h, Host, } from "@stencil/core";
import { BreakpointAware } from "../../../classes/breakpoint-aware";
import { ElementIdGenerator } from "../../../classes/element-id-handling";
import { getInnerActiveElement, tagOf } from "../../../classes/misc-util";
import { SlotObserver } from "../../../classes/slot-observer";
/**
 * Manages tabs to display different page contents by clicking on tabs.
 *
 * @path /Layout
 * @name Tab-Bar
 * @shortname Tabs
 * @icon columns
 * @stable
 *
 * @slot - `<dx-tab-page>` elements. A tab will be generated for each of them.
 * @slot-example simple
 * @slot-example complex
 */
export class DxTabBar {
  constructor() {
    this.tabPages = [];
    this.viewMode = "tab";
    this.showLeftButton = false;
    this.showRightButton = false;
    this.parentIsCard = false;
  }
  showChanged() {
    this.updateSlotVisibility();
  }
  connectedCallback() {
    this.initializeObservers();
    this.updateViewMode();
    this.parentIsCard = tagOf(this.self.parentElement) === "dx-card";
  }
  disconnectedCallback() {
    var _a, _b, _c;
    (_a = this.breakpointAware) === null || _a === void 0 ? void 0 : _a.disconnect();
    (_b = this.slotObserver) === null || _b === void 0 ? void 0 : _b.disconnect();
    (_c = this.resizeObserver) === null || _c === void 0 ? void 0 : _c.disconnect();
  }
  componentShouldUpdate(_, __, propName) {
    if (propName === "viewMode") {
      const innerActiveElement = getInnerActiveElement(this.self);
      innerActiveElement === null || innerActiveElement === void 0 ? void 0 : innerActiveElement.blur();
    }
    return true;
  }
  initializeObservers() {
    this.breakpointAware = new BreakpointAware(() => {
      this.updateViewMode();
    }, true);
    this.slotObserver = new SlotObserver(this.self, ":scope > dx-tab-page", async (nodes) => {
      var _a;
      await this.collectTabs(nodes);
      if (this.selected == undefined || this.selected === "") {
        this.selected = (_a = this.tabPages[0]) === null || _a === void 0 ? void 0 : _a.value;
      }
      this.updateSlotVisibility();
    });
    this.resizeObserver = new ResizeObserver(() => {
      this.checkShowButtons(this.scrollContainer);
    });
  }
  async collectTabs(nodes) {
    this.tabPages = await Promise.all(nodes.map((node) => {
      return node.toTabPage();
    }));
  }
  updateSlotVisibility() {
    this.tabPages.forEach((tabPage) => {
      const isVisible = this.selected === tabPage.value;
      tabPage.element.style.display = isVisible ? "block" : "none";
    });
  }
  updateViewMode() {
    this.viewMode =
      this.breakpointAware.mq1 || this.breakpointAware.mq2 ? "dropdown" : "tab";
  }
  setActiveTab(tabPage) {
    if (this.selected !== tabPage.value) {
      this.selected = tabPage.value;
      this.tabChange.emit(tabPage.value);
    }
  }
  getLabel(selected) {
    var _a;
    return (_a = this.tabPages.find((tabPage) => tabPage.value === selected)) === null || _a === void 0 ? void 0 : _a.label;
  }
  checkShowButtons(scrollContainer) {
    if (scrollContainer == null) {
      return;
    }
    this.showLeftButton = scrollContainer.scrollLeft - SCROLL_OFFSET_BIAS > 0;
    this.showRightButton =
      scrollContainer.offsetWidth +
        scrollContainer.scrollLeft +
        SCROLL_OFFSET_BIAS <
        scrollContainer.scrollWidth;
  }
  onScrollTabBar(e) {
    this.checkShowButtons(e.target);
  }
  get scrollContainer() {
    return this.self.shadowRoot.querySelector(".scroll-container");
  }
  onScrollButtonClicked(position) {
    const sign = position === "left" ? -1 : 1;
    const scrollContainer = this.scrollContainer;
    let scrollLeftOffset = SCROLL_STEP_IN_PX * sign;
    const newScrollLeft = scrollContainer.scrollLeft + scrollLeftOffset;
    if (newScrollLeft < SCROLL_OFFSET_BIAS) {
      scrollLeftOffset = -scrollContainer.scrollLeft;
    }
    else if (newScrollLeft >
      scrollContainer.scrollWidth -
        scrollContainer.offsetWidth -
        SCROLL_OFFSET_BIAS) {
      scrollLeftOffset =
        scrollContainer.scrollWidth - scrollContainer.offsetWidth;
    }
    this.scrollContainer.scrollBy({
      left: scrollLeftOffset,
      behavior: "smooth",
    });
  }
  renderBarItem(tabPage) {
    const isSelected = this.selected === tabPage.value;
    return (h("div", { class: { "bar-item": true, selected: isSelected } }, h("button", { id: ElementIdGenerator.createId(this.self, `tab-${tabPage.value}`), key: tabPage.value, class: {
        "bar-item-button": true,
        selected: isSelected,
      }, disabled: isSelected, onClick: (e) => {
        this.setActiveTab(tabPage);
        scrollElementIntoView(e.target);
      } }, h("dx-text", { type: "ps", class: "label" }, tabPage.label)), h("div", { class: { "selected-state-line-container": true } }, h("div", { class: { "selected-state-line": true, selected: isSelected } }))));
  }
  renderScrollButton(position) {
    return (h("button", { id: ElementIdGenerator.createId(this.self, `scroll-button-${position}`), class: {
        "scroll-button": true,
        left: position === "left",
        right: position === "right",
        show: (this.showLeftButton && position === "left") ||
          (this.showRightButton && position === "right"),
      }, onClick: () => this.onScrollButtonClicked(position) }, h("dx-icon", { icon: `chevron-${position === "left" ? "links" : "rechts"}`, size: 24 })));
  }
  renderTabBarItems() {
    return (h("div", { class: "clip-container", onScroll: (e) => {
        // If the clip-container is the one emitting the scroll event we want to prevent it.
        if (e.target.classList.contains("clip-container")) {
          // Fixes implicit scroll of clip-container when calling scrollIntoView
          // This bug could also be resolved by using overflow: clip instead of overflow: hidden for the clip-container,
          // but this feature is not implemented for Safari Browsers.
          e.preventDefault();
          e.target.scrollLeft = 0;
        }
      } }, h("div", { class: {
        "scroll-container": true,
        "right-button-hidden": !this.showRightButton && this.showLeftButton,
        "left-button-hidden": !this.showLeftButton && this.showRightButton,
        "both-buttons-hidden": !this.showLeftButton && !this.showRightButton,
      }, onScroll: (e) => this.onScrollTabBar(e) }, h("div", { class: "page-container", ref: (ref) => {
        if (ref != null) {
          this.resizeObserver.observe(ref);
        }
      } }, h("div", { class: "tab-bar-items-container" }, this.tabPages.map((tabPage, index) => {
      return [
        index !== 0 ? h("div", { class: { spacer: true } }) : null,
        this.renderBarItem(tabPage),
      ];
    }))))));
  }
  renderTabs() {
    return (h(Fragment, null, this.renderScrollButton("left"), this.renderTabBarItems(), this.renderScrollButton("right")));
  }
  renderDropdown() {
    return (h("dx-tab-dropdown", { class: "tab-dropdown", label: this.getLabel(this.selected), key: tabPageArrayHash(this.tabPages), onValueComplete: (e) => {
        this.selected = e.detail.value;
      } }, this.tabPages.map((tabPage) => (h("dx-dropdown-option", { label: tabPage.label, value: tabPage.value })))));
  }
  renderTabBar() {
    return (h("div", { class: {
        "tab-bar": true,
        "tab-mode": this.viewMode === "tab",
      } }, this.viewMode === "tab" ? this.renderTabs() : null, this.viewMode === "dropdown" ? this.renderDropdown() : null));
  }
  render() {
    return (h(Host, { class: {
        "parent-is-card": this.parentIsCard,
      } }, this.renderTabBar(), h("div", { class: "tab-page-content" }, h("div", { class: "page-container" }, h("slot", null)))));
  }
  static get is() { return "dx-tab-bar"; }
  static get encapsulation() { return "shadow"; }
  static get originalStyleUrls() {
    return {
      "$": ["dx-tab-bar.scss"]
    };
  }
  static get styleUrls() {
    return {
      "$": ["dx-tab-bar.css"]
    };
  }
  static get properties() {
    return {
      "selected": {
        "type": "string",
        "mutable": true,
        "complexType": {
          "original": "string",
          "resolved": "string",
          "references": {}
        },
        "required": false,
        "optional": true,
        "docs": {
          "tags": [{
              "name": "important",
              "text": undefined
            }, {
              "name": "value",
              "text": "string: `value` of the `<dx-tab-page>` to display."
            }, {
              "name": "example",
              "text": "selected"
            }],
          "text": "Displays the tab page which `value` property corresponds to this property."
        },
        "attribute": "selected",
        "reflect": true
      }
    };
  }
  static get states() {
    return {
      "tabPages": {},
      "viewMode": {},
      "showLeftButton": {},
      "showRightButton": {},
      "parentIsCard": {}
    };
  }
  static get events() {
    return [{
        "method": "tabChange",
        "name": "tabChange",
        "bubbles": true,
        "cancelable": true,
        "composed": true,
        "docs": {
          "tags": [{
              "name": "example",
              "text": "tab-change"
            }],
          "text": "This event fires when the user selects a new tab.\nIt contains the `value` of the corresponding `<dx-tab-page>`."
        },
        "complexType": {
          "original": "string",
          "resolved": "string",
          "references": {}
        }
      }];
  }
  static get elementRef() { return "self"; }
  static get watchers() {
    return [{
        "propName": "selected",
        "methodName": "showChanged"
      }];
  }
}
const SCROLL_STEP_IN_PX = 160;
const SCROLL_OFFSET_BIAS = 32;
function tabPageArrayHash(tabPages) {
  return tabPages.map((tabPage) => tabPage.label + tabPage.value).join(",");
}
function scrollElementIntoView(element) {
  element === null || element === void 0 ? void 0 : element.scrollIntoView({
    behavior: "smooth",
    inline: "center",
    block: "nearest",
  });
}
