import { PaginatorState, } from "./paginator-state";
import { waitAnimationFrame } from "../../../classes/misc-util";
export class PaginatorAnimationController {
  constructor(page, count) {
    this.elements = [];
    this.queue = [];
    this.animationDuration = DEFAULT_ANIMATION_DURATION;
    this.paginationState = new PaginatorState(page, count, this.onStateChanged.bind(this));
  }
  initialize() {
    this.elements.forEach(resetPageClass);
    this.updateElementPositions(this.paginationState.build());
    this.updateAnimationDuration();
  }
  updateAnimationDuration() {
    this.elements.forEach((element) => {
      element.style.setProperty("--dx-paginator-animation-duration", `${this.animationDuration}ms`);
    });
  }
  updateElementPositions(items) {
    // The startIndex begins with 1 because we ignore the first element which is hidden
    const startIndex = 1;
    items.forEach((paginationItem, index) => {
      const classes = convertPaginationItemToClass(paginationItem);
      this.elements[startIndex + index].classList.add(...classes);
    });
    const maxSpace = 90;
    const space = getPaginationSpace(items);
    const startX = (maxSpace - space) / 2;
    let currentX = startX;
    this.elements.forEach((element, index) => {
      const diff = index - startIndex;
      if (diff < 0) {
        element.style.transform = `translateX(0px)`;
      }
      else if (diff >= items.length) {
        element.style.transform = `translateX(${startX + space + MARGIN_BETWEEN_PAGINATION_ITEMS}px)`;
      }
      else {
        const currentPaginationItem = items[diff];
        const currentPaginationItemWidth = getItemWidth(currentPaginationItem);
        const marginLeft = diff === 0
          ? MARGIN_BETWEEN_PAGINATION_ITEMS
          : MARGIN_BETWEEN_PAGINATION_ITEMS * 0.5;
        const marginRight = diff === items.length - 1
          ? MARGIN_BETWEEN_PAGINATION_ITEMS
          : MARGIN_BETWEEN_PAGINATION_ITEMS * 0.5;
        element.style.transform = `translateX(${currentX + marginLeft}px)`;
        currentX += currentPaginationItemWidth + marginLeft + marginRight;
      }
    });
  }
  async onStateChanged(currentState, previousState) {
    // If an animation is currently playing we want to delay the next animation.
    if (this.timeoutHandle != null) {
      this.queue.push({
        current: currentState,
        previous: previousState,
      });
      this.animationDuration = Math.max(50, this.animationDuration * 0.75);
      this.updateAnimationDuration();
    }
    else {
      await this.processStateChanged(currentState, previousState);
    }
  }
  async processStateChanged(currentState, previousState) {
    const left = currentState.movedToLeft;
    if (currentState.page > 5 || previousState.page > 5) {
      this.shift(left);
    }
    await waitAnimationFrame();
    await waitAnimationFrame();
    this.elements.forEach(resetPageClass);
    this.elements.forEach((element) => element.classList.remove("no-animation"));
    this.updateElementPositions(currentState.items);
    this.timeoutHandle = setTimeout(() => {
      const transitionState = this.queue.shift();
      if (transitionState != null) {
        this.processStateChanged(transitionState.current, transitionState.previous);
      }
      else {
        this.timeoutHandle = null;
        this.animationDuration = DEFAULT_ANIMATION_DURATION;
        this.updateAnimationDuration();
        this.elements.forEach((element) => element.classList.add("no-animation"));
      }
    }, this.animationDuration);
  }
  // Shifts all elements states (classes and transform) to the left or right element.
  shift(left) {
    const elementStatesAndTransforms = this.elements.map((element) => {
      const classList = Array.from(element.classList);
      return {
        classes: classList,
        transform: element.style.transform,
      };
    });
    this.elements.forEach(resetPageClass);
    const scale = left ? -1 : 1;
    this.elements.forEach((element, index) => {
      element.classList.add("no-animation");
      const elementStateAndTransform = elementStatesAndTransforms[index + scale * 1];
      if (elementStateAndTransform) {
        element.classList.add(...elementStateAndTransform.classes);
        element.style.transform = elementStateAndTransform.transform;
      }
    });
  }
  setPage(page) {
    this.paginationState.setPage(page);
  }
  setIndex(index, element) {
    this.elements[index] = element;
  }
}
const DEFAULT_ANIMATION_DURATION = 300;
const PAGE_STATE_CLASSES = [
  "size-small",
  "size-medium",
  "size-large",
  "active",
];
const MARGIN_BETWEEN_PAGINATION_ITEMS = 8;
function resetPageClass(element) {
  element.classList.remove(...PAGE_STATE_CLASSES);
}
function getItemWidth(paginationItem) {
  return { small: 3, medium: 6, large: 8, active: 8 }[paginationItem];
}
function getPaginationSpace(paginationItems) {
  if (paginationItems == null) {
    return null;
  }
  return paginationItems.reduce((acc, item) => {
    const itemWidth = getItemWidth(item);
    return acc + itemWidth + MARGIN_BETWEEN_PAGINATION_ITEMS;
  }, -MARGIN_BETWEEN_PAGINATION_ITEMS);
}
function convertPaginationItemToClass(paginationItem) {
  if (paginationItem == null) {
    return [];
  }
  if (paginationItem === "active") {
    return ["active", "size-large"];
  }
  return [`size-${paginationItem}`];
}
