import { h, Host, } from "@stencil/core";
import { DragController } from "../../../../classes/drag-controller";
import { clamp } from "../../../../classes/math-util";
/**
 * Form element to select a numeric value within the range.
 *
 * @internal
 * @path /Form
 * @name Slider
 * @icon sliders-h
 * @stable
 */
export class DxSlideshowSlider {
  constructor() {
    // This is set to true, when the user interacts with the sidebar under the knob
    this.initDragOutsideOfKnob = false;
    this.internalValue = 0;
    this.isDragging = false;
    /**
     * Size of the Steps, the values can be selected.
     * @value number: Minimal possible change.
     * @example step
     */
    this.step = 0.01;
    /**
     * Current value of the slider.
     * @value number: Current value
     * @example min-max-value
     */
    this.value = 1;
  }
  onValueChanged() {
    if (!this.isDragging &&
      this.internalValue != this.value &&
      !isNaN(this.value)) {
      this.internalValue = this.value;
    }
  }
  componentWillLoad() {
    var _a;
    this.internalValue = (_a = this.value) !== null && _a !== void 0 ? _a : 1;
    this.dragController = new DragController((startX) => {
      var _a, _b;
      const knobBoundingClientRect = (_a = this.knob) === null || _a === void 0 ? void 0 : _a.getBoundingClientRect();
      if (this.initDragOutsideOfKnob) {
        const selfBoundingBox = this.self.getBoundingClientRect();
        this.initDragOutsideOfKnob = false;
        return {
          localKnobOffset: startX - knobBoundingClientRect.width * 0.5 - selfBoundingBox.x,
          knobWidth: knobBoundingClientRect.width,
        };
      }
      return {
        localKnobOffset: knobBoundingClientRect.x - ((_b = this.self.getBoundingClientRect()) === null || _b === void 0 ? void 0 : _b.x),
        knobWidth: knobBoundingClientRect.width,
      };
    }, (e) => {
      var _a;
      const boundingBox = this.self.getBoundingClientRect();
      const localMouseOnKnobPositionX = e.startX - boundingBox.x - e.startValue.localKnobOffset;
      const mouseLimitLeft = boundingBox.left + localMouseOnKnobPositionX;
      const mouseLimitRight = boundingBox.right -
        (e.startValue.knobWidth - localMouseOnKnobPositionX);
      const position = Math.max(0, Math.min((e.x - mouseLimitLeft) / (mouseLimitRight - mouseLimitLeft), 1));
      const computedValue = Math.ceil((MIN + position * (this.max - MIN)) / this.step) *
        this.step;
      const fractionDigits = ((_a = this.step.toString().split(".")[1]) === null || _a === void 0 ? void 0 : _a.length) || 0;
      const newValue = parseFloat(computedValue.toFixed(fractionDigits));
      if (this.internalValue !== newValue && !isNaN(newValue)) {
        this.internalValue = newValue;
        this.valueChange.emit(this.internalValue);
      }
    }, () => this.onStartDragging(), () => this.onStopDragging());
  }
  componentShouldUpdate(_, __, propName) {
    if (["min", "max"].includes(propName)) {
      this.internalValue = clamp(this.value, MIN, this.max);
    }
  }
  onStartDragging() {
    this.isDragging = true;
    this.dragging.emit(true);
  }
  onStopDragging() {
    this.isDragging = false;
    this.dragging.emit(false);
    this.internalValue = Math.round(this.internalValue);
    this.valueChange.emit(this.internalValue);
  }
  getKnobWidthPercentage() {
    return 100 / this.max;
  }
  getKnobPositionPercentage() {
    return 100 * (this.internalValue - 1);
  }
  render() {
    return (h(Host, { class: {
        "is-dragging": this.isDragging,
      }, onPointerDown: (e) => {
        this.initDragOutsideOfKnob = true;
        this.dragController.onPointerDown(e);
      }, onTouchStart: (e) => {
        this.initDragOutsideOfKnob = true;
        this.dragController.onTouchStart(e);
      } }, h("div", { class: "hover-trigger" }, h("div", { class: {
        "knob-trigger": true,
        "is-dragging": this.isDragging,
        "use-transition": !this.isDragging,
      }, onPointerDown: (e) => {
        // Host should not trigger onPointerDown or onTouchStart
        e.stopPropagation();
        this.dragController.onPointerDown(e);
      }, onTouchStart: (e) => {
        // Host should not trigger onPointerDown or onTouchStart
        e.stopPropagation();
        this.dragController.onTouchStart(e);
      }, ref: (ref) => (this.knob = ref), style: {
        transform: `translateX(${this.getKnobPositionPercentage()}%)`,
        width: `${this.getKnobWidthPercentage()}%`,
      } }, h("div", { class: { knob: true, "use-transition": !this.isDragging } })))));
  }
  static get is() { return "dx-slideshow-slider"; }
  static get encapsulation() { return "shadow"; }
  static get originalStyleUrls() {
    return {
      "$": ["dx-slideshow-slider.scss"]
    };
  }
  static get styleUrls() {
    return {
      "$": ["dx-slideshow-slider.css"]
    };
  }
  static get properties() {
    return {
      "max": {
        "type": "number",
        "mutable": false,
        "complexType": {
          "original": "number",
          "resolved": "number",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "number: Maximum value of the slider."
            }, {
              "name": "example",
              "text": "min-max-value"
            }],
          "text": "Maximum value of the range, the slider can have."
        },
        "attribute": "max",
        "reflect": false
      },
      "step": {
        "type": "number",
        "mutable": false,
        "complexType": {
          "original": "number",
          "resolved": "number",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "number: Minimal possible change."
            }, {
              "name": "example",
              "text": "step"
            }],
          "text": "Size of the Steps, the values can be selected."
        },
        "attribute": "step",
        "reflect": false,
        "defaultValue": "0.01"
      },
      "value": {
        "type": "number",
        "mutable": true,
        "complexType": {
          "original": "number",
          "resolved": "number",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "number: Current value"
            }, {
              "name": "example",
              "text": "min-max-value"
            }],
          "text": "Current value of the slider."
        },
        "attribute": "value",
        "reflect": true,
        "defaultValue": "1"
      }
    };
  }
  static get states() {
    return {
      "internalValue": {},
      "isDragging": {}
    };
  }
  static get events() {
    return [{
        "method": "valueChange",
        "name": "valueChange",
        "bubbles": true,
        "cancelable": true,
        "composed": true,
        "docs": {
          "tags": [{
              "name": "example",
              "text": "value-change"
            }],
          "text": "User made changes. Contains the chosen value."
        },
        "complexType": {
          "original": "number",
          "resolved": "number",
          "references": {}
        }
      }, {
        "method": "dragging",
        "name": "dragging",
        "bubbles": true,
        "cancelable": true,
        "composed": true,
        "docs": {
          "tags": [],
          "text": ""
        },
        "complexType": {
          "original": "boolean",
          "resolved": "boolean",
          "references": {}
        }
      }];
  }
  static get elementRef() { return "self"; }
  static get watchers() {
    return [{
        "propName": "value",
        "methodName": "onValueChanged"
      }];
  }
}
const MIN = 1;
