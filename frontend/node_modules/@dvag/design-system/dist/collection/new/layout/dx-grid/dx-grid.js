import { h, Host, } from "@stencil/core";
import { GridSyntaxParser } from "./grid-syntax-parser";
import { GridValidator } from "./grid-validator";
import { PAGE_GRID } from "./grid-base";
import { getBreakpointMinWidth, GridBreakpoint, } from "./grid-models";
import { GridCssBuilder } from "./grid-css-builder";
import { BreakpointAware } from "../../../classes/breakpoint-aware";
import { SlotObserver } from "../../../classes/slot-observer";
import { assert } from "../../../classes/assert";
import { assertIsPossibleSize } from "../../../classes/sizes.util";
/**
 * Responsive layout element to align multiple elements within a grid.
 *
 * Multiple grid systems are supported through the `base` property.
 *
 * There are currently five breakpoints which can be used:
 * MQ1 for Mobile devices
 * MQ2 and MQ3 for tablets,
 * MQ4 for laptops,
 * MQ5 for desktop PCs
 *
 * You can define each breakpoint indivually to match a style proper for the given context device.
 *
 * ## Grid-Syntax
 * The syntax consists of four operators:
 *
 * | Operator | Meaning |
 * |-----|-----|
 * | **`2`** | A number defines the amount of grid columns an element gets. `0` means that the corresponding element is hidden. |
 * | **`(3)`** | A number in brackets defines the amount of grid columns which are used as whitespace. |
 * | **`-`** | Delimitation between `numbers` in a row. In combination with numbers they define a row within the grid. e.g. `4-4-4`: Three elements in a row are each taking 4 columns of space. |
 * | **`/`** | Starts a new row definition. e.g. `2-2/4`: There are three elements. The first two elements will be displayed in the first row and the third will be displayed in the second row. |
 * | **`*`** | Repeats the previous row definition for all rows to follow. e.g. `12/*`: All elements use 12 grid columns and are displayed in a seperate row. |
 *
 * ## Column amount
 *
 * The amount of column is defined by the grid base (`base` property). Each breakpoint has a defined number of columns.
 * The default base defines 12 columns for each breakpoint. These can differ from base to base.
 *
 * @path /Layout
 * @name Grid
 * @icon th
 * @stable
 *
 * @slot - Elements to be layouted in the grid.
 * @example tutorial-1
 */
export class DxGrid {
  constructor() {
    /**
     * The grid's base. Different bases can define a custom amount of columns for every breakpoint.
     *
     * @value page: Default page grid.
     * @example page-1
     * @example page-2
     */
    this.base = "page";
    /**
     * The gap between the rows of the grid.
     *
     * @value 0, 4, 8, 16, 24, 32, 40, 48, 56, 64, 80, 120: The gap between the rows.
     * @example row-gap
     */
    this.rowgap = "16";
    this.updateGridPoolBeforeRender = false;
    this.gridPool = [];
  }
  updateGridPool() {
    assert((this.mq1 || this.mq2 || this.mq3 || this.mq4 || this.mq5) != null, () => '<dx-grid> There has to be at least one breakpoint defined: "mq1", "mq2", "mq3", "mq4" or "mq5".');
    this.gridPool = [];
    const gridBase = PAGE_GRID;
    if (this.mq1) {
      this.gridPool.push(new GridSyntaxParser().parse(this.mq1, GridBreakpoint.MQ1));
    }
    if (this.mq2) {
      this.gridPool.push(new GridSyntaxParser().parse(this.mq2, GridBreakpoint.MQ2));
    }
    if (this.mq3) {
      this.gridPool.push(new GridSyntaxParser().parse(this.mq3, GridBreakpoint.MQ3));
    }
    if (this.mq4) {
      this.gridPool.push(new GridSyntaxParser().parse(this.mq4, GridBreakpoint.MQ4));
    }
    if (this.mq5) {
      this.gridPool.push(new GridSyntaxParser().parse(this.mq5, GridBreakpoint.MQ5));
    }
    const validator = new GridValidator(gridBase);
    this.gridPool.forEach((grid) => validator.validate(grid));
    this.updateChosenGrid();
  }
  componentWillLoad() {
    this.updateGridPool();
  }
  connectedCallback() {
    this.slotObserver = new SlotObserver(this.self, "*", (nodes) => {
      this.numberOfChildNodes = nodes.filter((node) => node.parentElement === this.self).length;
    });
    this.breakpointAware = new BreakpointAware(() => this.updateChosenGrid(), true);
  }
  disconnectedCallback() {
    var _a, _b;
    (_a = this.breakpointAware) === null || _a === void 0 ? void 0 : _a.disconnect();
    (_b = this.slotObserver) === null || _b === void 0 ? void 0 : _b.disconnect();
  }
  componentShouldUpdate(_, __, propName) {
    if (propName.startsWith("mq")) {
      this.updateGridPoolBeforeRender = true;
    }
  }
  componentWillRender() {
    var _a;
    assertIsPossibleSize((_a = this.rowgap) !== null && _a !== void 0 ? _a : "16", this.self);
    if (this.updateGridPoolBeforeRender) {
      this.updateGridPool();
      this.updateGridPoolBeforeRender = false;
    }
  }
  gridBase() {
    if (this.base == "page") {
      return PAGE_GRID;
    }
    throw Error("<dx-grid> Invalid 'base' value");
  }
  getBreakpointFromBreakpointAware() {
    if (this.breakpointAware.mq1) {
      return GridBreakpoint.MQ1;
    }
    else if (this.breakpointAware.mq2) {
      return GridBreakpoint.MQ2;
    }
    else if (this.breakpointAware.mq3) {
      return GridBreakpoint.MQ3;
    }
    else if (this.breakpointAware.mq4) {
      return GridBreakpoint.MQ4;
    }
    else {
      return GridBreakpoint.MQ5;
    }
  }
  updateChosenGrid() {
    this.breakpoint = this.getBreakpointFromBreakpointAware();
    // 1. use direct matches
    this.usedGrid = this.gridPool.find((grid) => grid.breakpoint === this.breakpoint);
    // 2. else: find next smallest breakpoint
    if (!this.usedGrid) {
      const currentBreakpointMinWidth = getBreakpointMinWidth(this.breakpoint);
      this.usedGrid = this.gridPool.reduce((prev, next) => {
        const nextMinWidth = getBreakpointMinWidth(next.breakpoint);
        const prevMinWidth = getBreakpointMinWidth(prev.breakpoint);
        return nextMinWidth > prevMinWidth &&
          nextMinWidth < currentBreakpointMinWidth
          ? next
          : prev;
      });
    }
    // 3. else: use any
    if (!this.usedGrid) {
      this.usedGrid = this.gridPool[0];
    }
  }
  render() {
    let gridErrors = this.gridPool
      .map((grid) => grid.error)
      .reduce((a, b) => a + b, "");
    const rowGap = parseInt(this.rowgap);
    const result = new GridCssBuilder().build(this.gridBase(), this.usedGrid, this.getBreakpointFromBreakpointAware(), this.numberOfChildNodes, isNaN(rowGap) ? 16 : rowGap);
    gridErrors += result.error;
    if (gridErrors.length > 0) {
      console.error(`<dx-grid> ${gridErrors}`);
      return `Grid-Error: ${gridErrors}`;
    }
    return (h(Host, null, h("style", null, result.css), h("slot", null)));
  }
  static get is() { return "dx-grid"; }
  static get encapsulation() { return "shadow"; }
  static get originalStyleUrls() {
    return {
      "$": ["dx-grid.scss"]
    };
  }
  static get styleUrls() {
    return {
      "$": ["dx-grid.css"]
    };
  }
  static get properties() {
    return {
      "base": {
        "type": "string",
        "mutable": false,
        "complexType": {
          "original": "string",
          "resolved": "string",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "page: Default page grid."
            }, {
              "name": "example",
              "text": "page-1"
            }, {
              "name": "example",
              "text": "page-2"
            }],
          "text": "The grid's base. Different bases can define a custom amount of columns for every breakpoint."
        },
        "attribute": "base",
        "reflect": false,
        "defaultValue": "\"page\""
      },
      "rowgap": {
        "type": "string",
        "mutable": false,
        "complexType": {
          "original": "Size",
          "resolved": "\"0\" | \"4\" | \"8h\" | \"0v\" | \"0h\" | \"4v\" | \"4h\" | \"8\" | \"8v\" | \"16\" | \"16v\" | \"16h\" | \"24\" | \"24v\" | \"24h\" | \"32\" | \"32v\" | \"32h\" | \"40\" | \"40v\" | \"40h\" | \"48\" | \"48v\" | \"48h\" | \"56\" | \"56v\" | \"56h\" | \"64\" | \"64v\" | \"64h\" | \"80\" | \"80v\" | \"80h\" | \"120\" | \"120v\" | \"120h\"",
          "references": {
            "Size": {
              "location": "import",
              "path": "../../../classes/sizes.util"
            }
          }
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "0, 4, 8, 16, 24, 32, 40, 48, 56, 64, 80, 120: The gap between the rows."
            }, {
              "name": "example",
              "text": "row-gap"
            }],
          "text": "The gap between the rows of the grid."
        },
        "attribute": "rowgap",
        "reflect": false,
        "defaultValue": "\"16\""
      },
      "mq1": {
        "type": "string",
        "mutable": false,
        "complexType": {
          "original": "string",
          "resolved": "string",
          "references": {}
        },
        "required": false,
        "optional": true,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "string: Layout definition in the grid syntax."
            }, {
              "name": "important",
              "text": undefined
            }],
          "text": "Grid-Layout definition for the MQ1-Breakpoint.\n\nThere has to be at least one breakpoint defined (MQ1, MQ2, MQ3, MQ4 oder MQ5)."
        },
        "attribute": "mq1",
        "reflect": false
      },
      "mq2": {
        "type": "string",
        "mutable": false,
        "complexType": {
          "original": "string",
          "resolved": "string",
          "references": {}
        },
        "required": false,
        "optional": true,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "string: Layout definition in the grid syntax."
            }, {
              "name": "important",
              "text": undefined
            }],
          "text": "Grid-Layout definition for the MQ2-Breakpoint.\n\nThere has to be at least one breakpoint defined (MQ1, MQ2, MQ3, MQ4 oder MQ5)."
        },
        "attribute": "mq2",
        "reflect": false
      },
      "mq3": {
        "type": "string",
        "mutable": false,
        "complexType": {
          "original": "string",
          "resolved": "string",
          "references": {}
        },
        "required": false,
        "optional": true,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "string: Layout definition in the grid syntax."
            }, {
              "name": "important",
              "text": undefined
            }],
          "text": "Grid-Layout definition for the MQ3-Breakpoint.\n\nThere has to be at least one breakpoint defined (MQ1, MQ2, MQ3, MQ4 oder MQ5)."
        },
        "attribute": "mq3",
        "reflect": false
      },
      "mq4": {
        "type": "string",
        "mutable": false,
        "complexType": {
          "original": "string",
          "resolved": "string",
          "references": {}
        },
        "required": false,
        "optional": true,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "string: Layout definition in the grid syntax."
            }, {
              "name": "important",
              "text": undefined
            }],
          "text": "Grid-Layout definition for the MQ4-Breakpoint.\n\nThere has to be at least one breakpoint defined (MQ1, MQ2, MQ3, MQ4 oder MQ5)."
        },
        "attribute": "mq4",
        "reflect": false
      },
      "mq5": {
        "type": "string",
        "mutable": false,
        "complexType": {
          "original": "string",
          "resolved": "string",
          "references": {}
        },
        "required": false,
        "optional": true,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "string: Layout definition in the grid syntax."
            }, {
              "name": "important",
              "text": undefined
            }],
          "text": "Grid-Layout definition for the MQ5-Breakpoint.\n\nThere has to be at least one breakpoint defined (MQ1, MQ2, MQ3, MQ4 oder MQ5)."
        },
        "attribute": "mq5",
        "reflect": false
      }
    };
  }
  static get states() {
    return {
      "breakpoint": {},
      "numberOfChildNodes": {}
    };
  }
  static get elementRef() { return "self"; }
}
