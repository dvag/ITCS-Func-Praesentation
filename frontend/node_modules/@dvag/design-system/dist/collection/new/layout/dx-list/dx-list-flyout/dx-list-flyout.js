import { forceUpdate, h, Host, readTask, writeTask, } from "@stencil/core";
import { PreciseCssSetter } from "../../../../classes/precise-css-setter";
import { clamp } from "../../../../classes/math-util";
import { BreakpointAware } from "../../../../classes/breakpoint-aware";
import { unawaited } from "../../../../classes/async";
import { findClosestScrollElement, getSlottedContent, tagOf, } from "../../../../classes/misc-util";
/**
 * Wraps a dx-list component and adds functionality.
 * @internal
 */
export class DxListFlyout {
  constructor() {
    this.scrollHandle = () => this.updateScrollContainerMaxHeight();
    this.currentHighlightedItem = -1;
    this.listItems = [];
    this.defaultSlottedElements = [];
    this.open = false;
    this.position = "bottom";
    this.direction = "right";
    this.preventSpaceSelection = false;
    this.preventArrowSelection = false;
    this.size = "m";
    this.selectionmode = "single";
    this.stopclickpropagationonpopup = false;
    this.defaulthighlightfirst = false;
    this.focusable = true;
    /**
     * Automatically clears the current selected item when the list closes.
     */
    this.clearselectiononclose = false;
    /**
     * Whether a list item should be selected when focused with the keyboard or not.
     */
    this.selectonhighlight = true;
    // Only trigger render, when number changes.
    this.numberOfListItems = 0;
    this.internalPosition = "bottom";
    this.maxheight = null;
  }
  onMaxSelectionsChanged() {
    this.updateListItemsDisabledState();
  }
  componentWillLoad() {
    this.internalPosition = this.position;
  }
  connectedCallback() {
    this.breakpointAware = new BreakpointAware(() => forceUpdate(this), true);
    this.mutationObserver = this.createMutationObserver();
    this.mutationObserver.observe(this.self, {
      childList: true,
      subtree: true,
      attributes: true,
    });
    this.updateUpperScrollContainer();
    // In case of hydration the upper scroll container is not always available on startup (e.g. dx-modal scrollable content)
    setTimeout(() => {
      this.updateUpperScrollContainer();
    }, 1000);
  }
  createMutationObserver() {
    const onFocus = (e) => this.handleListItemFocus(e);
    // We want to prevent the mouse down event on all list items to prevent the focus on mousedown because the focus
    // event triggers the list flyout container to scroll to the corresponding list item.
    const onMouseDown = (e) => {
      e.preventDefault();
      const element = e.target;
      if (tagOf(element) === "dx-list-item") {
        element.classList.add("force-active");
      }
    };
    return new MutationObserver(() => {
      var _a;
      this.defaultSlottedElements = getSlottedContent(this.self).filter((element) => !element.slot);
      this.listItems = this.getListItems();
      this.numberOfListItems = this.listItems.length;
      this.listItems.forEach((listItem) => {
        listItem.removeEventListener("focus", onFocus);
        listItem.addEventListener("focus", onFocus);
        listItem.removeEventListener("mousedown", onMouseDown);
        listItem.addEventListener("mousedown", onMouseDown);
      });
      if (this.selectionmode === "single") {
        const selectedNodes = this.listItems.filter((node) => node.selected);
        if (selectedNodes.length > 1) {
          console.error("There can only be one selected item at a time. Please set 'selectionmode' to \"multi\".\n", this.self);
        }
      }
      if (!this.open && this.clearselectiononclose) {
        this.clearSelection();
      }
      this.updateListItemsDisabledState();
      if (this.defaulthighlightfirst &&
        ((_a = this.listItems) === null || _a === void 0 ? void 0 : _a.length) > 0 &&
        this.currentHighlightedItem === -1) {
        this.highlightItem(0);
      }
    });
  }
  getListItems() {
    return this.defaultSlottedElements
      .map((element) => {
      if (tagOf(element) === "dx-list-item") {
        return new Array(element);
      }
      else {
        return Array.from(element.querySelectorAll("dx-list-item"));
      }
    })
      .flat();
  }
  disconnectedCallback() {
    var _a, _b;
    (_a = this.mutationObserver) === null || _a === void 0 ? void 0 : _a.disconnect();
    this.removeScrollEventListener();
    this.upperScrollContainer.removeEventListener("scroll", this.scrollHandle);
    (_b = this.breakpointAware) === null || _b === void 0 ? void 0 : _b.disconnect();
  }
  /**
   * Workaround for Firefox Bug:
   * https://bugzilla.mozilla.org/show_bug.cgi?id=771241
   *
   * Because of the preventDefault used in mousedown for every listItem the CSS :active state is not applied for the list items.
   */
  onWindowMouseUp() {
    var _a;
    (_a = this.listItems) === null || _a === void 0 ? void 0 : _a.forEach((listItem) => {
      listItem.classList.remove("force-active");
    });
  }
  updateUpperScrollContainer() {
    readTask(() => {
      this.upperScrollContainer = findClosestScrollElement(this.self);
      this.addScrollEventListener();
    });
  }
  addScrollEventListener() {
    // We have to listen to the window scroll when the upperScrollContainer equals the
    // documentElement, because it does not fire the scroll event.
    if (this.upperScrollContainer === document.documentElement) {
      window.addEventListener("scroll", this.scrollHandle);
    }
    else {
      this.upperScrollContainer.addEventListener("scroll", this.scrollHandle);
    }
  }
  removeScrollEventListener() {
    if (this.upperScrollContainer === document.documentElement) {
      window.removeEventListener("scroll", this.scrollHandle);
    }
    else {
      this.upperScrollContainer.removeEventListener("scroll", this.scrollHandle);
    }
  }
  handleListItemFocus(e) {
    const index = this.listItems.indexOf(e.target);
    this.highlightItem(index);
  }
  updateScrollContainerMaxHeight() {
    if (this.scrollContainer == null) {
      return;
    }
    writeTask(async () => {
      this.scrollContainer.style.maxHeight =
        (await this.getScrollContainerHeight()) + "px";
    });
  }
  getMinListHeight() {
    const numberOfListItems = this.self.querySelectorAll("dx-list-item").length || 1;
    const itemHeight = this.size === "m" ? ITEM_HEIGHT_PX_M : ITEM_HEIGHT_PX_L;
    const visibleItems = Math.min(numberOfListItems, this.itemsvisible || Infinity);
    return visibleItems * itemHeight - BORDER_PX;
  }
  async computeHeightToViewportEnd() {
    return new Promise((resolve) => {
      readTask(() => {
        var _a, _b;
        let position = this.position;
        let height;
        const belowHeight = (_b = (_a = this.self.shadowRoot.querySelector(".below-container")) === null || _a === void 0 ? void 0 : _a.offsetHeight) !== null && _b !== void 0 ? _b : 0;
        const offsetToViewport = 24;
        const upperScrollContainerBoundingClientRect = this.upperScrollContainer.getBoundingClientRect();
        const getHeightBottom = () => {
          var _a, _b;
          const relativeValue = this.upperScrollContainer === document.documentElement
            ? this.upperScrollContainer.clientHeight
            : upperScrollContainerBoundingClientRect.bottom;
          const selfPositionY = relativeValue - ((_b = (_a = this.self) === null || _a === void 0 ? void 0 : _a.getBoundingClientRect()) === null || _b === void 0 ? void 0 : _b.bottom);
          return (selfPositionY -
            offsetToViewport -
            belowHeight -
            this.getOffsetY("bottom"));
        };
        const getHeightTop = () => {
          var _a, _b;
          const relativeValue = this.upperScrollContainer === document.documentElement
            ? 0
            : upperScrollContainerBoundingClientRect.top;
          const selfPositionY = ((_b = (_a = this.self) === null || _a === void 0 ? void 0 : _a.getBoundingClientRect()) === null || _b === void 0 ? void 0 : _b.top) - relativeValue;
          return (selfPositionY -
            offsetToViewport -
            belowHeight -
            this.getOffsetY("top"));
        };
        if (position === "bottom") {
          height = getHeightBottom();
          if (height < this.getMinListHeight()) {
            const topHeight = getHeightTop();
            if (topHeight > height) {
              height = topHeight;
              position = "top";
            }
          }
        }
        else if (position === "top") {
          height = getHeightTop();
          if (height < this.getMinListHeight()) {
            const bottomHeight = getHeightBottom();
            if (bottomHeight > height) {
              height = bottomHeight;
              position = "bottom";
            }
          }
        }
        if (position !== this.internalPosition) {
          this.internalPosition = position;
          this.positionChange.emit(this.internalPosition);
        }
        resolve(height);
      });
    });
  }
  async getScrollContainerHeight() {
    const maxHeight = this.maxheight == null || isNaN(this.maxheight)
      ? Infinity
      : this.maxheight;
    return Math.min(maxHeight, await this.computeHeightToViewportEnd());
  }
  getExplicitSelectionKeys() {
    const keyCodes = ["Enter"];
    if (!this.preventArrowSelection) {
      keyCodes.push("ArrowRight", "ArrowLeft");
    }
    if (!this.preventSpaceSelection) {
      keyCodes.push("ArrowRight", "ArrowLeft");
    }
    return keyCodes;
  }
  handleSelectionInput(keyCode) {
    if (this.getExplicitSelectionKeys().includes(keyCode)) {
      if (this.currentHighlightedItem >= 0) {
        this.selectItem(this.currentHighlightedItem, "explicit");
      }
    }
  }
  onWindowResize() {
    this.updateScrollContainerMaxHeight();
  }
  onWindowScroll() {
    this.updateScrollContainerMaxHeight();
  }
  onListItemInteraction(e) {
    if (this.selectionmode == null) {
      return;
    }
    e.stopPropagation();
    this.selectItem(this.listItems.indexOf(e.target), "explicit");
  }
  focusItem(itemIndex) {
    if (this.scrollContainer == null) {
      return;
    }
    if (itemIndex > -1) {
      readTask(() => {
        const listHeight = this.scrollContainer.offsetHeight;
        let count = 0;
        const itemIndexWithinSlot = this.defaultSlottedElements.findIndex((element) => {
          if (tagOf(element) === "dx-list-item") {
            return count++ === itemIndex;
          }
          return false;
        });
        const arrayBeforeScrollToItem = itemIndexWithinSlot < 0
          ? []
          : this.defaultSlottedElements.slice(0, itemIndexWithinSlot);
        const heightBeforeScrollToItem = arrayBeforeScrollToItem.reduce((acc, element) => acc + element.offsetHeight, 0);
        const listItem = this.listItems[itemIndex];
        if (this.focusable) {
          unawaited(listItem.focusControl());
        }
        this.scrollContainer.scrollTo({
          top: heightBeforeScrollToItem +
            listItem.offsetHeight / 2 -
            listHeight / 2,
          behavior: "smooth",
        });
      });
    }
    else {
      this.scrollContainer.scrollTop = 0;
    }
  }
  onGrowBoxStateChanged(e) {
    const clearSelectionBecauseClosed = this.clearselectiononclose && e.detail === "closed";
    // If there is always only one selection we want to check if the list is closed and the selection should be cleared.
    // If not we highlight the current selected item.
    if (!clearSelectionBecauseClosed && this.selectionmode === "single") {
      this.highlightItem(this.listItems.findIndex((node) => node.selected));
      return;
    }
    // Otherwise we clear the highlight and the selection (only if clearselectiononclose is true)
    this.clearHighlighting();
    if (this.clearselectiononclose) {
      this.clearSelection();
    }
  }
  onKeyDown(e) {
    //Prevents the whole page from scrolling
    if ([
      "ArrowDown",
      "ArrowUp",
      "Space",
      "ArrowRight",
      "ArrowLeft",
      "Enter",
    ].includes(e.key)) {
      e.preventDefault();
    }
    this.handleUpDownNavigation(e.key);
    this.handleSelectionInput(e.key);
  }
  emitSelectionChange(reason) {
    this.itemSelectionChange.emit({
      selectedItems: this.listItems
        .filter((listItem) => listItem.selected)
        .map((listItem) => listItem.value),
      reason,
    });
  }
  clearSelection() {
    writeTask(() => {
      var _a;
      (_a = this.listItems) === null || _a === void 0 ? void 0 : _a.forEach((listItem) => {
        if (listItem.selected) {
          listItem.setAttribute("selected", "false");
        }
      });
    });
  }
  selectItem(itemIndex, reason) {
    const element = this.listItems[itemIndex];
    if (element == null) {
      return;
    }
    writeTask(() => {
      if (this.selectionmode === "single") {
        this.listItems.forEach((listItem) => {
          listItem.setAttribute("selected", (listItem === element).toString());
        });
      }
      else if (this.selectionmode === "multi") {
        element.setAttribute("selected", (!element.selected).toString());
      }
      this.emitSelectionChange(reason);
    });
    this.highlightItem(itemIndex);
    this.updateListItemsDisabledState();
  }
  updateListItemsDisabledState() {
    writeTask(() => {
      if (this.maxselections == null) {
        this.listItems.forEach((listItem) => {
          listItem.disabled = false;
        });
      }
      else {
        const currentSelections = this.listItems.filter((listItem) => listItem.selected).length;
        this.listItems
          .filter((listItem) => !listItem.selected)
          .forEach((listItem) => {
          listItem.disabled = currentSelections >= this.maxselections;
        });
      }
    });
  }
  handleUpDownNavigation(keyCode) {
    if (keyCode === "ArrowUp" || keyCode === "ArrowDown") {
      const listItems = this.listItems;
      const step = keyCode.includes("Down") ? 1 : -1;
      const nextOrPreviousIndex = clamp(this.currentHighlightedItem + step, -1, listItems.length);
      const nextHighlightedIndex = (nextOrPreviousIndex + listItems.length) % listItems.length;
      if (this.selectionmode === "single" && this.selectonhighlight) {
        this.selectItem(nextHighlightedIndex, "implicit");
      }
      else {
        this.highlightItem(nextHighlightedIndex);
      }
    }
  }
  highlightItem(itemIndex) {
    this.currentHighlightedItem = itemIndex;
    this.setHighlightStyles(itemIndex);
    this.focusItem(itemIndex);
  }
  setHighlightStyles(itemIndex) {
    writeTask(() => {
      this.listItems.forEach((item, index) => {
        const isHighlighted = itemIndex === index;
        new PreciseCssSetter(item).set("highlighted", isHighlighted).execute();
      });
    });
  }
  clearHighlighting() {
    this.highlightItem(-1);
  }
  getOffsetY(position) {
    if ((position !== null && position !== void 0 ? position : this.internalPosition) === "top") {
      const offset = parseInt(getComputedStyle(this.self).getPropertyValue("--dx-overlay-offset"));
      return isNaN(offset) ? 0 : offset;
    }
    return 0;
  }
  componentWillRender() {
    this.updateUpperScrollContainer();
  }
  render() {
    return (h(Host, { tabIndex: -1 }, h("dx-flyout", { open: this.open, position: this.internalPosition, direction: this.direction, offsety: this.getOffsetY() }, h("slot", { name: "base" }), h("div", { slot: "overlay", class: {
        "scroll-container": true,
      }, ref: (ref) => {
        this.scrollContainer = ref;
        this.updateScrollContainerMaxHeight();
      }, onClick: (e) => {
        if (this.stopclickpropagationonpopup) {
          e.stopPropagation();
        }
      } }, h("dx-list", { class: { "list-container": true }, tabIndex: -1, size: this.size, width: "parent" }, h("slot", null))), h("div", { slot: "overlay", class: "below-container" }, h("slot", { name: "below" })))));
  }
  static get is() { return "dx-list-flyout"; }
  static get encapsulation() { return "shadow"; }
  static get originalStyleUrls() {
    return {
      "$": ["dx-list-flyout.scss"]
    };
  }
  static get styleUrls() {
    return {
      "$": ["dx-list-flyout.css"]
    };
  }
  static get properties() {
    return {
      "open": {
        "type": "boolean",
        "mutable": false,
        "complexType": {
          "original": "boolean",
          "resolved": "boolean",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [],
          "text": ""
        },
        "attribute": "open",
        "reflect": false,
        "defaultValue": "false"
      },
      "position": {
        "type": "string",
        "mutable": false,
        "complexType": {
          "original": "VerticalDirection",
          "resolved": "\"bottom\" | \"top\"",
          "references": {
            "VerticalDirection": {
              "location": "import",
              "path": "../../../../classes/common-types"
            }
          }
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [],
          "text": ""
        },
        "attribute": "position",
        "reflect": false,
        "defaultValue": "\"bottom\""
      },
      "direction": {
        "type": "string",
        "mutable": false,
        "complexType": {
          "original": "HorizontalDirection",
          "resolved": "\"left\" | \"right\"",
          "references": {
            "HorizontalDirection": {
              "location": "import",
              "path": "../../../../classes/common-types"
            }
          }
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [],
          "text": ""
        },
        "attribute": "direction",
        "reflect": false,
        "defaultValue": "\"right\""
      },
      "preventSpaceSelection": {
        "type": "boolean",
        "mutable": false,
        "complexType": {
          "original": "boolean",
          "resolved": "boolean",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [],
          "text": ""
        },
        "attribute": "prevent-space-selection",
        "reflect": false,
        "defaultValue": "false"
      },
      "preventArrowSelection": {
        "type": "boolean",
        "mutable": false,
        "complexType": {
          "original": "boolean",
          "resolved": "boolean",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [],
          "text": ""
        },
        "attribute": "prevent-arrow-selection",
        "reflect": false,
        "defaultValue": "false"
      },
      "size": {
        "type": "string",
        "mutable": false,
        "complexType": {
          "original": "\"m\" | \"l\"",
          "resolved": "\"l\" | \"m\"",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [],
          "text": ""
        },
        "attribute": "size",
        "reflect": false,
        "defaultValue": "\"m\""
      },
      "itemsvisible": {
        "type": "number",
        "mutable": false,
        "complexType": {
          "original": "number",
          "resolved": "number",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [],
          "text": ""
        },
        "attribute": "itemsvisible",
        "reflect": false
      },
      "selectionmode": {
        "type": "string",
        "mutable": false,
        "complexType": {
          "original": "ListFlyoutSelectionMode",
          "resolved": "\"multi\" | \"single\"",
          "references": {
            "ListFlyoutSelectionMode": {
              "location": "local"
            }
          }
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [],
          "text": ""
        },
        "attribute": "selectionmode",
        "reflect": false,
        "defaultValue": "\"single\""
      },
      "stopclickpropagationonpopup": {
        "type": "boolean",
        "mutable": false,
        "complexType": {
          "original": "boolean",
          "resolved": "boolean",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [],
          "text": ""
        },
        "attribute": "stopclickpropagationonpopup",
        "reflect": false,
        "defaultValue": "false"
      },
      "defaulthighlightfirst": {
        "type": "boolean",
        "mutable": false,
        "complexType": {
          "original": "boolean",
          "resolved": "boolean",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [],
          "text": ""
        },
        "attribute": "defaulthighlightfirst",
        "reflect": false,
        "defaultValue": "false"
      },
      "focusable": {
        "type": "boolean",
        "mutable": false,
        "complexType": {
          "original": "boolean",
          "resolved": "boolean",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [],
          "text": ""
        },
        "attribute": "focusable",
        "reflect": false,
        "defaultValue": "true"
      },
      "clearselectiononclose": {
        "type": "boolean",
        "mutable": false,
        "complexType": {
          "original": "boolean",
          "resolved": "boolean",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [],
          "text": "Automatically clears the current selected item when the list closes."
        },
        "attribute": "clearselectiononclose",
        "reflect": false,
        "defaultValue": "false"
      },
      "selectonhighlight": {
        "type": "boolean",
        "mutable": false,
        "complexType": {
          "original": "boolean",
          "resolved": "boolean",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [],
          "text": "Whether a list item should be selected when focused with the keyboard or not."
        },
        "attribute": "selectonhighlight",
        "reflect": false,
        "defaultValue": "true"
      },
      "maxselections": {
        "type": "number",
        "mutable": false,
        "complexType": {
          "original": "number",
          "resolved": "number",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "number: A number greater than zero which defines the upper limit of menu items being able to be selected."
            }, {
              "name": "value",
              "text": "undefined: The user is able to select all menu items."
            }],
          "text": "Defines the maximal number of menu items the user is able to select.\nThis property only has an effect if the `selectionmode` is `multi`."
        },
        "attribute": "maxselections",
        "reflect": false
      },
      "maxheight": {
        "type": "number",
        "mutable": false,
        "complexType": {
          "original": "number",
          "resolved": "number",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [],
          "text": ""
        },
        "attribute": "maxheight",
        "reflect": false,
        "defaultValue": "null"
      }
    };
  }
  static get states() {
    return {
      "numberOfListItems": {},
      "internalPosition": {}
    };
  }
  static get events() {
    return [{
        "method": "itemSelectionChange",
        "name": "itemSelectionChange",
        "bubbles": true,
        "cancelable": true,
        "composed": true,
        "docs": {
          "tags": [],
          "text": "Fires when the selection within the list changes.\nIt contains the values of the currently selected items."
        },
        "complexType": {
          "original": "ItemSelectionPayload",
          "resolved": "ItemSelectionPayload",
          "references": {
            "ItemSelectionPayload": {
              "location": "local"
            }
          }
        }
      }, {
        "method": "positionChange",
        "name": "positionChange",
        "bubbles": true,
        "cancelable": true,
        "composed": true,
        "docs": {
          "tags": [],
          "text": "Fires when the position of the flyout changes when specific conditions are met (not enough space in viewport etc.).\nIt contains the new position."
        },
        "complexType": {
          "original": "VerticalDirection",
          "resolved": "\"bottom\" | \"top\"",
          "references": {
            "VerticalDirection": {
              "location": "import",
              "path": "../../../../classes/common-types"
            }
          }
        }
      }];
  }
  static get elementRef() { return "self"; }
  static get watchers() {
    return [{
        "propName": "maxselections",
        "methodName": "onMaxSelectionsChanged"
      }];
  }
  static get listeners() {
    return [{
        "name": "mouseup",
        "method": "onWindowMouseUp",
        "target": "window",
        "capture": true,
        "passive": true
      }, {
        "name": "resize",
        "method": "onWindowResize",
        "target": "window",
        "capture": false,
        "passive": true
      }, {
        "name": "scroll",
        "method": "onWindowScroll",
        "target": "window",
        "capture": false,
        "passive": true
      }, {
        "name": "listItemInteraction",
        "method": "onListItemInteraction",
        "target": undefined,
        "capture": true,
        "passive": false
      }, {
        "name": "growBoxStateChange",
        "method": "onGrowBoxStateChanged",
        "target": undefined,
        "capture": false,
        "passive": false
      }, {
        "name": "keydown",
        "method": "onKeyDown",
        "target": undefined,
        "capture": false,
        "passive": false
      }];
  }
}
const BORDER_PX = 1;
const ITEM_HEIGHT_PX_M = 48;
const ITEM_HEIGHT_PX_L = 64;
