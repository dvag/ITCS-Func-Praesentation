export class GridCssBuilder {
  build(base, grid, currentBreakpoint, numberOfChildNodes, rowGap) {
    const builder = new CssBuilder();
    const columnGap = base.gapSizes[currentBreakpoint];
    const columns = base.columns[currentBreakpoint];
    builder.writeCss(`:host {
        column-gap: ${columnGap}px;
        row-gap: ${rowGap}px;
        grid-template-columns: repeat\(${columns}, 1fr\);
      }
    `);
    let childRuleNumber = 0;
    let rowNumber = 0;
    grid.rows.forEach((row, rowIndex) => {
      var _a;
      if (row.type === "columns") {
        rowNumber++;
        childRuleNumber = this.processRow(row.columns, childRuleNumber, builder, rowNumber);
      }
      if (row.type === "repeat") {
        const columns = (_a = grid.rows[rowIndex - 1]) === null || _a === void 0 ? void 0 : _a.columns;
        while (childRuleNumber < numberOfChildNodes) {
          rowNumber++;
          childRuleNumber = this.processRow(columns, childRuleNumber, builder, rowNumber);
        }
      }
    });
    if (numberOfChildNodes > childRuleNumber) {
      builder.writeError(`There are ${numberOfChildNodes} child elements within the grid, although it is only layed out for ${childRuleNumber} child elements.`);
    }
    return {
      css: builder.css,
      error: builder.error,
    };
  }
  processRow(columns, childRuleNumber, builder, rowNumber) {
    let currentColumn = 1;
    columns.forEach((column) => {
      if (column.type === "slotelement") {
        childRuleNumber++;
        if (column.size > 0) {
          builder.writeCss(`
:host ::slotted(*:nth-child(${childRuleNumber})) {
  grid-column-start: ${currentColumn};
  grid-column-end: span ${column.size};
  grid-row-start: ${rowNumber};
  grid-row-end: span 1;
}`);
        }
        else {
          builder.writeCss(`
:host ::slotted(*:nth-child(${childRuleNumber})) {
  display: none !important;
}`);
        }
      }
      currentColumn += column.size;
    });
    return childRuleNumber;
  }
}
class CssBuilder {
  constructor() {
    this.css = "";
    this.error = "";
  }
  writeCss(code) {
    this.css += code;
  }
  writeError(msg) {
    this.error += msg;
  }
}
