import { forceUpdate, h, Host, } from "@stencil/core";
import { SlotObserver } from "../../../classes/slot-observer";
import { getDefinedSlots } from "../../../classes/render-util";
import { BreakpointAware } from "../../../classes/breakpoint-aware";
import { GAP, generatePageIndexTypes, } from "../dx-number-paginator/page-index-type";
import { clamp } from "../../../classes/math-util";
import { CONTENT_SLOT_NAME } from "./wizard.util";
import { assert } from "../../../classes/assert";
import { ElementIdGenerator, verifyElementId, } from "../../../classes/element-id-handling";
import { GridBreakpoint } from "../dx-grid/grid-models";
import { sameArrayInOrder } from "../../../classes/misc-util";
/**
 * A component which enables you to display multiple views one by one. It is commonly used to lead the user through multiple forms.
 *
 * @name Wizard
 * @path /Layout
 * @icon step-forward
 *
 * @slot - `<dx-wizard-step>` elements representing the steps within this component.
 * @slot ${value} - These slots represent the content the wizard should transition to when displaying a specific step. The `value` reflects the `value` property of the corresponding `<dx-wizard-step>`. (e.g. `<dx-wizard-step value="info">` => `<dx-card slot="info">`
 * @slot content - This slot is displayed when there are no ${value} slots defined.
 *
 * @slot-example main
 * @slot-example content-example
 * @slot-example show-content
 */
export class DxWizard {
  constructor() {
    this.stepsAreVisible = true;
    /**
     * Defines from which breakpoint the expanded large screen layout of the component is displayed.
     *
     * @value auto: The expanded layout starts at mq2 for the `horizontal` layout and mq3 for the `vertical` layout.
     * @value mq3: The expanded layout starts at mq3 or bigger.
     * @value mq4: The expanded layout starts at mq4 or bigger.
     *
     * @example expanded-layout-at
     */
    this.expandedlayoutat = "auto";
    /**
     * Defines the orientation of the wizard's expanded view.
     * The default orientation of the mobile view (dependent on `expandedlayoutat` property) is always `horizontal`.
     *
     * @value horizontal: All wizards will be displayed from left to right as long as there are six steps at most. If there are more than six steps the `vertical` view will be displayed instead.
     * @value vertical: All steps are displayed from top to bottom. Only the mobile view displays a horizontal setup.
     *
     * @example orientation
     * @example orientation-invalid
     */
    this.orientation = "horizontal";
  }
  onOrientationChanged() {
    this.updateInternalOrientation();
  }
  onValueChanged(_, oldValue) {
    var _a;
    const wizardStepIndex = this.steps.findIndex((step) => step.value === this.currentstep);
    const wizardStep = this.steps[wizardStepIndex];
    const previousStep = this.steps[wizardStepIndex - 1];
    // Check if the previous step is finished. If wizardStepIndex is zero we want the attribute to be true.
    const previousStepIsFinished = (previousStep !== null && previousStep !== void 0 ? previousStep : { finished: true })
      .finished;
    if (wizardStep != null && previousStepIsFinished) {
      (_a = this.contentSwitcher) === null || _a === void 0 ? void 0 : _a.showValue(this.currentstep, true);
      this.editWizardStep(wizardStep);
      this.currentStepChange.emit(this.currentstep);
    }
    else {
      if (wizardStep) {
        console.warn("You cannot navigate to a step when the previous steps aren't finished yet.", this.self);
      }
      else {
        console.error(`There is no step which defines the value property with the value '${this.currentstep}'\nPossible values are [${this.steps
          .map((step) => `"${step.value}"`)
          .join(", ")}]`, this.self);
      }
      this.currentstep = oldValue;
    }
    this.buildPageIndexTypes();
  }
  connectedCallback() {
    var _a;
    this.initializeBreakpointAware();
    this.initializeSlotObserver();
    verifyElementId(this.self);
    assert(((_a = this.headline) === null || _a === void 0 ? void 0 : _a.length) > 0, () => "It is mandatory to define the headline property. Please set it's value to the current page's headline.", this.self);
  }
  disconnectedCallback() {
    this.slotObserver.disconnect();
    this.breakpointAware.disconnect();
  }
  onWizardStepFinishedChange(e) {
    var _a;
    const oldStepStates = this.steps.map((step) => step.state);
    const wizardStep = e.target;
    const extendedWizardStep = this.getExtendedWizardStep(wizardStep.value);
    if (extendedWizardStep != null) {
      const finished = e.detail;
      if (finished) {
        extendedWizardStep.finished = true;
        extendedWizardStep.state = "finished";
        const index = this.steps.indexOf(extendedWizardStep);
        const nextStep = this.steps[index + 1];
        if (nextStep) {
          nextStep.state = "edit";
          this.currentstep = nextStep.value;
        }
      }
      else if (extendedWizardStep.state === "finished") {
        extendedWizardStep.finished = false;
        extendedWizardStep.state = "visited";
      }
      else if (extendedWizardStep.state === "edit") {
        extendedWizardStep.finished = false;
      }
    }
    this.buildWizardStepStates();
    const newStep = (_a = this.getCurrentEditedStep()) === null || _a === void 0 ? void 0 : _a.value;
    if (newStep !== this.currentstep) {
      this.currentstep = newStep;
    }
    else {
      // We want to forceUpdate if the step states changed.
      // If newStep was already !== this.currentstep the render would trigger anyway and we don't need to compare the arrays.
      const newStepStates = this.steps.map((step) => step.state);
      if (!sameArrayInOrder(oldStepStates, newStepStates)) {
        forceUpdate(this.self);
      }
    }
  }
  initializeBreakpointAware() {
    this.breakpointAware = new BreakpointAware(() => {
      this.updateInternalOrientation();
      if (!this.isMobileView()) {
        this.modal.visible = false;
      }
      forceUpdate(this);
    }, true);
  }
  initializeSlotObserver() {
    let initialized = false;
    this.slotObserver = new SlotObserver(this.self, ":scope > dx-wizard-step", async (steps) => {
      var _a, _b;
      await this.collectWizardSteps(steps);
      this.updateInternalOrientation();
      if (!initialized) {
        this.buildWizardStepStates();
        initialized = true;
        // We don't want to set the property if it is already defined from outside.
        this.currentstep || (this.currentstep = (_a = this.getCurrentEditedStep()) === null || _a === void 0 ? void 0 : _a.value);
      }
      else {
        this.currentstep = (_b = this.getCurrentEditedStep()) === null || _b === void 0 ? void 0 : _b.value;
      }
      this.buildPageIndexTypes();
    });
  }
  getCurrentEditedStep() {
    var _a;
    return (_a = this.steps.find((step) => step.state === "edit")) !== null && _a !== void 0 ? _a : this.steps[0];
  }
  getExpandedViewOrientation() {
    var _a;
    if (this.orientation === "vertical" || ((_a = this.steps) === null || _a === void 0 ? void 0 : _a.length) > 6) {
      return "vertical";
    }
    return "horizontal";
  }
  buildWizardStepStates() {
    let indexOfLastFinished = this.steps.findIndex((step) => !step.finished) - 1;
    const lastIndex = this.steps.length - 1;
    indexOfLastFinished =
      indexOfLastFinished < -1 ? lastIndex : indexOfLastFinished;
    const currentEditedIndex = clamp(this.steps.indexOf(this.getExtendedWizardStep(this.currentstep)), 0, indexOfLastFinished + 1);
    const lastIsFinished = indexOfLastFinished === lastIndex;
    this.steps.forEach((step, index) => {
      const isLastAndFinished = index === lastIndex && lastIsFinished;
      const isCurrentEditedAndFinished = index === currentEditedIndex &&
        step.finished &&
        currentEditedIndex <= indexOfLastFinished;
      if (index === currentEditedIndex &&
        currentEditedIndex <= indexOfLastFinished + 1) {
        step.state = "edit";
      }
      else if (currentEditedIndex === -1 &&
        (index === indexOfLastFinished + 1 || isLastAndFinished)) {
        step.state = "edit";
      }
      else if (index <= indexOfLastFinished) {
        step.state = "finished";
      }
      else if (index - 1 === indexOfLastFinished) {
        step.state = "visited";
      }
      else {
        step.state = "unvisited";
      }
      step.finished =
        step.state === "finished" ||
          isLastAndFinished ||
          isCurrentEditedAndFinished;
      if (step.metaStepComponent.finished !== step.finished) {
        step.metaStepComponent.finished = step.finished;
      }
    });
  }
  buildPageIndexTypes() {
    var _a, _b, _c, _d;
    const currentPage = ((_b = (_a = this.steps) === null || _a === void 0 ? void 0 : _a.indexOf(this.getCurrentEditedStep())) !== null && _b !== void 0 ? _b : 0) + 1;
    this.pageIndexTypes = generatePageIndexTypes(currentPage, (_d = (_c = this.steps) === null || _c === void 0 ? void 0 : _c.length) !== null && _d !== void 0 ? _d : 0, MAX_VISIBLE_STEPS);
  }
  setInternalOrientation(orientation) {
    if (this.internalOrientation === orientation) {
      return;
    }
    this.internalOrientation = orientation;
    this.buildPageIndexTypes();
  }
  getExtendedWizardStep(value) {
    var _a;
    return (_a = this.steps) === null || _a === void 0 ? void 0 : _a.find((step) => step.value === value);
  }
  onWizardStepInteraction(e) {
    const wizardStep = e.target;
    const extendedWizardStep = this.getExtendedWizardStep(wizardStep.value);
    if (extendedWizardStep != null) {
      this.editWizardStep(extendedWizardStep);
      extendedWizardStep.interact();
      this.modal.visible = false;
    }
  }
  editWizardStep(wizardStep) {
    const currentEditedStep = this.getCurrentEditedStep();
    if (currentEditedStep != null) {
      currentEditedStep.state = currentEditedStep.finished
        ? "finished"
        : "visited";
    }
    this.currentstep = wizardStep.value;
    wizardStep.state = "edit";
  }
  async collectWizardSteps(steps) {
    var _a;
    const collectedSteps = await Promise.all(steps.map((step) => step.toWizardStep()));
    this.steps = collectedSteps.map((collectedStep) => {
      var _a, _b;
      return Object.assign(Object.assign({}, collectedStep), { state: (_b = (_a = this.getExtendedWizardStep(collectedStep.value)) === null || _a === void 0 ? void 0 : _a.state) !== null && _b !== void 0 ? _b : "unvisited" });
    });
    assert(((_a = this.steps) === null || _a === void 0 ? void 0 : _a.length) > 1, () => "A <dx-wizard> component must have at least 2 different steps!", this.self);
  }
  updateInternalOrientation() {
    if (this.getExpandedViewOrientation() === "vertical") {
      this.setInternalOrientation(this.isMobileView() ? "horizontal" : "vertical");
    }
    else {
      this.setInternalOrientation("horizontal");
    }
  }
  isMobileViewForBreakpoint(breakpoint) {
    switch (breakpoint) {
      case GridBreakpoint.MQ1:
        return true;
      case GridBreakpoint.MQ2:
        return (this.getExpandedViewOrientation() === "vertical" ||
          this.expandedlayoutat === "mq3" ||
          this.expandedlayoutat === "mq4");
      case GridBreakpoint.MQ3:
        return this.expandedlayoutat === "mq4";
      default:
        return false;
    }
  }
  isMobileView() {
    return this.breakpointAware.getEffectiveValue({
      mq1: this.isMobileViewForBreakpoint(GridBreakpoint.MQ1),
      mq2: this.isMobileViewForBreakpoint(GridBreakpoint.MQ2),
      mq3: this.isMobileViewForBreakpoint(GridBreakpoint.MQ3),
      mq4: this.isMobileViewForBreakpoint(GridBreakpoint.MQ4),
      mq5: this.isMobileViewForBreakpoint(GridBreakpoint.MQ5)
    });
  }
  renderStepDisplayText() {
    var _a, _b;
    const currentStep = this.steps.findIndex((step) => step.value === this.currentstep) + 1;
    const maxSteps = (_b = (_a = this.steps) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0;
    return (h("dx-text", { type: "its", color: "headline" }, "Schritt ", currentStep, " von ", maxSteps));
  }
  renderCurrentStepLabel() {
    var _a;
    return (h("dx-text", { class: "current-step-label", color: "headline", type: "ps-bold" }, (_a = this.getCurrentEditedStep()) === null || _a === void 0 ? void 0 : _a.label));
  }
  renderGap(isVisible, leftLineIsBlue, rightLineIsBlue) {
    return (h("div", { class: { "gap-container": true, visible: isVisible } }, h("div", { class: "gap" }, h("div", { class: {
        "horizontal-line": true,
        left: true,
        blue: leftLineIsBlue,
      } }), h("div", { class: { circle: true, blue: leftLineIsBlue || rightLineIsBlue } }), h("div", { class: {
        circle: true,
        center: true,
        blue: leftLineIsBlue || rightLineIsBlue,
      } }), h("div", { class: { circle: true, blue: leftLineIsBlue || rightLineIsBlue } }), h("div", { class: {
        "horizontal-line": true,
        right: true,
        blue: rightLineIsBlue,
      } }))));
  }
  renderFirstGap(isVisible) {
    // Normally the first gap has always left and right blue lines because it wouldn't be visible otherwise
    const isFirstStepFinished = this.steps[0].finished;
    return this.renderGap(isVisible, isFirstStepFinished, isFirstStepFinished);
  }
  renderLastGap(isVisible) {
    const isPreviousStepFinished = isVisible &&
      this.steps[this.pageIndexTypes[this.pageIndexTypes.length - 3] - 1].finished;
    const isPenultimateFinished = isVisible && this.steps[this.steps.length - 2].finished;
    return this.renderGap(isVisible, isPreviousStepFinished, isPenultimateFinished);
  }
  getLastVisitedStepIndex() {
    for (let i = this.steps.length - 1; i >= 0; --i) {
      const step = this.steps[i];
      if (["visited", "edit", "finished"].includes(step.state)) {
        return i;
      }
    }
    return -1;
  }
  renderWizardStep(wizardStepRenderPayload) {
    const { extendedWizardStep, orientation, index, indexOfLastVisitedStep, visible, useExtendedView, } = wizardStepRenderPayload;
    return (h("dx-internal-wizard-step", { id: ElementIdGenerator.createId(extendedWizardStep.metaStepComponent, "internal"), class: "wizard-step", state: extendedWizardStep.state, finished: extendedWizardStep.finished, label: extendedWizardStep.label, value: extendedWizardStep.value, orientation: orientation, neighborIsInteractive: index < indexOfLastVisitedStep, isFirstStep: index === 0, isLastStep: index === this.steps.length - 1, onInteraction: (e) => this.onWizardStepInteraction(e), key: index, hidden: !visible, isExtendedView: useExtendedView }));
  }
  renderWizardSteps(wizardStepsConfig) {
    var _a, _b, _c, _d, _e;
    const orientation = (_a = wizardStepsConfig === null || wizardStepsConfig === void 0 ? void 0 : wizardStepsConfig.overrideOrientation) !== null && _a !== void 0 ? _a : this.internalOrientation;
    const indexOfLastVisitedStep = this.getLastVisitedStepIndex();
    const isHorizontalOrientation = orientation === "horizontal";
    const hasFirstGap = isHorizontalOrientation && ((_b = this.pageIndexTypes) === null || _b === void 0 ? void 0 : _b[1]) === GAP;
    const hasLastGap = isHorizontalOrientation &&
      ((_c = this.pageIndexTypes) === null || _c === void 0 ? void 0 : _c[((_d = this.pageIndexTypes) === null || _d === void 0 ? void 0 : _d.length) - 2]) === GAP;
    const isExtendedView = (_e = wizardStepsConfig === null || wizardStepsConfig === void 0 ? void 0 : wizardStepsConfig.overrideUseExtendedView) !== null && _e !== void 0 ? _e : !this.isMobileView();
    return [
      this.renderWizardStep({
        extendedWizardStep: this.steps[0],
        orientation: orientation,
        index: 0,
        indexOfLastVisitedStep,
        visible: true,
        useExtendedView: isExtendedView,
      }),
      this.renderFirstGap(hasFirstGap),
      this.steps.map((step, index) => {
        if (index === 0 || index === this.steps.length - 1) {
          return null;
        }
        return this.renderWizardStep({
          extendedWizardStep: step,
          orientation: orientation,
          index,
          indexOfLastVisitedStep,
          visible: !isHorizontalOrientation || this.pageIndexTypes.includes(index + 1),
          useExtendedView: isExtendedView,
        });
      }),
      this.renderLastGap(hasLastGap),
      this.renderWizardStep({
        extendedWizardStep: this.steps[this.steps.length - 1],
        orientation: orientation,
        index: this.steps.length - 1,
        indexOfLastVisitedStep,
        visible: true,
        useExtendedView: isExtendedView,
      }),
    ];
  }
  getConnectedContentSlots() {
    const slots = getDefinedSlots(this.self).filter((slot) => !["", CONTENT_SLOT_NAME].includes(slot));
    // Get all slots which have a corresponding step and find their index.
    const slotToStepIndices = slots
      .map((slot) => {
      return {
        slot,
        stepIndex: this.steps.findIndex((step) => step.value === slot),
      };
    })
      .filter((slotToStepIndex) => slotToStepIndex.stepIndex !== -1);
    // Sort the slots by the step order and map them back to their slot name.
    return slotToStepIndices
      .sort((first, second) => first.stepIndex - second.stepIndex)
      .map((slotToStepIndex) => slotToStepIndex.slot);
  }
  renderContextContainer() {
    if (!this.isMobileView()) {
      return h("div", null);
    }
    return (h("button", { id: ElementIdGenerator.createId(this.self, "context-control"), class: "context-container", onClick: () => {
        this.modal.visible = true;
      } }, h("div", { class: "current-step-container" }, h("div", { class: "steps-counter" }, this.renderStepDisplayText()), h("div", null, this.renderCurrentStepLabel())), h("dx-button", { type: "text", icon: "ueberlauf-menue", id: ElementIdGenerator.createId(this.self, "context-button") })));
  }
  renderContent() {
    const connectedSlots = this.getConnectedContentSlots();
    if (connectedSlots.length === 0) {
      // Just display the content slot and let the user handle the view.
      return (h("div", { class: "content-slot" }, h("slot", { name: CONTENT_SLOT_NAME })));
    }
    return (h("dx-content-switcher", { key: "content-switcher", value: this.currentstep, ref: (contentSwitcher) => {
        var _a;
        if (this.contentSwitcher !== contentSwitcher) {
          this.contentSwitcher = contentSwitcher;
          if (this.currentstep != null) {
            (_a = this.contentSwitcher) === null || _a === void 0 ? void 0 : _a.showValue(this.currentstep, false);
          }
        }
      } }, connectedSlots.map((slot) => (h("dx-content-switcher-item", { value: slot }, h("slot", { name: slot }))))));
  }
  renderView() {
    const content = [
      h("div", { class: {
          "wizard-steps-container": true,
        } }, h("div", { class: { "wizard-steps": true, visible: this.stepsAreVisible } }, this.renderWizardSteps()), this.renderContextContainer()),
      this.renderContent(),
    ];
    const useVerticalGridParameters = this.getExpandedViewOrientation() === "vertical";
    // Returns the columns dependent on whether to use a vertical, horizontal or mobile view
    const getGridParams = (columns, useMobileView) => {
      if (useMobileView) {
        return undefined;
      }
      return useVerticalGridParameters ? `${columns}-${12 - columns}` : "12/*";
    };
    return (h("dx-grid", { key: "grid", rowgap: "32", mq1: "12/*", mq2: getGridParams(4, this.isMobileViewForBreakpoint(GridBreakpoint.MQ2)), mq3: getGridParams(4, this.isMobileViewForBreakpoint(GridBreakpoint.MQ3)), mq4: getGridParams(3, this.isMobileViewForBreakpoint(GridBreakpoint.MQ4)), mq5: getGridParams(3, this.isMobileViewForBreakpoint(GridBreakpoint.MQ5)) }, content));
  }
  render() {
    var _a, _b;
    if (this.steps == null) {
      return;
    }
    const orientationIsHorizontal = this.internalOrientation === "horizontal";
    return (h(Host, { style: {
        "--dx-wizard-step-count": Math.min((_b = (_a = this.steps) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0, MAX_VISIBLE_STEPS).toString(),
      }, class: {
        "expanded-layout-at-mq2": !this.isMobileViewForBreakpoint(GridBreakpoint.MQ2),
        "expanded-layout-at-mq3": !this.isMobileViewForBreakpoint(GridBreakpoint.MQ3),
        "expanded-layout-at-mq4": !this.isMobileViewForBreakpoint(GridBreakpoint.MQ4),
        "orientation-horizontal": orientationIsHorizontal,
        "orientation-vertical": !orientationIsHorizontal,
      } }, this.renderView(), h("dx-modal", { id: ElementIdGenerator.createId(this.self, "steps-modal"), width: "internal-site-navigation-menu", height: "internal-site-navigation-menu", label: this.headline, class: "modal", ref: (modal) => (this.modal = modal) }, h("div", { slot: "content" }, this.renderWizardSteps({
      overrideOrientation: "vertical",
      overrideUseExtendedView: true,
    })))));
  }
  static get is() { return "dx-wizard"; }
  static get encapsulation() { return "shadow"; }
  static get originalStyleUrls() {
    return {
      "$": ["dx-wizard.scss"]
    };
  }
  static get styleUrls() {
    return {
      "$": ["dx-wizard.css"]
    };
  }
  static get properties() {
    return {
      "headline": {
        "type": "string",
        "mutable": false,
        "complexType": {
          "original": "string",
          "resolved": "string",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "string: The headline of the current site."
            }, {
              "name": "example",
              "text": "headline"
            }, {
              "name": "important",
              "text": undefined
            }],
          "text": "This text will be displayed within the mobile-view's modal and should reflect the headline of the current page the user is in."
        },
        "attribute": "headline",
        "reflect": false
      },
      "expandedlayoutat": {
        "type": "string",
        "mutable": false,
        "complexType": {
          "original": "\"auto\" | \"mq3\" | \"mq4\"",
          "resolved": "\"auto\" | \"mq3\" | \"mq4\"",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "auto: The expanded layout starts at mq2 for the `horizontal` layout and mq3 for the `vertical` layout."
            }, {
              "name": "value",
              "text": "mq3: The expanded layout starts at mq3 or bigger."
            }, {
              "name": "value",
              "text": "mq4: The expanded layout starts at mq4 or bigger."
            }, {
              "name": "example",
              "text": "expanded-layout-at"
            }],
          "text": "Defines from which breakpoint the expanded large screen layout of the component is displayed."
        },
        "attribute": "expandedlayoutat",
        "reflect": false,
        "defaultValue": "\"auto\""
      },
      "orientation": {
        "type": "string",
        "mutable": false,
        "complexType": {
          "original": "Orientation",
          "resolved": "\"horizontal\" | \"vertical\"",
          "references": {
            "Orientation": {
              "location": "import",
              "path": "../../../classes/common-types"
            }
          }
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "horizontal: All wizards will be displayed from left to right as long as there are six steps at most. If there are more than six steps the `vertical` view will be displayed instead."
            }, {
              "name": "value",
              "text": "vertical: All steps are displayed from top to bottom. Only the mobile view displays a horizontal setup."
            }, {
              "name": "example",
              "text": "orientation"
            }, {
              "name": "example",
              "text": "orientation-invalid"
            }],
          "text": "Defines the orientation of the wizard's expanded view.\nThe default orientation of the mobile view (dependent on `expandedlayoutat` property) is always `horizontal`."
        },
        "attribute": "orientation",
        "reflect": false,
        "defaultValue": "\"horizontal\""
      },
      "currentstep": {
        "type": "string",
        "mutable": true,
        "complexType": {
          "original": "string",
          "resolved": "string",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "string: The `value` value of an inner `<dx-wizard-step>` element."
            }, {
              "name": "example",
              "text": "current-step"
            }],
          "text": "The current visible step."
        },
        "attribute": "currentstep",
        "reflect": false
      }
    };
  }
  static get states() {
    return {
      "stepsAreVisible": {},
      "internalOrientation": {}
    };
  }
  static get events() {
    return [{
        "method": "currentStepChange",
        "name": "currentStepChange",
        "bubbles": true,
        "cancelable": true,
        "composed": true,
        "docs": {
          "tags": [{
              "name": "example",
              "text": "current-step"
            }],
          "text": "Fires when the `currentstep` property value changes."
        },
        "complexType": {
          "original": "string",
          "resolved": "string",
          "references": {}
        }
      }];
  }
  static get elementRef() { return "self"; }
  static get watchers() {
    return [{
        "propName": "orientation",
        "methodName": "onOrientationChanged"
      }, {
        "propName": "currentstep",
        "methodName": "onValueChanged"
      }];
  }
  static get listeners() {
    return [{
        "name": "finishedChange",
        "method": "onWizardStepFinishedChange",
        "target": undefined,
        "capture": false,
        "passive": false
      }];
  }
}
const MAX_VISIBLE_STEPS = 7;
