import { forceUpdate, h, Host, readTask, writeTask, } from "@stencil/core";
import { isSlotDefined, onNextFrame } from "../../../classes/render-util";
import { findUpperElementByPredicate, getNamedSlottedContent, } from "../../../classes/misc-util";
/**
 * @internal
 *
 * @slot - The base content the popup needs for computing it's width. If no default slot is specified the overlay computes the width dependent on the viewport width.
 */
export class DxOverlay {
  constructor() {
    this.hidePopup = true;
    this.internalAnchorPosition = "left";
    /**
     * Position, where to place the popup
     */
    this.position = "bottom";
    /**
     * The position to anchor ("right" or "left" to the content width) the popup to.
     */
    this.anchorposition = "left";
    /**
     * CSS display mode of the content area.
     */
    this.contentdisplay = "block";
    /**
     * Additional pixels between content and popup when using horizontal placement.
     */
    this.offsetx = 0;
    /**
     * Additional pixels between content and popup when using vertical placement.
     */
    this.offsety = 0;
    /**
     * Pointer events are delegated to the popup element if true.
     */
    this.popupinteractable = true;
    /**
     * Whether the overlay's position and bounding can be changed over time.
     */
    this.fixate = false;
    /**
     * When the overlay is disabled the width and position is not updated anymore.
     */
    this.disabled = false;
  }
  onDisabledChanged() {
    if (!this.disabled) {
      this.initializeResizeObserver();
    }
    else {
      this.resizeObserver.disconnect();
      writeTask(() => {
        this.popupElement.style.setProperty("width", "0");
      });
    }
  }
  onWindowChange() {
    this.updatePosition();
  }
  connectedCallback() {
    this.initializeResizeObserver();
  }
  disconnectedCallback() {
    var _a, _b;
    (_a = this.slotObserver) === null || _a === void 0 ? void 0 : _a.disconnect();
    (_b = this.resizeObserver) === null || _b === void 0 ? void 0 : _b.disconnect();
  }
  componentWillUpdate() {
    return this.updatePosition();
  }
  async updateFixedPosition() {
    return new Promise((resolve) => {
      readTask(() => {
        // TODO: Implement also for right and top alignment.
        var _a;
        const bounding = this.contentElement.getBoundingClientRect();
        const viewportWidth = document.documentElement.offsetWidth;
        const width = (_a = this.fixatewidth) !== null && _a !== void 0 ? _a : bounding.width;
        const maxLeft = viewportWidth - width;
        const minLeft = Math.max(0, Math.min(bounding.left, maxLeft));
        const anchorPosition = minLeft < bounding.left ? "right" : "left";
        if (anchorPosition !== this.internalAnchorPosition) {
          this.internalAnchorPosition = anchorPosition;
          this.fixedAlignmentChange.emit(this.internalAnchorPosition);
        }
        const withPixels = (num) => `${num}px`;
        // Apply position values to popup
        this.applyValues({
          top: withPixels(bounding.bottom),
          left: withPixels(minLeft),
          bottom: undefined,
          width: withPixels(bounding.width),
          height: undefined,
        }).then(resolve);
      });
    });
  }
  initializeResizeObserver() {
    if (!this.contentElement || this.disabled) {
      return;
    }
    if (this.resizeObserver == null) {
      this.resizeObserver = new ResizeObserver(() => {
        this.updatePosition();
      });
    }
    this.resizeObserver.observe(this.contentElement);
  }
  async updatePosition() {
    if (this.disabled) {
      return;
    }
    return this.internalUpdatePosition();
  }
  internalUpdatePosition() {
    return new Promise((resolve) => {
      if (!this.contentElement ||
        !this.popupElement ||
        !isSlotDefined(this.self, "overlay")) {
        resolve();
        return;
      }
      if (this.fixate) {
        return this.updateFixedPosition().then(resolve);
      }
      readTask(() => {
        // Find element that defines the point of origin for our "position: absolute"
        const offsetParent = closestAnchor(this.contentElement);
        if (offsetParent == null) {
          // When the offsetParent is null this component is currently not visible (display: none)
          resolve();
          return;
        }
        const anchor = offsetParent === document.body
          ? document.documentElement
          : offsetParent; // If anchor is document.body it needs special treatment
        // Get bounding boxes of relevant elements
        const anchorBox = anchor.getBoundingClientRect();
        const popupBox = this.popupElement.getBoundingClientRect();
        const contentBox = this.contentElement.getBoundingClientRect();
        const position = this.position;
        const positionValues = this.computePosition(
        // Determine the final position
        position, contentBox, popupBox, anchorBox, anchor);
        // Apply position values to popup
        this.applyValues(positionValues).then(resolve);
      });
    });
  }
  computeWidth(position, anchorBox, contentBox) {
    const isContentDefined = getNamedSlottedContent(this.self);
    if ((isContentDefined === null || isContentDefined === void 0 ? void 0 : isContentDefined.length) > 0) {
      return contentBox.width;
    }
    if (position === "top" || position === "bottom") {
      const anchorPosition = this.anchorposition;
      if (anchorPosition === "left") {
        return (anchorBox.width - (contentBox.left - anchorBox.left) - OFFSET_BORDER_X);
      }
      else if (anchorPosition === "right") {
        return contentBox.right - anchorBox.left - OFFSET_BORDER_X;
      }
    }
  }
  computePosition(position, contentBox, popupBox, anchorBox, anchor) {
    if (position === "top" || position === "bottom") {
      const left = contentBox.left -
        anchorBox.left +
        anchor.scrollLeft +
        (this.anchorposition === "left"
          ? 0
          : contentBox.width - popupBox.width);
      const width = this.computeWidth(position, anchorBox, contentBox);
      let top;
      let bottom;
      if (position === "top") {
        const relativeValue = anchor === document.documentElement
          ? anchor.clientHeight
          : anchorBox.bottom;
        bottom =
          relativeValue - contentBox.top - anchor.scrollTop + this.offsety;
      }
      else {
        const relativeValue = anchor === document.documentElement ? 0 : anchorBox.top;
        top =
          contentBox.bottom - relativeValue + anchor.scrollTop + this.offsety;
      }
      return {
        left: `${left}px`,
        top: top != null ? `${top}px` : null,
        bottom: bottom != null ? `${bottom}px` : null,
        width: `${width}px`,
        height: `auto`,
      };
    }
    if (position === "left" || position === "right") {
      const top = contentBox.top - anchorBox.top + anchor.scrollTop;
      const height = contentBox.height;
      let left;
      if (position === "left") {
        left =
          contentBox.left -
            anchorBox.left +
            anchor.scrollLeft -
            popupBox.width -
            this.offsetx;
      }
      else {
        left =
          contentBox.right -
            anchorBox.left +
            anchor.scrollLeft +
            this.offsetx +
            anchorBox.width;
      }
      return {
        top: `${top}px`,
        bottom: null,
        left: `${left}px`,
        width: `auto`,
        height: `${height}px`,
      };
    }
  }
  applyValues(values) {
    return new Promise((resolve) => {
      writeTask(() => {
        var _a, _b, _c, _d, _e;
        if (this.hidePopup) {
          onNextFrame(() => {
            this.hidePopup = false;
            forceUpdate(this);
          });
        }
        this.popupElement.style.setProperty("top", (_a = values.top) !== null && _a !== void 0 ? _a : null);
        this.popupElement.style.setProperty("left", (_b = values.left) !== null && _b !== void 0 ? _b : null);
        this.popupElement.style.setProperty("bottom", (_c = values.bottom) !== null && _c !== void 0 ? _c : null);
        this.popupElement.style.setProperty("width", (_d = (this.disabled ? "0" : values.width)) !== null && _d !== void 0 ? _d : null);
        this.popupElement.style.setProperty("height", (_e = values.height) !== null && _e !== void 0 ? _e : null);
        resolve();
      });
    });
  }
  obtainContentRef(element) {
    this.contentElement = element;
    if (!this.resizeObserver && this.disabled) {
      this.internalUpdatePosition();
    }
    this.initializeResizeObserver();
  }
  obtainPopupRef(element) {
    this.popupElement = element;
    this.updatePosition();
  }
  render() {
    const isHidden = this.hidePopup || !isSlotDefined(this.self, "overlay");
    return (h(Host, null, h("div", { style: {
        display: this.contentdisplay,
      }, ref: (el) => this.obtainContentRef(el) }, h("slot", null)), h("div", { class: {
        popup: true,
        disabled: this.disabled,
        fixate: this.fixate,
        "is-hidden": isHidden,
        "not-interactive": !this.popupinteractable,
      }, ref: (el) => this.obtainPopupRef(el) }, h("slot", { name: "overlay" }))));
  }
  static get is() { return "dx-overlay"; }
  static get encapsulation() { return "shadow"; }
  static get originalStyleUrls() {
    return {
      "$": ["dx-overlay.scss"]
    };
  }
  static get styleUrls() {
    return {
      "$": ["dx-overlay.css"]
    };
  }
  static get properties() {
    return {
      "position": {
        "type": "string",
        "mutable": false,
        "complexType": {
          "original": "PopupPosition",
          "resolved": "\"bottom\" | \"left\" | \"right\" | \"top\"",
          "references": {
            "PopupPosition": {
              "location": "local"
            }
          }
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [],
          "text": "Position, where to place the popup"
        },
        "attribute": "position",
        "reflect": false,
        "defaultValue": "\"bottom\""
      },
      "anchorposition": {
        "type": "string",
        "mutable": false,
        "complexType": {
          "original": "HorizontalDirection",
          "resolved": "\"left\" | \"right\"",
          "references": {
            "HorizontalDirection": {
              "location": "import",
              "path": "../../../classes/common-types"
            }
          }
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [],
          "text": "The position to anchor (\"right\" or \"left\" to the content width) the popup to."
        },
        "attribute": "anchorposition",
        "reflect": false,
        "defaultValue": "\"left\""
      },
      "contentdisplay": {
        "type": "string",
        "mutable": false,
        "complexType": {
          "original": "\"block\" | \"inline-block\"",
          "resolved": "\"block\" | \"inline-block\"",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [],
          "text": "CSS display mode of the content area."
        },
        "attribute": "contentdisplay",
        "reflect": false,
        "defaultValue": "\"block\""
      },
      "offsetx": {
        "type": "number",
        "mutable": false,
        "complexType": {
          "original": "number",
          "resolved": "number",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [],
          "text": "Additional pixels between content and popup when using horizontal placement."
        },
        "attribute": "offsetx",
        "reflect": false,
        "defaultValue": "0"
      },
      "offsety": {
        "type": "number",
        "mutable": false,
        "complexType": {
          "original": "number",
          "resolved": "number",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [],
          "text": "Additional pixels between content and popup when using vertical placement."
        },
        "attribute": "offsety",
        "reflect": false,
        "defaultValue": "0"
      },
      "popupinteractable": {
        "type": "boolean",
        "mutable": false,
        "complexType": {
          "original": "boolean",
          "resolved": "boolean",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [],
          "text": "Pointer events are delegated to the popup element if true."
        },
        "attribute": "popupinteractable",
        "reflect": false,
        "defaultValue": "true"
      },
      "fixate": {
        "type": "boolean",
        "mutable": false,
        "complexType": {
          "original": "boolean",
          "resolved": "boolean",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [],
          "text": "Whether the overlay's position and bounding can be changed over time."
        },
        "attribute": "fixate",
        "reflect": false,
        "defaultValue": "false"
      },
      "disabled": {
        "type": "boolean",
        "mutable": false,
        "complexType": {
          "original": "boolean",
          "resolved": "boolean",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [],
          "text": "When the overlay is disabled the width and position is not updated anymore."
        },
        "attribute": "disabled",
        "reflect": false,
        "defaultValue": "false"
      },
      "fixatewidth": {
        "type": "number",
        "mutable": false,
        "complexType": {
          "original": "number",
          "resolved": "number",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [],
          "text": "The width of the popup. This simplifies the compution of the popup position.\nIf not fixatewidth is defined the width of the parent bounding box is used instead."
        },
        "attribute": "fixatewidth",
        "reflect": false
      }
    };
  }
  static get states() {
    return {
      "popupContentAvailable": {}
    };
  }
  static get events() {
    return [{
        "method": "fixedAlignmentChange",
        "name": "fixedAlignmentChange",
        "bubbles": true,
        "cancelable": true,
        "composed": true,
        "docs": {
          "tags": [],
          "text": ""
        },
        "complexType": {
          "original": "\"left\" | \"right\"",
          "resolved": "\"left\" | \"right\"",
          "references": {}
        }
      }];
  }
  static get elementRef() { return "self"; }
  static get watchers() {
    return [{
        "propName": "disabled",
        "methodName": "onDisabledChanged"
      }];
  }
  static get listeners() {
    return [{
        "name": "resize",
        "method": "onWindowChange",
        "target": "window",
        "capture": false,
        "passive": true
      }];
  }
}
function closestAnchor(element) {
  return (findUpperElementByPredicate(element, (elem) => {
    if (!(elem instanceof HTMLElement || elem instanceof SVGElement)) {
      return false;
    }
    const computedStyle = getComputedStyle(elem, null);
    const positionValue = computedStyle.getPropertyValue("position");
    const transformValue = computedStyle.getPropertyValue("transform");
    /**
     * positionValue !== "static": When the CSS-position of the element is not "static" it defines a relative positioning for it's children.
     * transformValue !== "none": When the CSS-transform of the element is defined (e.g. translateX(0px)) it also defines a relative positioning for it's children.
     *
     * So both conditions are independently valid for an element to be an anchor.
     */
    return positionValue !== "static" || transformValue !== "none";
  }) || document.body);
}
const OFFSET_BORDER_X = 24;
