import { h, Host, readTask, writeTask, } from "@stencil/core";
import { onNextFrame } from "../../../classes/render-util";
/**
 * @internal
 */
export class DxPopup {
  constructor() {
    this.iconWidth = 34;
    this.internalArrowPosition = "left";
    this.internalDirection = "left";
    /**
     * Show info or error popup
     */
    this.type = "info";
    /**
     * Is popup displayed?
     */
    this.show = false;
    /**
     * Uses old theme from <ds-popup>
     */
    this.dstheme = false;
    /**
     * Specifies the position of the arrow.
     */
    this.arrowposition = "left";
    /**
     * Specifies the width behavior of the popup bubble.
     * @value parent: width will increases until it matches the parent size
     * @value unconstrained: width will increase unconstrained
     */
    this.contentwidth = "parent";
  }
  onDirectionChange() {
    this.internalDirection = this.arrowposition;
    this.internalArrowPosition = this.arrowposition;
  }
  onResize() {
    this.updatePopupDirection();
  }
  componentWillLoad() {
    this.internalDirection = this.arrowposition;
    this.internalArrowPosition = this.arrowposition;
  }
  componentDidRender() {
    this.updatePopupDirection();
  }
  updatePopupDirection() {
    writeTask(() => {
      if (this.base) {
        this.base.classList.add("invisible");
        if (this.contentwidth === "unconstrained") {
          this.bubble.style.maxWidth = "inherit";
        }
        else if (this.contentwidth === "parent") {
          this.bubble.style.maxWidth = "100%";
        }
        onNextFrame(() => {
          var _a, _b, _c;
          if (this.arrowposition === "left" &&
            this.contentwidth === "unconstrained") {
            const popUpOffsetLeft = (_a = getComputedStyle(this.self).getPropertyValue("--dx-popup-offset-left")) !== null && _a !== void 0 ? _a : null;
            readTask(() => {
              const space = this.availableSpace();
              writeTask(() => {
                var _a, _b, _c, _d, _e, _f, _g, _h;
                if (space.right > 100) {
                  this.internalDirection = "left";
                  (_b = (_a = this.bubble) === null || _a === void 0 ? void 0 : _a.style) === null || _b === void 0 ? void 0 : _b.setProperty("max-width", `${space.right}px`);
                  (_d = (_c = this.base) === null || _c === void 0 ? void 0 : _c.style) === null || _d === void 0 ? void 0 : _d.setProperty("left", popUpOffsetLeft);
                }
                else {
                  this.internalDirection = "right";
                  (_f = (_e = this.bubble) === null || _e === void 0 ? void 0 : _e.style) === null || _f === void 0 ? void 0 : _f.setProperty("max-width", `${space.left}px`);
                  (_h = (_g = this.base) === null || _g === void 0 ? void 0 : _g.style) === null || _h === void 0 ? void 0 : _h.setProperty("left", `${this.calculateOffset(popUpOffsetLeft)}px`);
                }
              });
            });
          }
          (_c = (_b = this.base) === null || _b === void 0 ? void 0 : _b.classList) === null || _c === void 0 ? void 0 : _c.remove("invisible");
        });
      }
    });
  }
  availableSpace() {
    const docRect = document.body.getBoundingClientRect();
    const selfRect = this.self.getBoundingClientRect();
    return {
      left: selfRect.x,
      right: docRect.width - selfRect.x,
    };
  }
  calculateOffset(popUpOffsetLeft) {
    const popupOffsetLeft = isNaN(parseInt(popUpOffsetLeft))
      ? 0
      : parseInt(popUpOffsetLeft);
    const offset = -this.base.offsetWidth + this.iconWidth + popupOffsetLeft;
    return offset;
  }
  renderPopup() {
    if (this.show) {
      return (h("dx-overlay", { position: "bottom", fixate: true, fixatewidth: this.type === "error" ? undefined : 344, onFixedAlignmentChange: (e) => {
          this.internalArrowPosition = e.detail;
        } }, 
      // We insert a div which orients on the parent width because the overlay needs a content to compute the correct width
      h("div", null), h("div", { slot: "overlay", class: "base invisible", ref: (el) => (this.base = el) }, h("div", { class: {
          popup: true,
          right: this.internalArrowPosition === "right" ||
            this.internalDirection === "right",
        } }, h("div", { class: "arrow-up" }), h("div", { class: "bubble", ref: (r) => (this.bubble = r) }, h("div", { class: {
          content: true,
          right: this.internalArrowPosition === "right" ||
            this.internalDirection === "right",
        } }, h("slot", null)))))));
    }
  }
  render() {
    return (h(Host, { class: {
        error: this.type === "error",
        "ds-theme": this.dstheme,
      } }, this.renderPopup()));
  }
  static get is() { return "dx-popup"; }
  static get encapsulation() { return "shadow"; }
  static get originalStyleUrls() {
    return {
      "$": ["dx-popup.scss"]
    };
  }
  static get styleUrls() {
    return {
      "$": ["dx-popup.css"]
    };
  }
  static get properties() {
    return {
      "type": {
        "type": "string",
        "mutable": false,
        "complexType": {
          "original": "\"info\" | \"error\"",
          "resolved": "\"error\" | \"info\"",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [],
          "text": "Show info or error popup"
        },
        "attribute": "type",
        "reflect": false,
        "defaultValue": "\"info\""
      },
      "show": {
        "type": "boolean",
        "mutable": false,
        "complexType": {
          "original": "boolean",
          "resolved": "boolean",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [],
          "text": "Is popup displayed?"
        },
        "attribute": "show",
        "reflect": false,
        "defaultValue": "false"
      },
      "dstheme": {
        "type": "boolean",
        "mutable": false,
        "complexType": {
          "original": "boolean",
          "resolved": "boolean",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [],
          "text": "Uses old theme from <ds-popup>"
        },
        "attribute": "dstheme",
        "reflect": false,
        "defaultValue": "false"
      },
      "arrowposition": {
        "type": "string",
        "mutable": true,
        "complexType": {
          "original": "HorizontalDirection",
          "resolved": "\"left\" | \"right\"",
          "references": {
            "HorizontalDirection": {
              "location": "import",
              "path": "../../../classes/common-types"
            }
          }
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [],
          "text": "Specifies the position of the arrow."
        },
        "attribute": "arrowposition",
        "reflect": true,
        "defaultValue": "\"left\""
      },
      "contentwidth": {
        "type": "string",
        "mutable": false,
        "complexType": {
          "original": "\"unconstrained\" | \"parent\"",
          "resolved": "\"parent\" | \"unconstrained\"",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "parent: width will increases until it matches the parent size"
            }, {
              "name": "value",
              "text": "unconstrained: width will increase unconstrained"
            }],
          "text": "Specifies the width behavior of the popup bubble."
        },
        "attribute": "contentwidth",
        "reflect": false,
        "defaultValue": "\"parent\""
      }
    };
  }
  static get states() {
    return {
      "internalArrowPosition": {},
      "internalDirection": {}
    };
  }
  static get elementRef() { return "self"; }
  static get watchers() {
    return [{
        "propName": "arrowposition",
        "methodName": "onDirectionChange"
      }];
  }
  static get listeners() {
    return [{
        "name": "resize",
        "method": "onResize",
        "target": "window",
        "capture": false,
        "passive": true
      }];
  }
}
