import { h, Host, } from "@stencil/core";
import { Point, toPoint } from "../../../classes/math-util";
import { findClosestScrollElement, sameArrayInOrder, } from "../../../classes/misc-util";
import { SlotObserver } from "../../../classes/slot-observer";
/**
 * @hidden
 *
 * @slot - `<dx-sort-item>` elements which should be sorted.
 */
export class DxSort {
  constructor() {
    this.automaticScrollIntervalHandler = null;
    this.autoScrollActive = false;
    this.currentDraggingSortItem = null;
    /**
     * Whether the sorting is enabled or not.
     *
     * @example sortable
     */
    this.sortable = true;
    this.dragging = false;
  }
  onSortableChanged() {
    this.sortItems.forEach((item) => {
      item.internaldraggable = this.sortable;
    });
  }
  getNearestItem(mousePosition) {
    return this.sortItems.reduce((closest, current) => {
      const currentBoundingClientRect = current.getBoundingClientRect();
      const offset = mousePosition.y -
        currentBoundingClientRect.top -
        currentBoundingClientRect.height;
      if (offset < 0 && offset > closest.offset) {
        return { offset: offset, element: current };
      }
      else {
        return closest;
      }
    }, { offset: Number.NEGATIVE_INFINITY, element: null }).element;
  }
  stopAutomaticScrolling() {
    clearInterval(this.automaticScrollIntervalHandler);
    //Testwise defer
    setTimeout(() => {
      this.autoScrollActive = false;
    }, 200);
  }
  automaticScroll(direction, lastMousePositionY, yDistance) {
    clearInterval(this.automaticScrollIntervalHandler);
    let scrollSpeed = yDistance * 0.1;
    this.automaticScrollIntervalHandler = setInterval(() => {
      // The amount of speed increase every frame
      const scrollSpeedIncrement = 0.01;
      scrollSpeed = Math.max(1, scrollSpeed + scrollSpeedIncrement);
      if (direction === "down") {
        this.contentDiv.scrollTop = this.contentDiv.scrollTop + scrollSpeed;
      }
      else if (direction === "up") {
        this.contentDiv.scrollTop = this.contentDiv.scrollTop - scrollSpeed;
      }
      this.updateSlotsOrder(new Point(0, lastMousePositionY));
    }, 0);
    this.autoScrollActive = true;
  }
  onMouseWheel(e) {
    if (!this.dragging) {
      return;
    }
    this.contentDiv.scrollTop = this.contentDiv.scrollTop + e.deltaY;
    this.updateSlotsOrder(toPoint(e));
  }
  onDraggingStart(e) {
    this.dragging = true;
    this.currentDraggingSortItem = e.target;
  }
  onDragging(e) {
    this.dragging = true;
    if (!this.autoScrollActive) {
      this.updateSlotsOrder(e.detail);
    }
    this.updateAutomaticScrolling(e);
  }
  onDraggingEnd() {
    this.dragging = false;
    this.stopAutomaticScrolling();
    this.currentDraggingSortItem = null;
    const toValue = (sortItem) => sortItem.value;
    const originalArray = [...this.sortItems];
    const sortedArray = [...this.sortItems].sort((a, b) => parseFloat(a.slot) - parseFloat(b.slot));
    this.sort.emit({
      originalArray: originalArray.map(toValue),
      sortedArray: sortedArray.map(toValue),
    });
  }
  connectedCallback() {
    // Prevent race conditions by waiting 500ms before getting the contentDiv
    setTimeout(() => {
      this.contentDiv = findClosestScrollElement(this.self);
    }, 500);
    this.slotObserver = new SlotObserver(this.self, "dx-sort-item", (nodes) => {
      if (this.dragging || sameArrayInOrder(this.sortItems, nodes)) {
        return;
      }
      nodes.forEach((item, index) => {
        item.slot = index.toString();
        item.internaldraggable = this.sortable;
      });
      this.sortItems = nodes;
    });
  }
  disconnectedCallback() {
    var _a;
    (_a = this.slotObserver) === null || _a === void 0 ? void 0 : _a.disconnect();
  }
  updateAutomaticScrolling(e) {
    const scrollBoundsOffset = 32;
    const topBorder = this.contentDiv.getBoundingClientRect().y + scrollBoundsOffset;
    const bottomBorder = this.contentDiv.offsetHeight +
      this.contentDiv.getBoundingClientRect().y -
      scrollBoundsOffset;
    const sortItemIntersectsTopBorder = e.detail.y < topBorder;
    const sortItemIntersectsBottomBorder = e.detail.y > bottomBorder;
    if (!(sortItemIntersectsTopBorder || sortItemIntersectsBottomBorder)) {
      // Mouse is not intersecting with either the top or bottom border
      this.stopAutomaticScrolling();
      return;
    }
    const fullyScrolledTop = () => this.contentDiv.scrollTop === 0;
    if (sortItemIntersectsTopBorder && fullyScrolledTop()) {
      this.stopAutomaticScrolling();
      return;
    }
    const fullyScrolledBottom = () => this.contentDiv.scrollHeight - this.contentDiv.scrollTop ===
      this.contentDiv.clientHeight;
    if (sortItemIntersectsBottomBorder && fullyScrolledBottom()) {
      this.stopAutomaticScrolling();
      return;
    }
    if (sortItemIntersectsTopBorder) {
      const yDistance = topBorder - e.detail.y;
      this.automaticScroll("up", e.detail.y, yDistance);
    }
    else {
      const yDistance = e.detail.y - bottomBorder;
      this.automaticScroll("down", e.detail.y, yDistance);
    }
  }
  /**
   * Pushes all sortItems away to reserve space for the current dragging sort item.
   *
   * @param reservedSlotIndex: The new slot for the current dragging sort item.
   */
  pushAwaySortItems(reservedSlotIndex) {
    const currentSortItemSlotIndex = parseFloat(this.currentDraggingSortItem.slot);
    this.sortItems
      .filter((sortItem) => sortItem !== this.currentDraggingSortItem)
      .forEach((sortItem) => {
      const sortItemSlotIndex = parseFloat(sortItem.slot);
      // Moves a sortItem to the top or bottom dependent on it being within the drag path and
      // the current sortItem moves to the top or bottom
      if (sortItemSlotIndex > currentSortItemSlotIndex &&
        sortItemSlotIndex <= reservedSlotIndex) {
        sortItem.slot = (sortItemSlotIndex - 1).toString();
      }
      else if (sortItemSlotIndex < currentSortItemSlotIndex &&
        sortItemSlotIndex >= reservedSlotIndex) {
        sortItem.slot = (sortItemSlotIndex + 1).toString();
      }
    });
    this.currentDraggingSortItem.slot = reservedSlotIndex.toString();
    const map = {};
    this.sortItems.forEach((sortItem) => {
      if (map[sortItem.slot]) {
        console.error(sortItem.slot, "is already filled", map[sortItem.slot]);
      }
      if (!map[sortItem.slot]) {
        map[sortItem.slot] = [];
      }
      map[sortItem.slot].push(sortItem);
    });
  }
  updateSlotsOrder(currentDraggingPosition) {
    const nearestItem = this.getNearestItem(currentDraggingPosition);
    if (nearestItem != null) {
      const newSlot = parseFloat(nearestItem.slot);
      this.pushAwaySortItems(newSlot);
    }
  }
  render() {
    var _a, _b;
    return (h(Host, null, (_b = (_a = this.sortItems) === null || _a === void 0 ? void 0 : _a.map((_, index) => (h("slot", { name: index.toString() })))) !== null && _b !== void 0 ? _b : h("slot", null)));
  }
  static get is() { return "dx-sort"; }
  static get encapsulation() { return "shadow"; }
  static get originalStyleUrls() {
    return {
      "$": ["dx-sort.scss"]
    };
  }
  static get styleUrls() {
    return {
      "$": ["dx-sort.css"]
    };
  }
  static get properties() {
    return {
      "sortable": {
        "type": "boolean",
        "mutable": false,
        "complexType": {
          "original": "boolean",
          "resolved": "boolean",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "example",
              "text": "sortable"
            }],
          "text": "Whether the sorting is enabled or not."
        },
        "attribute": "sortable",
        "reflect": false,
        "defaultValue": "true"
      }
    };
  }
  static get states() {
    return {
      "dragging": {},
      "sortItems": {}
    };
  }
  static get events() {
    return [{
        "method": "sort",
        "name": "sort",
        "bubbles": true,
        "cancelable": true,
        "composed": true,
        "docs": {
          "tags": [{
              "name": "example",
              "text": "sort"
            }],
          "text": "Fires when the children are sorted by the user. By reading the event's detail property you can access the `originalArray` and the `sortedArray`.\nBoth arrays consist of the `value` properties provided by the `<dx-sort-item>` elements."
        },
        "complexType": {
          "original": "SortDetail",
          "resolved": "SortDetail",
          "references": {
            "SortDetail": {
              "location": "local"
            }
          }
        }
      }];
  }
  static get elementRef() { return "self"; }
  static get watchers() {
    return [{
        "propName": "sortable",
        "methodName": "onSortableChanged"
      }];
  }
  static get listeners() {
    return [{
        "name": "wheel",
        "method": "onMouseWheel",
        "target": undefined,
        "capture": false,
        "passive": true
      }, {
        "name": "draggingStart",
        "method": "onDraggingStart",
        "target": undefined,
        "capture": false,
        "passive": false
      }, {
        "name": "dragging",
        "method": "onDragging",
        "target": undefined,
        "capture": false,
        "passive": false
      }, {
        "name": "draggingEnd",
        "method": "onDraggingEnd",
        "target": undefined,
        "capture": false,
        "passive": false
      }];
  }
}
