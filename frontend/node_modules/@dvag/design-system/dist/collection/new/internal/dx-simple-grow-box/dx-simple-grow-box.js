import { h, Host, writeTask, } from "@stencil/core";
import { onNextFrame } from "../../../classes/render-util";
/**
 * @internal
 */
export class DxSimpleGrowBox {
  constructor() {
    this.initialized = false;
    /**
     * Defines whether the content is visible or not.
     *
     * @value true: The content under the header is visible.
     * @value false: The content under the header is not displayed.
     */
    this.open = false;
    /**
     * Reserves space before opening the grow-box.
     * The reserved space equals the final height of the animated content.
     */
    this.reservespaceonopen = false;
    this.animationmode = "top-to-bottom";
    this.slidecontent = true;
    this.height = 0;
    this.isFullyOpened = false;
  }
  onOpenChanged() {
    var _a, _b, _c, _d;
    this.animationContainer.classList.add("animatable");
    if (!this.open) {
      // Remove now because these styles should be set before next render step.
      (_b = (_a = this.animationContainer) === null || _a === void 0 ? void 0 : _a.classList) === null || _b === void 0 ? void 0 : _b.remove("ignore-transform");
      (_d = (_c = this.self) === null || _c === void 0 ? void 0 : _c.style) === null || _d === void 0 ? void 0 : _d.setProperty("height", `${this.height}px`);
      this.isFullyOpened = false;
    }
  }
  componentWillLoad() {
    this.setVisibility(this.open);
  }
  connectedCallback() {
    this.resizeObserver = new ResizeObserver((entries) => {
      const element = entries[0].target;
      // If element is currently not displayed, we don't want to set the height
      if (element.offsetParent == null) {
        return;
      }
      this.height = entries[0].target.offsetHeight;
    });
    this.isFullyOpened = this.open;
  }
  disconnectedCallback() {
    this.resizeObserver.disconnect();
  }
  setVisibility(visible) {
    writeTask(() => {
      this.self.style.setProperty("visibility", visible ? "visible" : "hidden");
    });
  }
  isValidTransitionTarget(target) {
    return target !== this.self && target !== this.animationContainer;
  }
  onTransitionStart(e) {
    if (this.isValidTransitionTarget(e.target) ||
      e.propertyName !== "transform") {
      return;
    }
    else if (this.open && this.isFullyOpened) {
      // This will be called after setting transform to "none" or undefined and would lead to an invalid state.
      // Therefor we return here.
      return;
    }
    this.growBoxStateChange.emit(this.open ? "opening" : "closing");
    this.setVisibility(true);
  }
  onTransitionEnd(e) {
    if (this.isValidTransitionTarget(e.target) ||
      e.propertyName !== "transform") {
      return;
    }
    else if (this.open && this.isFullyOpened) {
      // This will be called after setting transform to "none" or undefined and would lead to an invalid state.
      // Therefor we return here.
      return;
    }
    const state = this.open ? "opened" : "closed";
    this.growBoxStateChange.emit(state);
    this.setVisibility(this.open);
  }
  onStateChanged(e) {
    if (e.target !== this.self) {
      return;
    }
    if (e.detail === "closed") {
      writeTask(() => {
        var _a, _b;
        (_b = (_a = this.animationContainer) === null || _a === void 0 ? void 0 : _a.classList) === null || _b === void 0 ? void 0 : _b.remove("animatable");
      });
    }
    this.isFullyOpened = e.detail === "opened";
  }
  componentDidLoad() {
    this.initialized = true;
  }
  componentWillUpdate() {
    // Render should wait at least one frame before being called because the styles applied in `onOpenChanged`
    // need to be applied in one frame while the new styles in render should be applied in the next frame.
    return new Promise((resolve) => {
      onNextFrame(resolve);
    });
  }
  render() {
    const hostHeight = !this.reservespaceonopen
      ? this.open
        ? this.height
        : 0
      : null;
    return (h(Host, { style: {
        height: hostHeight == null || !this.initialized || this.isFullyOpened
          ? "unset"
          : `${hostHeight}px`,
      }, class: {
        "animate-with-content": !this.reservespaceonopen,
        "slide-content": this.slidecontent,
        "overflow-hidden": !this.isFullyOpened,
      } }, h("div", { class: {
        "animation-container": true,
        "top-to-bottom": this.animationmode === "top-to-bottom",
        "bottom-to-top": this.animationmode === "bottom-to-top",
        "ignore-transform": this.isFullyOpened,
        open: this.open,
      }, ref: (ref) => {
        this.animationContainer = ref;
      } }, h("div", { ref: (ref) => this.resizeObserver.observe(ref) }, h("slot", null)))));
  }
  static get is() { return "dx-simple-grow-box"; }
  static get encapsulation() { return "scoped"; }
  static get originalStyleUrls() {
    return {
      "$": ["dx-simple-grow-box.scss"]
    };
  }
  static get styleUrls() {
    return {
      "$": ["dx-simple-grow-box.css"]
    };
  }
  static get properties() {
    return {
      "open": {
        "type": "boolean",
        "mutable": false,
        "complexType": {
          "original": "boolean",
          "resolved": "boolean",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "true: The content under the header is visible."
            }, {
              "name": "value",
              "text": "false: The content under the header is not displayed."
            }],
          "text": "Defines whether the content is visible or not."
        },
        "attribute": "open",
        "reflect": false,
        "defaultValue": "false"
      },
      "reservespaceonopen": {
        "type": "boolean",
        "mutable": false,
        "complexType": {
          "original": "boolean",
          "resolved": "boolean",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [],
          "text": "Reserves space before opening the grow-box.\nThe reserved space equals the final height of the animated content."
        },
        "attribute": "reservespaceonopen",
        "reflect": false,
        "defaultValue": "false"
      },
      "animationmode": {
        "type": "string",
        "mutable": false,
        "complexType": {
          "original": "\"top-to-bottom\" | \"bottom-to-top\"",
          "resolved": "\"bottom-to-top\" | \"top-to-bottom\"",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [],
          "text": ""
        },
        "attribute": "animationmode",
        "reflect": false,
        "defaultValue": "\"top-to-bottom\""
      },
      "slidecontent": {
        "type": "boolean",
        "mutable": false,
        "complexType": {
          "original": "boolean",
          "resolved": "boolean",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [],
          "text": ""
        },
        "attribute": "slidecontent",
        "reflect": false,
        "defaultValue": "true"
      }
    };
  }
  static get states() {
    return {
      "height": {},
      "isFullyOpened": {}
    };
  }
  static get events() {
    return [{
        "method": "growBoxStateChange",
        "name": "growBoxStateChange",
        "bubbles": true,
        "cancelable": true,
        "composed": true,
        "docs": {
          "tags": [],
          "text": ""
        },
        "complexType": {
          "original": "GrowBoxState",
          "resolved": "\"closed\" | \"closing\" | \"opened\" | \"opening\"",
          "references": {
            "GrowBoxState": {
              "location": "local"
            }
          }
        }
      }];
  }
  static get elementRef() { return "self"; }
  static get watchers() {
    return [{
        "propName": "open",
        "methodName": "onOpenChanged"
      }];
  }
  static get listeners() {
    return [{
        "name": "transitionstart",
        "method": "onTransitionStart",
        "target": undefined,
        "capture": false,
        "passive": false
      }, {
        "name": "transitionend",
        "method": "onTransitionEnd",
        "target": undefined,
        "capture": false,
        "passive": false
      }, {
        "name": "growBoxStateChange",
        "method": "onStateChanged",
        "target": undefined,
        "capture": false,
        "passive": false
      }];
  }
}
