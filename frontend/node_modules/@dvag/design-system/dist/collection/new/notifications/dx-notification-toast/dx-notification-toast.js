import { forceUpdate, h, Host, } from "@stencil/core";
import { BreakpointAware } from "../../../classes/breakpoint-aware";
import { ElementIdGenerator } from "../../../classes/element-id-handling";
import { onNextFrame } from "../../../classes/render-util";
import { SwipeController, } from "../../layout/dx-slide-show/swipe-controller";
import { NotificationService } from "./notification-service";
/**
 * A notification toast to visualize specific events like successes, errors, warnings etc.
 * The notification automatically displays under any other visible notifications.
 *
 * @name Notification Toast
 * @shortname Toast
 * @path /Notifications
 * @icon bell
 * @stable
 *
 * @slot - Content within the notification which is displayed under the title
 */
export class DxNotificationToast {
  constructor() {
    this.swipeController = new SwipeController(() => {
      return 0;
    }, this.onSwipeStart.bind(this), this.onSwipeRecognized.bind(this), this.onSwipeUpdate.bind(this));
    this.show = false;
    this.animating = false;
    this.closingDirection = "top";
    /**
     * Specifies the time in seconds the notification is visible before it's closed automatically.
     * The specified time has to be greater than 0.
     *
     * @value number: A time in seconds.
     *
     * @example close-after
     */
    this.closeafter = 5;
  }
  onVisibleChanged() {
    if (this.visible) {
      this.resetTimerProperties();
      this.currentXOffset = undefined;
      this.flyout.style.removeProperty(ANIMATION_PLAY_STATE_VARIABLE_NAME);
      this.flyout.style.removeProperty(ANIMATION_DELAY_VARIABLE_NAME);
      this.animating = false;
      this.closingDirection = "top";
      NotificationService.instance().addNotificationToast(this.self);
      onNextFrame(() => {
        this.show = this.visible;
      });
    }
  }
  connectedCallback() {
    this.breakpointAware = new BreakpointAware(() => forceUpdate(this), true);
    if (this.visible) {
      NotificationService.instance().addNotificationToast(this.self);
    }
  }
  disconnectedCallback() {
    this.breakpointAware.disconnect();
  }
  componentDidLoad() {
    requestAnimationFrame(() => {
      this.show = this.visible;
    });
  }
  closeImmediately() {
    clearTimeout(this.closeHandle);
    this.closeNotification.emit();
    this.visible = false;
    this.show = false;
  }
  handleAnimationEnd(e) {
    if (e.elapsedTime > 0.001) {
      this.closeImmediately();
    }
    else {
      this.animating = false;
    }
  }
  handleTransitionEnd(e) {
    // handleTransitionEnd is called twice because two different properties transition (opacity and transform)
    if (e.propertyName === "opacity") {
      return;
    }
    if (this.show) {
      if (Number.isInteger(this.closeafter) && this.closeafter > 0) {
        this.restTime = this.closeafter * 1000;
        this.startTimer();
      }
      else {
        this.show = false;
        console.error("The 'closeafter' property has to be an integer > 0", this.self);
      }
    }
    else {
      this.closeImmediately();
    }
  }
  onSwipeStart() {
    this.animating = true;
    this.stopTimer();
  }
  onSwipeUpdate(updateData) {
    this.currentXOffset = updateData.currentX - updateData.startX;
    this.animating = true;
    this.closingDirection =
      updateData.currentX > updateData.startX ? "right" : "left";
    // Set animation dependant on x difference
    const maxMs = 500;
    const percentage = Math.abs(updateData.currentX - updateData.startX) /
      this.flyout.offsetWidth;
    this.flyout.style.setProperty(ANIMATION_DELAY_VARIABLE_NAME, -percentage * maxMs + "ms");
  }
  onSwipeRecognized(swipeDirection) {
    const currentLeftValue = this.currentXOffset;
    this.currentXOffset = undefined;
    const canBeSwipedAway = swipeDirection === "left" ||
      swipeDirection === "right" ||
      Math.abs(currentLeftValue) > window.innerWidth * 0.333;
    if (canBeSwipedAway) {
      this.flyout.style.setProperty(ANIMATION_PLAY_STATE_VARIABLE_NAME, "running");
      this.closingDirection =
        swipeDirection === "left" || currentLeftValue >= 0 ? "right" : "left";
      this.show = false;
      return;
    }
    this.flyout.style.removeProperty(ANIMATION_DELAY_VARIABLE_NAME);
    this.flyout.style.removeProperty(ANIMATION_PLAY_STATE_VARIABLE_NAME);
    this.closingDirection = "top";
    this.startTimer();
  }
  resetTimerProperties() {
    this.start = undefined;
    this.restTime = this.closeafter * 1000;
    clearTimeout(this.closeHandle);
    this.closeHandle = null;
  }
  startTimer() {
    clearTimeout(this.closeHandle);
    this.start = new Date().getTime();
    this.closeHandle = setTimeout(() => {
      this.show = false;
      this.resetTimerProperties();
    }, this.restTime);
  }
  stopTimer() {
    const currentTime = new Date().getTime();
    this.restTime -= currentTime - this.start;
    clearTimeout(this.closeHandle);
    this.closeHandle = null;
  }
  renderTitle() {
    if (this.titlestring == null || this.titlestring.length === 0) {
      return;
    }
    return (h("dx-text", { class: "title", type: "pb", color: "headline" }, this.titlestring));
  }
  renderSubContent() {
    if (!this.subcontent) {
      return;
    }
    return (h("dx-text", { class: "subcontent", type: "its" }, this.subcontent));
  }
  renderIcon() {
    if (!this.icon) {
      return;
    }
    return (h("div", { class: "icon-container" }, h("dx-icon", { size: this.breakpointAware.mq1 ? 48 : 72, icon: this.icon, color: this.iconcolor })));
  }
  renderCloseButton() {
    return (h("div", { class: "close-icon-container" }, h("button", { id: ElementIdGenerator.createId(this.self, "close-button"), onClick: () => (this.show = false), class: "close-button" }, h("dx-icon", { icon: "schliessen", size: 24, color: "default" }))));
  }
  render() {
    return (h(Host, { class: { visible: this.visible }, role: "alert" }, h("div", { class: "oversized-page" }, h("dx-card", { class: {
        flyout: true,
        show: this.show,
        "page-wrapped-content": true,
        "to-the-left": this.animating && this.closingDirection === "left",
        "to-the-right": this.animating && this.closingDirection === "right",
      }, ref: (ref) => (this.flyout = ref), onTouchStart: (e) => this.swipeController.onTouchStart(e), onTransitionEnd: (e) => this.handleTransitionEnd(e), onAnimationEnd: (e) => this.handleAnimationEnd(e) }, h("div", { class: "content-container" }, this.renderIcon(), h("div", { class: "text-container" }, this.renderTitle(), h("slot", null), this.renderSubContent())), this.renderCloseButton()))));
  }
  static get is() { return "dx-notification-toast"; }
  static get encapsulation() { return "shadow"; }
  static get originalStyleUrls() {
    return {
      "$": ["dx-notification-toast.scss"]
    };
  }
  static get styleUrls() {
    return {
      "$": ["dx-notification-toast.css"]
    };
  }
  static get properties() {
    return {
      "titlestring": {
        "type": "string",
        "mutable": false,
        "complexType": {
          "original": "string",
          "resolved": "string",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "string: The title."
            }, {
              "name": "example",
              "text": "default"
            }],
          "text": "The title of the notification."
        },
        "attribute": "titlestring",
        "reflect": false
      },
      "icon": {
        "type": "string",
        "mutable": false,
        "complexType": {
          "original": "string",
          "resolved": "string",
          "references": {}
        },
        "required": false,
        "optional": true,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "string: A valid icon name."
            }, {
              "name": "example",
              "text": "icon"
            }],
          "text": "The icon which is rendered at the left side of the notification."
        },
        "attribute": "icon",
        "reflect": false
      },
      "iconcolor": {
        "type": "string",
        "mutable": false,
        "complexType": {
          "original": "string",
          "resolved": "string",
          "references": {}
        },
        "required": false,
        "optional": true,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "string: A color which has to be defined within the color palette of the design system. (e.g.: dunkelblau-4)"
            }, {
              "name": "example",
              "text": "icon"
            }],
          "text": "The color of the icon."
        },
        "attribute": "iconcolor",
        "reflect": false
      },
      "subcontent": {
        "type": "string",
        "mutable": false,
        "complexType": {
          "original": "string",
          "resolved": "string",
          "references": {}
        },
        "required": false,
        "optional": true,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "string: Displayed text under the content."
            }, {
              "name": "example",
              "text": "sub-content"
            }],
          "text": "Text under the content. (e.g. for displaying error codes)"
        },
        "attribute": "subcontent",
        "reflect": false
      },
      "closeafter": {
        "type": "number",
        "mutable": false,
        "complexType": {
          "original": "number",
          "resolved": "number",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "number: A time in seconds."
            }, {
              "name": "example",
              "text": "close-after"
            }],
          "text": "Specifies the time in seconds the notification is visible before it's closed automatically.\nThe specified time has to be greater than 0."
        },
        "attribute": "closeafter",
        "reflect": false,
        "defaultValue": "5"
      },
      "visible": {
        "type": "boolean",
        "mutable": true,
        "complexType": {
          "original": "boolean",
          "resolved": "boolean",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "true: Toast will be displayed under the header."
            }, {
              "name": "value",
              "text": "false: Toast is invisible."
            }, {
              "name": "example",
              "text": "default"
            }],
          "text": "Specifies the visibility. If the notification closes automatically, by swiping the toast away (mobile only) or by clicking on the close button.\nthis attribute will be set to false."
        },
        "attribute": "visible",
        "reflect": true
      }
    };
  }
  static get states() {
    return {
      "show": {},
      "animating": {},
      "closingDirection": {}
    };
  }
  static get events() {
    return [{
        "method": "closeNotification",
        "name": "closeNotification",
        "bubbles": true,
        "cancelable": true,
        "composed": true,
        "docs": {
          "tags": [{
              "name": "example",
              "text": "close-notification"
            }],
          "text": "Fires when the notification closes automatically or by clicking on the close button."
        },
        "complexType": {
          "original": "void",
          "resolved": "void",
          "references": {}
        }
      }];
  }
  static get elementRef() { return "self"; }
  static get watchers() {
    return [{
        "propName": "visible",
        "methodName": "onVisibleChanged"
      }];
  }
}
const ANIMATION_PLAY_STATE_VARIABLE_NAME = "--dx-toast-flyout-play-state";
const ANIMATION_DELAY_VARIABLE_NAME = "--dx-toast-flyout-delay";
