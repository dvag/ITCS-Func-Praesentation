import { ValueStore } from "../../../classes/value-store";
import { BreakpointAware } from "../../../classes/breakpoint-aware";
import { Debounce } from "../../../classes/debounce";
const NOTIFICATION_SERVICE_KEY = "dx-notification-service";
export class NotificationService {
  constructor() {
    this.currentPaddingTop = 24;
    this.currentNotificationToasts = [];
    this.notificationsTransitionDebounce = new Debounce(50);
    this.notificationCloseHandle = (e) => this.internalCloseNotification(e.target);
    this.resizeObserver = new ResizeObserver(() => {
      this.setNotificationsTransition(NO_NOTIFICATION_TOAST_TRANSITION);
      this.updatePositions();
      this.notificationsTransitionDebounce.run(() => {
        this.setNotificationsTransition(DEFAULT_NOTIFICATION_TOAST_TRANSITION);
      });
    });
    this.updatePositions();
  }
  connect() {
    this.breakpointAware = new BreakpointAware(() => {
      this.currentPaddingTop = this.getCurrentPaddingTop();
      this.updatePositions();
    }, true);
    this.currentPaddingTop = this.getCurrentPaddingTop();
  }
  disconnect() {
    this.breakpointAware.disconnect();
  }
  getCurrentPaddingTop() {
    return this.breakpointAware.getEffectiveValue({
      mq1: 24,
      mq3: 40,
      mq5: 80,
    });
  }
  static instance() {
    return ValueStore.instance().getOrPut(NOTIFICATION_SERVICE_KEY, () => new NotificationService());
  }
  addNotificationToast(notification) {
    if (this.currentNotificationToasts.includes(notification)) {
      return;
    }
    if (this.resizeObserver == null || this.breakpointAware == null) {
      this.connect();
    }
    this.currentNotificationToasts.push(notification);
    notification.addEventListener("closeNotification", this.notificationCloseHandle);
    this.resizeObserver.observe(notification);
    this.updatePositions();
  }
  internalCloseNotification(notificationToClose) {
    this.currentNotificationToasts = this.currentNotificationToasts.filter((notification) => {
      return notificationToClose !== notification;
    });
    notificationToClose.removeEventListener("closeNotification", this.notificationCloseHandle);
    this.resizeObserver.unobserve(notificationToClose);
    if (this.currentNotificationToasts.length === 0) {
      this.disconnect();
    }
    else {
      this.updatePositions();
    }
  }
  updatePositions() {
    const spaceBetweenToasts = 24;
    let referencePositionY = this.currentPaddingTop;
    this.currentNotificationToasts.forEach((notification) => {
      notification.style.top = referencePositionY + "px";
      referencePositionY += notification.offsetHeight + spaceBetweenToasts;
    });
  }
  setNotificationsTransition(transitionValue) {
    this.currentNotificationToasts.forEach((notification) => {
      notification.style.transition = transitionValue;
    });
  }
}
const DEFAULT_NOTIFICATION_TOAST_TRANSITION = "top 500ms ease-in-out";
const NO_NOTIFICATION_TOAST_TRANSITION = "none";
