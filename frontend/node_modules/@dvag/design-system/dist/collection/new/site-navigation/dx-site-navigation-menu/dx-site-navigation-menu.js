import { forceUpdate, h, Host, readTask, writeTask, } from "@stencil/core";
import { sleep, unawaited } from "../../../classes/async";
import { BreakpointAware } from "../../../classes/breakpoint-aware";
import { ElementIdGenerator } from "../../../classes/element-id-handling";
import { notHidden } from "../../../classes/query-util";
import { isSlotDefined, onNextFrame } from "../../../classes/render-util";
import { createMetaComponentsSlotObserver, } from "../../../classes/slot-observer";
import { HeaderService, subscribeToHeaderHeight, } from "../../scaffold/dx-header/header-service";
import { obtainChildState } from "./obtain-child-priority";
/**
 * Adds a navigation menu to a content area. For examples see: [Site Navigation](#/component/dx-site-navigation)
 * @name Menu
 * @path /Scaffold/Site Navigation
 * @shortname Menu
 * @icon bars
 * @slot - A configuration of `<dx-site-navigation-menu-item>` elements.
 * @slot action - A place for action item, e.g. `<dx-button>` elements.
 * @stable
 */
export class DxSiteNavigationMenu {
  constructor() {
    this.scopes = [];
    this.enableScrollSelection = true;
    this.menuItems = [];
    this.openedMenuItemValue = null;
    this.headerState = { isVisible: true, height: 0 };
    this.usesStates = false;
    this.smallScreenModalVisible = false;
    /**
     * If activated, the menu looks out for dx-site-navigation-section elements with the same value
     * as the menu items, to automatically scroll into view.
     * @value true: Automatic navigation is enabled (default)
     * @value false: No automatic navigation
     */
    this.autonavigation = true;
    /**
     * Title of the page. The text is display in the modal view on the small screen modals.
     * @value string: Page title.
     */
    this.titlestring = "";
    /**
     * @internal
     */
    this.expandedlayoutat = "mq4";
  }
  onExpandedLayoutAtChanges() {
    this.updateLayoutDependentOnCurrentBreakpoint();
  }
  connectedCallback() {
    this.registerMenuItemObserver();
    this.breakpointAware = new BreakpointAware(() => forceUpdate(this), true);
    this.headerHeightSubscription = subscribeToHeaderHeight((height, isVisible) => {
      this.headerState = { height, isVisible };
      this.updateSmallScreenFloatingWrapperPosition();
    });
  }
  disconnectedCallback() {
    var _a, _b, _c, _d, _e;
    (_a = this.menuItemObserver) === null || _a === void 0 ? void 0 : _a.disconnect();
    (_b = this.breakpointAware) === null || _b === void 0 ? void 0 : _b.disconnect();
    (_c = this.headerHeightSubscription) === null || _c === void 0 ? void 0 : _c.unsubscribe();
    (_d = this.scopeIntersectionObserver) === null || _d === void 0 ? void 0 : _d.disconnect();
    (_e = this.smallScreenHeaderIntersectionObserver) === null || _e === void 0 ? void 0 : _e.disconnect();
  }
  onWindowChange() {
    this.updateLayoutDependentOnCurrentBreakpoint();
  }
  updateLayoutDependentOnCurrentBreakpoint() {
    if (this.isLargeScreen) {
      this.updateScrollabilityOfScrollContainer();
    }
    else {
      this.updateSmallScreenFloatingWrapperPosition();
    }
  }
  /**
   * Registers a new dx-site-navigation-scope element for tracking
   * @internal
   */
  async addScope(scope) {
    this.scopes = [...this.scopes, scope];
    this.configureIntersectionObserver();
  }
  /**
   * Removes a previously registered dx-site-navigation-scope element from tracking
   * @internal
   */
  async removeScope(scope) {
    this.scopes = this.scopes.filter((item) => item !== scope);
    this.configureIntersectionObserver();
  }
  updateScrollabilityOfScrollContainer() {
    onNextFrame(() => {
      readTask(() => {
        this.scrollContainerIsScrollable =
          this.scrollContainerElement != null &&
            this.scrollContainerElement.scrollHeight >
              this.scrollContainerElement.offsetHeight;
      });
    });
  }
  configureIntersectionObserver() {
    var _a;
    (_a = this.scopeIntersectionObserver) === null || _a === void 0 ? void 0 : _a.disconnect();
    // this structure keep track of known intersection data
    const data = {};
    // observer callback fires when some element passes a threshold
    this.scopeIntersectionObserver = new IntersectionObserver((entries) => {
      // update intersection data based on new incoming entries
      for (const entry of entries) {
        const value = entry.target.getAttribute("value");
        data[value] = {
          isIntersecting: entry.isIntersecting,
          target: entry.target,
          value: value,
          boundingRect: null,
        };
      }
      // filter for intersecting elements
      const visibleEntries = Object.values(data).filter((item) => {
        if (!item.isIntersecting) {
          return false;
        }
        // update bounding box
        item.boundingRect = item.target.getBoundingClientRect();
        // filter out intersecting items that are barely visible
        const headerBottom = this.headerState.isVisible
          ? this.headerState.height
          : 0;
        return item.boundingRect.bottom >= headerBottom;
      });
      if (visibleEntries.length === 0) {
        // Stop here if no visible elements available
        return;
      }
      visibleEntries.forEach((item) => (item.boundingRect = item.target.getBoundingClientRect()));
      // pick entry with lowest (on top of viewport) center
      const mostVisibleEntry = visibleEntries.reduce((a, b) => {
        const centerOfA = a.boundingRect.y + a.boundingRect.height / 2;
        const centerOfB = b.boundingRect.y + b.boundingRect.height / 2;
        return centerOfA < centerOfB ? a : b;
      });
      // if we have a candidate: select it!
      if (mostVisibleEntry) {
        this.selectValueWhileScrolling(visibleEntries[0].value);
      }
    }, intersectionObserverOptions([0]));
    this.scopes.forEach((scope) => this.scopeIntersectionObserver.observe(scope));
  }
  configureSmallScreenIntersectionObserver() {
    var _a;
    if (this.smallScreenTriggerElement == null) {
      return;
    }
    (_a = this.smallScreenHeaderIntersectionObserver) === null || _a === void 0 ? void 0 : _a.disconnect();
    // observer callback fires when some element passes a threshold
    this.smallScreenHeaderIntersectionObserver = new IntersectionObserver((entries) => {
      if (this.isLargeScreen || this.floatingWrapperElement == null) {
        return;
      }
      // Clear any remaining fade-out timeouts
      clearTimeout(this.fadeOutFloatingWrapperElementTimeout);
      const showFloatingHeader = entries[0].intersectionRatio < 1;
      if (showFloatingHeader) {
        this.floatingWrapperElement.classList.remove("fade-out");
        this.floatingWrapperElement.classList.add("visible");
        this.updateSmallScreenFloatingWrapperPosition();
      }
      else if (!showFloatingHeader) {
        this.floatingWrapperElement.classList.add("fade-out");
        this.fadeOutFloatingWrapperElementTimeout = setTimeout(() => {
          if (this.floatingWrapperElement == undefined) {
            //FloatingWrapper already removed from DOM
            return;
          }
          this.floatingWrapperElement.classList.remove("fade-out");
          this.floatingWrapperElement.classList.remove("visible");
        }, 200);
      }
    }, intersectionObserverOptions([0, 1]));
    this.smallScreenHeaderIntersectionObserver.observe(this.smallScreenTriggerElement);
  }
  updateSmallScreenFloatingWrapperPosition() {
    if (!this.floatingWrapperElement || !this.smallScreenTriggerElement) {
      return;
    }
    readTask(() => {
      const smallScreenTriggerElementWidth = this.smallScreenTriggerElement.offsetWidth + 2;
      writeTask(() => {
        var _a;
        // Asking again because floatingWrapperElement could be null again
        if (!this.floatingWrapperElement || !this.smallScreenTriggerElement) {
          return;
        }
        this.floatingWrapperElement.style.width = `${smallScreenTriggerElementWidth}px`;
        this.floatingWrapperElement.style.top = `${((_a = this.headerState) === null || _a === void 0 ? void 0 : _a.isVisible) ? this.headerState.height : 0}px`;
      });
    });
  }
  selectValueWhileScrolling(value) {
    this.lastRequestedSelectionValue = value;
    if (this.enableScrollSelection && this.selectedvalue !== value) {
      // scan level 1
      for (const item of this.menuItems) {
        if (item.value === value) {
          this.openedMenuItemValue = item.value;
          this.selectedvalue = item.value;
          return;
        }
        // scan level 2
        for (const subItem of item === null || item === void 0 ? void 0 : item.children) {
          if (subItem.value === value) {
            this.selectedvalue = subItem.value;
            this.openedMenuItemValue = item.value;
            return;
          }
        }
      }
    }
  }
  registerMenuItemObserver() {
    this.menuItemObserver =
      createMetaComponentsSlotObserver(this.self, ":scope > dx-site-navigation-menu-item.hydrated", async (nodes) => {
        // Receive menu item structure from DOM (level 1 items)
        this.menuItems = await Promise.all(nodes.map(async (node) => {
          return Object.assign(Object.assign({}, (await node.toMenuItemModel())), {
            // enrich with child nodes (level 2 items)
            children: await Promise.all(Array.from(
            // scan for child nodes within menu item element
            node.querySelectorAll(notHidden("dx-site-navigation-menu-item"))).map((child) => child.toMenuItemModel()))
          });
        }));
        // Obtain child states
        this.menuItems = obtainChildState(this.menuItems);
        this.usesStates = this.menuItems.some((item) => item.state !== "none");
        this.configureIntersectionObserver();
      });
  }
  get isLargeScreen() {
    return ((this.expandedlayoutat === "mq3" && this.breakpointAware.mq3) ||
      this.breakpointAware.mq4 ||
      this.breakpointAware.mq5);
  }
  openCloseItem(item) {
    if (this.openedMenuItemValue !== item.value) {
      this.openedMenuItemValue = item.value;
    }
    else {
      this.openedMenuItemValue = null;
    }
  }
  clickOnItem(item) {
    var _a;
    this.selectedvalue = item.value;
    const isLevel1Item = typeof item.children !== "undefined";
    if (isLevel1Item) {
      const hasChildren = ((_a = item.children) === null || _a === void 0 ? void 0 : _a.length) > 0;
      this.openedMenuItemValue = hasChildren ? item.value : null;
    }
    if (this.autonavigation) {
      // we don't want scroll/scope-based selection for a while.
      // but we track those selection, and if we re-enable scroll selection, we will pick the last tracked value.
      this.enableScrollSelection = false;
      this.smallScreenModalVisible = false;
      unawaited(this.waitAndScrollToScopeWithValue(item.value));
    }
    this.lastRequestedSelectionValue = item.value;
    this.navigate.emit({
      value: this.selectedvalue,
      complete: () => {
        this.reEnableScrollSelection();
        this.smallScreenModalVisible = false;
      },
    });
  }
  async waitAndScrollToScopeWithValue(value) {
    const siteNavigation = this.self.closest("dx-site-navigation");
    // Try to find element for a 5secs
    for (let i = 0; i < 8 * 5; i++) {
      if (this.selectedvalue !== value) {
        // cancel if not selected element anymore
        return;
      }
      const element = siteNavigation === null || siteNavigation === void 0 ? void 0 : siteNavigation.querySelector(`dx-site-navigation-scope[value='${value}']`);
      if (element) {
        // Stop loop if element is found
        await this.scrollToElement(element, "smooth");
        break;
      }
      else if (i == 0) {
        // if dont find the element on first try, temporary scroll to top to allow more overview
        unawaited(this.scrollToElement(siteNavigation));
      }
      await sleep(125); // wait between tries
    }
    this.reEnableScrollSelection();
  }
  reEnableScrollSelection() {
    this.enableScrollSelection = true;
    this.selectValueWhileScrolling(this.lastRequestedSelectionValue);
  }
  async scrollToElement(element, behavior = undefined) {
    if (!element) {
      return;
    }
    const relativePosY = element.getBoundingClientRect().top;
    // If we need to scroll upwards, the header will fade in and occupy space.
    // So we need to allocate some extra space.
    let additionalSpaceForHeaderElement = this.headerState.isVisible
      ? this.headerState.height
      : 0;
    if (!this.isLargeScreen) {
      // extra space for sticky small screen header
      additionalSpaceForHeaderElement +=
        SPACE_BETWEEN_FLOATING_AND_HEADER + SMALL_HEADER_ADDITIONAL_SPACE;
    }
    const scrollAmount = relativePosY - additionalSpaceForHeaderElement - HEADER_MARGIN;
    // don't scroll if it's just a little bit to bottom
    if (scrollAmount > 0 && scrollAmount < window.innerHeight / 4) {
      return;
    }
    unawaited(HeaderService.instance().disableScrollInteractionForMs(SCROLL_DURATION));
    window.scrollBy({ top: scrollAmount, behavior });
    await sleep(SCROLL_DURATION); // scroll duration
  }
  getParentOf(value) {
    return this.menuItems.find((item) => {
      var _a;
      return item.value === value ||
        ((_a = item.children) === null || _a === void 0 ? void 0 : _a.some((child) => child.value === value));
    });
  }
  renderItem(item, level = 1) {
    const children = level === 1 ? item === null || item === void 0 ? void 0 : item.children : [];
    const hasChildren = children.length > 0;
    const hasSelectedChild = children.some((child) => child.value === this.selectedvalue);
    const hasSelectedChildButItsHidden = hasSelectedChild && this.openedMenuItemValue !== item.value;
    return [
      h("div", { class: {
          item: true,
          selected: hasSelectedChildButItsHidden || item.value === this.selectedvalue,
          "level-1": level === 1,
          "level-2": level === 2,
        }, onClick: () => this.clickOnItem(item) }, h("div", { class: "indicator" }), h("div", { class: "indent" }), h("div", { class: { state: true, hidden: !this.usesStates } }, h("dx-icon", { icon: STATE_ICONS[item.state], color: STATE_COLORS[item.state], size: 16 })), h("div", { class: "label" }, h("button", { onClick: (e) => {
          e.stopPropagation();
          this.clickOnItem(item);
        }, id: ElementIdGenerator.createId(this.self, "button-" + item.value) }, h("dx-text", { type: "it", color: "headline" }, item.label))), h("div", { class: {
          arrow: true,
        } }, hasChildren ? (h("button", { onClick: hasChildren
          ? (e) => {
            e.stopPropagation();
            this.openCloseItem(item);
          }
          : undefined, id: ElementIdGenerator.createId(this.self, "open-close-control-" + item.value) }, h("dx-chevron", { directiontop: item.value === this.openedMenuItemValue, size: 16, active: item.value === this.selectedvalue }))) : undefined)),
      h("dx-simple-grow-box", { slidecontent: true, open: item.value === this.openedMenuItemValue }, children.map((child) => this.renderItem(child, level + 1))),
    ];
  }
  renderLargeScreenMenu() {
    const hasActionSlotItem = isSlotDefined(this.self, "action");
    // check if we need to hide show the separator after grow box (depends on number of visible items)
    onNextFrame(() => setTimeout(() => this.updateScrollabilityOfScrollContainer(), GROWBOX_ANIMATION_TIME));
    return (h("div", { class: "large-screen-frame" }, h("div", { class: "scroll-container", ref: (el) => {
        this.scrollContainerElement = el;
        this.updateScrollabilityOfScrollContainer();
      } }, this.menuItems.map((item) => this.renderItem(item))), this.scrollContainerIsScrollable ? (h("div", { class: "separator" }, h("div", { class: "shadow" }), h("div", { class: "border" }))) : null, hasActionSlotItem ? (h("div", { class: "action" }, h("slot", { name: "action" }))) : null));
  }
  renderSmallScreenHeader(position) {
    var _a;
    const selectedItem = (_a = this.getParentOf(this.selectedvalue)) !== null && _a !== void 0 ? _a : this.menuItems[0];
    if (!selectedItem) {
      return;
    }
    return (h("div", { class: {
        "small-screen-header": true,
        static: position === "static",
      }, onClick: () => (this.smallScreenModalVisible = true) }, position === "static" ? (h("div", { class: "trigger", ref: (el) => {
        this.smallScreenTriggerElement = el;
        this.configureSmallScreenIntersectionObserver();
      } })) : null, h("div", { class: { state: true, hidden: !this.usesStates } }, h("dx-icon", { icon: STATE_ICONS[selectedItem.state], color: STATE_COLORS[selectedItem.state], size: 16 })), h("div", { class: "label" }, h("dx-text", { type: "ps", color: "headline" }, selectedItem.label)), h("div", { class: "open-menu" }, h("button", { id: ElementIdGenerator.createId(this.self, "open-menu") }, h("dx-icon", { icon: "ueberlauf-menue", color: "default", size: 24 })))));
  }
  renderSmallScreenMenu() {
    const hasActionSlotItem = isSlotDefined(this.self, "action");
    return [
      this.renderSmallScreenHeader("static"),
      h("div", { class: "floating-wrapper", ref: (el) => {
          this.floatingWrapperElement = el;
          this.configureSmallScreenIntersectionObserver();
        } }, this.renderSmallScreenHeader("floating")),
      h("dx-modal", { height: "internal-site-navigation-menu", label: this.titlestring, visible: this.smallScreenModalVisible, onModalClosed: () => (this.smallScreenModalVisible = false) }, h("div", { slot: "content" }, this.menuItems.map((item) => this.renderItem(item))), hasActionSlotItem ? (h("slot", { name: "action", slot: "primary-actions" })) : null),
    ];
  }
  render() {
    const additionalSpaceForHeaderElement = this.headerState.isVisible
      ? this.headerState.height
      : 0;
    return (h(Host, { class: { "large-screen": this.isLargeScreen }, style: {
        top: `${HEADER_MARGIN + additionalSpaceForHeaderElement}px`,
      } }, this.isLargeScreen
      ? this.renderLargeScreenMenu()
      : this.renderSmallScreenMenu(), h("slot", null)));
  }
  static get is() { return "dx-site-navigation-menu"; }
  static get encapsulation() { return "shadow"; }
  static get originalStyleUrls() {
    return {
      "$": ["dx-site-navigation-menu.scss"]
    };
  }
  static get styleUrls() {
    return {
      "$": ["dx-site-navigation-menu.css"]
    };
  }
  static get properties() {
    return {
      "autonavigation": {
        "type": "boolean",
        "mutable": false,
        "complexType": {
          "original": "boolean",
          "resolved": "boolean",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "true: Automatic navigation is enabled (default)"
            }, {
              "name": "value",
              "text": "false: No automatic navigation"
            }],
          "text": "If activated, the menu looks out for dx-site-navigation-section elements with the same value\nas the menu items, to automatically scroll into view."
        },
        "attribute": "autonavigation",
        "reflect": false,
        "defaultValue": "true"
      },
      "titlestring": {
        "type": "string",
        "mutable": false,
        "complexType": {
          "original": "string",
          "resolved": "string",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "string: Page title."
            }],
          "text": "Title of the page. The text is display in the modal view on the small screen modals."
        },
        "attribute": "titlestring",
        "reflect": false,
        "defaultValue": "\"\""
      },
      "selectedvalue": {
        "type": "string",
        "mutable": true,
        "complexType": {
          "original": "string",
          "resolved": "string",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [],
          "text": "The value of the selected menu item."
        },
        "attribute": "selectedvalue",
        "reflect": true
      },
      "expandedlayoutat": {
        "type": "string",
        "mutable": false,
        "complexType": {
          "original": "SiteNavigationExpansionBreakpoint",
          "resolved": "\"mq3\" | \"mq4\"",
          "references": {
            "SiteNavigationExpansionBreakpoint": {
              "location": "import",
              "path": "../dx-site-navigation/dx-site-navigation"
            }
          }
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "internal",
              "text": undefined
            }],
          "text": ""
        },
        "attribute": "expandedlayoutat",
        "reflect": false,
        "defaultValue": "\"mq4\""
      }
    };
  }
  static get states() {
    return {
      "menuItems": {},
      "openedMenuItemValue": {},
      "headerState": {},
      "usesStates": {},
      "scrollContainerIsScrollable": {},
      "smallScreenModalVisible": {}
    };
  }
  static get events() {
    return [{
        "method": "navigate",
        "name": "navigate",
        "bubbles": true,
        "cancelable": true,
        "composed": true,
        "docs": {
          "tags": [],
          "text": "Event is fired when the user interacts with a menu item.\nThe event details object contains the following properties:\n- `value`: (string) value of the menu item the user clicked\n- `complete`: (function) needs to be called if not using autonavigation feature. While not completed the menu will not connect to scopes in order to select items by scrolling into the area."
        },
        "complexType": {
          "original": "NavigateEventDetail",
          "resolved": "NavigateEventDetail",
          "references": {
            "NavigateEventDetail": {
              "location": "local"
            }
          }
        }
      }];
  }
  static get methods() {
    return {
      "addScope": {
        "complexType": {
          "signature": "(scope: HTMLDxSiteNavigationScopeElement) => Promise<void>",
          "parameters": [{
              "tags": [],
              "text": ""
            }],
          "references": {
            "Promise": {
              "location": "global"
            },
            "HTMLDxSiteNavigationScopeElement": {
              "location": "global"
            }
          },
          "return": "Promise<void>"
        },
        "docs": {
          "text": "Registers a new dx-site-navigation-scope element for tracking",
          "tags": [{
              "name": "internal",
              "text": undefined
            }]
        }
      },
      "removeScope": {
        "complexType": {
          "signature": "(scope: HTMLDxSiteNavigationScopeElement) => Promise<void>",
          "parameters": [{
              "tags": [],
              "text": ""
            }],
          "references": {
            "Promise": {
              "location": "global"
            },
            "HTMLDxSiteNavigationScopeElement": {
              "location": "global"
            }
          },
          "return": "Promise<void>"
        },
        "docs": {
          "text": "Removes a previously registered dx-site-navigation-scope element from tracking",
          "tags": [{
              "name": "internal",
              "text": undefined
            }]
        }
      }
    };
  }
  static get elementRef() { return "self"; }
  static get watchers() {
    return [{
        "propName": "expandedlayoutat",
        "methodName": "onExpandedLayoutAtChanges"
      }];
  }
  static get listeners() {
    return [{
        "name": "resize",
        "method": "onWindowChange",
        "target": "window",
        "capture": false,
        "passive": true
      }];
  }
}
const STATE_COLORS = {
  error: "red-100",
  required: "gold",
  success: "green-100",
  none: "transparent",
};
const STATE_ICONS = {
  error: "state-error",
  required: "state-required",
  success: "state-success",
  none: "state-error", // intended because invisible
};
const HEADER_MARGIN = 24;
const GROWBOX_ANIMATION_TIME = 300;
const SCROLL_DURATION = 1000;
const SPACE_BETWEEN_FLOATING_AND_HEADER = 16;
const SMALL_HEADER_ADDITIONAL_SPACE = 48 + 8;
function intersectionObserverOptions(threshold) {
  return {
    root: null,
    rootMargin: "0px",
    threshold, // intersectionRatios in which the handler will fire
  };
}
