import { forceUpdate, h, Host, readTask, writeTask, } from "@stencil/core";
import { Debounce } from "../../../classes/debounce";
import { sameArrayIgnoreOrder, sameArrayInOrder, } from "../../../classes/misc-util";
import { sameColumnSettings } from "../dx-table-header-item/same-column-settings";
import { assert } from "../../../classes/assert";
import { ElementIdGenerator } from "../../../classes/element-id-handling";
import { containsExpandableRows } from "../table.util";
import { unawaited } from "../../../classes/async";
/**
 * A table for visualizing data in columns and rows.
 *
 * It has the ability to sort and paginate it's content out of the box.
 * This feature can be disabled, if you want to realize data sorting and pagination manually.
 *
 * @name Table
 * @path /
 * @icon table
 *
 * @stable
 *
 * @slot - Definition of the table data (rows) and data structure (columns) by using specialized sub-component (e.g.: `dx-table-header`, `dx-table-row`, etc.).
 */
export class DxTable {
  constructor() {
    this.currentSortSettings = { column: null, reverse: false };
    this.sortDebounce = new Debounce(50);
    this.rowDebounce = new Debounce(200);
    this.touchMoveDetected = false;
    this.expansionEnabled = false;
    this.initialized = false;
    this.scrollHandler = () => {
      this.controlOpticalHints();
    };
    this.currentPage = 1;
    this.selectedRowKeys = [];
    this.rowElements = [];
    /**
     * @internal
     */
    this.internalScrollable = false;
    /**
     * The initially selected option for the page size.
     * It only has an effect if the `pagesizes` property is defined.
     *
     * @value number: Number of rows per page.
     *
     * @example paginator
     */
    this.pagesize = 25;
    /**
     * When defined it enables the pagination for this table.
     * It defines the available page sizes a user is able to select.
     *
     * @value ArrayString: Comma separated List of values in JSON-format e.g.: "[5,10,25]"
     * @value number[]: Array of numbers.
     *
     * @example paginator
     */
    this.pagesizes = null;
    /**
     * Specifies the initial sort direction.
     *
     * @value asc: Ascending order.
     * @value desc: Descending order.
     *
     * @example initial-sort
     */
    this.initialsortdirection = "asc";
    /**
     * Specifies whether the table is self-managed or remote-controlled.
     *
     * @value managed: The table is responsible for sorting and pagination.
     * @value remote: The table relies on an external implementation for creating rows, sorting and pagination using the `tableStateChanged` event.
     *
     * @example remote
     * @example remote-complex
     */
    this.mode = "managed";
    /**
     * Enables the selection of rows.
     * A `key` for every row has to be specified.
     *
     * @value true: The selection-group will be opened.
     * @value false: The selection-group will be closed.
     *
     * @example selection
     */
    this.selectionenabled = false;
    /**
     * Specifies if only one or multiple rows can be selected.
     *
     * @value multi: Multiple rows can be selected.
     * @value single: One row can be selected at a time.
     *
     * @example selection-mode
     */
    this.selectionmode = "multi";
    /**
     * The data length this table should visualize. In case the table manages itself this attribute should not be set.
     * If the table is remote-controlled this attribute has to be set because the table needs to know the exact amount
     * of data to visualize the **paging** accordingly.
     *
     * @example remote
     * @example remote-complex
     */
    this.rowcount = 0;
  }
  onInternalScrollableChanged() {
    this.internalScrollChanged.emit(this.internalScrollable);
  }
  onSideBarOpenChange() {
    if (!this.selectionenabled) {
      this.selectedRowKeys = [];
      if (this.selectionGroup != null) {
        this.selectionGroup.value = null;
        this.rowsSelected.emit(null);
      }
      else {
        this.rowsSelected.emit([]);
      }
    }
    else {
      const noRowIdsDefined = this.getRows().every((row) => row.rowid == null);
      if (noRowIdsDefined) {
        console.warn("To use table selection you have to define at least one <dx-table-row> with a valid 'rowid'!\n", this.self);
        this.selectionenabled = false;
      }
    }
    this.controlOpticalHints();
    this.emitSelectionChanged();
    readTask(() => unawaited(this.updateTableScroll(this.self.offsetWidth)));
  }
  onSelectionModeChanged() {
    this.emitSelectionChanged();
  }
  onScrollableChange() {
    var _a;
    this.setScrollable();
    this.controlOpticalHints();
    (_a = this.headerItemElements) === null || _a === void 0 ? void 0 : _a.forEach((headerItem) => {
      headerItem.usemaxwidth = this.internalScrollable;
    });
  }
  onTouchStart() {
    this.touchMoveDetected = false;
  }
  onTouchmove() {
    this.touchMoveDetected = true;
  }
  onTouchEnd(event) {
    if (this.touchMoveDetected) {
      event.stopImmediatePropagation();
      this.touchMoveDetected = false;
    }
  }
  connectedCallback() {
    this.initialized = false;
    this.mutationObserver = new MutationObserver(() => {
      const headerItems = this.self.querySelectorAll("dx-table-header-item");
      const rows = this.self.querySelectorAll("dx-table-row");
      this.updateHeaderItems(Array.from(headerItems)).then(() => {
        this.updateRows(Array.from(rows));
        const expansionEnabled = containsExpandableRows(this.self);
        if (expansionEnabled !== this.expansionEnabled) {
          this.expansionEnabled = expansionEnabled;
          this.expansionChanged.emit(expansionEnabled);
        }
      });
    });
    this.mutationObserver.observe(this.self, {
      childList: true,
      subtree: true,
      attributes: true,
    });
    this.setScrollable();
  }
  disconnectedCallback() {
    var _a, _b;
    (_a = this.mutationObserver) === null || _a === void 0 ? void 0 : _a.disconnect();
    this.rowDebounce.reset();
    this.sortDebounce.reset();
    (_b = this.tableResizeObserver) === null || _b === void 0 ? void 0 : _b.disconnect();
  }
  initTableResizeObserver() {
    this.tableResizeObserver = new ResizeObserver((entries) => {
      this.updateTableScroll(entries[0].contentRect.width).then(() => {
        this.controlOpticalHints();
      });
      writeTask(() => {
        this.self.style.setProperty("--dx-table-width", `${entries[0].contentRect.width}px`);
      });
    });
  }
  setScrollable() {
    var _a;
    if (this.scrollable) {
      this.initTableResizeObserver();
    }
    else {
      (_a = this.tableResizeObserver) === null || _a === void 0 ? void 0 : _a.disconnect();
      this.tableResizeObserver = null;
      this.internalScrollable = false;
      this.updateCellSettings().then();
      writeTask(() => {
        this.self.style.removeProperty("--dx-table-width");
      });
    }
  }
  emitSelectionChanged() {
    this.selectionStateChanged.emit({
      enabled: this.selectionenabled,
      mode: this.selectionmode,
    });
  }
  async updateTableHeaderWidths() {
    var _a, _b;
    const headerItemWidthsPromises = (_b = (_a = this.headerItemElements) === null || _a === void 0 ? void 0 : _a.map(async (headerItem) => {
      const maxWidth = await headerItem.getMaxWidth();
      return {
        headerItemElement: headerItem,
        width: isNaN(maxWidth) ? await headerItem.getMinWidth() : maxWidth,
      };
    })) !== null && _b !== void 0 ? _b : [];
    this.headerItemElementsWidth = await Promise.all(headerItemWidthsPromises).then((headerItemElements) => {
      return headerItemElements.reduce((map, headerItemWidth) => {
        return map.set(headerItemWidth.headerItemElement, headerItemWidth.width);
      }, new Map());
    });
  }
  getStickyColumnsWidth() {
    var _a, _b;
    const expansionSpace = containsExpandableRows(this.self)
      ? EXPANSION_COLUMN_WIDTH
      : 0;
    const selectionSpace = this.selectionenabled ? SELECTION_COLUMN_WIDTH : 0;
    return (((_b = (_a = this.headerItemElements) === null || _a === void 0 ? void 0 : _a.filter((headerItem) => headerItem.slot === "sticky")) === null || _b === void 0 ? void 0 : _b.reduce((acc, headerItem) => {
      var _a;
      return (_a = acc + this.headerItemElementsWidth.get(headerItem)) !== null && _a !== void 0 ? _a : 0;
    }, 0)) +
      expansionSpace +
      selectionSpace);
  }
  getScrollWidth() {
    var _a, _b;
    const collapsableSpace = containsExpandableRows(this.self)
      ? EXPANSION_COLUMN_WIDTH
      : 0;
    const selectionSpace = this.selectionenabled ? SELECTION_COLUMN_WIDTH : 0;
    return (((_b = (_a = this.headerItemElements) === null || _a === void 0 ? void 0 : _a.reduce((acc, headerItem) => {
      var _a;
      return (_a = acc + this.headerItemElementsWidth.get(headerItem)) !== null && _a !== void 0 ? _a : 0;
    }, 0)) !== null && _b !== void 0 ? _b : 0) +
      collapsableSpace +
      selectionSpace);
  }
  setScrollContainer(scrollContainer) {
    var _a, _b;
    if (this.scrollContainer === scrollContainer) {
      return;
    }
    (_a = this.scrollContainer) === null || _a === void 0 ? void 0 : _a.removeEventListener("scroll", this.scrollHandler);
    this.scrollContainer = scrollContainer;
    (_b = this.scrollContainer) === null || _b === void 0 ? void 0 : _b.addEventListener("scroll", this.scrollHandler);
  }
  async updateTableScroll(tableWidth) {
    var _a;
    if (!this.scrollable) {
      return;
    }
    if (this.headerItemElements == null ||
      this.headerItemElements.length === 0) {
      return;
    }
    const collapsableSpace = containsExpandableRows(this.self)
      ? EXPANSION_COLUMN_WIDTH
      : 0;
    const selectionSpace = this.selectionenabled ? SELECTION_COLUMN_WIDTH : 0;
    await Promise.all((_a = this.headerItemElements) === null || _a === void 0 ? void 0 : _a.map((headerItemElement) => headerItemElement.getMinWidth())).then((minWidthArray) => {
      var _a;
      const columnsMinWidthsSum = (_a = minWidthArray === null || minWidthArray === void 0 ? void 0 : minWidthArray.reduce((acc, currentValue) => {
        if (isNaN(currentValue)) {
          console.error(`dx-table:`, this.self, `Every <dx-table-header-item> in a scrollable table has to set a minwidth. At least one <dx-table-header-item> was not given a size.`);
        }
        return acc + currentValue;
      }, 0)) !== null && _a !== void 0 ? _a : 0;
      const isScrollable = columnsMinWidthsSum + selectionSpace + collapsableSpace > tableWidth;
      if (this.internalScrollable !== isScrollable) {
        this.internalScrollable = isScrollable;
        this.updateCellSettings().then();
        if (!isScrollable) {
          this.showLeftShadow = false;
          this.showRightShadow = false;
        }
      }
    });
  }
  controlOpticalHints() {
    if (!this.internalScrollable || this.scrollContainer == null) {
      return;
    }
    const scrollDistance = this.scrollContainer.scrollLeft;
    const maxScrollDistance = this.scrollContainer.scrollWidth - this.scrollContainer.clientWidth;
    writeTask(() => {
      var _a;
      this.showRightShadow = scrollDistance < maxScrollDistance;
      this.showLeftShadow =
        this.isScrollingPossible() && ((_a = this.scrollContainer) === null || _a === void 0 ? void 0 : _a.scrollLeft) > 0;
    });
  }
  isScrollingPossible() {
    var _a, _b;
    return (this.internalScrollable &&
      ((_a = this.scrollContainer) === null || _a === void 0 ? void 0 : _a.scrollWidth) > ((_b = this.scrollContainer) === null || _b === void 0 ? void 0 : _b.clientWidth));
  }
  /**
   * @internal
   */
  async invokeSort(element, reverse) {
    if (!this.initialized) {
      this.invokeSortInputParamsBeforeInit = {
        element,
        reverse,
      };
      return;
    }
    return this.internalInvokeSort(element, reverse);
  }
  async internalInvokeSort(element, reverse) {
    var _a;
    const index = this.headerItemElements.indexOf(element);
    this.headerItemElements.forEach((el, i) => {
      if (index !== i) {
        el.setSortDirection("neutral");
      }
    });
    this.sortState = {
      column: (_a = element.columnid) !== null && _a !== void 0 ? _a : element.label,
      index: index,
      direction: reverse ? "desc" : "asc",
    };
    this.sortRows({ column: index, reverse: reverse });
  }
  reSort() {
    if (this.currentSortSettings.column !== null) {
      this.sortRows(this.currentSortSettings);
    }
  }
  handlePaginationPageSizeChanged(e) {
    this.pagesize = e.detail;
    this.emitTableStateChanged();
    this.updateVisibility();
  }
  isUsingPagination() {
    return this.pagesizes != null && this.pagesizes.length > 0;
  }
  updateRows(rows) {
    this.rowDebounce.run(async () => {
      // Disconnect to prevent further SlotObserver calls through DOM Manipulation
      this.mutationObserver.disconnect();
      this.checkForDuplicateRowKeys(rows);
      this.handleRemoteSelection(rows);
      if (!sameArrayIgnoreOrder(rows, this.rowElements)) {
        this.rowElements = rows;
        if (this.mode === "managed") {
          this.rowcount = rows.length;
          if (!hasAnySortableColumns(this.headerItemElements)) {
            await this.reOrderRows(this.rowElements);
          }
          else {
            this.reSort();
          }
        }
      }
      else {
        forceUpdate(this.self);
      }
      await this.updateVisibility();
      await this.updateCellSettings();
      // Reconnect SlotObserver
      this.mutationObserver.observe(this.self, {
        childList: true,
        subtree: true,
        attributes: true,
      });
      this.init();
    });
  }
  handleRemoteSelection(currentRows) {
    requestAnimationFrame(() => {
      var _a;
      const tmpRowsSelected = [...this.selectedRowKeys];
      if (this.selectionmode === "single") {
        const previousSelectedRowId = this.selectedRowKeys[0];
        const newlySelectedRowID = (_a = currentRows
          .filter((row) => row.selected == true)
          .filter((row) => row.rowid !== previousSelectedRowId)[0]) === null || _a === void 0 ? void 0 : _a.rowid;
        if (newlySelectedRowID == undefined) {
          return;
        }
        this.selectionenabled = true;
        this.handleRadioSelection(newlySelectedRowID);
      }
      else {
        currentRows.forEach((row) => {
          this.selectionenabled || (this.selectionenabled = row.selected);
          this.handleCheckboxSelection(row.rowid, row.selected);
        });
      }
      if (!sameArrayIgnoreOrder(tmpRowsSelected, this.selectedRowKeys)) {
        this.rowsSelected.emit([...this.selectedRowKeys]);
      }
    });
  }
  init() {
    this.initialized = true;
    if (this.invokeSortInputParamsBeforeInit != null) {
      this.internalInvokeSort(this.invokeSortInputParamsBeforeInit.element, this.invokeSortInputParamsBeforeInit.reverse).then();
      this.invokeSortInputParamsBeforeInit = null;
    }
  }
  getCurrentRowsRangeIndices() {
    var _a, _b;
    const fromIndex = ((_a = this.pagesize) !== null && _a !== void 0 ? _a : 0) * (this.currentPage - 1);
    const result = {
      fromIndex: fromIndex,
      toIndex: fromIndex,
    };
    if (this.mode === "managed") {
      result.toIndex += ((_b = this.pagesize) !== null && _b !== void 0 ? _b : this.rowcount) - 1;
    }
    else {
      result.toIndex += this.pagesize - 1;
    }
    // There could be fewer rows visible than the pagesize allows at the last page
    result.toIndex = Math.min(this.rowcount - 1, result.toIndex);
    return result;
  }
  emitTableStateChanged() {
    const currentRowsRangeIndices = this.getCurrentRowsRangeIndices();
    this.tableStateChanged.emit({
      page: this.currentPage,
      pageSize: this.pagesize,
      fromIndex: currentRowsRangeIndices.fromIndex,
      toIndex: currentRowsRangeIndices.toIndex,
      sortState: this.sortState,
    });
  }
  async updateHeaderItems(headerItems) {
    var _a, _b;
    const newSettings = await Promise.all(headerItems.map((headerItem) => {
      return headerItem.toColumnSettings();
    }));
    if (this.sameSettings(newSettings) &&
      sameArrayInOrder(this.headerItemElements, headerItems)) {
      return;
    }
    this.settings = newSettings;
    const hadAnySortableColumnsBeforeChange = hasAnySortableColumns(this.headerItemElements);
    this.headerItemElements = headerItems;
    if (!hadAnySortableColumnsBeforeChange) {
      const sortableHeaderColumns = headerItems === null || headerItems === void 0 ? void 0 : headerItems.filter((headerItem) => headerItem.sortable);
      let sortedHeaderColumn = null;
      if (((_a = this.initialsort) === null || _a === void 0 ? void 0 : _a.length) > 0) {
        sortedHeaderColumn = sortableHeaderColumns === null || sortableHeaderColumns === void 0 ? void 0 : sortableHeaderColumns.find((headerItem) => {
          return (headerItem.columnid === this.initialsort ||
            headerItem.label === this.initialsort);
        });
        assert(sortedHeaderColumn != null, () => `No <dx-table-header-item> element with 'columnid' or 'label' "${this.initialsort}" found`);
      }
      sortedHeaderColumn !== null && sortedHeaderColumn !== void 0 ? sortedHeaderColumn : (sortedHeaderColumn = sortableHeaderColumns === null || sortableHeaderColumns === void 0 ? void 0 : sortableHeaderColumns[0]);
      sortedHeaderColumn === null || sortedHeaderColumn === void 0 ? void 0 : sortedHeaderColumn.setSortDirection((_b = this.initialsortdirection) !== null && _b !== void 0 ? _b : "asc");
    }
    readTask(() => {
      const table = this.self.shadowRoot.querySelector(".table");
      if (table != null) {
        unawaited(this.updateTableScroll(table.getBoundingClientRect().width));
      }
      this.updateCellSettings().then();
    });
  }
  sameSettings(settings) {
    return (this.settings != null &&
      this.settings.length === settings.length &&
      settings.every((setting, index) => {
        return sameColumnSettings(setting, this.settings[index]);
      }));
  }
  async updateCellSettings() {
    var _a;
    (_a = this.headerItemElements) === null || _a === void 0 ? void 0 : _a.forEach((headerItem) => {
      headerItem.usemaxwidth = this.internalScrollable;
    });
    return Promise.all(this.getRows().concat(this.getFooters()).flatMap((row) => {
      return Array.from(row.querySelectorAll("dx-table-cell"))
        .map((cell, index) => {
        var _a;
        if (index < ((_a = this.headerItemElements) === null || _a === void 0 ? void 0 : _a.length)) {
          return cell.obtainSettings(this.settings[index]);
        }
        return null;
      })
        .filter((promise) => promise != null);
    }));
  }
  getRows() {
    var _a;
    return (_a = this.rowElements) !== null && _a !== void 0 ? _a : [];
  }
  getFooters() {
    var _a;
    return (_a = Array.from(this.self.querySelectorAll("dx-table-footer"))) !== null && _a !== void 0 ? _a : [];
  }
  compareColumns(firstRow, secondRow, columnIndex, type) {
    var _a;
    const columnSelector = "dx-table-cell:nth-child(" + (columnIndex + 1) + ")";
    if (type === "html") {
      const headerItem = this.headerItemElements[columnIndex];
      if (headerItem.customSort != null) {
        return headerItem.customSort(firstRow.querySelector(columnSelector), secondRow.querySelector(columnSelector));
      }
      return 0;
    }
    const valueA = firstRow.querySelector(columnSelector).getAttribute("value");
    const valueB = secondRow
      .querySelector(columnSelector)
      .getAttribute("value");
    if (type === "numeric" || type === "currency") {
      return parseFloat(valueA) - parseFloat(valueB);
    }
    return (_a = valueA === null || valueA === void 0 ? void 0 : valueA.localeCompare(valueB)) !== null && _a !== void 0 ? _a : (valueB ? -1 : 0);
  }
  sortRows(sortSettings) {
    if (!equalSortSettings(this.currentSortSettings, sortSettings)) {
      this.currentPage = 1;
      this.emitTableStateChanged();
    }
    if (this.mode === "remote") {
      return;
    }
    this.currentSortSettings.column = sortSettings.column;
    this.currentSortSettings.reverse = sortSettings.reverse;
    this.sortDebounce.run(async () => {
      var _a, _b;
      const rows = [...((_a = this.getRows()) !== null && _a !== void 0 ? _a : [])];
      const type = (_b = this.settings[sortSettings.column]) === null || _b === void 0 ? void 0 : _b.type;
      const sortScale = sortSettings.reverse ? -1 : 1;
      const sortOrder = this.headerItemElements
        .filter((_, index) => index !== sortSettings.column)
        .filter((headerItem) => headerItem.sortable && headerItem.sortpriority != null)
        .sort((a, b) => b.sortpriority - a.sortpriority)
        .map((headerItem) => this.headerItemElements.indexOf(headerItem));
      rows.sort((a, b) => {
        var _a;
        let currentColumnIndex = sortSettings.column;
        let currentType = type;
        const sortOrderCpy = [...sortOrder];
        let result = this.compareColumns(a, b, currentColumnIndex, currentType) *
          sortScale;
        // Secondary sorting
        while (result === 0 && sortOrderCpy.length > 0) {
          currentColumnIndex = sortOrderCpy.pop();
          currentType = (_a = this.settings[currentColumnIndex]) === null || _a === void 0 ? void 0 : _a.type;
          // Do not apply scale because we want to always sort ascending for secondary sorting
          result = this.compareColumns(a, b, currentColumnIndex, currentType);
        }
        return result;
      });
      await this.reOrderRows(rows);
      this.updateVisibility();
    });
  }
  checkForDuplicateRowKeys(currentRows) {
    const duplicateMap = currentRows.reduce((map, row) => {
      var _a, _b;
      if (row.rowid != null) {
        map[row.rowid] = (_b = (_a = map[row.rowid]) === null || _a === void 0 ? void 0 : _a.concat(row)) !== null && _b !== void 0 ? _b : [row];
      }
      return map;
    }, {});
    Object.keys(duplicateMap).forEach((key) => {
      const rowList = duplicateMap[key];
      if (rowList.length > 1) {
        console.error(`Duplicate key "${key}" in rows:\n`, ...rowList);
      }
    });
  }
  async reOrderRows(rows) {
    return new Promise((resolve) => {
      writeTask(() => {
        rows.forEach((row, index) => {
          row.style.order = (index + 1).toString();
        });
        resolve();
      });
    });
  }
  async updateVisibility() {
    const rows = this.getRows();
    if (this.mode === "managed" && this.isUsingPagination()) {
      const visibleRowRange = this.getCurrentRowsRangeIndices();
      await new Promise((resolve) => {
        readTask(() => {
          const rowVisibilities = rows.map((row) => {
            const sortIndex = parseInt(row.style.order) - 1;
            return (sortIndex >= visibleRowRange.fromIndex &&
              sortIndex <= visibleRowRange.toIndex);
          });
          writeTask(() => {
            rows.forEach((row, index) => {
              row.setAttribute("visible", rowVisibilities[index].toString());
            });
            resolve();
          });
        });
      });
    }
    const lastRow = this.getLastVisibleRow();
    if (lastRow != null) {
      lastRow.style.setProperty(BORDER_BOTTOM_PROPERTY, "none");
    }
    rows.forEach((row) => {
      const isLastRow = lastRow === row;
      if (!isLastRow) {
        row.style.removeProperty(BORDER_BOTTOM_PROPERTY);
      }
    });
  }
  getLastVisibleRow(rows) {
    return (rows !== null && rows !== void 0 ? rows : this.getRows())
      .filter((row) => row.visible)
      .reduce((rowAndOrder, currentRow) => {
      const order = parseInt(currentRow.style.order);
      if (order > rowAndOrder.order ||
        rowAndOrder.order === -1 ||
        isNaN(rowAndOrder.order)) {
        return {
          order: order,
          row: currentRow,
        };
      }
      return rowAndOrder;
    }, {
      order: -1,
      row: null,
    }).row;
  }
  handlePaginationPageChanged(e) {
    const page = e.detail;
    if (this.currentPage !== page) {
      this.currentPage = page;
      this.emitTableStateChanged();
      this.updateVisibility();
    }
  }
  handleRadioSelection(key) {
    if (this.selectedRowKeys[0] === key) {
      return;
    }
    this.selectedRowKeys = [key];
    this.rowElements.forEach((row) => {
      row.selected = row.rowid == this.selectedRowKeys[0];
    });
  }
  handleCheckboxSelection(key, checked) {
    const containsKey = this.selectedRowKeys.includes(key);
    if (containsKey && !checked) {
      this.selectedRowKeys = this.selectedRowKeys.filter((rowKey) => rowKey !== key);
    }
    else if (!containsKey && checked) {
      this.selectedRowKeys = [...this.selectedRowKeys, key];
    }
  }
  componentDidRender() {
    this.controlOpticalHints();
    if (this.selectionmode === "single") {
      this.selectionGroup.value = this.selectedRowKeys[0];
    }
  }
  async componentWillRender() {
    await this.updateTableHeaderWidths();
  }
  render() {
    return (h(Host, { role: "table", style: {
        "--dx-internal-table-sticky-columns-width": this.getStickyColumnsWidth().toString() + "px",
        "--dx-table-selection-column-width": this.selectionenabled
          ? `${SELECTION_COLUMN_WIDTH}px`
          : "0px",
        "--dx-table-expansion-column-width": this.expansionEnabled
          ? `${EXPANSION_COLUMN_WIDTH}px`
          : "0px",
      } }, this.renderPageSizePicker(), h("dx-radio-button-group", { radiogroupid: "table-selection-group", ref: (ref) => {
        this.selectionGroup = ref;
      } }, h("div", { class: "table-container" }, this.renderTable())), this.renderPaginator()));
  }
  renderPageSizePicker() {
    if (!this.isUsingPagination()) {
      return;
    }
    return (h("dx-number-picker", { id: ElementIdGenerator.createId(this.self, "page-size-picker"), align: "right", class: "page-size-picker", value: this.pagesize, values: this.pagesizes, onValueChange: (e) => this.handlePaginationPageSizeChanged(e) }));
  }
  renderPaginator() {
    if (!this.isUsingPagination()) {
      return;
    }
    return (h("div", { class: "paginator-container" }, h("dx-number-paginator", { id: ElementIdGenerator.createId(this.self, "paginator"), class: "paginator", onPageChanged: (e) => this.handlePaginationPageChanged(e), current: this.currentPage, count: Math.ceil(this.rowcount / this.pagesize) })));
  }
  renderScrollableTableContent() {
    return (h("div", null, h("ds-scroll-container", { scrollbarborderradius: 0, thumbwidth: 8, scrollbaroffset: 4 }, h("div", { ref: (ref) => {
        writeTask(() => {
          this.setScrollContainer(ref);
        });
      }, class: { scrollable: true }, style: {
        "--dx-table-row-width": this.internalScrollable
          ? `${this.getScrollWidth()}px`
          : "none",
      } }, h("slot", null)))));
  }
  renderTable() {
    const reserveSpaceForCollapsableRows = containsExpandableRows(this.self);
    return [
      h("div", { class: {
          table: true,
          "with-collapse-rows": reserveSpaceForCollapsableRows,
          "selection-enabled": this.selectionenabled,
        }, ref: (ref) => {
          var _a;
          (_a = this.tableResizeObserver) === null || _a === void 0 ? void 0 : _a.observe(ref);
        } }, this.internalScrollable ? (this.renderScrollableTableContent()) : (h("slot", null)), h("div", { class: {
          shadow: true,
          left: true,
          show: this.showLeftShadow,
        } }, "\u00A0"), h("div", { class: {
          shadow: true,
          right: true,
          show: this.showRightShadow,
        } }, "\u00A0")),
    ];
  }
  static get is() { return "dx-table"; }
  static get encapsulation() { return "shadow"; }
  static get originalStyleUrls() {
    return {
      "$": ["dx-table.scss"]
    };
  }
  static get styleUrls() {
    return {
      "$": ["dx-table.css"]
    };
  }
  static get properties() {
    return {
      "internalScrollable": {
        "type": "boolean",
        "mutable": true,
        "complexType": {
          "original": "boolean",
          "resolved": "boolean",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "internal",
              "text": undefined
            }],
          "text": ""
        },
        "attribute": "internal-scrollable",
        "reflect": false,
        "defaultValue": "false"
      },
      "pagesize": {
        "type": "number",
        "mutable": true,
        "complexType": {
          "original": "number",
          "resolved": "number",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "number: Number of rows per page."
            }, {
              "name": "example",
              "text": "paginator"
            }],
          "text": "The initially selected option for the page size.\nIt only has an effect if the `pagesizes` property is defined."
        },
        "attribute": "pagesize",
        "reflect": false,
        "defaultValue": "25"
      },
      "pagesizes": {
        "type": "string",
        "mutable": false,
        "complexType": {
          "original": "ArrayStringOrArray",
          "resolved": "number[] | string",
          "references": {
            "ArrayStringOrArray": {
              "location": "import",
              "path": "../../misc/dx-number-picker/dx-number-picker"
            }
          }
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "ArrayString: Comma separated List of values in JSON-format e.g.: \"[5,10,25]\""
            }, {
              "name": "value",
              "text": "number[]: Array of numbers."
            }, {
              "name": "example",
              "text": "paginator"
            }],
          "text": "When defined it enables the pagination for this table.\nIt defines the available page sizes a user is able to select."
        },
        "attribute": "pagesizes",
        "reflect": false,
        "defaultValue": "null"
      },
      "initialsort": {
        "type": "string",
        "mutable": false,
        "complexType": {
          "original": "string",
          "resolved": "string",
          "references": {}
        },
        "required": false,
        "optional": true,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "string: The `columnId` or `label` of the column."
            }, {
              "name": "example",
              "text": "initial-sort"
            }],
          "text": "Defines the column that is used for initially sorting the table."
        },
        "attribute": "initialsort",
        "reflect": false
      },
      "initialsortdirection": {
        "type": "string",
        "mutable": false,
        "complexType": {
          "original": "\"asc\" | \"desc\"",
          "resolved": "\"asc\" | \"desc\"",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "asc: Ascending order."
            }, {
              "name": "value",
              "text": "desc: Descending order."
            }, {
              "name": "example",
              "text": "initial-sort"
            }],
          "text": "Specifies the initial sort direction."
        },
        "attribute": "initialsortdirection",
        "reflect": false,
        "defaultValue": "\"asc\""
      },
      "mode": {
        "type": "string",
        "mutable": false,
        "complexType": {
          "original": "\"managed\" | \"remote\"",
          "resolved": "\"managed\" | \"remote\"",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "managed: The table is responsible for sorting and pagination."
            }, {
              "name": "value",
              "text": "remote: The table relies on an external implementation for creating rows, sorting and pagination using the `tableStateChanged` event."
            }, {
              "name": "example",
              "text": "remote"
            }, {
              "name": "example",
              "text": "remote-complex"
            }],
          "text": "Specifies whether the table is self-managed or remote-controlled."
        },
        "attribute": "mode",
        "reflect": false,
        "defaultValue": "\"managed\""
      },
      "selectionenabled": {
        "type": "boolean",
        "mutable": true,
        "complexType": {
          "original": "boolean",
          "resolved": "boolean",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "true: The selection-group will be opened."
            }, {
              "name": "value",
              "text": "false: The selection-group will be closed."
            }, {
              "name": "example",
              "text": "selection"
            }],
          "text": "Enables the selection of rows.\nA `key` for every row has to be specified."
        },
        "attribute": "selectionenabled",
        "reflect": false,
        "defaultValue": "false"
      },
      "selectionmode": {
        "type": "string",
        "mutable": false,
        "complexType": {
          "original": "SelectionMode",
          "resolved": "\"multi\" | \"single\"",
          "references": {
            "SelectionMode": {
              "location": "import",
              "path": "../table-common-types"
            }
          }
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "multi: Multiple rows can be selected."
            }, {
              "name": "value",
              "text": "single: One row can be selected at a time."
            }, {
              "name": "example",
              "text": "selection-mode"
            }],
          "text": "Specifies if only one or multiple rows can be selected."
        },
        "attribute": "selectionmode",
        "reflect": false,
        "defaultValue": "\"multi\""
      },
      "rowcount": {
        "type": "number",
        "mutable": true,
        "complexType": {
          "original": "number",
          "resolved": "number",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "example",
              "text": "remote"
            }, {
              "name": "example",
              "text": "remote-complex"
            }],
          "text": "The data length this table should visualize. In case the table manages itself this attribute should not be set.\nIf the table is remote-controlled this attribute has to be set because the table needs to know the exact amount\nof data to visualize the **paging** accordingly."
        },
        "attribute": "rowcount",
        "reflect": false,
        "defaultValue": "0"
      },
      "scrollable": {
        "type": "boolean",
        "mutable": false,
        "complexType": {
          "original": "boolean",
          "resolved": "boolean",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "true: Table is scrollable."
            }, {
              "name": "value",
              "text": "false: Table is not scrollable."
            }, {
              "name": "example",
              "text": "scrollable"
            }],
          "text": "Specifies if the table should be scrollable. It is necessary to ensure that every `<dx-header-item>` has the width property set."
        },
        "attribute": "scrollable",
        "reflect": false
      }
    };
  }
  static get states() {
    return {
      "currentPage": {},
      "sortState": {},
      "selectedRowKeys": {},
      "showLeftShadow": {},
      "showRightShadow": {},
      "scrollContainer": {},
      "rowElements": {}
    };
  }
  static get events() {
    return [{
        "method": "tableStateChanged",
        "name": "tableStateChanged",
        "bubbles": true,
        "cancelable": true,
        "composed": true,
        "docs": {
          "tags": [{
              "name": "example",
              "text": "table-state-changed"
            }],
          "text": "This event will be fired as soon as the table`s state changes (e.g. sorting, paging...)"
        },
        "complexType": {
          "original": "TableConfig",
          "resolved": "TableConfig",
          "references": {
            "TableConfig": {
              "location": "local"
            }
          }
        }
      }, {
        "method": "selectionStateChanged",
        "name": "selectionStateChanged",
        "bubbles": true,
        "cancelable": true,
        "composed": true,
        "docs": {
          "tags": [{
              "name": "example",
              "text": "table-state-changed"
            }],
          "text": "This event will be fired as soon as the table`s state changes (e.g. sorting, paging...)"
        },
        "complexType": {
          "original": "TableSelection",
          "resolved": "TableSelection",
          "references": {
            "TableSelection": {
              "location": "import",
              "path": "../table-common-types"
            }
          }
        }
      }, {
        "method": "expansionChanged",
        "name": "expansionChanged",
        "bubbles": true,
        "cancelable": true,
        "composed": true,
        "docs": {
          "tags": [{
              "name": "example",
              "text": "table-state-changed"
            }],
          "text": "This event will be fired as soon as the table`s state changes (e.g. sorting, paging...)"
        },
        "complexType": {
          "original": "boolean",
          "resolved": "boolean",
          "references": {}
        }
      }, {
        "method": "internalScrollChanged",
        "name": "internalScrollChanged",
        "bubbles": true,
        "cancelable": true,
        "composed": true,
        "docs": {
          "tags": [{
              "name": "internal",
              "text": undefined
            }],
          "text": "This event will be fired as soon as the table`s scroll state changes."
        },
        "complexType": {
          "original": "boolean",
          "resolved": "boolean",
          "references": {}
        }
      }, {
        "method": "rowsSelected",
        "name": "rowsSelected",
        "bubbles": true,
        "cancelable": true,
        "composed": true,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "string: If the `selectionmode` allows a single selection the event will delegate one selected row key."
            }, {
              "name": "value",
              "text": "string[]: If the `selectionmode` allows a multi selection the event will delegate all selected row keys."
            }, {
              "name": "deprecated",
              "text": "Please use the `rowSelected` event of the `<dx-table-row>` components to get notified when a new row was selected."
            }],
          "text": "In case a row is selected this event will fire the key of the row."
        },
        "complexType": {
          "original": "string[]",
          "resolved": "string[]",
          "references": {}
        }
      }];
  }
  static get methods() {
    return {
      "invokeSort": {
        "complexType": {
          "signature": "(element: HTMLDxTableHeaderItemElement, reverse: boolean) => Promise<void>",
          "parameters": [{
              "tags": [],
              "text": ""
            }, {
              "tags": [],
              "text": ""
            }],
          "references": {
            "Promise": {
              "location": "global"
            },
            "HTMLDxTableHeaderItemElement": {
              "location": "global"
            }
          },
          "return": "Promise<void>"
        },
        "docs": {
          "text": "",
          "tags": [{
              "name": "internal",
              "text": undefined
            }]
        }
      }
    };
  }
  static get elementRef() { return "self"; }
  static get watchers() {
    return [{
        "propName": "internalScrollable",
        "methodName": "onInternalScrollableChanged"
      }, {
        "propName": "selectionenabled",
        "methodName": "onSideBarOpenChange"
      }, {
        "propName": "selectionmode",
        "methodName": "onSelectionModeChanged"
      }, {
        "propName": "scrollable",
        "methodName": "onScrollableChange"
      }];
  }
  static get listeners() {
    return [{
        "name": "touchstart",
        "method": "onTouchStart",
        "target": undefined,
        "capture": false,
        "passive": true
      }, {
        "name": "touchmove",
        "method": "onTouchmove",
        "target": undefined,
        "capture": false,
        "passive": true
      }, {
        "name": "touchend",
        "method": "onTouchEnd",
        "target": undefined,
        "capture": true,
        "passive": true
      }];
  }
}
const BORDER_BOTTOM_PROPERTY = "--dx-table-row-border-bottom";
function hasAnySortableColumns(headerItems) {
  return headerItems === null || headerItems === void 0 ? void 0 : headerItems.some((headerItem) => headerItem.sortable);
}
function equalSortSettings(first, second) {
  return first.column === second.column && first.reverse === second.reverse;
}
const EXPANSION_COLUMN_WIDTH = 64;
const SELECTION_COLUMN_WIDTH = 56;
