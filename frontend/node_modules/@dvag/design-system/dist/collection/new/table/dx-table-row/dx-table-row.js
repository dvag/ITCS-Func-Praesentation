import { forceUpdate, h, Host, writeTask, } from "@stencil/core";
import { isSlotDefined } from "../../../classes/render-util";
import { ElementIdGenerator } from "../../../classes/element-id-handling";
import { findClosestScrollElement, findUpperElement, } from "../../../classes/misc-util";
import { containsExpandableRows, showStickyContainer } from "../table.util";
import { BreakpointAware } from "../../../classes/breakpoint-aware";
/**
 * A table row which represents a data object within an array.
 * It renders `<dx-table-cell>` components in a row.
 *
 * @path /Table
 * @name Table Row
 * @shortname Row
 * @icon grip-lines
 * @stable
 *
 *
 * @slot `<dx-table-cell>` elements which are aligned dependant on the outer table columns.
 * @slot content - The content which is placed inside the row. When defined, a collapsable button is displayed which triggers the visibility of the content.
 * @slot-example content
 */
export class DxTableRow {
  constructor() {
    this.tableScrollChanged = (e) => {
      this.tableScrollable = e.detail;
    };
    this.expansionChangedHandler = (e) => {
      this.showExpandColumn = e.detail;
    };
    this.selectionChangedHandler = (e) => {
      this.showSelectionColumn = e.detail.enabled;
      this.selectionMode = e.detail.mode;
    };
    this.open = false;
    this.showExpandColumn = false;
    this.showSelectionColumn = false;
    this.tableScrollable = false;
    this.selectionMode = "multi";
    this.mediaQueryAllowsStickyness = false;
    /**
     * @internal
     */
    this.visible = true;
  }
  onRowSelected() {
    this.rowSelected.emit(this.selected);
  }
  connectedCallback() {
    this.breakpointAware = new BreakpointAware(() => this.updateMediaQueryStickyness(), true);
    this.table = findUpperElement(this.self, "dx-table");
    this.table.addEventListener("expansionChanged", this.expansionChangedHandler);
    this.table.addEventListener("selectionStateChanged", this.selectionChangedHandler);
    this.table.addEventListener("internalScrollChanged", this.tableScrollChanged);
    this.tableScrollable = this.table.internalScrollable;
    this.showSelectionColumn = this.table.selectionenabled;
    this.selectionMode = this.table.selectionmode;
    this.showExpandColumn = containsExpandableRows(this.table);
    this.updateMediaQueryStickyness();
  }
  disconnectedCallback() {
    this.table.removeEventListener("expansionChanged", this.expansionChangedHandler);
    this.table.removeEventListener("internalScrollChanged", this.tableScrollChanged);
    this.table.removeEventListener("selectionStateChanged", this.selectionChangedHandler);
    this.breakpointAware.disconnect();
  }
  showStickyContainer() {
    return showStickyContainer(this.tableScrollable, this.showExpandColumn, this.showSelectionColumn, this.mediaQueryAllowsStickyness, () => isSlotDefined(this.self, "sticky"));
  }
  updateMediaQueryStickyness() {
    this.mediaQueryAllowsStickyness = this.breakpointAware.getEffectiveValue({
      mq1: false,
      mq3: true,
    });
  }
  handleGrowBoxStateChanged(e) {
    // We have to listen to the grow-box state changed event because the overflow hidden style of the simple-grow-box
    // disabled the sticky ability of the sticky-space. That's why we update the left position of the sticky-space
    // while the content is animating.
    const stickySpace = this.self.shadowRoot.querySelector(".sticky-space");
    if (stickySpace == null) {
      return;
    }
    const getLeft = () => {
      return new Promise((resolve) => {
        var _a;
        if (e.detail === "closing" || e.detail === "opening") {
          const closestScrollElement = findClosestScrollElement(this.self);
          // We cannot use readTask here because the style doesn't update fast enough.
          resolve((_a = closestScrollElement === null || closestScrollElement === void 0 ? void 0 : closestScrollElement.scrollLeft) !== null && _a !== void 0 ? _a : 0);
          return;
        }
        resolve(0);
      });
    };
    getLeft().then((left) => {
      writeTask(() => {
        stickySpace.style.left = left + "px";
      });
    });
  }
  renderStickyColumn(mode) {
    const isInStickyContainer = this.tableScrollable && this.mediaQueryAllowsStickyness;
    if (mode === "sticky" && !isInStickyContainer) {
      return null;
    }
    if (mode === "default" && isInStickyContainer) {
      return null;
    }
    return (h("slot", { name: "sticky", onSlotchange: () => {
        forceUpdate(this.self);
      } }));
  }
  renderStickyColumns(containsContent, stickyEnabled) {
    return (h("div", { class: { sticky: true, visible: stickyEnabled } }, h("div", { class: {
        "collapsable-button-container": true,
        "expand-cell": true,
      } }, containsContent ? (h("button", { class: {
        "collapsable-button": true,
      } }, h("dx-chevron", { directiontop: this.open }))) : null), h("dx-table-cell", { type: "html", class: "selection-cell" }, this.renderSelectionInput()), this.renderStickyColumn("sticky")));
  }
  renderSelectionInput() {
    if (this.selectionMode === "single") {
      if (this.rowid != null) {
        return (h("dx-radio-button", { id: ElementIdGenerator.createId(this.self, "selection"), groupid: "table-selection-group", disabled: !this.visible, onClick: (e) => e.stopPropagation(), value: this.rowid, onInternalCheckedChange: (e) => {
            this.selected = e.detail;
          } }));
      }
    }
    return (h("dx-checkbox", { id: ElementIdGenerator.createId(this.self, "selection"), onClick: (e) => e.stopPropagation(), onCheckedChange: (e) => {
        this.selected = e.detail;
      }, checked: this.selected }));
  }
  render() {
    const containsContent = isSlotDefined(this.self, "content");
    const stickyEnabled = this.showStickyContainer();
    return (h(Host, { class: {
        visible: this.visible,
      }, role: "row" }, h("div", { class: {
        "table-row-container": true,
      } }, h("div", { class: {
        "table-row": true,
        "has-content": containsContent,
      }, onClick: () => {
        this.open = !this.open;
      } }, this.renderStickyColumns(containsContent, stickyEnabled), this.renderStickyColumn("default"), h("slot", null)), containsContent ? (h("dx-simple-grow-box", { open: this.open, onGrowBoxStateChange: (e) => {
        this.handleGrowBoxStateChanged(e);
      } }, h("div", { class: "content-container" }, h("div", { class: {
        "sticky-space": true,
        visible: stickyEnabled,
      } }), h("div", { class: "content" }, h("slot", { name: "content" }))))) : null)));
  }
  static get is() { return "dx-table-row"; }
  static get encapsulation() { return "shadow"; }
  static get originalStyleUrls() {
    return {
      "$": ["dx-table-row.scss"]
    };
  }
  static get styleUrls() {
    return {
      "$": ["dx-table-row.css"]
    };
  }
  static get properties() {
    return {
      "visible": {
        "type": "boolean",
        "mutable": false,
        "complexType": {
          "original": "boolean",
          "resolved": "boolean",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "internal",
              "text": undefined
            }],
          "text": ""
        },
        "attribute": "visible",
        "reflect": true,
        "defaultValue": "true"
      },
      "rowid": {
        "type": "string",
        "mutable": false,
        "complexType": {
          "original": "string",
          "resolved": "string",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "string: Unique identifier"
            }],
          "text": "A unique identifier for the data this row displays in a table."
        },
        "attribute": "rowid",
        "reflect": true
      },
      "selected": {
        "type": "boolean",
        "mutable": true,
        "complexType": {
          "original": "boolean",
          "resolved": "boolean",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "true: Row is selected."
            }, {
              "name": "value",
              "text": "false: Row is not selected."
            }, {
              "name": "example",
              "text": "selection"
            }],
          "text": "Selects this row.\nIf true the row will be selected and the table's selection will be enabled."
        },
        "attribute": "selected",
        "reflect": true
      }
    };
  }
  static get states() {
    return {
      "open": {},
      "showExpandColumn": {},
      "showSelectionColumn": {},
      "tableScrollable": {},
      "selectionMode": {},
      "mediaQueryAllowsStickyness": {}
    };
  }
  static get events() {
    return [{
        "method": "rowSelected",
        "name": "rowSelected",
        "bubbles": true,
        "cancelable": true,
        "composed": true,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "boolean: Row is selected or not."
            }],
          "text": "Fired when the selection-status of the row is changed."
        },
        "complexType": {
          "original": "boolean",
          "resolved": "boolean",
          "references": {}
        }
      }];
  }
  static get elementRef() { return "self"; }
  static get watchers() {
    return [{
        "propName": "selected",
        "methodName": "onRowSelected"
      }];
  }
}
