import { forceUpdate, h, Host, } from "@stencil/core";
import { ElementIdGenerator } from "../../../classes/element-id-handling";
import { createMetaComponentsSlotObserver, } from "../../../classes/slot-observer";
import { assert, assertPropertyValue } from "../../../classes/assert";
import { isPositiveInteger } from "../../../classes/math-util";
/**
 * A menu which holds multiple `<dx-overflow-menu-item>` elements to perform specific actions within a specific application context.
 *
 * @path /Miscellaneous
 * @name Overflow Menu
 * @shortname Menu
 * @icon ellipsis-h
 * @stable
 */
export class DxOverflowMenu {
  constructor() {
    /**
     * The alignment defines in which direction the menu button aligns.
     *
     * @value left: The menu button is displayed on the left and the list anchors on the left of the button.
     * @value right: The menu button is displayed on the right and the list anchors on the right of the button.
     *
     * @example align
     */
    this.align = "left";
    /**
     * Defines whether the user is able to select only one or multiple menu items.
     *
     * @value single: The user can select only one menu-item which immediately closes the flyout.
     * @value multi: The user is able to select multiple menu items.
     *
     * @example selection-mode
     */
    this.selectionmode = "single";
    /**
     * Defines the maximum number of selected menu-item labels the menu displays.
     * This property only has an effect if the `selectionmode` is `multi`.
     *
     * @value number: A number greater than zero which defines the upper limit of labels being displayed in the menu.
     * @value undefined: All selected labels are displayed in the menu.
     * @example max-labels
     */
    this.maxlabels = 1;
    this.listOpen = false;
  }
  onListOpenChanged() {
    this.listOpenChange.emit({
      isOpen: this.listOpen,
    });
  }
  connectedCallback() {
    this.menuItemsObserver =
      createMetaComponentsSlotObserver(this.self, "dx-overflow-menu-item", async (nodes) => {
        await this.collectMenuItems(nodes);
        this.updateInternalLabel();
      });
  }
  disconnectedCallback() {
    this.menuItemsObserver.disconnect();
  }
  componentWillRender() {
    assert(this.maxselections == null || isPositiveInteger(this.maxselections), () => "The `maxselections` property has to be a natural number greater than zero ([1,2,3,...]) or undefined.", this.self);
    assert(this.maxlabels == null || isPositiveInteger(this.maxlabels), () => "The `maxlabels` property has to be a natural number greater than zero ([1,2,3,...]) or undefined.", this.self);
    assertPropertyValue("dx-overflow-menu", "selectionmode", this.selectionmode, ["single", "multi"], this.self);
  }
  onItemSelectionChange(e) {
    var _a;
    e.stopPropagation();
    const selectedValues = (_a = e.detail) === null || _a === void 0 ? void 0 : _a.selectedItems;
    this.emitSelection(selectedValues);
    if (this.selectionmode === "single") {
      this.listOpen = false;
    }
    this.updateMenuItems(selectedValues);
    this.updateInternalLabel();
  }
  updateMenuItems(selectedValues) {
    this.menuItems.forEach((menuItem) => {
      menuItem.setSelected(selectedValues.find((value) => value === menuItem.value) != null);
    });
  }
  // Computes the internalLabel dependent on the provided selected values
  updateInternalLabel() {
    if (this.selectionmode === "single") {
      this.internalLabel = ""; // Reset internalLabel just in case
    }
    else if (this.selectionmode === "multi") {
      this.internalLabel = this.computeInternalLabel();
    }
  }
  computeInternalLabel() {
    const selectedMenuItemValues = this.menuItems
      .filter((menuItem) => menuItem.selected)
      .map((menuItem) => menuItem.value);
    const currentLabels = selectedMenuItemValues
      .map((value) => {
      return this.menuItems.find((menuItem) => menuItem.value === value);
    })
      .map((menuItem) => menuItem.label);
    const displayValues = currentLabels.slice(0, this.maxlabels);
    const diff = selectedMenuItemValues.length - displayValues.length;
    const joinSeparator = ", ";
    if (diff === 0) {
      return displayValues.join(joinSeparator);
    }
    return displayValues.join(joinSeparator) + ` (+${diff})`;
  }
  emitSelection(values) {
    const emittedValue = this.selectionmode === "single" ? values[0] : values;
    this.selection.emit({
      value: emittedValue,
    });
  }
  async collectMenuItems(menuItems) {
    this.menuItems = await Promise.all(menuItems.map((menuItem) => menuItem.toOverflowMenuItem()));
  }
  onInputKeyDown(event) {
    const listFlyoutElement = this.self.shadowRoot.querySelector("dx-list-flyout");
    if (event.target === listFlyoutElement) {
      return;
    }
    if ((listFlyoutElement === null || listFlyoutElement === void 0 ? void 0 : listFlyoutElement.open) && event.code !== "Tab") {
      // If the flyout is open we want to prevent all keyboard inputs and delegate it to the list flyout.
      event.preventDefault();
      listFlyoutElement === null || listFlyoutElement === void 0 ? void 0 : listFlyoutElement.dispatchEvent(new event.constructor(event.type, event));
    }
    else if (event.code === "ArrowDown") {
      this.listOpen = true;
    }
  }
  renderButtonIconSlot() {
    var _a, _b;
    if (((_a = this.internalLabel) === null || _a === void 0 ? void 0 : _a.length) > 0 || ((_b = this.label) === null || _b === void 0 ? void 0 : _b.length) > 0) {
      return (h("dx-chevron", { size: 24, slot: "icon", directiontop: this.listOpen }));
    }
    else {
      return (h("dx-element-swapper", { active: this.listOpen ? "second" : "first", slot: "icon" }, h("dx-icon", { icon: "ueberlauf-menue", slot: "first", size: 24 }), h("dx-icon", { icon: "schliessen", slot: "second", size: 24 })));
    }
  }
  renderTextButton() {
    return (h("dx-button", { id: ElementIdGenerator.createId(this.self, "menu-button"), class: {
        "simulate-active": this.listOpen,
      }, onKeyDown: (e) => this.onInputKeyDown(e), type: "text", slot: "base", label: this.internalLabel || this.label, onClick: () => (this.listOpen = !this.listOpen), iconposition: "right" }, this.renderButtonIconSlot()));
  }
  render() {
    var _a, _b;
    return (h(Host, { onBlur: () => {
        this.listOpen = false;
      }, class: {
        "align-right": this.align === "right",
        "mock-list-item-width": (_a = this.menuItems) === null || _a === void 0 ? void 0 : _a.some((menuItem) => { var _a; return ((_a = menuItem.icon) === null || _a === void 0 ? void 0 : _a.length) > 0; }),
      } }, this.renderTextButton(), h("dx-list-flyout", { class: "list-flyout", open: this.listOpen, direction: this.align === "left" ? "right" : "left", itemsvisible: 5.5, size: "m", selectionmode: this.selectionmode, selectonhighlight: false, clearselectiononclose: this.selectionmode === "single", maxselections: this.maxselections, ref: (ref) => forceUpdate(ref) }, (_b = this.menuItems) === null || _b === void 0 ? void 0 : _b.map((item, index) => {
      var _a;
      return (h("dx-list-item", { id: (_a = ElementIdGenerator.createIdFromString(item.id, "list-item")) !== null && _a !== void 0 ? _a : ElementIdGenerator.createId(this.self, `list-item-${index}`), label: item.label, value: item.value, icon: item.icon, selected: item.selected, type: this.selectionmode === "single" ? "clickable" : "checkbox" }));
    }))));
  }
  static get is() { return "dx-overflow-menu"; }
  static get encapsulation() { return "shadow"; }
  static get originalStyleUrls() {
    return {
      "$": ["dx-overflow-menu.scss"]
    };
  }
  static get styleUrls() {
    return {
      "$": ["dx-overflow-menu.css"]
    };
  }
  static get properties() {
    return {
      "label": {
        "type": "string",
        "mutable": false,
        "complexType": {
          "original": "string",
          "resolved": "string",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "string: The text."
            }, {
              "name": "example",
              "text": "label"
            }],
          "text": "The text which is displayed instead of the menu icon."
        },
        "attribute": "label",
        "reflect": false
      },
      "align": {
        "type": "string",
        "mutable": false,
        "complexType": {
          "original": "HorizontalDirection",
          "resolved": "\"left\" | \"right\"",
          "references": {
            "HorizontalDirection": {
              "location": "import",
              "path": "../../../classes/common-types"
            }
          }
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "left: The menu button is displayed on the left and the list anchors on the left of the button."
            }, {
              "name": "value",
              "text": "right: The menu button is displayed on the right and the list anchors on the right of the button."
            }, {
              "name": "example",
              "text": "align"
            }],
          "text": "The alignment defines in which direction the menu button aligns."
        },
        "attribute": "align",
        "reflect": false,
        "defaultValue": "\"left\""
      },
      "selectionmode": {
        "type": "string",
        "mutable": false,
        "complexType": {
          "original": "ListFlyoutSelectionMode",
          "resolved": "\"multi\" | \"single\"",
          "references": {
            "ListFlyoutSelectionMode": {
              "location": "import",
              "path": "../../layout/dx-list/dx-list-flyout/dx-list-flyout"
            }
          }
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "single: The user can select only one menu-item which immediately closes the flyout."
            }, {
              "name": "value",
              "text": "multi: The user is able to select multiple menu items."
            }, {
              "name": "example",
              "text": "selection-mode"
            }],
          "text": "Defines whether the user is able to select only one or multiple menu items."
        },
        "attribute": "selectionmode",
        "reflect": false,
        "defaultValue": "\"single\""
      },
      "maxselections": {
        "type": "number",
        "mutable": false,
        "complexType": {
          "original": "number",
          "resolved": "number",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "number: A number greater than zero which defines the upper limit of menu items being able to be selected."
            }, {
              "name": "value",
              "text": "undefined: The user is able to select all menu items."
            }, {
              "name": "example",
              "text": "max-selections"
            }],
          "text": "Defines the maximum number of menu items the user is able to select.\nThis property only has an effect if the `selectionmode` is `multi`."
        },
        "attribute": "maxselections",
        "reflect": false
      },
      "maxlabels": {
        "type": "number",
        "mutable": false,
        "complexType": {
          "original": "number",
          "resolved": "number",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "number: A number greater than zero which defines the upper limit of labels being displayed in the menu."
            }, {
              "name": "value",
              "text": "undefined: All selected labels are displayed in the menu."
            }, {
              "name": "example",
              "text": "max-labels"
            }],
          "text": "Defines the maximum number of selected menu-item labels the menu displays.\nThis property only has an effect if the `selectionmode` is `multi`."
        },
        "attribute": "maxlabels",
        "reflect": false,
        "defaultValue": "1"
      }
    };
  }
  static get states() {
    return {
      "menuItems": {},
      "internalLabel": {},
      "listOpen": {}
    };
  }
  static get events() {
    return [{
        "method": "selection",
        "name": "selection",
        "bubbles": true,
        "cancelable": true,
        "composed": true,
        "docs": {
          "tags": [{
              "name": "example",
              "text": "selection"
            }, {
              "name": "example",
              "text": "selection-complex"
            }],
          "text": "Fires when the user selects a menu item.\nThe event payload consists of a `SelectionPayload` object which contains a `value` property, being either a string, an object.\nWhen the `selectionmode` equals `multi` the omitted `value` within the `SelectionPayload` is an array of strings and objects."
        },
        "complexType": {
          "original": "SelectionPayload",
          "resolved": "SelectionPayload",
          "references": {
            "SelectionPayload": {
              "location": "local"
            }
          }
        }
      }, {
        "method": "listOpenChange",
        "name": "listOpenChange",
        "bubbles": true,
        "cancelable": true,
        "composed": true,
        "docs": {
          "tags": [{
              "name": "example",
              "text": "list-open-change"
            }],
          "text": "Fires when the list opens.\nThe event payload consists of an `OpenChangePayload` object which contains an `isOpen` property."
        },
        "complexType": {
          "original": "OpenChangePayload",
          "resolved": "OpenChangePayload",
          "references": {
            "OpenChangePayload": {
              "location": "local"
            }
          }
        }
      }];
  }
  static get elementRef() { return "self"; }
  static get watchers() {
    return [{
        "propName": "listOpen",
        "methodName": "onListOpenChanged"
      }];
  }
  static get listeners() {
    return [{
        "name": "itemSelectionChange",
        "method": "onItemSelectionChange",
        "target": undefined,
        "capture": true,
        "passive": false
      }];
  }
}
