import { forceUpdate, h, } from "@stencil/core";
import { SlotObserver } from "../../../../classes/slot-observer";
import { getSlottedContent, tagOf } from "../../../../classes/misc-util";
import { isSlotDefined } from "../../../../classes/render-util";
import { assert } from "../../../../classes/assert";
import { isMenuGroup, isMenuItem, isMenuLink, } from "../header-menu.util";
import { ElementIdGenerator } from "../../../../classes/element-id-handling";
import { getSpacerWidth } from "../../../../classes/sizes.util";
/**
 * Menu bar which holds multiple menu items within the header.
 * @name Header Menu Bar
 * @shortname Menu Bar
 * @path /Scaffold/Header
 *
 * @internal
 */
export class DxHeaderMenuBar {
  constructor() {
    this.navigationInSlot = false;
    this.showSidebar = false;
  }
  onShowSidebarChanged() {
    const sidebarOpenChangeEvent = new CustomEvent(this.showSidebar ? "sidebarOpen" : "sidebarClose", {
      detail: {
        showNavigationItem: this.navigationValueToShowInNavigationMenu,
      },
    });
    this.navigationValueToShowInNavigationMenu = null;
    this.menuItems.forEach((menuItem) => {
      menuItem.internalactive && (menuItem.internalactive = this.showSidebar);
      menuItem.dispatchEvent(sidebarOpenChangeEvent);
    });
    if (this.showSidebar) {
      this.showChildrenOnSidebarOpen();
    }
    else {
      this.updateChildren(this.lastPossibleAvailableSpace).then();
    }
    this.sidebarOpenChange.emit(this.showSidebar);
  }
  connectedCallback() {
    this.menuItemsObserver = new SlotObserver(this.self, "*", () => {
      this.menuItems = this.getAllSlottedMenuItemElements();
      this.handleSlottedNavigationItem();
    });
  }
  disconnectedCallback() {
    var _a;
    (_a = this.menuItemsObserver) === null || _a === void 0 ? void 0 : _a.disconnect();
  }
  async componentWillRender() {
    var _a;
    const renderPromises = (_a = this.menuItems) === null || _a === void 0 ? void 0 : _a.map((menuItem) => {
      var _a, _b;
      return ((_b = (_a = menuItem.renderSidebarContent) === null || _a === void 0 ? void 0 : _a.call(menuItem)) !== null && _b !== void 0 ? _b : (h("slot", { name: menuItem.connectedslot })));
    });
    if (renderPromises == null) {
      this.sidebarContentOutputs = null;
      return;
    }
    this.sidebarContentOutputs = (await Promise.all(renderPromises)).map((output, index) => {
      var _a;
      return (h("dx-content-switcher-item", { value: (_a = this.menuItems[index].connectedslot) !== null && _a !== void 0 ? _a : index }, output));
    });
  }
  onForceSidebarContentUpdate() {
    forceUpdate(this);
  }
  handleOpenSidebar(e) {
    this.showSidebar = e.detail;
  }
  onMenuInteraction(e) {
    if (e.target === this.self) {
      // The navigation element triggered the menuInteraction event
      return;
    }
    const interactedMenuEntry = e.target;
    if (isMenuItem(interactedMenuEntry)) {
      const interactedMenuItem = interactedMenuEntry;
      const currentlyActive = interactedMenuItem.internalactive;
      this.menuItems.forEach((menuItem) => {
        menuItem.internalactive =
          this.menuItemHasSidebarContent(menuItem) &&
            menuItem === interactedMenuItem &&
            !currentlyActive;
      });
      if (interactedMenuItem.internalactive) {
        this.contentSwitcher
          .showValue(interactedMenuItem.connectedslot, this.showSidebar)
          .then();
      }
      this.showSidebar = interactedMenuItem.internalactive;
    }
    else if (isMenuLink(e.target)) {
      const interactedMenuLink = e.target;
      if (this.menuLinkHasNavigationElement(interactedMenuLink)) {
        this.navigationValueToShowInNavigationMenu =
          interactedMenuLink.connectednavigationvalue;
        this.navigationMenuItem.internalactive = true;
        this.contentSwitcher
          .showValue(this.navigationMenuItem.connectedslot, this.showSidebar)
          .then();
        this.showSidebar = true;
      }
    }
  }
  showChildrenOnSidebarOpen() {
    this.getGroupedHeaderMenuEntries().forEach((element) => {
      element.internalopen || (element.internalopen = isMenuItem(element));
    });
    this.navigationMenuItem.internalnotification = false;
  }
  /**
   * @internal
   */
  async updateChildren(possibleAvailableSpace) {
    this.lastPossibleAvailableSpace = Math.floor(possibleAvailableSpace);
    const sortedMenuEntries = this.getGroupedHeaderMenuEntries()
      .sort((first, second) => (second.priority || Number.POSITIVE_INFINITY) -
      (first.priority || Number.POSITIVE_INFINITY))
      .reverse();
    if (sortedMenuEntries.length === 0) {
      return;
    }
    let accumulatedWidth = 0;
    let showNotificationInNavigation = false;
    let navigationNotificationsTheme = null;
    const updateNavigationProperties = (menuitem) => {
      navigationNotificationsTheme = calculateTheme(menuitem, navigationNotificationsTheme);
      showNotificationInNavigation || (showNotificationInNavigation = menuItemHasNotifications(menuitem));
    };
    const slottedContent = getSlottedContent(this.self);
    for (const sortedMenuEntry of sortedMenuEntries) {
      const defaultWidth = await sortedMenuEntry.getDefaultWidth();
      accumulatedWidth += defaultWidth;
      const spacerToTheRight = this.getSpacerToTheRight(sortedMenuEntry, slottedContent);
      accumulatedWidth += getSpacerWidth(spacerToTheRight);
      const enoughSpaceLeft = accumulatedWidth <= this.lastPossibleAvailableSpace;
      sortedMenuEntry.internalopen =
        enoughSpaceLeft || (this.showSidebar && isMenuItem(sortedMenuEntry));
      this.updateSpacerVisibility(spacerToTheRight, enoughSpaceLeft);
      if (!showNotificationInNavigation && !sortedMenuEntry.internalopen) {
        if (isHeaderMenuGroup(sortedMenuEntry)) {
          const menuItems = await sortedMenuEntry.getInnerMenuItems();
          menuItems.forEach((menuItem) => {
            updateNavigationProperties(menuItem);
          });
        }
        else if (isMenuItem(sortedMenuEntry)) {
          updateNavigationProperties(sortedMenuEntry);
        }
      }
    }
    if (this.navigationMenuItem) {
      this.navigationMenuItem.internalnotification =
        showNotificationInNavigation;
      this.navigationMenuItem.internalnotificationstheme =
        navigationNotificationsTheme;
    }
  }
  updateSpacerVisibility(spacerToTheRight, enoughSpaceLeft) {
    if (spacerToTheRight) {
      spacerToTheRight.style.transition =
        "width var(--dx-header-hide-animation-duration) ease-in-out";
      spacerToTheRight.style.width = enoughSpaceLeft
        ? getSpacerWidth(spacerToTheRight) + "px"
        : "0";
    }
  }
  getSpacerToTheRight(sortedMenuElement, slottedContent) {
    const menuItemIndex = slottedContent.indexOf(sortedMenuElement);
    if (menuItemIndex >= 0 && slottedContent.length > menuItemIndex + 1) {
      const elementToTheRight = slottedContent[menuItemIndex + 1];
      return tagOf(elementToTheRight) === "dx-spacer"
        ? elementToTheRight
        : null;
    }
    return null;
  }
  getAllSlottedMenuItemElements() {
    return getSlottedContent(this.self)
      .filter((node) => isValidHeaderComponentTag(node.tagName))
      .map((menuItem, index) => {
      var _a;
      if (isMenuItem(menuItem)) {
        (_a = menuItem.connectedslot) !== null && _a !== void 0 ? _a : (menuItem.connectedslot = index.toString());
        return menuItem;
      }
      if (isMenuGroup(menuItem)) {
        return getSlottedContent(menuItem);
      }
    })
      .filter((element) => !!element)
      .flat();
  }
  handleSlottedNavigationItem() {
    const navigationMenuItem = this.menuItems.find((menuItem) => tagOf(menuItem) === "dx-header-navigation");
    this.navigationInSlot = navigationMenuItem != null;
    // If there already is a navigation defined we want to reorder the menuItems array.
    if (this.navigationInSlot) {
      this.navigationMenuItem = navigationMenuItem;
      assert(this.menuItems.indexOf(this.navigationMenuItem) ===
        this.menuItems.length - 1, () => "The <dx-header-navigation> has to be the last menu item integrated into the <dx-header> element. This has to be ensured because of the tab order and accessibility reasons.", this.navigationMenuItem);
    }
    else if (this.navigationMenuItem != null) {
      this.menuItems.push(this.navigationMenuItem);
    }
  }
  menuItemHasSidebarContent(menuItem) {
    var _a;
    return (menuItem.renderSidebarContent != null ||
      (((_a = menuItem.connectedslot) === null || _a === void 0 ? void 0 : _a.length) > 0 &&
        isSlotDefined(this.self, menuItem.connectedslot)));
  }
  menuLinkHasNavigationElement(menuItem) {
    var _a;
    return (((_a = menuItem.connectednavigationvalue) === null || _a === void 0 ? void 0 : _a.length) > 0 &&
      menuItem.label &&
      getSlottedContent(this.navigationMenuItem).some((element) => element.value === menuItem.connectednavigationvalue));
  }
  getGroupedHeaderMenuEntries() {
    return getSlottedContent(this.self)
      .filter((element) => {
      return isValidHeaderComponentTag(element.tagName);
    })
      .concat(this.navigationInSlot || this.menuItems.length === 0
      ? []
      : this.menuItems[this.menuItems.length - 1]);
  }
  renderHeaderNavigation() {
    var _a, _b;
    if (this.navigationInSlot || ((_b = (_a = this.menuItems) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0) == 0) {
      return;
    }
    return (h("dx-header-navigation", { id: ElementIdGenerator.createId(this.self, "navigation"), onMenuInteraction: (e) => this.onMenuInteraction(e), class: { "header-navigation": true }, ref: (ref) => requestAnimationFrame(() => {
        this.navigationMenuItem = ref;
        this.navigationMenuItem.connectedslot = "dx-internal-navigation";
        if (!this.menuItems.includes(this.navigationMenuItem)) {
          this.menuItems.push(this.navigationMenuItem);
        }
      }) }));
  }
  render() {
    return [
      h("div", { class: "menu-bar" }, h("slot", null), this.renderHeaderNavigation()),
      h("dx-sidebar", { open: this.showSidebar, onOpenChange: (e) => (this.showSidebar = e.detail) }, h("dx-content-switcher", { ref: (ref) => (this.contentSwitcher = ref) }, this.sidebarContentOutputs)),
    ];
  }
  static get is() { return "dx-header-menu-bar"; }
  static get encapsulation() { return "shadow"; }
  static get originalStyleUrls() {
    return {
      "$": ["dx-header-menu-bar.scss"]
    };
  }
  static get styleUrls() {
    return {
      "$": ["dx-header-menu-bar.css"]
    };
  }
  static get states() {
    return {
      "navigationMenuItem": {},
      "navigationInSlot": {},
      "showSidebar": {}
    };
  }
  static get events() {
    return [{
        "method": "sidebarOpenChange",
        "name": "sidebarOpenChange",
        "bubbles": true,
        "cancelable": true,
        "composed": true,
        "docs": {
          "tags": [],
          "text": ""
        },
        "complexType": {
          "original": "boolean",
          "resolved": "boolean",
          "references": {}
        }
      }];
  }
  static get methods() {
    return {
      "updateChildren": {
        "complexType": {
          "signature": "(possibleAvailableSpace: number) => Promise<void>",
          "parameters": [{
              "tags": [],
              "text": ""
            }],
          "references": {
            "Promise": {
              "location": "global"
            },
            "MenuEntry": {
              "location": "import",
              "path": "../header-menu.util"
            },
            "NotificationIndicatorThemeType": {
              "location": "import",
              "path": "../../../internal/dx-notification-indicator/notification-indicator.util"
            },
            "MenuItemElement": {
              "location": "import",
              "path": "../header-menu.util"
            }
          },
          "return": "Promise<void>"
        },
        "docs": {
          "text": "",
          "tags": [{
              "name": "internal",
              "text": undefined
            }]
        }
      }
    };
  }
  static get elementRef() { return "self"; }
  static get watchers() {
    return [{
        "propName": "showSidebar",
        "methodName": "onShowSidebarChanged"
      }];
  }
  static get listeners() {
    return [{
        "name": "internalForceSidebarContentUpdate",
        "method": "onForceSidebarContentUpdate",
        "target": undefined,
        "capture": false,
        "passive": false
      }, {
        "name": "internalChangeSidebarVisibility",
        "method": "handleOpenSidebar",
        "target": undefined,
        "capture": false,
        "passive": false
      }, {
        "name": "menuInteraction",
        "method": "onMenuInteraction",
        "target": undefined,
        "capture": false,
        "passive": false
      }];
  }
}
function calculateTheme(item, theme) {
  var _a;
  if (theme !== "system" && menuItemHasNotifications(item)) {
    return (_a = item.notificationstheme) !== null && _a !== void 0 ? _a : theme;
  }
  return theme;
}
function isHeaderMenuGroup(element) {
  return element.tagName.toLowerCase() === "dx-header-menu-group";
}
function isValidHeaderComponentTag(tagName) {
  return tagName.toLowerCase().startsWith("dx-header-");
}
function menuItemHasNotifications(menuItem) {
  return (menuItem.notification ||
    menuItem.notifications === "no-number" ||
    menuItem.notifications >= 1);
}
