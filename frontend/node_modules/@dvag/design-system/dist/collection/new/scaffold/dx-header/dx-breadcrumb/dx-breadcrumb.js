import { Fragment, h, Host, } from "@stencil/core";
import { onNextFrame } from "../../../../classes/render-util";
import { SlotObserver } from "../../../../classes/slot-observer";
/**
 * The breadcrumb allows for easy overview and navigation within the applications header.
 *
 * @path /Scaffold/Header
 * @name Breadcrumb
 * @shortname Breadcrumb
 * @icon road
 * @stable
 */
export class DxBreadcrumb {
  constructor() {
    this.renderHomeIcon = true;
    this.items = [];
    this.renderModel = [];
  }
  connectedCallback() {
    this.itemObserver = new SlotObserver(this.self, "dx-breadcrumb-item", async (nodes) => {
      await this.collectOptions(nodes);
    });
    this.measurementResizeObserver = new ResizeObserver(() => {
      this.measureBreadcrumbParts();
    });
  }
  componentDidRender() {
    this.measureBreadcrumbParts();
  }
  disconnectedCallback() {
    var _a, _b;
    (_a = this.itemObserver) === null || _a === void 0 ? void 0 : _a.disconnect();
    (_b = this.measurementResizeObserver) === null || _b === void 0 ? void 0 : _b.disconnect();
  }
  onResize() {
    this.updateModel();
  }
  async collectOptions(nodes) {
    return Promise.all(nodes.map((node) => {
      return node.toItem();
    })).then((nodes) => {
      this.items = nodes;
    });
  }
  updateModel() {
    var _a;
    const breadcrumbContainerWidth = (_a = this.breadcrumbContainer) === null || _a === void 0 ? void 0 : _a.clientWidth;
    const totalItemWidth = this.calculateItemWidth();
    const breadcrumbsFit = totalItemWidth <= breadcrumbContainerWidth;
    this.renderHomeIcon = breadcrumbsFit;
    if (breadcrumbsFit) {
      this.renderModel = this.items;
    }
    else {
      onNextFrame(() => {
        this.renderModel = this.calculateRemainingItems(breadcrumbContainerWidth);
      });
    }
  }
  calculateRemainingItems(breadcrumbContainerWidth) {
    let itemWidth = this.calculateItemWidth();
    const remainingItems = Array.from(this.items);
    while (itemWidth - HOME_AND_DOTS_WIDTH_DIFFERENCE > breadcrumbContainerWidth &&
      remainingItems.length > 1) {
      remainingItems.shift();
      const skippedElements = (this.items.length + HOME_OR_DOTS_OFFSET - remainingItems.length) *
        HTML_ELEMENTS_PER_LOGICAL_BUTTON;
      itemWidth = this.calculateItemWidth(skippedElements);
    }
    return remainingItems;
  }
  measureBreadcrumbParts() {
    if (this.totalItemWidth === this.calculateItemWidth()) {
      return;
    }
    onNextFrame(() => {
      this.updateModel();
      this.totalItemWidth = this.calculateItemWidth();
    });
  }
  calculateItemWidth(elementsToSkip = 0) {
    var _a, _b, _c;
    const measurementBoxChildren = Array.from((_c = (_b = (_a = this.measurementBox) === null || _a === void 0 ? void 0 : _a.children[0]) === null || _b === void 0 ? void 0 : _b.children) !== null && _c !== void 0 ? _c : []);
    const spliced = measurementBoxChildren.splice(elementsToSkip);
    const totalWidth = spliced.reduce((prev, curr) => prev + curr.clientWidth, 0);
    const widthForDotsTextOrHomeIcon = elementsToSkip > 0 ? 48 : 0;
    return totalWidth + widthForDotsTextOrHomeIcon;
  }
  setMeasurementBox(measurementBox) {
    if (measurementBox !== this.measurementBox) {
      this.measurementResizeObserver.disconnect();
      this.measurementResizeObserver.observe(measurementBox);
      this.measurementBox = measurementBox;
      requestAnimationFrame(() => {
        this.totalItemWidth = this.calculateItemWidth();
      });
    }
  }
  renderBreadcrumb() {
    return [
      this.renderHomeIcon ? this.renderHomePart() : this.renderDots(),
      this.renderBreadcrumbItems(this.renderModel),
    ];
  }
  renderBreadcrumbItems(items) {
    return items.map((item, index) => {
      return this.renderBreadcrumbItem(item, items.length === 1, index === items.length - 1);
    });
  }
  renderBreadcrumbItem(item, textEllipsis = false, lastItem = false) {
    if (!lastItem) {
      return (h(Fragment, null, h("div", { class: { "breadcrumb-item": true, "with-label": true } }, h("button", { class: "breadcrumb-item-button", onClick: () => this.navigate.emit(item.value) }, this.renderBreadcrumbItemText(textEllipsis, item))), this.renderChevron()));
    }
    else {
      return (h("div", { class: { "breadcrumb-item": true, ellipsis: textEllipsis } }, this.renderBreadcrumbItemText(textEllipsis, item)));
    }
  }
  renderBreadcrumbItemText(textEllipsis, item) {
    return (h("dx-text", { type: "Infotext-Small", class: { "ellipsis-text": textEllipsis } }, item.label));
  }
  renderHomePart() {
    return (h(Fragment, null, h("div", { class: { "breadcrumb-item": true, "with-home-icon": true } }, h("button", { class: "breadcrumb-item-button", onClick: () => this.navigateHome.emit() }, h("dx-icon", { class: "home-icon", icon: "home", size: 16 }))), this.renderChevron()));
  }
  renderDots() {
    var _a;
    const previousItem = this.items.length - this.renderModel.length - 1;
    const navigateValue = (_a = this.items[previousItem]) === null || _a === void 0 ? void 0 : _a.value;
    return (h(Fragment, null, h("div", { class: { "breadcrumb-item": true, "with-dots": true } }, h("button", { class: "breadcrumb-item-button", onClick: () => {
        if (previousItem >= 0) {
          this.navigate.emit(navigateValue);
        }
        else {
          this.navigateHome.emit();
        }
      } }, h("dx-text", { type: "Infotext-Small", key: "ellipse" }, "..."))), this.renderChevron()));
  }
  renderChevron() {
    return h("dx-icon", { class: "chevron-icon", icon: "chevron-rechts", size: 16 });
  }
  render() {
    return (h(Host, null, h("div", { class: "item-measurement-box", ref: (ref) => {
        this.setMeasurementBox(ref);
      } }, h("div", { class: "breadcrumb-parts-container" }, this.renderHomePart(), this.renderBreadcrumbItems(this.items))), h("div", { ref: (ref) => (this.breadcrumbContainer = ref), class: "width-measurement-box" }, h("div", { class: "breadcrumb-parts-container" }, this.renderBreadcrumb()))));
  }
  static get is() { return "dx-breadcrumb"; }
  static get encapsulation() { return "shadow"; }
  static get originalStyleUrls() {
    return {
      "$": ["dx-breadcrumb.scss"]
    };
  }
  static get styleUrls() {
    return {
      "$": ["dx-breadcrumb.css"]
    };
  }
  static get states() {
    return {
      "items": {},
      "totalItemWidth": {},
      "renderModel": {}
    };
  }
  static get events() {
    return [{
        "method": "navigateHome",
        "name": "navigateHome",
        "bubbles": true,
        "cancelable": true,
        "composed": true,
        "docs": {
          "tags": [{
              "name": "example",
              "text": "navigation"
            }],
          "text": "Fired when the user interacts with this item."
        },
        "complexType": {
          "original": "void",
          "resolved": "void",
          "references": {}
        }
      }, {
        "method": "navigate",
        "name": "navigate",
        "bubbles": true,
        "cancelable": true,
        "composed": true,
        "docs": {
          "tags": [{
              "name": "example",
              "text": "navigation"
            }],
          "text": "Fired when the user interacts with a breadcrumb item.\nAs event payload (`event.detail`) the value of the interacted item is supplied."
        },
        "complexType": {
          "original": "string",
          "resolved": "string",
          "references": {}
        }
      }];
  }
  static get elementRef() { return "self"; }
  static get listeners() {
    return [{
        "name": "resize",
        "method": "onResize",
        "target": "window",
        "capture": false,
        "passive": true
      }];
  }
}
const HOME_AND_DOTS_WIDTH_DIFFERENCE = 4;
const HOME_OR_DOTS_OFFSET = 1;
const HTML_ELEMENTS_PER_LOGICAL_BUTTON = 2; // Each button has a chevron, so we need to compute with 2 html elements for each
