import { h, Host, } from "@stencil/core";
import { SlotObserver } from "../../../classes/slot-observer";
import { findUpperElement, tagOf } from "../../../classes/misc-util";
/**
 * Collapses and unfolds the content of a card.
 *
 * @path /Card
 * @name Card Collapsable
 * @shortname Collapsable
 * @icon hand-pointer
 * @stable
 */
export class DxCardCollapsable {
  constructor() {
    /**
     * The current collapse state.
     *
     * @value false: The card is collapsed.
     * @value true: The card is unfolded.
     *
     * @example open
     */
    this.open = false;
    this.animationState = "closed";
  }
  connectedCallback() {
    this.cardHeaderSlotObserver = new SlotObserver(this.self, "dx-card-header", (nodes) => {
      const header = nodes[0];
      if (header) {
        header.collapsable = true;
        header.collapsed = this.open;
      }
    });
    // The card stretches it's content to fit the parent container. This should not happen when a collapsable is within the card.
    const card = this.self.closest("dx-card");
    if (card) {
      card.maxcontent = true;
    }
  }
  disconnectedCallback() {
    this.cardHeaderSlotObserver.disconnect();
  }
  componentWillLoad() {
    this.animationState = this.open ? "opened" : "closed";
  }
  onCardHeaderInteracted(e) {
    const element = e.target;
    if (tagOf(element) === "dx-card-header") {
      const upperCardCollapsable = findUpperElement(element, "dx-card-collapsable");
      if (upperCardCollapsable === this.self) {
        this.open = !this.open;
        element.collapsed = this.open;
      }
    }
  }
  renderContent() {
    return (h("dx-simple-grow-box", { slidecontent: true, class: {
        content: true,
      }, ref: (ref) => (this.growBox = ref), open: this.open, onGrowBoxStateChange: (event) => {
        if (event.target === this.growBox) {
          this.animationState = event.detail;
        }
      } }, h("slot", null)));
  }
  render() {
    return (h(Host, { class: {
        "state-closed": this.animationState === "closed",
        "state-closing": this.animationState === "closing",
        "state-opened": this.animationState === "opened",
        "state-opening": this.animationState === "opening",
      } }, h("slot", { name: "header" }), this.renderContent()));
  }
  static get is() { return "dx-card-collapsable"; }
  static get encapsulation() { return "shadow"; }
  static get originalStyleUrls() {
    return {
      "$": ["dx-card-collapsable.scss"]
    };
  }
  static get styleUrls() {
    return {
      "$": ["dx-card-collapsable.css"]
    };
  }
  static get properties() {
    return {
      "open": {
        "type": "boolean",
        "mutable": true,
        "complexType": {
          "original": "boolean",
          "resolved": "boolean",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "value",
              "text": "false: The card is collapsed."
            }, {
              "name": "value",
              "text": "true: The card is unfolded."
            }, {
              "name": "example",
              "text": "open"
            }],
          "text": "The current collapse state."
        },
        "attribute": "open",
        "reflect": false,
        "defaultValue": "false"
      }
    };
  }
  static get states() {
    return {
      "animationState": {}
    };
  }
  static get elementRef() { return "self"; }
  static get listeners() {
    return [{
        "name": "cardHeaderInteract",
        "method": "onCardHeaderInteracted",
        "target": undefined,
        "capture": false,
        "passive": false
      }];
  }
}
