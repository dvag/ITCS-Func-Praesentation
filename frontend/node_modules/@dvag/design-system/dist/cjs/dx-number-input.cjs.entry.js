'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const index = require('./index-2f41386b.js');
const currencyUtil = require('./currency-util-f7a65567.js');
const elementIdHandling = require('./element-id-handling-89898a1c.js');
const error = require('./error-e6134abb.js');
const mathUtil = require('./math-util-a514efc6.js');
const miscUtil = require('./misc-util-63b423bd.js');
const baseElements = require('./base-elements-f50ffdf3.js');
const inputContainer = require('./input-container-97007eba.js');
require('./value-store-f683b26f.js');

const dxNumberInputCss = ":host{min-width:0;display:block}:host:host([hidden]){display:none !important}:host:host(.disabled){pointer-events:none}:host:host(.disabled:not(.nested-form-element)){opacity:0.4}:host label{display:block}:host label .container.size-s{position:relative;top:0;left:0;display:flex;height:40px;padding:8px 16px 8px 16px;--dx-info-button-offset-y:0px;box-sizing:border-box;border:1px solid #d6d6d6;border-bottom:var(--dx-container-border-bottom, 1px solid #d6d6d6);background-color:#ffffff;align-items:center;--dx-icon-color:#337a96}:host label .container.size-s.error{border-color:#9d2235;background-color:#f5e9eb}:host label .container.size-s.error input,:host label .container.size-s.error textarea{background:transparent}:host label .container.size-s.active{border-color:#004763;--dx-text-color:#004763;--dx-icon-color:#004763}:host label .container.size-m{position:relative;top:0;left:0;display:flex;height:48px;padding:10px 16px 10px 16px;box-sizing:border-box;border:1px solid #d6d6d6;border-bottom:var(--dx-container-border-bottom, 1px solid #d6d6d6);background-color:#ffffff;align-items:center;--dx-icon-color:#337a96}:host label .container.size-m.error{border-color:#9d2235;background-color:#f5e9eb}:host label .container.size-m.error input,:host label .container.size-m.error textarea{background:transparent}:host label .container.size-m.active{border-color:#004763;--dx-text-color:#004763;--dx-icon-color:#004763}:host label .container .input-container{display:flex;width:100%;align-items:center;overflow:hidden}:host label .container .input-container input{height:24px;border:none;outline:none;font-family:DVAG-Type;font-size:16px;line-height:24px;letter-spacing:0.02px;color:#2b2b2b;width:1px;flex-grow:1;padding:0}@media (min-width: 1280px){:host label .container .input-container input{font-size:18px;line-height:28px}}:host label .container .input-container input::placeholder{color:#ababab;opacity:1}:host label .container .input-container input:disabled{background-color:#ffffff}:host label .container .input-container .unit{margin-left:8px;--dx-text-color:#ababab}:host label .container .input-container .unit.valid-value{--dx-text-color:#2b2b2b}:host input{height:24px;border:none;outline:none;font-family:DVAG-Type;font-size:16px;line-height:24px;letter-spacing:0.02px;color:#2b2b2b;width:1px;flex-grow:1;padding:0;text-align:right}@media (min-width: 1280px){:host input{font-size:18px;line-height:28px}}:host input::placeholder{color:#ababab;opacity:1}:host input:disabled{background-color:#ffffff}:host input::-webkit-outer-spin-button,:host input::-webkit-inner-spin-button{-webkit-appearance:none;margin:0}:host input[type=number]{-moz-appearance:textfield}";

const DxNumberInput = class {
  constructor(hostRef) {
    index.registerInstance(this, hostRef);
    this.valueChange = index.createEvent(this, "valueChange", 7);
    this.valueComplete = index.createEvent(this, "valueComplete", 7);
    this.formattedValue = undefined;
    this.preventObtainValueChanges = false;
    this.lastUnpreventedInputElementValue = null;
    this.inputFocused = false;
    this.active = false;
    /**
     * Value of the input field.
     * @important
     * @value string: Value of the input.
     * @example value
     */
    this.value = null;
    /**
     * Defines the size of this input.
     *
     * @value m: medium size text-input
     * @value s: small sized input. Should only be used in special cases.
     */
    this.size = "m";
    /**
     * Determines the amount of pre-decimal numbers.
     * The element prevents all inputs higher than this value.
     *
     * @value number: Maximum amount of pre-decimal numbers.
     * @example limit-length
     */
    this.limitlength = null;
    /**
     * Determines the minimal value. The minimal value is **within** the possible input.
     * @value number: The minimal value the input field can have.
     */
    this.min = Number.NEGATIVE_INFINITY;
    /**
     * Determines the maximum value. The maximum value is **within** the possible input.
     * @value number: The maximum value the input field can have.
     */
    this.max = Number.POSITIVE_INFINITY;
    /**
     * Displays a unit next to the input.
     * @value string: A unit text (e.g: "€", "$", "qm").
     * @example custom
     */
    this.unit = undefined;
    /**
     * Input is not interactable.
     * Label and border are grey.
     * @value true: Input is disabled.
     * @value false: Input is not disabled.
     * @example disabled
     */
    this.disabled = false;
    /**
     * Input is in read only mode.
     * The content of the input is displayed in a simple way. The input is not interactable.
     * @value false: Formfield.
     * @value true: Text of the value.
     * @example readonly
     */
    this.readonly = false;
    /**
     * Marks the formfield as mandatory.
     * @value false: Not mandatory (default).
     * @value true: Mandatory.
     * @example required
     */
    this.required = false;
    /**
     * Indicates that the form is synced with the KI.
     * @value true: Synchronized.
     * @value false: Not synchronized.
     * @example kisynced
     */
    this.kisynced = false;
  }
  valueChanged() {
    this.obtainValueChangesFromOutside();
  }
  /**
   * Sets the tab-focus to the form element.
   */
  async focusControl() {
    this.inputElement.focus();
  }
  componentWillLoad() {
    elementIdHandling.verifyElementId(this.self);
    this.obtainValueChangesFromOutside(true);
  }
  // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
  componentShouldUpdate(_, __, propName) {
    if (["min", "max"].includes(propName)) {
      this.obtainValueChangesFromOutside();
    }
  }
  onForceUpdateOnChange(e) {
    e.detail(this.self);
  }
  getUnformattedValue() {
    return this.formattedValue
      ? parseFloat(miscUtil.replaceCommaWithDot(this.formattedValue.replace(/\./g, "")))
      : null;
  }
  obtainValueChangesFromOutside(force = false) {
    var _a;
    if (!this.preventObtainValueChanges) {
      this.value = this.sanitizeValue(this.value);
      if (force || this.value !== this.getUnformattedValue()) {
        this.formattedValue = this.getDisplayValue();
        this.lastEmittedChangeValue = this.value;
        this.lastEmittedCompleteValue = this.value;
        this.lastUnpreventedInputElementValue = (_a = this.value) === null || _a === void 0 ? void 0 : _a.toString();
      }
    }
    this.preventObtainValueChanges = false;
  }
  sanitizeValue(value) {
    if (isNaN(value) || value == null) {
      return null;
    }
    return mathUtil.clamp(value, this.min, this.max);
  }
  onInputFocused() {
    this.inputFocused = true;
  }
  onInputBlurred() {
    this.inputFocused = false;
    this.setValueInternal(this.value != null ? mathUtil.clamp(this.value, this.min, this.max) : this.value);
    this.emitValueChange();
    this.emitValueComplete();
  }
  clearInput() {
    this.inputElement.value = "";
    this.setValueInternal(null);
    this.formattedValue = null;
    this.lastUnpreventedInputElementValue = "";
    this.emitValueChange();
  }
  setValueInternal(newValue) {
    if (isNaN(newValue)) {
      newValue = null;
    }
    if (this.value !== newValue) {
      this.preventObtainValueChanges = true;
      this.formattedValue = this.getDisplayValue(newValue);
      this.value = newValue;
    }
  }
  onInputKeyUp(event) {
    if (event.key === "Enter") {
      this.inputElement.blur();
    }
  }
  preventInput() {
    var _a;
    if (!this.inputElement.value || this.inputElement.value === "-") {
      return false;
    }
    const inputTypeDefinition = this.inputTypeDefinition;
    const zeroPrecision = inputTypeDefinition.decimalDigits === 0;
    const stripTooManyDigits = new RegExp(zeroPrecision ? `^-?[\\d]+$` : `^-?[\\d]+[\,|\.]?[\\d]*$`);
    if (!stripTooManyDigits.test(this.inputElement.value)) {
      return true;
    }
    if (this.limitlength > 0) {
      const stripPreCommaDigits = new RegExp(`^-?([\\d]+)([,.][\\d]*)?$`);
      const preCommaDigits = (_a = this.inputElement.value) === null || _a === void 0 ? void 0 : _a.match(stripPreCommaDigits)[1];
      if (preCommaDigits.length > this.limitlength) {
        return true;
      }
    }
    return false;
  }
  computeDisplayValue(value) {
    var _a, _b;
    return ((_b = (_a = mathUtil.cutValueToPrecision(mathUtil.clamp(value, this.min, this.max), this.inputTypeDefinition.decimalDigits)) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : "");
  }
  onInput() {
    var _a;
    if (this.preventInput()) {
      const cursorPosition = this.inputElement.selectionStart - 1;
      const value = this.lastUnpreventedInputElementValue || this.inputElement.value;
      const lastUnpreventedInputElementValueNumber = parseFloat(miscUtil.replaceCommaWithDot(this.lastUnpreventedInputElementValue));
      const inputElementValueNumber = parseFloat(miscUtil.replaceCommaWithDot(this.inputElement.value));
      if (inputElementValueNumber !== lastUnpreventedInputElementValueNumber) {
        this.inputElement.value =
          (_a = this.computeDisplayValue(parseFloat(miscUtil.replaceCommaWithDot(value)))) !== null && _a !== void 0 ? _a : "";
      }
      else {
        this.inputElement.value = this.lastUnpreventedInputElementValue;
      }
      this.inputElement.selectionStart = cursorPosition;
      this.inputElement.selectionEnd = cursorPosition;
      return;
    }
    this.lastUnpreventedInputElementValue = this.inputElement.value;
    this.setValueInternal(mathUtil.cutValueToPrecision(parseFloat(miscUtil.replaceCommaWithDot(this.inputElement.value)), this.inputTypeDefinition.decimalDigits));
    this.formattedValue = this.getDisplayValue();
    this.emitValueChange();
  }
  emitValueChange() {
    if (this.value !== this.lastEmittedChangeValue) {
      this.setValueInternal(this.getUnformattedValue());
      this.lastEmittedChangeValue = this.value;
      this.valueChange.emit(this.value);
    }
  }
  emitValueComplete() {
    if (this.lastEmittedCompleteValue !== this.value) {
      this.valueComplete.emit(this.value);
      this.lastEmittedCompleteValue = this.value;
    }
  }
  get inputTypeDefinition() {
    let unit = null;
    let decimalDigits = 0;
    let placeholder = "0";
    let thousandsSeparator = true;
    if (this.profile === "currency-euro") {
      unit = "€";
      decimalDigits = 2;
    }
    else if (this.profile === "percent") {
      unit = "%";
      decimalDigits = 0;
    }
    if (this.precision != null) {
      decimalDigits = this.precision;
    }
    if (decimalDigits > 0) {
      placeholder += ",";
      for (let i = 0; i < decimalDigits; i++) {
        placeholder += "0";
      }
    }
    if (this.placeholder != null) {
      placeholder = this.placeholder;
    }
    if (this.unit != null) {
      unit = this.unit;
    }
    if (this.thousandseparator != null) {
      thousandsSeparator = this.thousandseparator;
    }
    return { unit: unit, placeholder, decimalDigits, thousandsSeparator };
  }
  getDisplayValue(value = null) {
    return currencyUtil.displayNumberAsCurrency(mathUtil.cutValueToPrecision(value !== null && value !== void 0 ? value : this.value, this.inputTypeDefinition.decimalDigits), this.inputTypeDefinition.decimalDigits, this.inputTypeDefinition.thousandsSeparator);
  }
  isClearButtonVisible() {
    return this.inputFocused && this.formattedValue != null;
  }
  render() {
    if (this.readonly) {
      const unit = this.inputTypeDefinition.unit;
      const readonlyText = this.formattedValue + ((unit === null || unit === void 0 ? void 0 : unit.length) > 0 ? ` ${unit}` : "");
      return index.h(baseElements.ReadonlyTextElement, { text: readonlyText, label: this.label });
    }
    return (index.h(index.Host, { class: { disabled: this.disabled } }, this.renderInput(), index.h(error.ErrorMessage, { self: this.self, message: this.errormessage })));
  }
  handleArrows(e) {
    if (["ArrowUp", "ArrowDown"].includes(e.key)) {
      this.setValueInternal(this.inputElement.valueAsNumber);
      this.emitValueChange();
    }
  }
  renderInput() {
    var _a;
    const inputTypeDefinition = this.inputTypeDefinition;
    return (index.h("label", null, index.h(inputContainer.LabeledInputContainer, { containerProperties: {
        size: this.size,
        active: this.inputFocused,
        error: error.hasError(this.self),
        title: (_a = this.value) === null || _a === void 0 ? void 0 : _a.toString(),
      }, labelProperties: {
        label: this.label,
        disabled: this.disabled,
        required: this.required,
        kisynced: this.kisynced,
      } }, index.h("div", { class: "input-container" }, index.h("input", Object.assign({ id: elementIdHandling.ElementIdGenerator.createId(this.self, "control"), ref: (el) => (this.inputElement = el), onKeyUp: (event) => this.onInputKeyUp(event), onInput: () => this.onInput(), onFocus: () => this.onInputFocused(), onBlur: () => this.onInputBlurred(), onKeyDown: (e) => this.handleArrows(e), type: this.inputFocused ? "number" : "text", inputMode: "numeric" }, (this.inputFocused
      ? {
        step: this.step,
        min: this.min,
        max: this.max,
        value: this.value,
      }
      : {
        value: this.formattedValue,
      }), { placeholder: inputTypeDefinition.placeholder, class: {
        animatable: inputTypeDefinition.unit == null,
        "clear-button-visible": this.isClearButtonVisible(),
      }, lang: "de-DE", disabled: this.disabled })), this.renderUnit(), this.renderClearButton()))));
  }
  renderUnit() {
    const unit = this.inputTypeDefinition.unit;
    if (unit == null) {
      return;
    }
    return (index.h("dx-text", { class: {
        unit: true,
        "valid-value": !this.inputFocused && this.value != null,
      } }, unit));
  }
  renderClearButton() {
    return (index.h("dx-clear-button", { onClearInput: () => this.clearInput(), visible: this.isClearButtonVisible(), id: elementIdHandling.ElementIdGenerator.createId(this.self, "clear-button") }));
  }
  get self() { return index.getElement(this); }
  static get watchers() { return {
    "value": ["valueChanged"]
  }; }
};
DxNumberInput.style = dxNumberInputCss;

exports.dx_number_input = DxNumberInput;
