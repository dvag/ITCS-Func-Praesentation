'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const index = require('./index-2f41386b.js');
const mathUtil = require('./math-util-a514efc6.js');
const assert = require('./assert-d8ea75c6.js');
const miscUtil = require('./misc-util-63b423bd.js');
const elementIdHandling = require('./element-id-handling-89898a1c.js');
const renderUtil = require('./render-util-6b278c0d.js');
const error = require('./error-e6134abb.js');
require('./value-store-f683b26f.js');

const dxErrorMessageCss = ":host{display:block}:host:host([hidden]){display:none !important}:host .error-container{margin-top:4px;display:flex;align-items:flex-start}:host .error-container .error-icon{flex:0 0 16px;margin-right:4px}@media (min-width: 1280px){:host .error-container .error-icon{margin-top:2px}}:host .error-container .error-message.ellipse{display:-webkit-box;-webkit-line-clamp:var(--dx-error-message-lines);-webkit-box-orient:vertical;overflow:hidden}:host .link{display:block;margin-top:4px;margin-left:20px;white-space:nowrap}";

const DxErrorMessage = class {
  constructor(hostRef) {
    index.registerInstance(this, hostRef);
    this.forceUpdateOnChange = index.createEvent(this, "forceUpdateOnChange", 7);
    /**
     * The number of lines the error message should display.
     *
     * @value 1, 2, 3: The number of lines the text can display simultaneously.
     * @value all: The error message will not be clipped. This mode should only be used in important cases.
     *
     * @example lines
     */
    this.lines = 1;
    this.showCompleteMessage = false;
    this.showLink = false;
  }
  onLinesChanged() {
    this.checkLines();
  }
  connectedCallback() {
    this.initializeMutationObserver();
    this.resizeObserver = new ResizeObserver(() => {
      this.updateView();
    });
    // connectedCallback does not trigger a re-render (which updates the resizeObserver)
    // when the element is deattached and attached again so we have to explicitly observe the
    // textElement if it is not null
    if (this.textElement) {
      this.resizeObserver.observe(this.textElement);
    }
    this.forceUpdateOnChange.emit((ref) => {
      this.forceUpdateReference = ref;
      if (ref) {
        index.forceUpdate(ref);
      }
    });
  }
  disconnectedCallback() {
    var _a, _b;
    (_a = this.resizeObserver) === null || _a === void 0 ? void 0 : _a.disconnect();
    (_b = this.mutationObserver) === null || _b === void 0 ? void 0 : _b.disconnect();
    if (this.forceUpdateReference) {
      index.forceUpdate(this.forceUpdateReference);
      this.forceUpdateReference = null;
    }
  }
  initializeMutationObserver() {
    this.mutationObserver = new MutationObserver(() => {
      // We want to reset the showCompleteMessage state because we want to check if the current text is ellipsed.
      const tmpShowCompleteMessage = this.showCompleteMessage;
      this.showCompleteMessage = false;
      index.forceUpdate(this);
      if (this.forceUpdateReference) {
        index.forceUpdate(this.forceUpdateReference);
      }
      renderUtil.onNextFrame(() => {
        this.updateView();
        // If the text is ellipsed (showLink => true) we want to reset the showCompleteMessage property to it's former state.
        // Otherwise there is no link and showCompleteMessage has to be false.
        this.showCompleteMessage = tmpShowCompleteMessage && this.showLink;
      });
    });
    this.mutationObserver.observe(this.self, {
      subtree: true,
      characterData: true,
      childList: true,
    });
  }
  updateView() {
    // When the text is cut we want to show the "more"-link
    this.showLink =
      this.lines !== "all" &&
        (this.showCompleteMessage ||
          (this.self.textContent && miscUtil.isOverflown(this.textElement)));
  }
  checkLines() {
    var _a;
    if (this.lines === "all") {
      return;
    }
    const clampedLines = mathUtil.clamp((_a = this.lines) !== null && _a !== void 0 ? _a : 1, 1, 3);
    assert.assert(clampedLines === this.lines, () => `The 'lines' has to be 1, 2 or 3. Current value: ${this.lines}`, this.self);
    this.lines = clampedLines;
  }
  setTextElement(element) {
    this.textElement = element;
    if (this.textElement) {
      this.resizeObserver.observe(this.textElement);
    }
  }
  renderLink() {
    if (!this.showLink) {
      return;
    }
    const linkText = this.showCompleteMessage
      ? "Weniger anzeigen"
      : "Mehr anzeigen";
    return (index.h("dx-link", { id: elementIdHandling.ElementIdGenerator.createId(this.self, "show-more"), class: "link", onClick: () => {
        this.showCompleteMessage = !this.showCompleteMessage;
      } }, index.h("dx-text", { type: "its" }, linkText)));
  }
  render() {
    if (this.self.textContent.length <= 0) {
      return;
    }
    return (index.h(index.Host, { style: {
        "--dx-error-message-lines": this.lines.toString(),
      } }, index.h("div", { class: "error-container" }, index.h("dx-icon", { class: "error-icon", icon: "state-error", color: "error", size: 16 }), index.h("dx-text", { type: "its-bold", color: "error", class: {
        "error-message": true,
        ellipse: !this.showCompleteMessage && this.lines !== "all",
      }, ref: (ref) => this.setTextElement(ref) }, index.h("slot", null))), this.renderLink()));
  }
  get self() { return index.getElement(this); }
  static get watchers() { return {
    "lines": ["onLinesChanged"]
  }; }
};
DxErrorMessage.style = dxErrorMessageCss;

const dxFormWrapperCss = ":host{display:block}:host:host([hidden]){display:none !important}:host .form-container .slot-container{padding:0;box-sizing:border-box;transition:padding 250ms ease-in-out}:host .form-container .slot-container.error{padding:8px 16px;background-color:#f5e9eb;border:1px solid #9d2235;--dx-list-item-background-color-active:#d8a7ae;--dx-list-item-background-color-hover:#ebd3d7;--dx-list-item-background-color-default:#f5e9eb}";

const DxFormWrapper = class {
  constructor(hostRef) {
    index.registerInstance(this, hostRef);
    /**
     * Indicates that the form is synced with KI.
     * @value true: Synchronized.
     * @value false: Not synchronized.
     * @example kisynced
     */
    this.kisynced = false;
  }
  componentDidLoad() {
    elementIdHandling.verifyElementId(this.self);
  }
  onForceUpdateOnChange(e) {
    e.stopPropagation();
    e.detail(this.self);
  }
  render() {
    return (index.h(index.Host, null, index.h("div", { class: {
        "form-container": true,
      } }, index.h("dx-input-label", { type: "ps", class: "input-label", label: this.label, required: this.required, kisynced: this.kisynced, condensedlayout: true }), index.h("div", { class: {
        "slot-container": true,
        error: error.hasError(this.self),
      } }, index.h("slot", null)), index.h(error.ErrorMessage, { self: this.self, message: this.errormessage, forceUpdateOnChange: (e) => {
        e.detail(this.self);
      } }))));
  }
  get self() { return index.getElement(this); }
};
DxFormWrapper.style = dxFormWrapperCss;

const dxLinkCss = ":host:host([hidden]){display:none !important}:host a{cursor:pointer;text-decoration:none;--dx-text-internal-text-decoration:underline;--dx-text-internal-color:#337a96;--dx-icon-internal-color:#337a96;--dx-text-text-decoration:underline;--dx-text-color:#337a96;--dx-icon-color:#337a96}:host a:hover{--dx-text-color:#00587c;--dx-icon-color:#00587c}:host a:active{--dx-text-color:#004763;--dx-icon-color:#004763}:host a:focus-visible{outline-offset:2px;outline:2px solid #004763}";

const DxLink = class {
  constructor(hostRef) {
    index.registerInstance(this, hostRef);
  }
  render() {
    return (index.h("a", { href: this.url, target: this.target, rel: "noreferrer noopener", tabIndex: 0 }, index.h("slot", null)));
  }
  get self() { return index.getElement(this); }
};
DxLink.style = dxLinkCss;

exports.dx_error_message = DxErrorMessage;
exports.dx_form_wrapper = DxFormWrapper;
exports.dx_link = DxLink;
