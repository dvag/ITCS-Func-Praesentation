'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const index = require('./index-2f41386b.js');
const assert = require('./assert-d8ea75c6.js');
const date_utils = require('./date.utils-9ecc3482.js');
const elementIdHandling = require('./element-id-handling-89898a1c.js');
const miscUtil = require('./misc-util-63b423bd.js');
const renderUtil = require('./render-util-6b278c0d.js');
const slotObserver = require('./slot-observer-2e83212e.js');
const date = require('./date-c691d072.js');
const dateRange_util = require('./date-range.util-3f8b8422.js');
require('./value-store-f683b26f.js');
require('./query-util-8642f149.js');

const dxDateRangeCss = ":host{display:block}:host:host([hidden]){display:none !important}:host .date-container{display:flex;align-items:baseline;gap:24px;flex-direction:column;align-items:stretch}@media (min-width: 476px){:host .date-container{flex-direction:row}}:host .date-container .date-input-container{flex:1}:host .date-container .date-input-container:first-child{position:relative}@media (min-width: 476px){:host .date-container .date-input-container ::slotted(*[slot=from]):after{font-family:DVAG-Type, sans-serif;content:\"-\";display:flex;top:0;right:-24px;width:24px;height:100%;align-items:center;justify-content:center;position:absolute}}:host .date-container .date-input-container ::slotted(*[label]):after{top:12px}";

const DxDateRange = class {
  constructor(hostRef) {
    index.registerInstance(this, hostRef);
    this.errors = {
      from: date.DateErrorType.NO_ERROR,
      to: date.DateErrorType.NO_ERROR,
    };
    this.currentlyFocused = false;
    this.internalErrorMessage = "";
    /**
     * Defines how a date range can be selected or edited.
     *
     * @value "day-month-year": The user can select a specific date range.
     * The calendar shows all three views (month, year and decade) for selecting a date range.
     * @value "month-year": The user can select a month range.
     * The calendar shows two views (year and decade) for selecting a month range.
     * @value "day-month": The user can select two possible dates within a year.
     * The calendar shows two views (month and year) for selecting a date range.
     */
    this.mode = "day-month-year";
    /**
     * The current displayed date range.
     *
     * @important
     * @value string: Two comma seperated dates in following format: YYYY-MM-dd (e.g.: 2021-01-01,2021-12-31)
     * @example value
     */
    this.value = null;
    this.onFocus = () => (this.currentlyFocused = true);
    this.onBlur = () => this.handleBlur();
    this.onError = (e) => this.handleError(e);
    this.onDateValueChange = (e) => this.handleDateValueChange(e);
  }
  onValueChange() {
    const range = dateRange_util.extractDateRange(this.value);
    this.selectRange(range);
  }
  connectedCallback() {
    this.slotObserver = new slotObserver.SlotObserver(this.self, "dx-date-input", (dateInputs) => {
      assert.assert(dateInputs.length === 2, () => "You have to define exactly two dx-date-inputs within this component");
      const rangeFromDateInputs = {
        from: null,
        to: null,
      };
      dateInputs.forEach((dateInput) => {
        dateInput.removeEventListener("focus", this.onFocus);
        dateInput.addEventListener("focus", this.onFocus);
        dateInput.removeEventListener("blur", this.onBlur);
        dateInput.addEventListener("blur", this.onBlur);
        dateInput.removeEventListener("errorFound", this.onError);
        dateInput.addEventListener("errorFound", this.onError);
        dateInput.removeEventListener("valueChange", this.onDateValueChange);
        dateInput.addEventListener("valueChange", this.onDateValueChange);
        // Override date-input properties
        dateInput.min = this.min;
        dateInput.max = this.max;
        dateInput.mode = this.mode;
        // Show custom calendar for date-range and disable calendars of inner date inputs
        dateInput.calendarenabled = false;
        rangeFromDateInputs[dateInput.slot] = date_utils.DateUtils.stringToDate(dateInput.value);
      });
      if (this.value != null) {
        this.selectRange(dateRange_util.extractDateRange(this.value));
      }
      else {
        this.selectRange(rangeFromDateInputs);
      }
    });
  }
  componentDidLoad() {
    this.updateCalendarValue();
  }
  disconnectedCallback() {
    this.slotObserver.disconnect();
  }
  onSegmentBlurred() {
    this.updateCalendarValue();
  }
  /**
   * Sets the focus on the first date input element.
   */
  async focusControl() {
    var _a;
    (_a = this.self.querySelector("dx-date-input")) === null || _a === void 0 ? void 0 : _a.focusControl();
  }
  handleBlur() {
    renderUtil.onNextFrame(() => {
      const loseFocus = !miscUtil.isActiveElement(this.self) &&
        // Check if any inner dx-date-input elements have focus
        !Array.from(this.self.querySelectorAll("dx-date-input[slot]")).some((elem) => miscUtil.isActiveElement(elem));
      if (loseFocus) {
        this.currentlyFocused = false;
      }
    });
  }
  handleError(e) {
    const error = e.detail;
    const slot = e.target.slot;
    this.errors[slot] = error.type;
    const errorType = this.errors.from !== date.DateErrorType.NO_ERROR
      ? this.errors.from
      : this.errors.to;
    // Record makes this type-safe. If a new DateError appears, the compiler will complain here.
    const errorToMessageMap = {
      [date.DateErrorType.INVALID_DATE]: () => "Invalides Datum gefunden!",
      [date.DateErrorType.UNDER_MIN]: () => `Die eingegeben Daten müssen nach dem ${date_utils.DateUtils.getFormattedDisplayDate(this.min)} liegen.`,
      [date.DateErrorType.OVER_MAX]: () => `Die eingegeben Daten müssen vor dem ${date_utils.DateUtils.getFormattedDisplayDate(this.max)} liegen.`,
      [date.DateErrorType.NO_ERROR]: () => "",
    };
    this.internalErrorMessage = errorToMessageMap[errorType]();
  }
  handleDateValueChange(e) {
    const dateInput = e.target;
    if (!dateInput.slot) {
      return;
    }
    const range = dateRange_util.extractDateRange(this.value);
    // Slot == from or to. So we set from or to property dependant of slot
    range[dateInput.slot] = e.detail ? new Date(e.detail) : null;
    this.selectRange(range);
  }
  getDateInputs() {
    return Array.from(this.self.querySelectorAll("dx-date-input"));
  }
  selectRange(range, source = "other") {
    // TODO: ... Check for range validity with min and max
    var _a, _b;
    this.value = `${(_a = date_utils.DateUtils.dateToString(range.from)) !== null && _a !== void 0 ? _a : ""},${(_b = date_utils.DateUtils.dateToString(range.to)) !== null && _b !== void 0 ? _b : ""}`;
    const dateInputs = this.getDateInputs();
    if (dateInputs[0]) {
      dateInputs[0].value = date_utils.DateUtils.dateToString(range.from);
      if (source === "calendar-widget") {
        dateInputs[0].internalForceEmitChangeEvent();
      }
    }
    if (dateInputs[1]) {
      dateInputs[1].value = date_utils.DateUtils.dateToString(range.to);
      if (source === "calendar-widget") {
        dateInputs[1].internalForceEmitChangeEvent();
      }
    }
  }
  updateCalendarValue() {
    if (this.calendar != null) {
      this.calendar.value = this.value;
    }
  }
  setCalendar(calendar) {
    if (this.calendar !== calendar) {
      this.calendar = calendar;
      this.updateCalendarValue();
    }
  }
  renderCalendar() {
    return (index.h("dx-calendar", { slot: "overlay", id: elementIdHandling.ElementIdGenerator.createId(this.self, "calendar"), ref: (ref) => this.setCalendar(ref), tabindex: -1, errormessage: this.internalErrorMessage, rangeenabled: true, onBlur: () => {
        this.onBlur();
      }, min: this.min, max: this.max, onRangeSelected: (e) => {
        this.selectRange(e.detail, "calendar-widget");
      }, mode: this.mode }));
  }
  render() {
    return (index.h(index.Host, null, index.h("dx-flyout", { open: this.currentlyFocused, offsety: 4 }, index.h("div", { class: "date-container" }, index.h("div", { class: "date-input-container" }, index.h("slot", { name: "from" })), index.h("div", { class: "date-input-container" }, index.h("slot", { name: "to" }))), this.renderCalendar())));
  }
  get self() { return index.getElement(this); }
  static get watchers() { return {
    "value": ["onValueChange"]
  }; }
};
DxDateRange.style = dxDateRangeCss;

exports.dx_date_range = DxDateRange;
