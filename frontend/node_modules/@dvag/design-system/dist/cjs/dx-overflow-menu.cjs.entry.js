'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const index = require('./index-2f41386b.js');
const elementIdHandling = require('./element-id-handling-89898a1c.js');
const slotObserver = require('./slot-observer-2e83212e.js');
const assert = require('./assert-d8ea75c6.js');
const mathUtil = require('./math-util-a514efc6.js');
require('./value-store-f683b26f.js');
require('./query-util-8642f149.js');

const dxOverflowMenuCss = ":host{display:block;--dx-flyout-simple-grow-box-width:fit-content;--dx-flyout-simple-grow-box-min-width:192px;--dx-overlay-popup-max-width:max-content;--dx-overlay-offset:40px;text-align:left}:host:host([hidden]){display:none !important}:host:host(.align-right){text-align:right;display:flex;flex-direction:column;align-items:flex-end}:host:host(.mock-list-item-width){--dx-list-mock-icon-container-width:40px}:host .list-flyout{min-width:192px}";

const DxOverflowMenu = class {
  constructor(hostRef) {
    index.registerInstance(this, hostRef);
    this.selection = index.createEvent(this, "selection", 7);
    this.listOpenChange = index.createEvent(this, "listOpenChange", 7);
    /**
     * The alignment defines in which direction the menu button aligns.
     *
     * @value left: The menu button is displayed on the left and the list anchors on the left of the button.
     * @value right: The menu button is displayed on the right and the list anchors on the right of the button.
     *
     * @example align
     */
    this.align = "left";
    /**
     * Defines whether the user is able to select only one or multiple menu items.
     *
     * @value single: The user can select only one menu-item which immediately closes the flyout.
     * @value multi: The user is able to select multiple menu items.
     *
     * @example selection-mode
     */
    this.selectionmode = "single";
    /**
     * Defines the maximum number of selected menu-item labels the menu displays.
     * This property only has an effect if the `selectionmode` is `multi`.
     *
     * @value number: A number greater than zero which defines the upper limit of labels being displayed in the menu.
     * @value undefined: All selected labels are displayed in the menu.
     * @example max-labels
     */
    this.maxlabels = 1;
    this.listOpen = false;
  }
  onListOpenChanged() {
    this.listOpenChange.emit({
      isOpen: this.listOpen,
    });
  }
  connectedCallback() {
    this.menuItemsObserver =
      slotObserver.createMetaComponentsSlotObserver(this.self, "dx-overflow-menu-item", async (nodes) => {
        await this.collectMenuItems(nodes);
        this.updateInternalLabel();
      });
  }
  disconnectedCallback() {
    this.menuItemsObserver.disconnect();
  }
  componentWillRender() {
    assert.assert(this.maxselections == null || mathUtil.isPositiveInteger(this.maxselections), () => "The `maxselections` property has to be a natural number greater than zero ([1,2,3,...]) or undefined.", this.self);
    assert.assert(this.maxlabels == null || mathUtil.isPositiveInteger(this.maxlabels), () => "The `maxlabels` property has to be a natural number greater than zero ([1,2,3,...]) or undefined.", this.self);
    assert.assertPropertyValue("dx-overflow-menu", "selectionmode", this.selectionmode, ["single", "multi"], this.self);
  }
  onItemSelectionChange(e) {
    var _a;
    e.stopPropagation();
    const selectedValues = (_a = e.detail) === null || _a === void 0 ? void 0 : _a.selectedItems;
    this.emitSelection(selectedValues);
    if (this.selectionmode === "single") {
      this.listOpen = false;
    }
    this.updateMenuItems(selectedValues);
    this.updateInternalLabel();
  }
  updateMenuItems(selectedValues) {
    this.menuItems.forEach((menuItem) => {
      menuItem.setSelected(selectedValues.find((value) => value === menuItem.value) != null);
    });
  }
  // Computes the internalLabel dependent on the provided selected values
  updateInternalLabel() {
    if (this.selectionmode === "single") {
      this.internalLabel = ""; // Reset internalLabel just in case
    }
    else if (this.selectionmode === "multi") {
      this.internalLabel = this.computeInternalLabel();
    }
  }
  computeInternalLabel() {
    const selectedMenuItemValues = this.menuItems
      .filter((menuItem) => menuItem.selected)
      .map((menuItem) => menuItem.value);
    const currentLabels = selectedMenuItemValues
      .map((value) => {
      return this.menuItems.find((menuItem) => menuItem.value === value);
    })
      .map((menuItem) => menuItem.label);
    const displayValues = currentLabels.slice(0, this.maxlabels);
    const diff = selectedMenuItemValues.length - displayValues.length;
    const joinSeparator = ", ";
    if (diff === 0) {
      return displayValues.join(joinSeparator);
    }
    return displayValues.join(joinSeparator) + ` (+${diff})`;
  }
  emitSelection(values) {
    const emittedValue = this.selectionmode === "single" ? values[0] : values;
    this.selection.emit({
      value: emittedValue,
    });
  }
  async collectMenuItems(menuItems) {
    this.menuItems = await Promise.all(menuItems.map((menuItem) => menuItem.toOverflowMenuItem()));
  }
  onInputKeyDown(event) {
    const listFlyoutElement = this.self.shadowRoot.querySelector("dx-list-flyout");
    if (event.target === listFlyoutElement) {
      return;
    }
    if ((listFlyoutElement === null || listFlyoutElement === void 0 ? void 0 : listFlyoutElement.open) && event.code !== "Tab") {
      // If the flyout is open we want to prevent all keyboard inputs and delegate it to the list flyout.
      event.preventDefault();
      listFlyoutElement === null || listFlyoutElement === void 0 ? void 0 : listFlyoutElement.dispatchEvent(new event.constructor(event.type, event));
    }
    else if (event.code === "ArrowDown") {
      this.listOpen = true;
    }
  }
  renderButtonIconSlot() {
    var _a, _b;
    if (((_a = this.internalLabel) === null || _a === void 0 ? void 0 : _a.length) > 0 || ((_b = this.label) === null || _b === void 0 ? void 0 : _b.length) > 0) {
      return (index.h("dx-chevron", { size: 24, slot: "icon", directiontop: this.listOpen }));
    }
    else {
      return (index.h("dx-element-swapper", { active: this.listOpen ? "second" : "first", slot: "icon" }, index.h("dx-icon", { icon: "ueberlauf-menue", slot: "first", size: 24 }), index.h("dx-icon", { icon: "schliessen", slot: "second", size: 24 })));
    }
  }
  renderTextButton() {
    return (index.h("dx-button", { id: elementIdHandling.ElementIdGenerator.createId(this.self, "menu-button"), class: {
        "simulate-active": this.listOpen,
      }, onKeyDown: (e) => this.onInputKeyDown(e), type: "text", slot: "base", label: this.internalLabel || this.label, onClick: () => (this.listOpen = !this.listOpen), iconposition: "right" }, this.renderButtonIconSlot()));
  }
  render() {
    var _a, _b;
    return (index.h(index.Host, { onBlur: () => {
        this.listOpen = false;
      }, class: {
        "align-right": this.align === "right",
        "mock-list-item-width": (_a = this.menuItems) === null || _a === void 0 ? void 0 : _a.some((menuItem) => { var _a; return ((_a = menuItem.icon) === null || _a === void 0 ? void 0 : _a.length) > 0; }),
      } }, this.renderTextButton(), index.h("dx-list-flyout", { class: "list-flyout", open: this.listOpen, direction: this.align === "left" ? "right" : "left", itemsvisible: 5.5, size: "m", selectionmode: this.selectionmode, selectonhighlight: false, clearselectiononclose: this.selectionmode === "single", maxselections: this.maxselections, ref: (ref) => index.forceUpdate(ref) }, (_b = this.menuItems) === null || _b === void 0 ? void 0 : _b.map((item, index$1) => {
      var _a;
      return (index.h("dx-list-item", { id: (_a = elementIdHandling.ElementIdGenerator.createIdFromString(item.id, "list-item")) !== null && _a !== void 0 ? _a : elementIdHandling.ElementIdGenerator.createId(this.self, `list-item-${index$1}`), label: item.label, value: item.value, icon: item.icon, selected: item.selected, type: this.selectionmode === "single" ? "clickable" : "checkbox" }));
    }))));
  }
  get self() { return index.getElement(this); }
  static get watchers() { return {
    "listOpen": ["onListOpenChanged"]
  }; }
};
DxOverflowMenu.style = dxOverflowMenuCss;

exports.dx_overflow_menu = DxOverflowMenu;
