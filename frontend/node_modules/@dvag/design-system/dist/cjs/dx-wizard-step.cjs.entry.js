'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const index = require('./index-2f41386b.js');
const assert = require('./assert-d8ea75c6.js');
const wizard_util = require('./wizard.util-6e67973d.js');
const elementIdHandling = require('./element-id-handling-89898a1c.js');
require('./value-store-f683b26f.js');

const DxWizardStep = class {
  constructor(hostRef) {
    index.registerInstance(this, hostRef);
    this.finishedChange = index.createEvent(this, "finishedChange", 7);
    this.interaction = index.createEvent(this, "interaction", 7);
    /**
     * Whether this step is already finished or not.
     *
     * @value true: The step is finished. If all previous steps are finished as well the wizard automatically switches to the next page.
     * @value false: The step is not finished yet.
     *
     * @example finished
     */
    this.finished = false;
  }
  onFinishedChanged() {
    this.finishedChange.emit(this.finished);
  }
  connectedCallback() {
    elementIdHandling.verifyElementId(this.self);
    assert.assert(this.value !== wizard_util.CONTENT_SLOT_NAME, () => `The value "content" should not be used because it is already reserved for the "content" slot of the <dx-wizard> element.`, this.self);
  }
  /**
   * @internal
   */
  async toWizardStep() {
    return {
      label: this.label,
      value: this.value,
      finished: this.finished,
      interact: () => this.interaction.emit(),
      metaStepComponent: this.self,
    };
  }
  get self() { return index.getElement(this); }
  static get watchers() { return {
    "finished": ["onFinishedChanged"]
  }; }
};

exports.dx_wizard_step = DxWizardStep;
