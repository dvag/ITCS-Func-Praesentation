'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const index = require('./index-2f41386b.js');
const elementIdHandling = require('./element-id-handling-89898a1c.js');
const slotObserver = require('./slot-observer-2e83212e.js');
const value = require('./value-1f8d9874.js');
const assert = require('./assert-d8ea75c6.js');
const renderUtil = require('./render-util-6b278c0d.js');
const baseElements = require('./base-elements-0dbfd791.js');
const miscUtil = require('./misc-util-63b423bd.js');
const inputContainer = require('./input-container-9bf53d94.js');
const errorPopup = require('./error-popup-9c9bd96e.js');
const compareObjects = require('./compare-objects-1e161956.js');
require('./value-store-f683b26f.js');
require('./query-util-8642f149.js');

const dsDropdownCss = ":host{display:block;min-width:0}:host:host([hidden]){display:none !important}:host:host([label]:not([label=\"\"])){--ds-info-button-offset-y:24px}:host .input{outline:none;cursor:pointer;--dx-overlay-popup-min-width:unset}:host .input.disabled{cursor:default;pointer-events:none}:host .input .container{position:relative;top:0;left:0;display:flex;height:38px;border-radius:4px;border:1px solid #c1c1c1;background-color:#ffffff;box-sizing:border-box;align-items:center}:host .input .container.required-outline{border-color:#e8b50e}:host .input .container.requirement-fulfilled{border-color:#c1c1c1}:host .input .container.red-outline{border-color:#be1413}:host .input .container.disabled-outline{border-color:#ebebeb}:host .input .container.active{border-color:#4c4c4c}:host .input .container select{position:absolute;width:100%;left:0;top:0;pointer-events:none;opacity:0}:host .input .container .current-value{flex:1;overflow:hidden}:host .input .container .current-value .item{background:none}:host .input .container .current-value .item ds-text{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}:host .input .container .current-value .item.is-placeholder ds-text{color:#c1c1c1}:host .input .container .current-value .item.disabled{--ds-text-color:#dedede;--ds-icon-color:#dedede}:host .input .container .open-list-button{pointer-events:none}:host .input .container .open-list-button ds-icon.rotated{transform:scaleY(-1)}:host .input .container .open-list-button ds-icon.disabled{--ds-icon-color:#dedede}:host .input .list-wrapper{position:relative;bottom:0;top:0;width:100%}:host .input .list-wrapper:not(.list-open){position:fixed;top:-9999px;left:-9999px;visibility:hidden;pointer-events:none}:host .input .list-wrapper .item-list{width:100%;word-wrap:break-word;z-index:110;max-height:136.5px;border-radius:4px;box-shadow:0 4px 12px 0 rgba(0, 0, 0, 0.32);background-color:#ffffff;display:flex;flex-direction:column}@media (min-width: 768px){:host .input .list-wrapper .item-list{max-height:214.5px}}:host .input .list-wrapper .item-list .item-list-options{flex-grow:1;overflow-y:scroll}:host .input .list-wrapper .item-list .item-list-options .item{padding-right:10px}:host .input .list-wrapper .item-list .else-option-button{flex-shrink:0;height:38px;display:flex;justify-content:center;align-items:center;border-top:1px solid #dedede}:host .input .list-wrapper.position-top{top:0}:host .input .list-wrapper.position-top .item-list{bottom:5px}:host .input .list-wrapper .item.right{padding-right:10px}:host .item{user-select:none;-webkit-user-select:none;padding-left:10px;text-align:left;min-height:39px;display:flex;box-sizing:border-box;border-bottom:1px solid #dedede;padding-top:7px;padding-bottom:7px}:host .item .icon-container{flex:0 0 24px;height:24px}:host .item .labels-container{display:block;flex:1;overflow:hidden}:host .item .labels-container ds-text{display:block}:host .item ds-icon{flex-shrink:0}:host .item.selected{background-color:#f5f5f5}:host .item.right{text-align:right}:host .item ds-icon{margin-right:8px}:host .item:last-child{border-bottom:none}:host .enable-mouse-hover .item:hover{cursor:pointer;background-color:#f5f5f5}:host .else-option-input-container{margin-top:16px}";

const DsDropdown = class {
  constructor(hostRef) {
    index.registerInstance(this, hostRef);
    this.valueChange = index.createEvent(this, "valueChange", 7);
    this.valueComplete = index.createEvent(this, "valueComplete", 7);
    this.lastEmittedChangeValue = null;
    this.lastEmittedCompleteValue = null;
    this.preventReFocus = false;
    this.selectScanningEnabled = true;
    this.options = [];
    this.inputFocused = false;
    this.listOpen = false;
    this.internalValue = null;
    this.showMouseHoverEffectOnList = true;
    /**
     * Indicates that an error exist within the input field. Colors the border in red.
     * @value true: An error exists.
     * @value false: There is no error.
     * @example error
     */
    this.error = false;
    /**
     * Whether the selection is readonly or editable.
     * If true the value of this component will be visualized as a normal text.
     * @value false: Input is editable.
     * @value true: Input is read-only.
     *
     * @example readonly
     */
    this.readonly = false;
    /**
     * Marks this input field as a required form element.
     * @value false: Not required
     * @value true: It is necessary to select an option to fulfill the requirement.
     * @example required
     */
    this.required = false;
    /**
     * Placeholder text which is displayed when no option is currently selected.
     * @value string: Placeholder text
     * @example placeholder
     */
    this.placeholder = "Bitte w√§hlen";
    /**
     * The current value of this element. It represents the `value` property of the current selected `<dx-dropdown-option>` or null.
     * Other by selecting an option with the mouse or keyboard, it is possible to set this property programmatically.
     *
     * @important
     * @value string: The string value of the selected option.
     * @value object: The value of the selected option in case it's a complex type.
     * @value null: No option selected.
     * @example value
     */
    this.value = null;
    /**
     * Defines the text alignment.
     * @value left: Text is left aligned.
     * @value right: Text is right aligned.
     * @example text-align
     */
    this.textalign = "left";
    /**
     * Defines the position of the dropdown list.
     * @value top: The list is displayed at the top of the input field.
     * @value bottom: The list is displayed at the bottom of the input field.
     * @example popup-position
     */
    this.popupposition = "bottom";
    /**
     * Whether it is possible to select an option which is not present in the current option list.
     *
     * @value false: The user can only select an option in the list.
     * @value true: The user is able to set a value which is not present in the option list by editing a text field under
     * the selection input field.
     * @example elseoption
     */
    this.elseoption = false;
    /**
     * The label of the button which activates the `elseoption` input field. The `elseoption` property has to be `true`.
     * @value string: Button label
     * @example elseoption
     */
    this.elseoptionbuttonlabel = "Sonstige Eingabe";
    /**
     * The label of the text input field which represents the `elseoption`. The `elseoption` property has to be `true`.
     * @value string: Text input label.
     * @example elseoption
     */
    this.elseoptioninputlabel = "Sonstige Eingabe";
    /**
     * Determines if the else-option input field is visible to the user. This property automatically changes
     * on user interaction or providing a value that doesn't match any dropdown options.
     * @value false: Else-option input field is not displayed.
     * @value true: Else-option input field is displayed.
     * @example elseoption-selected
     */
    this.elseoptionselected = false;
    /**
     * Defines whether the dropdown is enabled or not.
     * @value true: Dropdown is not editable.
     * @value false: Dropdown is editable.
     * @example disabled
     */
    this.disabled = false;
    /**
     * Indicates that the form is synced with the KI.
     * @value true: Synchronized.
     * @value false: Not synchronized.
     * @example kisynced
     */
    this.kisynced = false;
  }
  valueChanged() {
    this.obtainValueChangesFromOutside();
  }
  /**
   * Sets the focus on this element.
   *
   * @example focus
   */
  async focusControl() {
    this.inputElement.focus();
  }
  componentWillLoad() {
    elementIdHandling.verifyElementId(this.self);
    this.obtainValueChangesFromOutside(true);
  }
  connectedCallback() {
    this.optionsObserver =
      slotObserver.createMetaComponentsSlotObserver(this.self, "ds-dropdown-option", async (nodes) => {
        await this.collectOptions(nodes);
        this.findSelectedOption();
        const duplicates = value.findDuplicatedValues(this.options);
        assert.assert(duplicates.length == 0, () => `Innerhalb eines DsDropdowns sollten kein Eintrag mit denselben values existieren!\nFolgende duplizierte Values wurden gefunden: ${duplicates.join()}`);
      });
  }
  disconnectedCallback() {
    var _a;
    (_a = this.optionsObserver) === null || _a === void 0 ? void 0 : _a.disconnect();
    clearInterval(this.observeSelectElementIntervalHandle);
  }
  componentDidRender() {
    if (this.listOpen && this.selectedOption != null) {
      this.scrollIntoView(this.selectedOption);
    }
  }
  /**
   * If the value changed from outside we need to check what option to use.
   * Possible cases can be:
   * - Setting value attribute
   * - Set of possible <ds-dropdown-option> changed
   * - Native <select> supervise detected a value change
   */
  findSelectedOption() {
    if (this.self.querySelectorAll("ds-dropdown-option").length !==
      this.options.length) {
      return; // can't decide now, cause not all option nodes are initialized
    }
    const optionMatchingValue = this.options.find((option) => option.value === this.value);
    if (!this.elseoptionselected && optionMatchingValue != null) {
      // Is there an option matching the value and our internal selectedOption is unset or set to a different option?
      if (this.selectedOption == null ||
        !compareObjects.compareObjectsEqual(optionMatchingValue, this.selectedOption)) {
        this.selectedOption = optionMatchingValue;
      }
    }
    else if (this.elseoption && this.internalValue !== null) {
      // Is elseoption enabled and therefore we don't need to match an option and use the value as elseoption value?
      this.elseoptionselected = true;
      this.selectedOption = null;
    }
    else {
      // We couldn't figure out an existing option => no option set
      this.selectedOption = null;
      this.elseoptionselected = false;
    }
  }
  async collectOptions(nodes) {
    const previousOptions = this.options;
    this.options = await Promise.all(nodes.map((node) => node.toOption()));
    if (this.options.length > 0 && previousOptions.length > 0) {
      this.findSelectedOption();
    }
  }
  // Always keep internalValue in sync with nativeSelect value. Otherwise there could be a race condition where a selection fails.
  updateInternalValue(newValue) {
    this.internalValue = newValue;
    if (this.nativeSelect) {
      this.nativeSelect.value = JSON.stringify(this.internalValue);
    }
  }
  obtainValueChangesFromOutside(force = false) {
    this.sanitizeValue();
    if (force || this.value !== this.internalValue) {
      this.updateInternalValue(this.value);
      this.lastEmittedChangeValue = this.value;
      this.lastEmittedCompleteValue = this.value;
      this.findSelectedOption();
    }
  }
  sanitizeValue() {
    if (this.value === undefined || this.value === NULL_STRING) {
      this.value = null;
    }
  }
  onInputFocused() {
    this.inputFocused = true;
  }
  onInputBlurred() {
    renderUtil.onNextFrame(() => {
      if (this.preventReFocus || !miscUtil.isActiveElement(this.self)) {
        this.inputFocused = false;
        this.setOpenListStatus(false);
        this.emitValueChange();
        this.emitValueComplete();
      }
      else {
        this.inputElement.focus();
      }
      this.preventReFocus = false;
    });
  }
  toggleList() {
    this.setOpenListStatus(!this.listOpen);
  }
  onInputKeyUp(event) {
    if (this.handleUpAndDownNavigation(event)) ;
    else if (["Enter", "Escape"].includes(event.code)) {
      this.setOpenListStatus(false);
      this.emitValueComplete();
    }
  }
  onInputKeyDown(event) {
    if (["ArrowDown", "ArrowUp"].includes(event.code)) {
      event.preventDefault();
    }
  }
  onInputClicked() {
    if (!this.disabled) {
      this.toggleList();
    }
  }
  setOpenListStatus(isOpen) {
    this.listOpen = isOpen;
    index.forceUpdate(this);
    if (this.listOpen) {
      this.inputElement.focus();
    }
  }
  /**
   * Used by the hidden native <select> to react to changes.
   */
  selectOptionsByValue(text) {
    if (text === NULL_STRING || text === "") {
      if (this.internalValue !== null) {
        this.selectedOption = null;
        this.updateInternalValue(null);
        this.emitValueChange();
      }
    }
    else {
      const optionWithValueMatchingText = this.options.find((option) => JSON.stringify(option.value) === text);
      if (optionWithValueMatchingText != null) {
        this.selectedOption = optionWithValueMatchingText;
        this.updateInternalValue(this.selectedOption.value);
        this.elseoptionselected = false;
        this.emitValueChange();
      }
      else {
        this.updateInternalValue(this.internalValue);
      }
    }
  }
  requestElseOption() {
    this.elseoptionselected = true;
    this.selectedOption = null;
    this.updateInternalValue("");
    renderUtil.onNextFrame(() => {
      var _a;
      (_a = this.elseOptionInput) === null || _a === void 0 ? void 0 : _a.focusControl();
    });
  }
  selectValueFromElseOption(value) {
    this.updateInternalValue(value);
    this.emitValueChange();
  }
  handleUpAndDownNavigation(event) {
    if (["ArrowDown", "ArrowUp"].includes(event.code)) {
      const selectedIndex = this.options.findIndex((option) => { var _a; return option.value === ((_a = this.selectedOption) === null || _a === void 0 ? void 0 : _a.value); });
      if (event.code == "ArrowDown") {
        if (selectedIndex === -1 || selectedIndex === this.options.length - 1) {
          this.selectOption(this.options[0]);
        }
        else {
          this.selectOption(this.options[selectedIndex + 1]);
        }
      }
      if (event.code == "ArrowUp") {
        if (selectedIndex === -1 || selectedIndex === 0) {
          this.selectOption(this.options[this.options.length - 1]);
        }
        else {
          this.selectOption(this.options[selectedIndex - 1]);
        }
      }
      this.showMouseHoverEffectOnList = false;
      this.setOpenListStatus(true);
      event.preventDefault();
      event.stopImmediatePropagation();
      return true;
    }
    return false;
  }
  emitValueChange() {
    this.value = this.internalValue;
    if (this.lastEmittedChangeValue !== this.value) {
      this.valueChange.emit(this.value);
      this.lastEmittedChangeValue = this.value;
    }
  }
  emitValueComplete() {
    if (this.lastEmittedCompleteValue !== this.value) {
      this.valueComplete.emit(this.value);
      this.lastEmittedCompleteValue = this.value;
    }
  }
  selectOption(option) {
    this.selectedOption = option;
    this.elseoptionselected = false;
    this.updateInternalValue(this.selectedOption.value);
    this.emitValueChange();
    this.scrollIntoView(this.selectedOption);
  }
  scrollIntoView(optionToView) {
    if (this.listOpen) {
      renderUtil.onNextFrame(() => {
        const selectedIndex = this.options.findIndex((option) => option.value === (optionToView === null || optionToView === void 0 ? void 0 : optionToView.value));
        if (selectedIndex > -1) {
          const list = this.self.shadowRoot.querySelector(".item-list-options");
          if (list == null) {
            return;
          }
          const items = Array.from(this.self.shadowRoot.querySelectorAll(".item-list .item"));
          const listHeight = list.offsetHeight;
          const itemHeight = items[0].offsetHeight;
          list.scrollTop =
            itemHeight * selectedIndex - listHeight / 2 + itemHeight / 2;
        }
      });
    }
  }
  superviseSelectElement(el) {
    clearInterval(this.observeSelectElementIntervalHandle);
    this.nativeSelect = el;
    // When the value of the select changes we want to run the code below
    miscUtil.hookToUpdateProperty(el, "value", () => {
      var _a;
      const areAllOptionsScanned = () => el.querySelectorAll("option").length >= this.options.length + 1;
      if (!this.elseoptionselected &&
        this.selectScanningEnabled &&
        !this.readonly &&
        JSON.stringify((_a = this.internalValue) !== null && _a !== void 0 ? _a : "null") !== el.value &&
        areAllOptionsScanned()) {
        this.selectOptionsByValue(el.value);
      }
    });
  }
  valueMatchesOption() {
    var _a, _b;
    return (((_b = (_a = this.value) === null || _a === void 0 ? void 0 : _a.toString()) === null || _b === void 0 ? void 0 : _b.length) > 0 &&
      this.options.find((option) => option.value === this.value) != null);
  }
  render() {
    var _a, _b, _c, _d;
    if (this.readonly) {
      return (index.h(baseElements.ReadonlyTextElement, { text: (_b = (_a = this.selectedOption) === null || _a === void 0 ? void 0 : _a.label) !== null && _b !== void 0 ? _b : "", label: this.label, kisynced: this.kisynced }));
    }
    const isErrorOutline = ((_c = this.errormessage) === null || _c === void 0 ? void 0 : _c.length) > 0 || this.error;
    const requirementFulfilled = this.valueMatchesOption() || this.elseoptionselected;
    return (index.h(index.Host, null, index.h("div", { class: {
        input: true,
        disabled: this.disabled,
      }, ref: (el) => (this.inputElement = el), id: elementIdHandling.ElementIdGenerator.createId(this.self, "user-interaction"), tabIndex: this.disabled ? -1 : 0, onKeyDown: (event) => this.onInputKeyDown(event), onKeyUp: (event) => this.onInputKeyUp(event), onFocus: () => this.onInputFocused(), onBlur: () => this.onInputBlurred(), onClick: () => this.onInputClicked() }, " ", index.h("ds-input-label", { disabled: this.disabled, label: this.label, kisynced: this.kisynced }), index.h("dx-overlay", { position: this.popupposition, offsety: 4, disabled: !this.listOpen }, index.h(inputContainer.InputContainer, { active: this.inputFocused, error: isErrorOutline, required: this.required && !this.elseoptionselected, requirementFulfilled: requirementFulfilled, disabled: this.disabled, title: (_d = this.selectedOption) === null || _d === void 0 ? void 0 : _d.label }, this.renderNativeSelect(), this.renderCurrentValue(), this.renderOpenListButton(), index.h(errorPopup.ErrorPopup, { text: this.errormessage, show: !this.listOpen &&
        !this.elseoptionselected &&
        this.inputFocused })), this.renderItemList())), index.h("ds-required-hint", { required: this.required, fulfilled: requirementFulfilled }), this.renderElseOptionInput()));
  }
  renderNativeSelect() {
    // The native select can be used for test automation tools to
    // change and read values from the select box.
    let nativeOptions = [
      { label: "-", value: NULL_STRING, icon: null },
      ...this.options,
    ];
    if (this.elseoptionselected) {
      nativeOptions = [
        {
          label: this.elseoptionbuttonlabel,
          value: "$$$ELSEOPTION$$$",
          icon: null,
        },
        ...nativeOptions,
      ];
    }
    return (index.h("select", { id: elementIdHandling.ElementIdGenerator.createId(this.self, "control"), ref: (el) => this.superviseSelectElement(el), tabIndex: -1, onChange: (e) => {
        const value = e.target.value;
        this.selectOptionsByValue(value);
      } }, nativeOptions.map((option) => {
      return (index.h("option", { selected: option.value === this.internalValue ||
          (this.internalValue === null && option.value === NULL_STRING), value: JSON.stringify(option.value) }, option.label));
    })));
  }
  renderOpenListButton() {
    return (index.h("ds-function-icon-button", { id: elementIdHandling.ElementIdGenerator.createId(this.self, "open-list-button"), unfocusable: true, class: {
        "open-list-button": true,
      } }, index.h("ds-icon", { icon: "drop-down", size: 16, class: {
        rotated: this.popupposition === "top",
        disabled: this.disabled === true,
      } })));
  }
  renderItemList() {
    if (this.listOpen) {
      return (index.h("div", { slot: "overlay", onMouseMove: () => (this.showMouseHoverEffectOnList = true), class: {
          "list-wrapper": true,
          "list-open": this.listOpen,
          "enable-mouse-hover": this.showMouseHoverEffectOnList,
        }, tabIndex: -1 }, index.h("div", { class: "item-list" }, index.h("div", { class: "item-list-options" }, this.options.map((option) => this.renderOption(option))), this.renderElseOptionButton())));
    }
  }
  renderElseOptionButton() {
    if (!this.elseoption || this.elseoptionselected) {
      return;
    }
    return (index.h("div", { class: "else-option-button", onClick: () => this.requestElseOption() }, index.h("ds-text-button", { unfocusable: true, id: elementIdHandling.ElementIdGenerator.createId(this.self, "else-option-button"), screensize: "small" }, index.h("ds-text", null, this.elseoptionbuttonlabel))));
  }
  renderOption(option, interactive = true, isPlaceholder = false) {
    var _a, _b;
    return (index.h("div", { id: !isPlaceholder
        ? elementIdHandling.ElementIdGenerator.createId(this.self, `item-list-value-${option.value}`)
        : undefined, class: {
        item: true,
        "is-placeholder": isPlaceholder,
        right: this.textalign == "right",
        selected: option.value == ((_a = this.selectedOption) === null || _a === void 0 ? void 0 : _a.value),
        disabled: this.disabled === true,
      }, onClick: () => {
        if (interactive) {
          this.selectOption(option);
          this.inputElement.blur();
        }
      } }, ((_b = option.icon) === null || _b === void 0 ? void 0 : _b.length) > 0 ? (index.h("div", { class: { "icon-container": true } }, index.h("ds-icon", { size: 24, icon: option.icon }))) : null, index.h("div", { class: { "labels-container": true } }, index.h("ds-text", { key: option.label, type: "ft", screensize: "small" }, option.label), this.renderSubLabels(option, interactive, isPlaceholder))));
  }
  renderSubLabels(option, interactive, isPlaceholder) {
    // We don't want to render the sub labels in the dropdown container.
    if (isPlaceholder || !interactive) {
      return;
    }
    const subLabels = [];
    if (option.secondaryLabel) {
      subLabels.push(index.h("ds-text", { type: "it", screensize: "small" }, option.secondaryLabel));
    }
    if (option.tertiaryLabel) {
      subLabels.push(index.h("ds-text", { type: "itk", screensize: "small" }, option.tertiaryLabel));
    }
    return subLabels;
  }
  renderCurrentValue() {
    const className = "current-value";
    if (this.elseoptionselected) {
      return (index.h("div", { class: className }, this.renderOption({
        label: this.elseoptionbuttonlabel,
        value: "",
      }, false)));
    }
    if (this.selectedOption != null) {
      return (index.h("div", { class: className }, this.renderOption(this.selectedOption, false)));
    }
    return (index.h("div", { class: className }, this.renderOption({
      label: this.placeholder,
      icon: this.icon,
      value: "",
    }, false, true)));
  }
  renderElseOptionInput() {
    var _a;
    if (!this.elseoptionselected) {
      return;
    }
    return (index.h("div", { class: "else-option-input-container" }, index.h("ds-text-input", { ref: (el) => (this.elseOptionInput = el), id: elementIdHandling.ElementIdGenerator.createId(this.self, "else-option-input"), label: this.elseoptioninputlabel, value: this.internalValue, disabled: this.disabled, required: this.required, error: this.error || ((_a = this.errormessage) === null || _a === void 0 ? void 0 : _a.length) > 0, errormessage: this.errormessage, onFocus: () => {
        this.selectScanningEnabled = false;
        this.preventReFocus = true;
      }, onBlur: () => {
        this.selectScanningEnabled = true;
        this.preventReFocus = false;
      }, onValueChange: (event) => {
        this.selectValueFromElseOption(event.detail);
        event.stopPropagation();
      } })));
  }
  get self() { return index.getElement(this); }
  static get watchers() { return {
    "value": ["valueChanged"]
  }; }
};
const NULL_STRING = "null";
DsDropdown.style = dsDropdownCss;

exports.ds_dropdown = DsDropdown;
