'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const index = require('./index-2f41386b.js');
const assert = require('./assert-d8ea75c6.js');
const elementIdHandling = require('./element-id-handling-89898a1c.js');
const miscUtil = require('./misc-util-63b423bd.js');
const breakpointAware = require('./breakpoint-aware-cc9d0ee6.js');
require('./value-store-f683b26f.js');

const dxTableHeaderItemCss = ":host{overflow:hidden;display:flex;flex:1;padding-top:8px;padding-bottom:8px}:host:host([hidden]){display:none !important}:host:host(.align-left){justify-content:flex-start}:host:host(.align-right){justify-content:flex-end}:host:host(.align-center){justify-content:center}:host .sort-icon{cursor:pointer;margin-left:4px;flex:0 0 16px}:host .header{width:100%;overflow:hidden;width:auto;text-align:left;height:100%;border:none;text-decoration:none;background:none;padding:4px 0;cursor:pointer;-webkit-appearance:none;-moz-appearance:none;outline:none}:host .header .cell{font-family:DVAG-Type, sans-serif;color:#2b2b2b;overflow:hidden;white-space:nowrap;text-overflow:ellipsis;width:100%;box-sizing:border-box;padding:0 16px}:host .header .cell.multiple-lines{display:-webkit-box;-webkit-line-clamp:var(--dx-table-cell-lines, 1);-webkit-box-orient:vertical;white-space:break-spaces}:host .header .cell.align-left{text-align:start}:host .header .cell.align-right{text-align:end}:host .header .cell.align-center{text-align:center}:host .header .cell dx-text{overflow:hidden;text-overflow:ellipsis}:host .header .cell ::slotted(*){overflow:hidden;text-overflow:ellipsis}:host .header:host(.cell){font-family:DVAG-Type, sans-serif;color:#2b2b2b;overflow:hidden;white-space:nowrap;text-overflow:ellipsis;width:100%;box-sizing:border-box;padding:0 16px}:host .header:host(.cell).multiple-lines{display:-webkit-box;-webkit-line-clamp:var(--dx-table-cell-lines, 1);-webkit-box-orient:vertical;white-space:break-spaces}:host .header:host(.cell).align-left{text-align:start}:host .header:host(.cell).align-right{text-align:end}:host .header:host(.cell).align-center{text-align:center}:host .header:host(.cell) dx-text{overflow:hidden;text-overflow:ellipsis}:host .header:host(.cell) ::slotted(*){overflow:hidden;text-overflow:ellipsis}:host .header[disabled]{cursor:default}:host .header:focus-visible{outline:2px solid #004763;outline-offset:-2px}:host .header .cell .label-container{display:flex;align-items:center}:host .header .cell .label-container .label{flex:1;display:flex;overflow:hidden;text-overflow:ellipsis}:host .header .cell .label-container .label.multiple-lines{display:-webkit-box;-webkit-box-orient:vertical;white-space:break-spaces}";

const DxTableHeaderItem = class {
  constructor(hostRef) {
    index.registerInstance(this, hostRef);
    this.tableScrollChanged = (e) => {
      this.tableScrollable = e.detail;
    };
    /**
     * Allows the table to sort this column.
     *
     * @value true: The column is sortable.
     * @value false: The column is not sortable.
     */
    this.sortable = false;
    /**
     * The alignment of the title text and the cell contents within this column.
     * **Warning:** The default alignment which is defined by the `type` property will be overriden.
     *
     * @value left: Child elements are left-aligned.
     * @value right: Child elements right-aligned.
     * @value center: Child elements are centered.
     */
    this.align = null;
    /**
     * Specifies the priority of this column which is considered in the table's secondary sorting.
     *
     * @value number: Priority. The lower this number the higher the chance this column will be considered first
     * in the secondary sorting of the table.
     *
     */
    this.sortpriority = null;
    /**
     * Specifies the number of rows within an column.
     *
     * @value s: Table cells have only 1 text row
     * @value m: Table cells have up to 2 text rows.
     * @value l: Table cell have up to 3 text rows.
     */
    this.linesize = "s";
    /**
     * @internal
     */
    this.usemaxwidth = false;
    /**
     * Whether this column is sticky or not.
     * @value true: The column and the corresponding cells are sticky and cannot be scrolled
     * @value false: The column can be scrolled away.
     */
    this.sticky = false;
    this.sortState = "neutral";
    this.internAlign = null;
    this.tableScrollable = false;
    this.mediaQueryAllowsStickyness = false;
  }
  onSortableChange() {
    if (this.sortable) {
      elementIdHandling.verifyElementId(this.self);
    }
  }
  onCustomSortChanged() {
    if (this.sortState !== "neutral") {
      this.invokeSort(this.sortState);
    }
  }
  onChangeAlign() {
    this.internAlign = this.getAlignment();
  }
  connectedCallback() {
    this.breakpointAware = new breakpointAware.BreakpointAware(() => this.updateMediaQueryStickyness(), true);
    this.table = miscUtil.findUpperElement(this.self, "dx-table");
    this.table.addEventListener("internalScrollChanged", this.tableScrollChanged);
    this.tableScrollable = this.table.internalScrollable;
    this.updateMediaQueryStickyness();
  }
  disconnectedCallback() {
    this.table.removeEventListener("internalScrollChanged", this.tableScrollChanged);
    this.table = null;
    this.breakpointAware.disconnect();
  }
  componentWillLoad() {
    this.internAlign = this.getAlignment();
    assert.assert(!!(this.label || this.columnid) || !this.sortable, () => "Sortable columns should define 'columnid' or 'label' properties. This is important for the table to differentiate between the columns.", this.self);
    if (this.sortable) {
      elementIdHandling.verifyElementId(this.self);
    }
  }
  /**
   * @internal
   */
  async setSortDirection(state) {
    this.invokeSort(state);
  }
  /**
   * @internal
   */
  async toColumnSettings() {
    return {
      type: this.type,
      align: this.internAlign,
      lines: this.getCellLines(),
      sizeStyle: this.buildStyle(),
      sticky: this.sticky,
    };
  }
  async getMinWidth() {
    return this.internalGetMinWidth();
  }
  async getMaxWidth() {
    return this.internalGetMaxWidth();
  }
  updateMediaQueryStickyness() {
    this.mediaQueryAllowsStickyness = this.breakpointAware.getEffectiveValue({
      mq1: false,
      mq3: true,
    });
  }
  getCellLines() {
    var _a;
    return {
      s: 1,
      m: 2,
      l: 3,
    }[(_a = this.linesize) !== null && _a !== void 0 ? _a : "s"];
  }
  buildStyle() {
    const minWidth = this.internalGetMinWidth();
    const maxWidth = this.internalGetMaxWidth();
    const style = {
      "max-width": isNaN(maxWidth) ? "100%" : maxWidth + "px",
      "min-width": minWidth + "px",
    };
    if (this.usemaxwidth) {
      const width = this.internalGetMaxWidth();
      style["width"] = width;
      style["flex"] = `0 0 ${width}`;
    }
    return style;
  }
  internalGetMinWidth() {
    return this.minwidth || this.maxwidth || 0;
  }
  internalGetMaxWidth() {
    if (this.isSticky()) {
      return this.internalGetMinWidth();
    }
    if (this.maxwidth != null) {
      return this.maxwidth;
    }
    if (this.usemaxwidth) {
      return this.internalGetMinWidth();
    }
    return NaN;
  }
  getAlignment() {
    var _a;
    return ((_a = this.align) !== null && _a !== void 0 ? _a : (this.type === "currency" || this.type === "numeric" ? "right" : "left"));
  }
  getSortIcon() {
    if (this.sortState === "neutral") {
      return "verteilen-vertik";
    }
    else if (this.sortState === "asc") {
      return "pfeil-hoch";
    }
    else {
      return "pfeil-runter";
    }
  }
  getHeaderCellLines() {
    return this.useMultipleLines() ? 2 : 1;
  }
  useMultipleLines() {
    return /\s|\xAD/.test(this.label); // &shy;
  }
  isSticky() {
    return (this.sticky && this.tableScrollable && this.mediaQueryAllowsStickyness);
  }
  render() {
    const alignClass = {};
    alignClass["align-" + this.internAlign] = true;
    return (index.h(index.Host, { slot: this.sticky ? "sticky" : undefined, style: this.buildStyle(), class: alignClass, role: "columnheader" }, index.h("button", { id: elementIdHandling.ElementIdGenerator.createId(this.self, "sort-button"), type: "button", disabled: !this.sortable, onClick: () => this.invokeSort(), class: "header" }, index.h("div", { class: Object.assign({ cell: true }, alignClass) }, index.h("div", { class: "label-container" }, index.h("div", { class: {
        label: true,
        "multiple-lines": this.useMultipleLines(),
      }, style: {
        "-webkit-line-clamp": `${this.getHeaderCellLines()}`,
      } }, this.renderLabel(), index.h("slot", null)), this.renderSortButton())))));
  }
  renderLabel() {
    if (this.label != null) {
      return (index.h("dx-text", { type: "ps", color: this.sortState !== "neutral" ? "default" : "gray-50" }, this.label));
    }
  }
  renderSortButton() {
    if (this.sortable) {
      return (index.h("dx-icon", { class: "sort-icon", icon: this.getSortIcon(), color: "default", size: 16 }));
    }
  }
  getNextSortState() {
    if (this.sortState == "neutral") {
      return "asc";
    }
    return this.sortState === "asc" ? "desc" : "asc";
  }
  invokeSort(state = undefined) {
    if (this.sortable) {
      this.sortState = state !== null && state !== void 0 ? state : this.getNextSortState();
      if (this.sortState !== "neutral") {
        const table = this.getParentTable();
        table.invokeSort(this.self, this.sortState === "desc").then();
      }
    }
  }
  getParentTable() {
    return this.self.closest("dx-table");
  }
  get self() { return index.getElement(this); }
  static get watchers() { return {
    "sortable": ["onSortableChange"],
    "customSort": ["onCustomSortChanged"],
    "align": ["onChangeAlign"]
  }; }
};
DxTableHeaderItem.style = dxTableHeaderItemCss;

exports.dx_table_header_item = DxTableHeaderItem;
