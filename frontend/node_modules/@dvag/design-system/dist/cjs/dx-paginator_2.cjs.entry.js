'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const index = require('./index-2f41386b.js');
const elementIdHandling = require('./element-id-handling-89898a1c.js');
const mathUtil = require('./math-util-a514efc6.js');
const miscUtil = require('./misc-util-63b423bd.js');
const dragController = require('./drag-controller-fb679cde.js');
require('./value-store-f683b26f.js');

class PaginatorState {
  constructor(page, count, onStateChange) {
    this.page = page;
    this.count = count;
    this.onStateChange = onStateChange;
    this.previousState = {
      page: this.page,
      count: this.count,
      items: this.build(),
      movedToLeft: false,
    };
  }
  toTheLeft() {
    this.setPage(this.page - 1);
  }
  toTheRight() {
    this.setPage(this.page + 1);
  }
  setPage(page) {
    page = mathUtil.clamp(page, 1, this.count);
    if (page !== this.page) {
      const movedToLeft = page < this.page;
      this.page = page;
      const currentState = {
        page: this.page,
        count: this.count,
        items: this.build(),
        movedToLeft,
      };
      this.onStateChange(currentState, this.previousState);
      this.previousState = currentState;
    }
  }
  build() {
    const diffToStart = this.page - 1;
    const diffToEnd = this.count - this.page;
    const result = [];
    if (diffToStart > 3) {
      result.push("small", "medium", "large", "large", "active");
    }
    else if (diffToStart > 2) {
      result.push("medium", "large", "large", "active");
    }
    else {
      for (let i = 1; i <= 3; ++i) {
        if (this.page === i) {
          result.push("active");
        }
        else {
          result.push("large");
        }
      }
    }
    if (diffToEnd > 1) {
      result.push("medium", "small");
    }
    else if (diffToEnd === 1) {
      result.push("medium");
    }
    return result;
  }
}

class PaginatorAnimationController {
  constructor(page, count) {
    this.elements = [];
    this.queue = [];
    this.animationDuration = DEFAULT_ANIMATION_DURATION;
    this.paginationState = new PaginatorState(page, count, this.onStateChanged.bind(this));
  }
  initialize() {
    this.elements.forEach(resetPageClass);
    this.updateElementPositions(this.paginationState.build());
    this.updateAnimationDuration();
  }
  updateAnimationDuration() {
    this.elements.forEach((element) => {
      element.style.setProperty("--dx-paginator-animation-duration", `${this.animationDuration}ms`);
    });
  }
  updateElementPositions(items) {
    // The startIndex begins with 1 because we ignore the first element which is hidden
    const startIndex = 1;
    items.forEach((paginationItem, index) => {
      const classes = convertPaginationItemToClass(paginationItem);
      this.elements[startIndex + index].classList.add(...classes);
    });
    const maxSpace = 90;
    const space = getPaginationSpace(items);
    const startX = (maxSpace - space) / 2;
    let currentX = startX;
    this.elements.forEach((element, index) => {
      const diff = index - startIndex;
      if (diff < 0) {
        element.style.transform = `translateX(0px)`;
      }
      else if (diff >= items.length) {
        element.style.transform = `translateX(${startX + space + MARGIN_BETWEEN_PAGINATION_ITEMS}px)`;
      }
      else {
        const currentPaginationItem = items[diff];
        const currentPaginationItemWidth = getItemWidth(currentPaginationItem);
        const marginLeft = diff === 0
          ? MARGIN_BETWEEN_PAGINATION_ITEMS
          : MARGIN_BETWEEN_PAGINATION_ITEMS * 0.5;
        const marginRight = diff === items.length - 1
          ? MARGIN_BETWEEN_PAGINATION_ITEMS
          : MARGIN_BETWEEN_PAGINATION_ITEMS * 0.5;
        element.style.transform = `translateX(${currentX + marginLeft}px)`;
        currentX += currentPaginationItemWidth + marginLeft + marginRight;
      }
    });
  }
  async onStateChanged(currentState, previousState) {
    // If an animation is currently playing we want to delay the next animation.
    if (this.timeoutHandle != null) {
      this.queue.push({
        current: currentState,
        previous: previousState,
      });
      this.animationDuration = Math.max(50, this.animationDuration * 0.75);
      this.updateAnimationDuration();
    }
    else {
      await this.processStateChanged(currentState, previousState);
    }
  }
  async processStateChanged(currentState, previousState) {
    const left = currentState.movedToLeft;
    if (currentState.page > 5 || previousState.page > 5) {
      this.shift(left);
    }
    await miscUtil.waitAnimationFrame();
    await miscUtil.waitAnimationFrame();
    this.elements.forEach(resetPageClass);
    this.elements.forEach((element) => element.classList.remove("no-animation"));
    this.updateElementPositions(currentState.items);
    this.timeoutHandle = setTimeout(() => {
      const transitionState = this.queue.shift();
      if (transitionState != null) {
        this.processStateChanged(transitionState.current, transitionState.previous);
      }
      else {
        this.timeoutHandle = null;
        this.animationDuration = DEFAULT_ANIMATION_DURATION;
        this.updateAnimationDuration();
        this.elements.forEach((element) => element.classList.add("no-animation"));
      }
    }, this.animationDuration);
  }
  // Shifts all elements states (classes and transform) to the left or right element.
  shift(left) {
    const elementStatesAndTransforms = this.elements.map((element) => {
      const classList = Array.from(element.classList);
      return {
        classes: classList,
        transform: element.style.transform,
      };
    });
    this.elements.forEach(resetPageClass);
    const scale = left ? -1 : 1;
    this.elements.forEach((element, index) => {
      element.classList.add("no-animation");
      const elementStateAndTransform = elementStatesAndTransforms[index + scale * 1];
      if (elementStateAndTransform) {
        element.classList.add(...elementStateAndTransform.classes);
        element.style.transform = elementStateAndTransform.transform;
      }
    });
  }
  setPage(page) {
    this.paginationState.setPage(page);
  }
  setIndex(index, element) {
    this.elements[index] = element;
  }
}
const DEFAULT_ANIMATION_DURATION = 300;
const PAGE_STATE_CLASSES = [
  "size-small",
  "size-medium",
  "size-large",
  "active",
];
const MARGIN_BETWEEN_PAGINATION_ITEMS = 8;
function resetPageClass(element) {
  element.classList.remove(...PAGE_STATE_CLASSES);
}
function getItemWidth(paginationItem) {
  return { small: 3, medium: 6, large: 8, active: 8 }[paginationItem];
}
function getPaginationSpace(paginationItems) {
  if (paginationItems == null) {
    return null;
  }
  return paginationItems.reduce((acc, item) => {
    const itemWidth = getItemWidth(item);
    return acc + itemWidth + MARGIN_BETWEEN_PAGINATION_ITEMS;
  }, -MARGIN_BETWEEN_PAGINATION_ITEMS);
}
function convertPaginationItemToClass(paginationItem) {
  if (paginationItem == null) {
    return [];
  }
  if (paginationItem === "active") {
    return ["active", "size-large"];
  }
  return [`size-${paginationItem}`];
}

const dxPaginatorCss = ":host{display:flex}:host:host([hidden]){display:none !important}:host:host(.hide){display:none}:host .page-switcher{transition:opacity 150ms ease-in-out}:host .pages-container{display:flex;justify-content:center;align-items:center;overflow:hidden;position:relative;height:40px;box-sizing:border-box}:host .pages-container.size-small{width:106px}:host .pages-container .movable-page{display:flex;position:absolute;left:0;height:8px;align-items:center;margin:0;transition:transform ease-in-out;transition-duration:var(--dx-paginator-animation-duration, 300ms)}:host .pages-container .movable-page .dot{width:0;height:0;border-radius:50%;background-color:#d6d6d6;transition:background-color ease-in-out, width ease-in-out, height ease-in-out;transition-duration:var(--dx-paginator-animation-duration, 300ms)}:host .pages-container .movable-page.no-animation{transition:none}:host .pages-container .movable-page.no-animation .dot{transition:none}:host .pages-container .movable-page.size-small,:host .pages-container .movable-page.size-medium,:host .pages-container .movable-page.size-large,:host .pages-container .movable-page.active{width:unset}:host .pages-container .movable-page.size-small .dot{width:3px;height:3px}:host .pages-container .movable-page.size-medium .dot{width:6px;height:6px}:host .pages-container .movable-page.size-large .dot{width:8px;height:8px}:host .pages-container .movable-page.active .dot{background-color:#004763}:host .page-container{white-space:nowrap}:host .page-container .page-button{width:var(--dx-button-width, fit-content);width:var(--dx-button-width, -moz-fit-content);cursor:pointer;display:inline-flex;justify-content:center;align-items:center;box-sizing:border-box;white-space:nowrap;user-select:none;-webkit-user-select:none;border:none;margin:0;background-color:transparent;transition:background-color 150ms ease-in-out, border-color 150ms ease-in-out;outline-offset:2px;width:40px;height:40px;padding:14px;background-color:rgba(0, 88, 124, 0);transition:background-color 150ms ease-in-out}:host .page-container .page-button[disabled]{cursor:unset}:host .page-container .page-button.icon-right{flex-direction:row-reverse}:host .page-container .page-button:focus-visible{outline:2px solid #004763}:host .page-container .page-button .dot{content:\"\";border-radius:50%;width:12px;height:12px;background-color:#d6d6d6;transition:background-color 150ms ease-in-out}@media not all and (pointer: coarse){:host .page-container .page-button:hover{background-color:rgba(0, 88, 124, 0.1)}:host .page-container .page-button:hover .dot{background-color:#00587c}}:host .page-container .page-button:focus{outline:none;background-color:rgba(0, 88, 124, 0.2)}:host .page-container .page-button:focus .dot{background-color:#004763}:host .page-container .page-button:active{background-color:rgba(0, 88, 124, 0.2)}:host .page-container .page-button:active .dot{background-color:#004763}:host .page-container .page-button.current-page{pointer-events:none;cursor:default}:host .page-container .page-button.current-page .dot{background-color:#004763}:host .page-container .page-button.current-page:focus{background-color:initial}";

const DxPaginator = class {
  constructor(hostRef) {
    index.registerInstance(this, hostRef);
    this.pageChanged = index.createEvent(this, "pageChanged", 7);
    this.shouldInitializeAnimationController = true;
    /**
     * The first page which should be displayed.
     *
     *@value number: A number from 1 to `count`. This property is mutable and will be delegated by the `pageChanged` event.
     *
     * @example current
     */
    this.current = 1;
    this.currentPage = 1;
  }
  onCountChange() {
    if (this.shouldDisplayAnimatablePageButtons()) {
      this.definePaginatorAnimationController();
    }
    else {
      this.paginatorAnimationController = null;
    }
    this.setCurrentPage(this.currentPage);
  }
  onPageChange() {
    this.setCurrentPage(this.current, false);
  }
  componentWillLoad() {
    this.currentPage = this.current;
    elementIdHandling.verifyElementId(this.self);
    if (this.shouldDisplayAnimatablePageButtons()) {
      this.definePaginatorAnimationController();
    }
  }
  componentDidRender() {
    if (this.shouldInitializeAnimationController &&
      this.shouldDisplayAnimatablePageButtons()) {
      this.paginatorAnimationController.initialize();
      this.shouldInitializeAnimationController = false;
    }
  }
  shouldDisplayAnimatablePageButtons() {
    return this.count > 5;
  }
  definePaginatorAnimationController() {
    this.paginatorAnimationController = new PaginatorAnimationController(this.currentPage, this.count);
    this.shouldInitializeAnimationController = true;
  }
  setCurrentPage(page, emit = true) {
    var _a;
    const clampedPage = mathUtil.clamp(page, 1, Math.max(this.count, 1));
    if (clampedPage !== this.currentPage) {
      this.currentPage = clampedPage;
      (_a = this.paginatorAnimationController) === null || _a === void 0 ? void 0 : _a.setPage(this.currentPage);
      if (emit) {
        this.pageChanged.emit(this.currentPage);
      }
    }
  }
  renderPageButton(page) {
    const isSelected = this.currentPage === page;
    return (index.h("button", { id: elementIdHandling.ElementIdGenerator.createId(this.self, `page-${page}`), type: "button", class: {
        "page-button": true,
        "current-page": isSelected,
      }, disabled: isSelected, tabIndex: isSelected ? -1 : 0, onClick: () => this.setCurrentPage(page) }, index.h("div", { class: "dot" })));
  }
  renderMovableButtons() {
    return Array.from(new Array(9)).map((_, index) => {
      return this.renderMovablePage(index);
    });
  }
  renderMovablePage(index$1) {
    return (index.h("div", { class: {
        "movable-page": true,
        "no-animation": true,
      }, key: index$1, ref: (ref) => { var _a; return (_a = this.paginatorAnimationController) === null || _a === void 0 ? void 0 : _a.setIndex(index$1, ref); } }, index.h("div", { class: {
        dot: true,
      } })));
  }
  renderPageButtons() {
    if (this.count <= 1 || isNaN(this.count)) {
      return null;
    }
    if (this.count > 5) {
      return this.renderMovableButtons();
    }
    return (index.h("div", { class: "page-container" }, Array.from(new Array(this.count)).map((_, index) => {
      return this.renderPageButton(index + 1);
    })));
  }
  render() {
    const leftButtonIsDisabled = this.currentPage > 1;
    const rightButtonIsDisabled = this.currentPage < this.count;
    return (index.h(index.Host, { class: {
        hide: this.count <= 1,
      } }, index.h("dx-button", { id: elementIdHandling.ElementIdGenerator.createId(this.self, "page-down"), icon: "chevron-links", type: "text", class: {
        "page-switcher": true,
      }, disabled: !leftButtonIsDisabled, onClick: () => this.setCurrentPage(this.currentPage - 1) }), index.h("div", { class: {
        "pages-container": true,
        "size-small": this.shouldDisplayAnimatablePageButtons(),
      } }, this.renderPageButtons()), index.h("dx-button", { id: elementIdHandling.ElementIdGenerator.createId(this.self, "page-up"), icon: "chevron-rechts", type: "text", class: {
        "page-switcher": true,
      }, disabled: !rightButtonIsDisabled, onClick: () => this.setCurrentPage(this.currentPage + 1) })));
  }
  get self() { return index.getElement(this); }
  static get watchers() { return {
    "count": ["onCountChange"],
    "current": ["onPageChange"]
  }; }
};
DxPaginator.style = dxPaginatorCss;

const dxSlideshowSliderCss = ":host{display:block;width:100%;position:relative;top:0;left:0;height:4px;background-color:#d6d6d6}:host:host([hidden]){display:none !important}:host .hover-trigger{position:absolute;top:-16px;height:36px;left:0;right:0;display:flex;align-items:center}:host .hover-trigger .knob-trigger{height:20px;display:flex;align-items:center;cursor:grab !important}:host .hover-trigger .knob-trigger.use-transition{transition:width 150ms ease-in-out, transform 300ms ease-in-out}:host .hover-trigger .knob-trigger .knob{background-color:#337a96;box-sizing:border-box;height:4px;width:100%}:host .hover-trigger .knob-trigger .knob.use-transition{transition:height 150ms ease-in-out}:host .hover-trigger:hover .knob,:host .hover-trigger .knob-trigger.is-dragging .knob{height:8px}";

const DxSlideshowSlider = class {
  constructor(hostRef) {
    index.registerInstance(this, hostRef);
    this.valueChange = index.createEvent(this, "valueChange", 7);
    this.dragging = index.createEvent(this, "dragging", 7);
    // This is set to true, when the user interacts with the sidebar under the knob
    this.initDragOutsideOfKnob = false;
    this.internalValue = 0;
    this.isDragging = false;
    /**
     * Size of the Steps, the values can be selected.
     * @value number: Minimal possible change.
     * @example step
     */
    this.step = 0.01;
    /**
     * Current value of the slider.
     * @value number: Current value
     * @example min-max-value
     */
    this.value = 1;
  }
  onValueChanged() {
    if (!this.isDragging &&
      this.internalValue != this.value &&
      !isNaN(this.value)) {
      this.internalValue = this.value;
    }
  }
  componentWillLoad() {
    var _a;
    this.internalValue = (_a = this.value) !== null && _a !== void 0 ? _a : 1;
    this.dragController = new dragController.DragController((startX) => {
      var _a, _b;
      const knobBoundingClientRect = (_a = this.knob) === null || _a === void 0 ? void 0 : _a.getBoundingClientRect();
      if (this.initDragOutsideOfKnob) {
        const selfBoundingBox = this.self.getBoundingClientRect();
        this.initDragOutsideOfKnob = false;
        return {
          localKnobOffset: startX - knobBoundingClientRect.width * 0.5 - selfBoundingBox.x,
          knobWidth: knobBoundingClientRect.width,
        };
      }
      return {
        localKnobOffset: knobBoundingClientRect.x - ((_b = this.self.getBoundingClientRect()) === null || _b === void 0 ? void 0 : _b.x),
        knobWidth: knobBoundingClientRect.width,
      };
    }, (e) => {
      var _a;
      const boundingBox = this.self.getBoundingClientRect();
      const localMouseOnKnobPositionX = e.startX - boundingBox.x - e.startValue.localKnobOffset;
      const mouseLimitLeft = boundingBox.left + localMouseOnKnobPositionX;
      const mouseLimitRight = boundingBox.right -
        (e.startValue.knobWidth - localMouseOnKnobPositionX);
      const position = Math.max(0, Math.min((e.x - mouseLimitLeft) / (mouseLimitRight - mouseLimitLeft), 1));
      const computedValue = Math.ceil((MIN + position * (this.max - MIN)) / this.step) *
        this.step;
      const fractionDigits = ((_a = this.step.toString().split(".")[1]) === null || _a === void 0 ? void 0 : _a.length) || 0;
      const newValue = parseFloat(computedValue.toFixed(fractionDigits));
      if (this.internalValue !== newValue && !isNaN(newValue)) {
        this.internalValue = newValue;
        this.valueChange.emit(this.internalValue);
      }
    }, () => this.onStartDragging(), () => this.onStopDragging());
  }
  componentShouldUpdate(_, __, propName) {
    if (["min", "max"].includes(propName)) {
      this.internalValue = mathUtil.clamp(this.value, MIN, this.max);
    }
  }
  onStartDragging() {
    this.isDragging = true;
    this.dragging.emit(true);
  }
  onStopDragging() {
    this.isDragging = false;
    this.dragging.emit(false);
    this.internalValue = Math.round(this.internalValue);
    this.valueChange.emit(this.internalValue);
  }
  getKnobWidthPercentage() {
    return 100 / this.max;
  }
  getKnobPositionPercentage() {
    return 100 * (this.internalValue - 1);
  }
  render() {
    return (index.h(index.Host, { class: {
        "is-dragging": this.isDragging,
      }, onPointerDown: (e) => {
        this.initDragOutsideOfKnob = true;
        this.dragController.onPointerDown(e);
      }, onTouchStart: (e) => {
        this.initDragOutsideOfKnob = true;
        this.dragController.onTouchStart(e);
      } }, index.h("div", { class: "hover-trigger" }, index.h("div", { class: {
        "knob-trigger": true,
        "is-dragging": this.isDragging,
        "use-transition": !this.isDragging,
      }, onPointerDown: (e) => {
        // Host should not trigger onPointerDown or onTouchStart
        e.stopPropagation();
        this.dragController.onPointerDown(e);
      }, onTouchStart: (e) => {
        // Host should not trigger onPointerDown or onTouchStart
        e.stopPropagation();
        this.dragController.onTouchStart(e);
      }, ref: (ref) => (this.knob = ref), style: {
        transform: `translateX(${this.getKnobPositionPercentage()}%)`,
        width: `${this.getKnobWidthPercentage()}%`,
      } }, index.h("div", { class: { knob: true, "use-transition": !this.isDragging } })))));
  }
  get self() { return index.getElement(this); }
  static get watchers() { return {
    "value": ["onValueChanged"]
  }; }
};
const MIN = 1;
DxSlideshowSlider.style = dxSlideshowSliderCss;

exports.dx_paginator = DxPaginator;
exports.dx_slideshow_slider = DxSlideshowSlider;
