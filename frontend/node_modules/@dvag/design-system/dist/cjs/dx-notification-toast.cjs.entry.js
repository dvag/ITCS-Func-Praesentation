'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const index = require('./index-2f41386b.js');
const breakpointAware = require('./breakpoint-aware-cc9d0ee6.js');
const elementIdHandling = require('./element-id-handling-89898a1c.js');
const renderUtil = require('./render-util-6b278c0d.js');
const swipeController = require('./swipe-controller-dd30ba97.js');
const valueStore = require('./value-store-f683b26f.js');
const debounce = require('./debounce-0d323abe.js');

const NOTIFICATION_SERVICE_KEY = "dx-notification-service";
class NotificationService {
  constructor() {
    this.currentPaddingTop = 24;
    this.currentNotificationToasts = [];
    this.notificationsTransitionDebounce = new debounce.Debounce(50);
    this.notificationCloseHandle = (e) => this.internalCloseNotification(e.target);
    this.resizeObserver = new ResizeObserver(() => {
      this.setNotificationsTransition(NO_NOTIFICATION_TOAST_TRANSITION);
      this.updatePositions();
      this.notificationsTransitionDebounce.run(() => {
        this.setNotificationsTransition(DEFAULT_NOTIFICATION_TOAST_TRANSITION);
      });
    });
    this.updatePositions();
  }
  connect() {
    this.breakpointAware = new breakpointAware.BreakpointAware(() => {
      this.currentPaddingTop = this.getCurrentPaddingTop();
      this.updatePositions();
    }, true);
    this.currentPaddingTop = this.getCurrentPaddingTop();
  }
  disconnect() {
    this.breakpointAware.disconnect();
  }
  getCurrentPaddingTop() {
    return this.breakpointAware.getEffectiveValue({
      mq1: 24,
      mq3: 40,
      mq5: 80,
    });
  }
  static instance() {
    return valueStore.ValueStore.instance().getOrPut(NOTIFICATION_SERVICE_KEY, () => new NotificationService());
  }
  addNotificationToast(notification) {
    if (this.currentNotificationToasts.includes(notification)) {
      return;
    }
    if (this.resizeObserver == null || this.breakpointAware == null) {
      this.connect();
    }
    this.currentNotificationToasts.push(notification);
    notification.addEventListener("closeNotification", this.notificationCloseHandle);
    this.resizeObserver.observe(notification);
    this.updatePositions();
  }
  internalCloseNotification(notificationToClose) {
    this.currentNotificationToasts = this.currentNotificationToasts.filter((notification) => {
      return notificationToClose !== notification;
    });
    notificationToClose.removeEventListener("closeNotification", this.notificationCloseHandle);
    this.resizeObserver.unobserve(notificationToClose);
    if (this.currentNotificationToasts.length === 0) {
      this.disconnect();
    }
    else {
      this.updatePositions();
    }
  }
  updatePositions() {
    const spaceBetweenToasts = 24;
    let referencePositionY = this.currentPaddingTop;
    this.currentNotificationToasts.forEach((notification) => {
      notification.style.top = referencePositionY + "px";
      referencePositionY += notification.offsetHeight + spaceBetweenToasts;
    });
  }
  setNotificationsTransition(transitionValue) {
    this.currentNotificationToasts.forEach((notification) => {
      notification.style.transition = transitionValue;
    });
  }
}
const DEFAULT_NOTIFICATION_TOAST_TRANSITION = "top 500ms ease-in-out";
const NO_NOTIFICATION_TOAST_TRANSITION = "none";

const dxNotificationToastCss = ":host{display:none;pointer-events:none;position:fixed;left:0;z-index:1002;width:100%;box-sizing:border-box;transition:top 500ms ease-in-out}:host:host([hidden]){display:none !important}:host:host(.visible){display:block}@keyframes to-the-right{0%{opacity:1;transform:translateY(0px) translateX(0px)}100%{opacity:0;transform:translateY(0px) translateX(100%)}}@keyframes to-the-left{0%{opacity:1;transform:translateY(0px) translateX(0px)}100%{opacity:0;transform:translateY(0px) translateX(-100%)}}:host .oversized-page{padding:0 8px;max-width:1460px;box-sizing:border-box}@media (min-width: 476px){:host .oversized-page{padding:0 12px}}@media (min-width: 760px){:host .oversized-page{padding:0 16px}}@media (min-width: 1280px){:host .oversized-page{padding:0 20px}}@media (min-width: 1460px){:host .oversized-page{margin:auto}}:host .oversized-page .flyout{box-shadow:0 0 8px rgba(0, 0, 0, 0.16);--delay:0;pointer-events:initial;display:flex;opacity:0;transform:translateY(-100px);transition:opacity 500ms ease-in-out, transform 500ms ease-in-out;will-change:opacity, transform}@media (min-width: 0px){:host .oversized-page .flyout{padding:48px 24px 24px 24px}}@media (min-width: 760px){:host .oversized-page .flyout{padding:24px 56px 24px 24px}}:host .oversized-page .flyout.show{opacity:1;transform:translateY(0px)}:host .oversized-page .flyout.to-the-right{animation:to-the-right 500ms linear;animation-play-state:var(--dx-toast-flyout-play-state, paused);animation-delay:var(--dx-toast-flyout-delay)}:host .oversized-page .flyout.to-the-left{animation:to-the-left 500ms linear;animation-play-state:var(--dx-toast-flyout-play-state, paused);animation-delay:var(--dx-toast-flyout-delay)}:host .oversized-page .flyout .content-container{display:flex;width:100%}@media (min-width: 0px){:host .oversized-page .flyout .content-container{flex-direction:column}}@media (min-width: 760px){:host .oversized-page .flyout .content-container{flex-direction:row}}:host .oversized-page .flyout .icon-container{display:flex;align-items:center;justify-content:center}@media (min-width: 760px){:host .oversized-page .flyout .icon-container{margin-right:24px}}:host .oversized-page .flyout .text-container{flex:1}:host .oversized-page .flyout .text-container .title{display:block;margin-bottom:8px}:host .oversized-page .flyout .text-container .subcontent{display:block;margin-top:8px}:host .oversized-page .flyout .close-icon-container{position:absolute;right:24px;top:24px}:host .oversized-page .flyout .close-icon-container .close-button{width:var(--dx-button-width, fit-content);width:var(--dx-button-width, -moz-fit-content);cursor:pointer;display:inline-flex;justify-content:center;align-items:center;box-sizing:border-box;white-space:nowrap;user-select:none;-webkit-user-select:none;border:none;margin:0;background-color:transparent;transition:background-color 150ms ease-in-out, border-color 150ms ease-in-out}:host .oversized-page .flyout .close-icon-container .close-button[disabled]{cursor:unset}:host ds-text{display:block}";

const DxNotificationToast = class {
  constructor(hostRef) {
    index.registerInstance(this, hostRef);
    this.closeNotification = index.createEvent(this, "closeNotification", 7);
    this.swipeController = new swipeController.SwipeController(() => {
      return 0;
    }, this.onSwipeStart.bind(this), this.onSwipeRecognized.bind(this), this.onSwipeUpdate.bind(this));
    this.show = false;
    this.animating = false;
    this.closingDirection = "top";
    /**
     * Specifies the time in seconds the notification is visible before it's closed automatically.
     * The specified time has to be greater than 0.
     *
     * @value number: A time in seconds.
     *
     * @example close-after
     */
    this.closeafter = 5;
  }
  onVisibleChanged() {
    if (this.visible) {
      this.resetTimerProperties();
      this.currentXOffset = undefined;
      this.flyout.style.removeProperty(ANIMATION_PLAY_STATE_VARIABLE_NAME);
      this.flyout.style.removeProperty(ANIMATION_DELAY_VARIABLE_NAME);
      this.animating = false;
      this.closingDirection = "top";
      NotificationService.instance().addNotificationToast(this.self);
      renderUtil.onNextFrame(() => {
        this.show = this.visible;
      });
    }
  }
  connectedCallback() {
    this.breakpointAware = new breakpointAware.BreakpointAware(() => index.forceUpdate(this), true);
    if (this.visible) {
      NotificationService.instance().addNotificationToast(this.self);
    }
  }
  disconnectedCallback() {
    this.breakpointAware.disconnect();
  }
  componentDidLoad() {
    requestAnimationFrame(() => {
      this.show = this.visible;
    });
  }
  closeImmediately() {
    clearTimeout(this.closeHandle);
    this.closeNotification.emit();
    this.visible = false;
    this.show = false;
  }
  handleAnimationEnd(e) {
    if (e.elapsedTime > 0.001) {
      this.closeImmediately();
    }
    else {
      this.animating = false;
    }
  }
  handleTransitionEnd(e) {
    // handleTransitionEnd is called twice because two different properties transition (opacity and transform)
    if (e.propertyName === "opacity") {
      return;
    }
    if (this.show) {
      if (Number.isInteger(this.closeafter) && this.closeafter > 0) {
        this.restTime = this.closeafter * 1000;
        this.startTimer();
      }
      else {
        this.show = false;
        console.error("The 'closeafter' property has to be an integer > 0", this.self);
      }
    }
    else {
      this.closeImmediately();
    }
  }
  onSwipeStart() {
    this.animating = true;
    this.stopTimer();
  }
  onSwipeUpdate(updateData) {
    this.currentXOffset = updateData.currentX - updateData.startX;
    this.animating = true;
    this.closingDirection =
      updateData.currentX > updateData.startX ? "right" : "left";
    // Set animation dependant on x difference
    const maxMs = 500;
    const percentage = Math.abs(updateData.currentX - updateData.startX) /
      this.flyout.offsetWidth;
    this.flyout.style.setProperty(ANIMATION_DELAY_VARIABLE_NAME, -percentage * maxMs + "ms");
  }
  onSwipeRecognized(swipeDirection) {
    const currentLeftValue = this.currentXOffset;
    this.currentXOffset = undefined;
    const canBeSwipedAway = swipeDirection === "left" ||
      swipeDirection === "right" ||
      Math.abs(currentLeftValue) > window.innerWidth * 0.333;
    if (canBeSwipedAway) {
      this.flyout.style.setProperty(ANIMATION_PLAY_STATE_VARIABLE_NAME, "running");
      this.closingDirection =
        swipeDirection === "left" || currentLeftValue >= 0 ? "right" : "left";
      this.show = false;
      return;
    }
    this.flyout.style.removeProperty(ANIMATION_DELAY_VARIABLE_NAME);
    this.flyout.style.removeProperty(ANIMATION_PLAY_STATE_VARIABLE_NAME);
    this.closingDirection = "top";
    this.startTimer();
  }
  resetTimerProperties() {
    this.start = undefined;
    this.restTime = this.closeafter * 1000;
    clearTimeout(this.closeHandle);
    this.closeHandle = null;
  }
  startTimer() {
    clearTimeout(this.closeHandle);
    this.start = new Date().getTime();
    this.closeHandle = setTimeout(() => {
      this.show = false;
      this.resetTimerProperties();
    }, this.restTime);
  }
  stopTimer() {
    const currentTime = new Date().getTime();
    this.restTime -= currentTime - this.start;
    clearTimeout(this.closeHandle);
    this.closeHandle = null;
  }
  renderTitle() {
    if (this.titlestring == null || this.titlestring.length === 0) {
      return;
    }
    return (index.h("dx-text", { class: "title", type: "pb", color: "headline" }, this.titlestring));
  }
  renderSubContent() {
    if (!this.subcontent) {
      return;
    }
    return (index.h("dx-text", { class: "subcontent", type: "its" }, this.subcontent));
  }
  renderIcon() {
    if (!this.icon) {
      return;
    }
    return (index.h("div", { class: "icon-container" }, index.h("dx-icon", { size: this.breakpointAware.mq1 ? 48 : 72, icon: this.icon, color: this.iconcolor })));
  }
  renderCloseButton() {
    return (index.h("div", { class: "close-icon-container" }, index.h("button", { id: elementIdHandling.ElementIdGenerator.createId(this.self, "close-button"), onClick: () => (this.show = false), class: "close-button" }, index.h("dx-icon", { icon: "schliessen", size: 24, color: "default" }))));
  }
  render() {
    return (index.h(index.Host, { class: { visible: this.visible }, role: "alert" }, index.h("div", { class: "oversized-page" }, index.h("dx-card", { class: {
        flyout: true,
        show: this.show,
        "page-wrapped-content": true,
        "to-the-left": this.animating && this.closingDirection === "left",
        "to-the-right": this.animating && this.closingDirection === "right",
      }, ref: (ref) => (this.flyout = ref), onTouchStart: (e) => this.swipeController.onTouchStart(e), onTransitionEnd: (e) => this.handleTransitionEnd(e), onAnimationEnd: (e) => this.handleAnimationEnd(e) }, index.h("div", { class: "content-container" }, this.renderIcon(), index.h("div", { class: "text-container" }, this.renderTitle(), index.h("slot", null), this.renderSubContent())), this.renderCloseButton()))));
  }
  get self() { return index.getElement(this); }
  static get watchers() { return {
    "visible": ["onVisibleChanged"]
  }; }
};
const ANIMATION_PLAY_STATE_VARIABLE_NAME = "--dx-toast-flyout-play-state";
const ANIMATION_DELAY_VARIABLE_NAME = "--dx-toast-flyout-delay";
DxNotificationToast.style = dxNotificationToastCss;

exports.dx_notification_toast = DxNotificationToast;
