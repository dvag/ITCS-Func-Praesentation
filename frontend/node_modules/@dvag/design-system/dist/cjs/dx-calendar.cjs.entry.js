'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const index = require('./index-2f41386b.js');
const dateRange_util = require('./date-range.util-3f8b8422.js');
const date_utils = require('./date.utils-9ecc3482.js');
const miscUtil = require('./misc-util-63b423bd.js');
const elementIdHandling = require('./element-id-handling-89898a1c.js');
require('./value-store-f683b26f.js');

function createRowEntry(date, outOfBoundsDateMin, outOfBoundsDateMax, constructDateEntry) {
  if (date_utils.DateUtils.isBeforeDate(date, outOfBoundsDateMin) ||
    date_utils.DateUtils.isAfterDate(date, outOfBoundsDateMax)) {
    return null;
  }
  if (date_utils.DateUtils.isSameDate(date, outOfBoundsDateMin)) {
    return "min";
  }
  if (date_utils.DateUtils.isSameDate(date, outOfBoundsDateMax)) {
    return "max";
  }
  return constructDateEntry();
}
function getOutOfBoundsDateMax(maxDate, mode) {
  const outOfBoundsDateMax = new Date(maxDate !== null && maxDate !== void 0 ? maxDate : NaN);
  if (mode === "day") {
    outOfBoundsDateMax.setDate(outOfBoundsDateMax.getDate() + 1);
  }
  else if (mode === "month") {
    outOfBoundsDateMax.setMonth(outOfBoundsDateMax.getMonth() + 1, 1);
  }
  else if (mode === "year") {
    outOfBoundsDateMax.setFullYear(outOfBoundsDateMax.getFullYear() + 1, 0, 1);
  }
  outOfBoundsDateMax.setHours(0, 0, 0, 0);
  return outOfBoundsDateMax;
}
function getOutOfBoundsDateMin(minDate, mode) {
  const outOfBoundsDateMin = new Date(minDate !== null && minDate !== void 0 ? minDate : NaN);
  if (mode === "day") {
    outOfBoundsDateMin.setDate(outOfBoundsDateMin.getDate() - 1);
  }
  else if (mode === "month") {
    outOfBoundsDateMin.setMonth(outOfBoundsDateMin.getMonth() - 1, 1);
  }
  else if (mode === "year") {
    outOfBoundsDateMin.setFullYear(outOfBoundsDateMin.getFullYear() - 1, 0, 1);
  }
  outOfBoundsDateMin.setHours(0, 0, 0, 0);
  return outOfBoundsDateMin;
}
window["callIt"] = () => {
  return createSimpleDayCalendar({
    date: date_utils.DateUtils.newDateFromString("2021-01-01"),
    selectedRange: {
      from: date_utils.DateUtils.newDateFromString("2021-01-01"),
      to: undefined,
    },
  });
};
function getWithYearToZero(date) {
  if (date == null) {
    return null;
  }
  const result = new Date(date);
  result.setFullYear(0);
  return result;
}
function createSimpleDayCalendar(calendarInputParams) {
  const date = getWithYearToZero(calendarInputParams.date);
  const selectedRange = {
    from: getWithYearToZero(calendarInputParams.selectedRange.from),
    to: getWithYearToZero(calendarInputParams.selectedRange.to),
  };
  const minDate = getWithYearToZero(calendarInputParams.minDate);
  const maxDate = getWithYearToZero(calendarInputParams.maxDate);
  const outOfBoundsDateMin = getOutOfBoundsDateMin(minDate, "day");
  const outOfBoundsDateMax = getOutOfBoundsDateMax(maxDate, "day");
  const calendarLabel = date_utils.MONTH_NAMES[date.getMonth()];
  const amountOfDays = {
    Januar: 31,
    Februar: 29,
    MÃ¤rz: 31,
    April: 30,
    Mai: 31,
    Juni: 30,
    Juli: 31,
    August: 31,
    September: 30,
    Oktober: 31,
    November: 30,
    Dezember: 31,
  }[calendarLabel];
  const rowEntries = [];
  for (let day = 1; day <= 36; ++day) {
    const newDate = date_utils.DateUtils.newDate(0, date.getMonth(), day);
    if (day <= amountOfDays) {
      rowEntries.push(createRowEntry(newDate, outOfBoundsDateMin, outOfBoundsDateMax, () => {
        return {
          label: day.toString(),
          date: new Date(newDate),
          bright: false,
          active: date_utils.DateUtils.isSameDate(newDate, selectedRange.from) ||
            date_utils.DateUtils.isSameDate(newDate, selectedRange.to),
          highlightedLeft: date_utils.DateUtils.isAfterDate(newDate, selectedRange.from) &&
            date_utils.DateUtils.isBeforeOrSameDate(newDate, selectedRange.to),
          highlightedRight: date_utils.DateUtils.isAfterOrSameDate(newDate, selectedRange.from) &&
            date_utils.DateUtils.isBeforeDate(newDate, selectedRange.to),
          interactable: true,
        };
      }));
    }
    else {
      rowEntries.push(null);
    }
  }
  const rows = [];
  rowEntries.forEach((value, index) => {
    var _a, _b;
    const rowIndex = Math.floor(index / 6);
    rows[rowIndex] = (_b = (_a = rows[rowIndex]) === null || _a === void 0 ? void 0 : _a.concat(value)) !== null && _b !== void 0 ? _b : [value];
  });
  const firstOfMonth = date_utils.DateUtils.getFirstDayOfMonth(date);
  const lastOfMonth = date_utils.DateUtils.getLastDayOfMonth(firstOfMonth);
  return {
    headerLabel: calendarLabel,
    headerRow: null,
    rows: rows,
    canNavigateLeft: date.getMonth() > 0 &&
      (!date_utils.DateUtils.isValidDate(minDate) ||
        date_utils.DateUtils.isBeforeDate(minDate, firstOfMonth)),
    canNavigateRight: date.getMonth() < 11 &&
      (!date_utils.DateUtils.isValidDate(maxDate) ||
        date_utils.DateUtils.isAfterDate(maxDate, lastOfMonth)),
  };
}
function createDayCalendar(calendarInputParams) {
  const date = calendarInputParams.date;
  const selectedRange = calendarInputParams.selectedRange;
  const minDate = calendarInputParams.minDate;
  const maxDate = calendarInputParams.maxDate;
  const outOfBoundsDateMin = getOutOfBoundsDateMin(minDate, "day");
  const outOfBoundsDateMax = getOutOfBoundsDateMax(maxDate, "day");
  const calendarLabel = date_utils.MONTH_NAMES[date.getMonth()] + " " + date.getFullYear();
  const firstOfMonth = date_utils.DateUtils.getFirstDayOfMonth(date);
  const start = date_utils.DateUtils.getMondayOfWeek(firstOfMonth);
  const lastOfMonth = date_utils.DateUtils.getLastDayOfMonth(firstOfMonth);
  const end = date_utils.DateUtils.getSundayOfWeek(lastOfMonth);
  const iterator = new Date(start);
  const rowEntries = [];
  while (date_utils.DateUtils.isBeforeOrSameDate(iterator, end)) {
    rowEntries.push(createRowEntry(iterator, outOfBoundsDateMin, outOfBoundsDateMax, () => {
      return {
        label: iterator.getDate().toString(),
        date: new Date(iterator),
        bright: iterator.getMonth() !== firstOfMonth.getMonth(),
        active: date_utils.DateUtils.isSameDate(iterator, selectedRange.from) ||
          date_utils.DateUtils.isSameDate(iterator, selectedRange.to),
        highlightedLeft: date_utils.DateUtils.isAfterDate(iterator, selectedRange.from) &&
          date_utils.DateUtils.isBeforeOrSameDate(iterator, selectedRange.to),
        highlightedRight: date_utils.DateUtils.isAfterOrSameDate(iterator, selectedRange.from) &&
          date_utils.DateUtils.isBeforeDate(iterator, selectedRange.to),
        interactable: true,
      };
    }));
    date_utils.DateUtils.addDays(iterator, 1);
  }
  const headerEntries = date_utils.DateUtils.getShortWeekdayNames().map((weekDayName) => {
    return {
      label: weekDayName,
      date: undefined,
      textType: "its",
    };
  });
  const rows = [];
  rowEntries.forEach((value, index) => {
    var _a, _b;
    const rowIndex = Math.floor(index / 7);
    rows[rowIndex] = (_b = (_a = rows[rowIndex]) === null || _a === void 0 ? void 0 : _a.concat(value)) !== null && _b !== void 0 ? _b : [value];
  });
  return {
    headerLabel: calendarLabel,
    headerRow: headerEntries,
    rows: rows,
    canNavigateLeft: !date_utils.DateUtils.isValidDate(minDate) ||
      date_utils.DateUtils.isBeforeDate(minDate, firstOfMonth),
    canNavigateRight: !date_utils.DateUtils.isValidDate(maxDate) ||
      date_utils.DateUtils.isAfterDate(maxDate, lastOfMonth),
  };
}
function createMonthCalendar(calendarInputParams) {
  const date = calendarInputParams.date;
  const selectedRange = calendarInputParams.selectedRange;
  const minDate = calendarInputParams.minDate;
  const maxDate = calendarInputParams.maxDate;
  const outOfBoundsDateMin = getOutOfBoundsDateMin(minDate, "month");
  const outOfBoundsDateMax = getOutOfBoundsDateMax(maxDate, "month");
  const monthEntries = date_utils.MONTH_NAMES_SHORT.map((monthName, index) => {
    const monthDate = date_utils.DateUtils.newDate(date.getFullYear(), index);
    return createRowEntry(monthDate, outOfBoundsDateMin, outOfBoundsDateMax, () => {
      return {
        label: monthName,
        bright: false,
        active: date_utils.DateUtils.isSameMonth(monthDate, selectedRange.from) ||
          date_utils.DateUtils.isSameMonth(monthDate, selectedRange.to),
        date: monthDate,
        highlightedLeft: date_utils.DateUtils.isAfterMonth(monthDate, selectedRange.from) &&
          date_utils.DateUtils.isBeforeOrSameMonth(monthDate, selectedRange.to),
        highlightedRight: date_utils.DateUtils.isAfterOrSameMonth(monthDate, selectedRange.from) &&
          date_utils.DateUtils.isBeforeMonth(monthDate, selectedRange.to),
        interactable: true,
      };
    });
  });
  const rows = [
    monthEntries.slice(0, 4),
    monthEntries.slice(4, 8),
    monthEntries.slice(8, 12),
  ];
  const firstOfYear = date_utils.DateUtils.newDate(date.getFullYear());
  const lastOfYear = date_utils.DateUtils.newDate(date.getFullYear(), 11, 31);
  return {
    headerLabel: date.getFullYear().toString(),
    headerRow: undefined,
    rows: rows,
    canNavigateLeft: !date_utils.DateUtils.isValidDate(minDate) ||
      date_utils.DateUtils.isBeforeDate(minDate, firstOfYear),
    canNavigateRight: !date_utils.DateUtils.isValidDate(maxDate) ||
      date_utils.DateUtils.isAfterDate(maxDate, lastOfYear),
  };
}
function createYearCalendar(calendarInputParams) {
  var _a, _b;
  const date = calendarInputParams.date;
  const selectedRange = calendarInputParams.selectedRange;
  const minDate = calendarInputParams.minDate;
  const maxDate = calendarInputParams.maxDate;
  const outOfBoundsDateMin = getOutOfBoundsDateMin(minDate, "year");
  const outOfBoundsDateMax = getOutOfBoundsDateMax(maxDate, "year");
  const currentYear = date.getFullYear().toString();
  const currentYearInDecade = parseInt(currentYear[currentYear.length - 1]);
  const firstYearOfDecade = date.getFullYear() -
    (currentYearInDecade - 1) -
    (currentYearInDecade % 10 == 0 ? 10 : 0);
  const firstYearOfDecadeDate = date_utils.DateUtils.newDate(firstYearOfDecade, 0);
  const lastYearOfDecadeDate = date_utils.DateUtils.newDate(firstYearOfDecadeDate.getFullYear() + 9, 0);
  const iterator = new Date(firstYearOfDecadeDate);
  const yearEntries = [];
  while (date_utils.DateUtils.isBeforeOrSameDate(iterator, lastYearOfDecadeDate)) {
    const fromYear = (_a = selectedRange.from) === null || _a === void 0 ? void 0 : _a.getFullYear();
    const toYear = (_b = selectedRange.to) === null || _b === void 0 ? void 0 : _b.getFullYear();
    const iteratorYear = iterator.getFullYear();
    yearEntries.push(createRowEntry(new Date(iterator), outOfBoundsDateMin, outOfBoundsDateMax, () => {
      return {
        label: iteratorYear.toString(),
        date: new Date(iterator),
        bright: false,
        active: iteratorYear === fromYear || iteratorYear === toYear,
        highlightedLeft: iteratorYear > fromYear && iteratorYear <= toYear,
        highlightedRight: iteratorYear >= fromYear && iteratorYear < toYear,
        interactable: true,
      };
    }));
    iterator.setTime(date_utils.DateUtils.newDate(iterator.getFullYear() + 1, 0).getTime());
  }
  const lastDayOfDecade = date_utils.DateUtils.getLastDayOfYear(lastYearOfDecadeDate);
  return {
    headerLabel: `${firstYearOfDecadeDate.getFullYear()} - ${lastYearOfDecadeDate.getFullYear()}`,
    headerRow: undefined,
    rows: [yearEntries.slice(0, 5), yearEntries.slice(5, 10)],
    canNavigateLeft: !date_utils.DateUtils.isValidDate(minDate) ||
      date_utils.DateUtils.isBeforeDate(minDate, firstYearOfDecadeDate),
    canNavigateRight: !date_utils.DateUtils.isValidDate(maxDate) ||
      date_utils.DateUtils.isAfterDate(maxDate, lastDayOfDecade),
  };
}
function isDateEntry(entry) {
  var _a;
  return ((_a = entry === null || entry === void 0 ? void 0 : entry.label) !== null && _a !== void 0 ? _a : undefined) !== undefined;
}
function isBoundingEntry(entry) {
  return entry === "min" || entry === "max";
}
function isNullEntry(entry) {
  return entry === null;
}

const dxCalendarCss = "@keyframes fade-in{0%{opacity:0}100%{opacity:1}}@keyframes fade-out{0%{opacity:1}100%{opacity:0}}:host{display:block;outline:none;background:white;min-width:280px;--dx-simple-grow-box-border-top-width:0px;--dx-simple-grow-box-border-right-width:0px;--dx-simple-grow-box-border-bottom-width:0px;--dx-simple-grow-box-border-left-width:0px;pointer-events:all}:host:host([hidden]){display:none !important}:host .header-container{height:64px;background-color:#ffffff;padding:0 16px;box-sizing:border-box}:host .header-container .header{height:100%;border-bottom:1px solid #c8aa22;display:flex;justify-content:space-between;align-items:center}:host .header-container .header .label-container{font-family:DVAG-Type, sans-serif;display:flex;justify-content:center;align-items:center;flex:1;font-size:16px;color:#c8aa22;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;--dx-button-outline-box-shadow:none}@keyframes to-the-left{0%{transform:translateX(0px)}100%{transform:translateX(-10px)}}@keyframes to-the-right{0%{transform:translateX(0px)}100%{transform:translateX(10px)}}@keyframes to-the-bottom{0%{transform:scale(1)}100%{transform:scale(0.8)}}@keyframes to-the-top{0%{transform:scale(1)}100%{transform:scale(1.2)}}:host .header-container .header .label-container.slide-right{animation:to-the-left 150ms ease-in, fade-out 150ms ease-in, to-the-right 150ms ease-in reverse 200ms, fade-in 150ms ease-in 200ms;animation-fill-mode:forwards;animation-iteration-count:1}:host .header-container .header .label-container.slide-left{animation:to-the-right 150ms ease-in, fade-out 150ms ease-in, to-the-left 150ms ease-in reverse 200ms, fade-in 150ms ease-in 200ms;animation-fill-mode:forwards;animation-iteration-count:1}:host .header-container .header .label-container.slide-in{animation:to-the-bottom 150ms ease-in, fade-out 150ms ease-in, to-the-top 150ms ease-in reverse 200ms, fade-in 150ms ease-in 200ms;animation-fill-mode:forwards;animation-iteration-count:1}:host .header-container .header .label-container.slide-out{animation:to-the-top 150ms ease-in, fade-out 150ms ease-in, to-the-bottom 150ms ease-in reverse 200ms, fade-in 150ms ease-in 200ms;animation-fill-mode:forwards;animation-iteration-count:1}:host .calendar-container{padding:16px;width:100%;height:100%;box-sizing:border-box}@keyframes to-the-left{0%{transform:translateX(0px)}100%{transform:translateX(-10px)}}@keyframes to-the-right{0%{transform:translateX(0px)}100%{transform:translateX(10px)}}@keyframes to-the-bottom{0%{transform:scale(1)}100%{transform:scale(0.8)}}@keyframes to-the-top{0%{transform:scale(1)}100%{transform:scale(1.2)}}:host .calendar-container.slide-right{animation:to-the-left 150ms ease-in, fade-out 150ms ease-in, to-the-right 150ms ease-in reverse 200ms, fade-in 150ms ease-in 200ms;animation-fill-mode:forwards;animation-iteration-count:1}:host .calendar-container.slide-left{animation:to-the-right 150ms ease-in, fade-out 150ms ease-in, to-the-left 150ms ease-in reverse 200ms, fade-in 150ms ease-in 200ms;animation-fill-mode:forwards;animation-iteration-count:1}:host .calendar-container.slide-in{animation:to-the-bottom 150ms ease-in, fade-out 150ms ease-in, to-the-top 150ms ease-in reverse 200ms, fade-in 150ms ease-in 200ms;animation-fill-mode:forwards;animation-iteration-count:1}:host .calendar-container.slide-out{animation:to-the-top 150ms ease-in, fade-out 150ms ease-in, to-the-bottom 150ms ease-in reverse 200ms, fade-in 150ms ease-in 200ms;animation-fill-mode:forwards;animation-iteration-count:1}:host .calendar-container .slide-container{display:flex}:host .calendar-container dx-button{outline:none}:host .calendar-container .error-message{display:block;text-align:center;--dx-text-color:#9d2235;animation:fade-in 150ms;margin-bottom:12px}:host .calendar-container .calendar{--dx-button-outline-box-shadow:none;user-select:none;cursor:default;flex-grow:0;flex-shrink:0;box-sizing:border-box}:host .calendar-container .calendar .calendar-row{display:flex;justify-content:space-around;margin-bottom:12px}:host .calendar-container .calendar .calendar-row.header-labels{margin-bottom:16px;--dx-text-color:#ababab}:host .calendar-container .calendar .calendar-entry-container{flex:1;display:flex;justify-content:center;align-items:center}:host .calendar-container .calendar .calendar-entry-container.highlighted-left{background:linear-gradient(90deg, #e5eef2 50%, transparent 50%)}:host .calendar-container .calendar .calendar-entry-container.highlighted-right{background:linear-gradient(90deg, transparent 50%, #e5eef2 50%)}:host .calendar-container .calendar .calendar-entry-container.highlighted{background:#e5eef2}:host .calendar-container .calendar .calendar-entry-container .calendar-entry{width:var(--dx-button-width, fit-content);width:var(--dx-button-width, -moz-fit-content);cursor:pointer;display:inline-flex;justify-content:center;align-items:center;box-sizing:border-box;white-space:nowrap;user-select:none;-webkit-user-select:none;border:none;margin:0;background-color:transparent;transition:background-color 150ms ease-in-out, border-color 150ms ease-in-out;min-width:40px;min-height:40px;text-align:center;padding:4px;--dx-text-color:#2b2b2b}:host .calendar-container .calendar .calendar-entry-container .calendar-entry[disabled]{cursor:unset}:host .calendar-container .calendar .calendar-entry-container .calendar-entry.selected{background-color:#004763;--dx-text-color:#ffffff}:host .calendar-container .calendar .calendar-entry-container .calendar-entry.disabled{opacity:0.4;pointer-events:none}:host .calendar-container .calendar .calendar-entry-container .calendar-entry.bright-color{--dx-text-color:#ababab}:host .calendar-container .calendar .calendar-entry-container .calendar-entry.bound{border-left:1px solid #337a96;max-width:24px;padding:0;pointer-events:none}@media not all and (pointer: coarse){:host .calendar-container .calendar .calendar-entry-container .calendar-entry:not(.selected):hover{background-color:rgba(51, 122, 150, 0.1);--dx-text-color:#337a96}}:host .calendar-container .calendar .calendar-entry-container .calendar-entry:not(.selected):active{background-color:rgba(0, 88, 124, 0.2);--dx-text-color:#00587c}:host .calendar-container .calendar.day-view .calendar-entry{padding:0}:host .calendar-container .calendar.month-view{padding-top:4px}:host .calendar-container .calendar.month-view .calendar-entry{padding:0 8px}:host .calendar-container .calendar.year-view{padding-top:4px}:host .calendar-container .calendar.year-view .calendar-entry{padding:0 8px}";

const DxCalendar = class {
  constructor(hostRef) {
    index.registerInstance(this, hostRef);
    this.rangeSelected = index.createEvent(this, "rangeSelected", 7);
    this.preventNextDateViewChange = false;
    this.currentView = "day" /* CalendarView.DAY */;
    this.internalView = "day" /* CalendarView.DAY */;
    this.selectedRange = { from: undefined, to: undefined };
    /**
     * Defines how a date can be selected.
     *
     * @value "day-month-year": The month calendar view is the main view to select a date in.
     * You can click on days within a month to select them.
     * @value "month-year": The year calendar view is the main view to select a date in.
     * You can click on months within a year to select them.
     * @value "day-month": The month calendar view is the main view to select a date in.
     * You can click on days within a month to select them. The year information is irrelevant in this mode.
     * Selected date's years are always 0.
     */
    this.mode = "day-month-year";
  }
  onValueChange() {
    this.updateInternalState();
  }
  connectedCallback() {
    this.parent = miscUtil.findUpperElementByPredicate(this.self, (elem) => {
      const tag = elem.tagName.toLowerCase();
      return tag === "dx-date-input" || tag === "dx-date-range";
    });
  }
  componentWillLoad() {
    const initView = this.getInitializedView();
    this.currentView = initView;
    this.internalView = initView;
    this.updateInternalState();
  }
  getInitializedView() {
    if (this.isDateSelectionEnabled()) {
      return "day" /* CalendarView.DAY */;
    }
    if (this.isMonthSelectionEnabled()) {
      return "month" /* CalendarView.MONTH */;
    }
    if (this.isYearSelectionEnabled()) {
      return "year" /* CalendarView.YEAR */;
    }
  }
  /**
   * Sets the date dependant on the current mode
   * E.g: If the current mode is "day-month" we have to set every date's year in this context to 0
   */
  adjustDateDependantOnCurrentMode(date) {
    if (date_utils.DateUtils.isValidDate(date) && !this.isYearSelectionEnabled()) {
      const result = new Date(date);
      result.setFullYear(0);
      return result;
    }
    return date;
  }
  updateInternalState() {
    var _a;
    const range = dateRange_util.extractDateRange(this.value);
    this.selectedRange = {
      from: range.from,
      to: this.rangeenabled ? range.to : null,
    };
    if (this.preventNextDateViewChange) {
      this.preventNextDateViewChange = false;
      return;
    }
    const minDate = !date_utils.DateUtils.isValidDate(this.minDate) ? null : this.minDate;
    const maxDate = !date_utils.DateUtils.isValidDate(this.maxDate) ? null : this.maxDate;
    const today = this.adjustDateDependantOnCurrentMode(date_utils.DateUtils.today);
    if (date_utils.DateUtils.isBeforeDate(this.selectedRange.from, minDate)) {
      this.currentDate = new Date(minDate);
      this.internalDate = new Date(minDate);
    }
    else if (date_utils.DateUtils.isAfterDate(this.selectedRange.from, maxDate)) {
      this.currentDate = new Date(maxDate);
      this.internalDate = new Date(maxDate);
    }
    else {
      const newCurrentDate = (_a = this.selectedRange.from) !== null && _a !== void 0 ? _a : date_utils.DateUtils.clamp(today, minDate, maxDate);
      this.currentDate = this.adjustDateDependantOnCurrentMode(new Date(newCurrentDate));
      this.internalDate = this.adjustDateDependantOnCurrentMode(new Date(newCurrentDate));
    }
  }
  isDateSelectionEnabled() {
    return this.mode !== "month-year";
  }
  /**
   * Currently no mode disables the month selection.
   * This method exists in case a mode appears which doesn't need a month selection.
   */
  isMonthSelectionEnabled() {
    return true;
  }
  isYearSelectionEnabled() {
    return this.mode !== "day-month";
  }
  onAnimationStart() {
    this.isAnimating = true;
  }
  onAnimationEnd(e) {
    if (e.animationName === "fade-out") {
      this.internalDate = new Date(this.currentDate);
      this.internalView = this.currentView;
    }
    else if (e.animationName === "fade-in") {
      this.addSlidingAnimation(this.calendarContainer, null);
      this.addSlidingAnimation(this.headerLabel, null);
      this.isAnimating = false;
    }
  }
  addSlidingAnimation(element, mode) {
    element.classList.remove("slide-left", "slide-right", "slide-in", "slide-out");
    if (mode != null) {
      element.classList.add(`slide-${mode}`);
    }
  }
  slide(mode) {
    this.addSlidingAnimation(this.calendarContainer, mode);
    this.addSlidingAnimation(this.headerLabel, mode);
  }
  navigate(direction) {
    var _a;
    if (direction === "left") {
      this.previous();
    }
    else if (direction === "right") {
      this.next();
    }
    // The focus will be lost, when clicking on a button which is disabled in the next or previous month/year/decade.
    // So we have to prevent the calendar from close by focusing it here.
    (_a = this.parent) === null || _a === void 0 ? void 0 : _a.focusControl();
  }
  previous() {
    if (!this.isAnimating) {
      switch (this.internalView) {
        case "day" /* CalendarView.DAY */:
          this.currentDate = date_utils.DateUtils.getPreviousMonth(this.currentDate);
          break;
        case "month" /* CalendarView.MONTH */:
          this.currentDate.setFullYear(this.currentDate.getFullYear() - 1, 0, 1);
          break;
        case "year" /* CalendarView.YEAR */:
          this.currentDate.setFullYear(this.currentDate.getFullYear() - 10, 0, 1);
          break;
      }
      this.slide("left" /* SlideMode.LEFT */);
    }
  }
  next() {
    if (!this.isAnimating) {
      switch (this.internalView) {
        case "day" /* CalendarView.DAY */:
          this.currentDate = date_utils.DateUtils.getNextMonth(this.currentDate);
          break;
        case "month" /* CalendarView.MONTH */:
          this.currentDate.setFullYear(this.currentDate.getFullYear() + 1, 0, 1);
          break;
        case "year" /* CalendarView.YEAR */:
          this.currentDate.setFullYear(this.currentDate.getFullYear() + 10, 0, 1);
          break;
      }
      this.slide("right" /* SlideMode.RIGHT */);
    }
  }
  onClickHeaderLabel() {
    this.currentView = this.getAboveView();
    if (this.currentView !== this.internalView) {
      this.slide("in" /* SlideMode.IN */);
    }
  }
  get maxDate() {
    const maxDate = this.max ? new Date(this.max) : new Date(NaN);
    maxDate.setHours(0, 0, 0, 0);
    if (!date_utils.DateUtils.isValidDate(maxDate) && !this.isYearSelectionEnabled()) {
      maxDate.setTime(date_utils.DateUtils.newDate(0, 11, 31).getTime());
    }
    return this.adjustDateDependantOnCurrentMode(maxDate);
  }
  get minDate() {
    const minDate = this.min ? new Date(this.min) : new Date(NaN);
    minDate.setHours(0, 0, 0, 0);
    if (!date_utils.DateUtils.isValidDate(minDate) && !this.isYearSelectionEnabled()) {
      minDate.setTime(date_utils.DateUtils.newDate(0, 0, 1).getTime());
    }
    return this.adjustDateDependantOnCurrentMode(minDate);
  }
  handleRowEntryClick(date) {
    var _a, _b, _c, _d, _e;
    this.currentView = this.getBelowView();
    // Because entries will be destroyed on rerendering we have to focus self. Otherwise the input would lose focus completely
    (_a = this.parent) === null || _a === void 0 ? void 0 : _a.focusControl();
    const oldSelectedRange = Object.assign({}, this.selectedRange);
    if (this.currentView !== this.internalView) {
      this.currentDate = date;
      this.slide("out" /* SlideMode.OUT */);
    }
    else {
      // Update internals here in case no animation is triggered
      const clickedDate = new Date(date);
      if (this.rangeenabled) {
        this.selectRange(clickedDate);
      }
      else {
        this.selectedRange.from = clickedDate;
      }
      // Updating reference to trigger render
      this.selectedRange = Object.assign({}, this.selectedRange);
      if (((_b = oldSelectedRange.from) === null || _b === void 0 ? void 0 : _b.getTime()) !==
        ((_c = this.selectedRange.from) === null || _c === void 0 ? void 0 : _c.getTime()) ||
        ((_d = oldSelectedRange.to) === null || _d === void 0 ? void 0 : _d.getTime()) !== ((_e = this.selectedRange.to) === null || _e === void 0 ? void 0 : _e.getTime())) {
        this.rangeSelected.emit(Object.assign({}, this.selectedRange));
      }
    }
  }
  componentShouldUpdate(_, __, propName) {
    if (propName === "min" || propName === "max") {
      const minDate = this.minDate;
      const maxDate = this.maxDate;
      if (date_utils.DateUtils.isBeforeDate(this.selectedRange.from, minDate)) {
        this.selectedRange.from = minDate;
      }
      if (date_utils.DateUtils.isAfterDate(this.selectedRange.to, maxDate)) {
        this.selectedRange.to = maxDate;
      }
    }
  }
  selectRange(date) {
    this.preventNextDateViewChange = true;
    if (this.selectedRange.from == null) {
      this.selectedRange.from = date;
    }
    else if (this.selectedRange.to == null) {
      if (date_utils.DateUtils.isBeforeDate(date, this.selectedRange.from)) {
        this.selectedRange.from = date;
      }
      else {
        this.selectedRange.to = date;
      }
    }
    else {
      this.selectedRange.from = date;
      this.selectedRange.to = undefined;
    }
  }
  getAboveView() {
    const order = this.getViews();
    const currentIndex = order.indexOf(this.internalView);
    const newIndex = Math.min(currentIndex + 1, order.length - 1);
    return order[newIndex];
  }
  getBelowView() {
    const order = this.getViews();
    const currentIndex = order.indexOf(this.internalView);
    const newIndex = Math.max(currentIndex - 1, 0);
    return order[newIndex];
  }
  getViews() {
    const views = [];
    if (this.isDateSelectionEnabled()) {
      views.push("day" /* CalendarView.DAY */);
    }
    if (this.isMonthSelectionEnabled()) {
      views.push("month" /* CalendarView.MONTH */);
    }
    if (this.isYearSelectionEnabled()) {
      views.push("year" /* CalendarView.YEAR */);
    }
    return views;
  }
  createCalendar() {
    const calendarInputParams = {
      date: this.internalDate,
      selectedRange: Object.assign({}, this.selectedRange),
      minDate: this.minDate,
      maxDate: this.maxDate,
    };
    switch (this.internalView) {
      case "day" /* CalendarView.DAY */:
        if (this.isYearSelectionEnabled()) {
          return createDayCalendar(calendarInputParams);
        }
        return createSimpleDayCalendar(calendarInputParams);
      case "month" /* CalendarView.MONTH */:
        const monthCalendar = createMonthCalendar(calendarInputParams);
        if (!this.isYearSelectionEnabled()) {
          monthCalendar.headerLabel = "Monate";
        }
        return monthCalendar;
      case "year" /* CalendarView.YEAR */:
        return createYearCalendar(calendarInputParams);
    }
  }
  renderRowEntry(rowEntry) {
    var _a, _b;
    if (isDateEntry(rowEntry)) {
      return (index.h("div", { class: {
          "calendar-entry-container": true,
          highlighted: rowEntry.highlightedLeft && rowEntry.highlightedRight,
          "highlighted-left": rowEntry.highlightedLeft && !rowEntry.highlightedRight,
          "highlighted-right": rowEntry.highlightedRight && !rowEntry.highlightedLeft,
        } }, rowEntry.interactable ? (index.h("button", { key: `${date_utils.DateUtils.dateToString(rowEntry.date)}-${this.currentView}`, id: elementIdHandling.ElementIdGenerator.createId(this.self, `row-entry-${date_utils.DateUtils.dateToString(rowEntry.date)}`), tabIndex: -1, class: {
          "calendar-entry": true,
          "bright-color": rowEntry.bright,
          selected: rowEntry.active,
        }, onClick: () => this.handleRowEntryClick(rowEntry.date) }, index.h("dx-text", { type: (_a = rowEntry.textType) !== null && _a !== void 0 ? _a : "ps" }, rowEntry.label))) : (index.h("dx-text", { type: (_b = rowEntry.textType) !== null && _b !== void 0 ? _b : "ps" }, rowEntry.label))));
    }
    if (isBoundingEntry(rowEntry)) {
      return (index.h("div", { class: {
          "calendar-entry-container": true,
        } }, index.h("dx-icon", { size: 24, icon: rowEntry === "min" ? "chevron-rechts" : "chevron-links", color: "default", class: {
          "calendar-entry": true,
          bound: true,
        } })));
    }
    if (isNullEntry(rowEntry)) {
      return (index.h("div", { class: {
          "calendar-entry-container": true,
        } }));
    }
  }
  renderErrorMessage() {
    var _a;
    if (((_a = this.errormessage) === null || _a === void 0 ? void 0 : _a.length) > 0) {
      return (index.h("dx-text", { class: "error-message", type: "its" }, this.errormessage));
    }
  }
  renderCalendar(calendar) {
    return (index.h("div", { class: {
        calendar: true,
        "day-view": this.internalView === "day" /* CalendarView.DAY */,
        "month-view": this.internalView === "month" /* CalendarView.MONTH */,
        "year-view": this.internalView === "year" /* CalendarView.YEAR */,
      } }, calendar.headerRow ? (index.h("div", { class: {
        "calendar-row": true,
        "header-labels": true,
      } }, calendar.headerRow.map((headerEntry) => {
      return this.renderRowEntry(headerEntry);
    }))) : null, calendar.rows.map((rowEntry) => {
      return (index.h("div", { class: "calendar-row" }, rowEntry.map((dayEntry) => {
        return this.renderRowEntry(dayEntry);
      })));
    })));
  }
  renderHeader(label, leftButtonEnabled, rightButtonEnabled) {
    const isYearView = this.currentView === "year" /* CalendarView.YEAR */;
    return (index.h("div", { class: "header-container" }, index.h("div", { class: {
        header: true,
      } }, index.h("dx-button", { unfocusable: true, onClick: () => this.navigate("left"), disabled: !leftButtonEnabled, id: elementIdHandling.ElementIdGenerator.createId(this.self, `right-button`), icon: "chevron-links", type: "text" }), index.h("div", { class: "label-container", ref: (ref) => (this.headerLabel = ref), tabIndex: -1 }, index.h("dx-text", { style: {
        overflow: "hidden",
        width: isYearView ? "unset" : "0",
      } }, label), index.h("div", { style: {
        flex: isYearView ? "0" : "1",
        overflow: "hidden",
      } }, index.h("dx-button", { class: "label", id: elementIdHandling.ElementIdGenerator.createId(this.self, `header-label-button`), onClick: () => this.onClickHeaderLabel(), type: "text", label: label, unfocusable: true, stretch: true }))), index.h("dx-button", { unfocusable: true, onClick: () => this.navigate("right"), disabled: !rightButtonEnabled, id: elementIdHandling.ElementIdGenerator.createId(this.self, `right-button`), icon: "chevron-rechts", type: "text" }))));
  }
  render() {
    const calendar = this.createCalendar();
    return (index.h(index.Host, null, [
      this.renderHeader(calendar.headerLabel, calendar.canNavigateLeft, calendar.canNavigateRight),
      index.h("div", { class: {
          "calendar-container": true,
        }, onAnimationEnd: (e) => this.onAnimationEnd(e), onAnimationStart: () => this.onAnimationStart(), ref: (ref) => (this.calendarContainer = ref) }, this.renderErrorMessage(), this.renderCalendar(calendar)),
    ]));
  }
  get self() { return index.getElement(this); }
  static get watchers() { return {
    "value": ["onValueChange"]
  }; }
};
DxCalendar.style = dxCalendarCss;

exports.dx_calendar = DxCalendar;
