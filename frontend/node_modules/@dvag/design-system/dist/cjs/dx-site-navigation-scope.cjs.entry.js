'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const index = require('./index-2f41386b.js');
const async = require('./async-da958283.js');

const dxSiteNavigationScopeCss = ":host{display:block}:host:host([hidden]){display:none !important}";

const DxSiteNavigationScope = class {
  constructor(hostRef) {
    index.registerInstance(this, hostRef);
  }
  connectedCallback() {
    this.menu().then((menu) => async.unawaited(menu.addScope(this.self)));
  }
  disconnectedCallback() {
    this.menu().then((menu) => async.unawaited(menu.removeScope(this.self)));
  }
  async menu() {
    var _a, _b;
    // we could not be sure whether menu or scopes are hydrated first
    // so we add some tolerance in finding the "control center" ;-)
    let menu;
    while (!menu) {
      menu = (_b = (_a = this.self) === null || _a === void 0 ? void 0 : _a.closest("dx-site-navigation")) === null || _b === void 0 ? void 0 : _b.querySelector("dx-site-navigation-menu");
      if (!menu) {
        await async.sleep(PERFECT_AMOUNT_OF_TIME_FOR_A_GOOD_SLEEP);
      }
    }
    return menu;
  }
  render() {
    return (index.h(index.Host, null, index.h("slot", null)));
  }
  get self() { return index.getElement(this); }
};
const PERFECT_AMOUNT_OF_TIME_FOR_A_GOOD_SLEEP = 100;
DxSiteNavigationScope.style = dxSiteNavigationScopeCss;

exports.dx_site_navigation_scope = DxSiteNavigationScope;
