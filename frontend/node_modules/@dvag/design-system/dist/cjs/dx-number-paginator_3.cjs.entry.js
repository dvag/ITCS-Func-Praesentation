'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const index = require('./index-2f41386b.js');
const elementIdHandling = require('./element-id-handling-89898a1c.js');
const mathUtil = require('./math-util-a514efc6.js');
const pageIndexType = require('./page-index-type-1fc5150f.js');
const breakpointAware = require('./breakpoint-aware-cc9d0ee6.js');
const miscUtil = require('./misc-util-63b423bd.js');
const event_util = require('./event.util-7f75b6a8.js');
const assert = require('./assert-d8ea75c6.js');
const value = require('./value-1f8d9874.js');
const baseElements = require('./base-elements-0dbfd791.js');
require('./value-store-f683b26f.js');

const dxNumberPaginatorCss = ":host{display:flex;align-items:center;justify-content:space-between}:host:host([hidden]){display:none !important}:host:host(.mode-default){width:max-content}:host:host(.mode-default) .page-container{white-space:nowrap}:host:host(.mode-default) .page-container .gap-container{display:inline-flex;flex-direction:column;text-align:center;width:40px;height:40px}:host:host(.mode-default) .page-container .gap-container dx-list-flyout{width:78px}:host:host(.mode-default) .page-container .page-button{width:var(--dx-button-width, fit-content);width:var(--dx-button-width, -moz-fit-content);cursor:pointer;display:inline-flex;justify-content:center;align-items:center;box-sizing:border-box;white-space:nowrap;user-select:none;-webkit-user-select:none;border:none;margin:0;background-color:transparent;transition:background-color 150ms ease-in-out, border-color 150ms ease-in-out;background-color:rgba(0, 88, 124, 0);border-color:#337a96;--dx-text-color:#337a96;--dx-icon-color:#337a96;width:40px;height:40px}:host:host(.mode-default) .page-container .page-button[disabled]{cursor:unset}@media not all and (pointer: coarse){:host:host(.mode-default) .page-container .page-button:hover{background-color:rgba(0, 88, 124, 0.1);border-color:#00587c;--dx-text-color:#00587c;--dx-icon-color:#00587c}}:host:host(.mode-default) .page-container .page-button:active{background-color:rgba(0, 88, 124, 0.2);border-color:#004763;--dx-text-color:#004763;--dx-icon-color:#004763}:host:host(.mode-default) .page-container .page-button.current-page{--dx-text-color:#004763}:host:host(.mode-default) .page-switcher{transition:opacity 300ms ease-in-out}:host:host(.mode-dropdown){width:100%}:host:host(.mode-dropdown) .dropdown{flex:1;margin:0 16px}";

const DxNumberPaginator = class {
  constructor(hostRef) {
    index.registerInstance(this, hostRef);
    this.pageChanged = index.createEvent(this, "pageChanged", 7);
    this.mode = "default";
    /**
     * The current selected page.
     *
     * @value number: The current selected page from 1 to `count`.
     *
     * @example current
     */
    this.current = 1;
  }
  componentDidLoad() {
    elementIdHandling.verifyElementId(this.self);
  }
  onCountChange() {
    this.setCurrentPage(this.current);
  }
  onPageChange(newValue, oldValue) {
    this.setCurrentPage(newValue);
    if (this.current !== oldValue) {
      this.pageChanged.emit(this.current);
    }
  }
  connectedCallback() {
    this.breakpointAware = new breakpointAware.BreakpointAware(() => {
      this.onBreakpointChange();
    }, true);
  }
  disconnectedCallback() {
    this.breakpointAware.disconnect();
  }
  componentWillLoad() {
    elementIdHandling.verifyElementId(this.self);
    this.onBreakpointChange();
  }
  async componentWillRender() {
    if (this.mode === "default") {
      this.pageIndexTypes = pageIndexType.generatePageIndexTypes(this.current, this.count, 7);
    }
  }
  onItemSelectionChanged(e) {
    this.current = e.detail;
  }
  onDropdownClicked(event) {
    const listItem = event_util.extractPath(event).find((el) => { var _a; return ((_a = el.tagName) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === "dx-list-item"; });
    if (listItem) {
      this.current = parseInt(listItem.value.toString());
    }
  }
  onBreakpointChange() {
    this.mode = this.breakpointAware.mq1 ? "dropdown" : "default";
  }
  setCurrentPage(page) {
    const clampedPage = mathUtil.clamp(page, 1, Math.max(this.count, 1));
    if (clampedPage !== this.current) {
      this.current = clampedPage;
    }
  }
  renderGap(from, to, idPostfix) {
    return (index.h("dx-number-paginator-page-button", { id: elementIdHandling.ElementIdGenerator.createId(this.self, `gap-${idPostfix}`), state: { from, to } }));
  }
  renderPageButton(page) {
    return (index.h("dx-number-paginator-page-button", { id: elementIdHandling.ElementIdGenerator.createId(this.self, `page-${page}`), state: { page: page, active: page === this.current }, onPageSelect: (e) => (this.current = e.detail) }));
  }
  renderPageSelection() {
    const renderHandlerOf = {
      default: this.renderPageButtons.bind(this),
      dropdown: this.renderDropdown.bind(this),
    };
    return renderHandlerOf[this.mode]();
  }
  renderDropdown() {
    const range = 25;
    const min = Math.max(2, this.current - range);
    const max = Math.min(this.count - 1, this.current + range);
    const hasMinGap = min > 2;
    const hasMaxGap = max < this.count - 1;
    const arr = miscUtil.createNumberArray(min, max);
    return (index.h("dx-dropdown", { id: elementIdHandling.ElementIdGenerator.createId(this.self, `dropdown`), value: this.current.toString(), class: "dropdown", formatter: (str) => `${str} von ${this.count}`, onValueComplete: (e) => {
        this.current = parseInt(e.detail);
      }, onClick: (e) => this.onDropdownClicked(e) }, index.h("dx-dropdown-option", { value: (1).toString(), label: (1).toString() }), hasMinGap ? (index.h("dx-dropdown-option", { label: "...", isseparator: true })) : null, arr.map((num) => {
      return (index.h("dx-dropdown-option", { value: num.toString(), label: num.toString() }));
    }), hasMaxGap ? (index.h("dx-dropdown-option", { label: "...", isseparator: true })) : null, index.h("dx-dropdown-option", { value: this.count.toString(), label: this.count.toString() })));
  }
  renderPageButtons() {
    return (index.h("div", { class: "page-container" }, this.pageIndexTypes.map((page, index) => {
      if (page === pageIndexType.GAP) {
        const from = this.pageIndexTypes[index - 1] + 1;
        const to = this.pageIndexTypes[index + 1] - 1;
        return this.renderGap(from, to, index === 1 ? "0" : "1");
      }
      else {
        return this.renderPageButton(page);
      }
    })));
  }
  render() {
    if (this.count <= 1) {
      return null;
    }
    const leftButtonIsDisabled = this.current > 1;
    const rightButtonIsDisabled = this.current < this.count;
    return (index.h(index.Host, { class: {
        "mode-default": this.mode === "default",
        "mode-dropdown": this.mode === "dropdown",
      }, style: {
        visibility: this.count <= 1 ? "hidden" : "visible",
      } }, index.h("dx-button", { id: elementIdHandling.ElementIdGenerator.createId(this.self, "page-down"), icon: "chevron-links", type: "text", class: {
        "page-switcher": true,
      }, disabled: !leftButtonIsDisabled, onClick: () => this.setCurrentPage(this.current - 1) }), this.renderPageSelection(), index.h("dx-button", { id: elementIdHandling.ElementIdGenerator.createId(this.self, "page-up"), icon: "chevron-rechts", type: "text", class: {
        "page-switcher": true,
      }, disabled: !rightButtonIsDisabled, onClick: () => this.setCurrentPage(this.current + 1) })));
  }
  get self() { return index.getElement(this); }
  static get watchers() { return {
    "count": ["onCountChange"],
    "current": ["onPageChange"]
  }; }
};
DxNumberPaginator.style = dxNumberPaginatorCss;

const dxNumberPickerCss = ":host{display:block;line-height:48px}:host:host([hidden]){display:none !important}:host:host(.align-left){text-align:left}:host:host(.align-left) .button:not(:last-child){margin-right:16px}:host:host(.align-right){text-align:right}:host:host(.align-right) .button:not(:first-child){margin-left:16px}:host:host(.align-center){text-align:center}:host:host(.align-center) .button{margin-left:8px;margin-right:8px}:host .button{width:var(--dx-button-width, fit-content);width:var(--dx-button-width, -moz-fit-content);cursor:pointer;display:inline-flex;justify-content:center;align-items:center;box-sizing:border-box;white-space:nowrap;user-select:none;-webkit-user-select:none;border:none;margin:0;background-color:transparent;transition:background-color 150ms ease-in-out, border-color 150ms ease-in-out;outline-offset:2px;background-color:rgba(0, 88, 124, 0);border-color:#337a96;--dx-text-color:#337a96;--dx-icon-color:#337a96;display:inline-block;border:2px solid #337a96;min-width:40px;height:40px;padding:0 14px;cursor:pointer}:host .button[disabled]{cursor:unset}:host .button.icon-right{flex-direction:row-reverse}:host .button:focus-visible{outline:2px solid #004763}@media not all and (pointer: coarse){:host .button:hover{background-color:rgba(0, 88, 124, 0.1);border-color:#00587c;--dx-text-color:#00587c;--dx-icon-color:#00587c}}:host .button:active{background-color:rgba(0, 88, 124, 0.2);border-color:#004763;--dx-text-color:#004763;--dx-icon-color:#004763}:host .button.active{background-color:rgba(0, 88, 124, 0.2);border-color:#004763;--dx-text-color:#004763;--dx-icon-color:#004763;cursor:default}";

const DxNumberPicker = class {
  constructor(hostRef) {
    index.registerInstance(this, hostRef);
    this.valueChange = index.createEvent(this, "valueChange", 7);
    /**
     * Defines whether the numbers are displayed from left to right, right to left or centered.
     *
     * @value left: The numbers will be displayed from left to right.
     * @value right: The numbers will be displayed from right to left.
     * @value center: The numbers will are centered.
     */
    this.align = "left";
  }
  onValueChange() {
    var _a;
    this.setValue((_a = this.value) !== null && _a !== void 0 ? _a : this.getValuesArray()[0]);
  }
  componentWillRender() {
    elementIdHandling.verifyElementId(this.self);
    const valuesArray = this.getValuesArray();
    if (!valuesArray.includes(this.value)) {
      this.setValue(valuesArray[0]);
    }
  }
  setValue(newValue) {
    if (newValue !== this.value) {
      this.value = newValue;
      this.valueChange.emit(this.value);
    }
  }
  getValuesArray() {
    const valuesArray = Array.isArray(this.values)
      ? this.values
      : JSON.parse(this.values);
    const isValidNumberArray = Array.isArray(valuesArray) &&
      valuesArray.every((value) => !isNaN(+value));
    assert.assert(isValidNumberArray, () => {
      return "Found error parsing 'values' property.";
    }, this.self);
    return valuesArray;
  }
  renderValues() {
    const valuesArray = this.getValuesArray();
    return valuesArray.map((value) => {
      const active = this.value === value;
      return (index.h("button", { id: elementIdHandling.ElementIdGenerator.createId(this.self, `${value}-control`), class: { button: true, active: active }, onClick: () => this.setValue(value), disabled: active }, index.h("dx-text", null, value)));
    });
  }
  render() {
    return (index.h(index.Host, { class: {
        "align-left": this.align === "left",
        "align-right": this.align === "right",
        "align-center": this.align === "center",
      } }, this.renderValues()));
  }
  get self() { return index.getElement(this); }
  static get watchers() { return {
    "value": ["onValueChange"]
  }; }
};
DxNumberPicker.style = dxNumberPickerCss;

async function extractRadioButtonOutOfEventPath(e) {
  var _a, _b, _c;
  return ((_c = (_b = (_a = e.target).getRadioElement) === null || _b === void 0 ? void 0 : _b.call(_a)) !== null && _c !== void 0 ? _c : e
    .composedPath()
    .find((element) => miscUtil.tagOf(element) === "dx-radio-button"));
}

const dxRadioButtonGroupCss = ":host{display:block;min-width:0}:host:host([hidden]){display:none !important}:host ::slotted(dx-radio-button:not(:last-of-type)){margin-bottom:16px}";

const DxRadioButtonGroup = class {
  constructor(hostRef) {
    index.registerInstance(this, hostRef);
    this.valueChange = index.createEvent(this, "valueChange", 7);
    this.shouldEmitValueChange = false;
    this.radioButtons = [];
    /**
     * @internal
     */
    this.radiogroupid = null;
    /**
     * Defines if the group is in a read-only state.
     * The label of the current selected radio button will be displayed.
     *
     * @value false: The component is displayed normally.
     * @value true: The current selected option is displayed as text. If no option is selected no text will be displayed.
     * @example readonly
     */
    this.readonly = false;
    /**
     * Defines if the radio button group is a required form element.
     * @value false: It is not required to select an option.
     * @value true: To fulfill the requirement one option has to be selected.
     * @example required
     */
    this.required = false;
    /**
     * Indicates that the form is synced with the KI.
     * @value true: Synchronized.
     * @value false: Not synchronized.
     * @example kisynced
     */
    this.kisynced = false;
    /**
     * Disables the ability to interact with this component.
     * Every option inside will also be set to `disabled`.
     *
     * @value false: User can select an option.
     * @value true: User cannot select an option.
     *
     * @example disabled
     */
    this.disabled = false;
  }
  onDisabledChange() {
    this.radioButtons.forEach((radioButton) => {
      if (this.disabled) {
        radioButton.classList.add("disabled");
      }
      else if (!radioButton.disabled) {
        radioButton.classList.remove("disabled");
      }
      radioButton.forceUpdate();
    });
  }
  valueChanged(newValue, oldValue) {
    if (newValue === oldValue) {
      return;
    }
    this.updateCheckedStates();
    this.emitValueChange();
  }
  componentWillLoad() {
    elementIdHandling.verifyElementId(this.self);
  }
  async onKeyUp(e) {
    if (this.shouldHandleKeyboardEvent(e)) {
      const radioButton = await extractRadioButtonOutOfEventPath(e);
      if (this.radioButtons.includes(radioButton)) {
        this.handleKeyboardArrows(e);
      }
    }
  }
  onForceUpdateOnChange(e) {
    e.stopPropagation();
    e.detail(this);
  }
  /**
   * Sets the focus on the radio group.
   *
   * If an option is selected it will be focused.
   * If no option is selected the first option will be focused.
   * @example focus
   */
  async focusControl() {
    var _a;
    if (this.radioButtons.length === 0) {
      return;
    }
    const radioButton = (_a = this.getSelectedRadioButton()) !== null && _a !== void 0 ? _a : this.radioButtons[0];
    radioButton.focusControl().then();
  }
  /**
   * @internal
   */
  async select(value) {
    this.shouldEmitValueChange = true;
    this.value = value;
  }
  async connectRadioButton(connectedRadioButton) {
    const insertBeforeIndex = this.getRadioButtonsInsertIndex(connectedRadioButton);
    if (insertBeforeIndex === -1) {
      this.radioButtons = this.radioButtons.concat(connectedRadioButton);
    }
    else {
      this.radioButtons.splice(insertBeforeIndex, 0, connectedRadioButton);
    }
    this.postRadioButtonConnect();
  }
  async disconnectRadioButton(disconnectedRadioButton) {
    this.radioButtons = this.radioButtons.filter((radioButton) => disconnectedRadioButton !== radioButton);
  }
  postRadioButtonConnect() {
    this.updateCheckedStates();
    this.injectStates();
    const duplicates = value.findDuplicatedValues(this.radioButtons);
    assert.assert(duplicates.length == 0, () => `There should not be any duplicated values within <dx-radio-button-group> elements!\nFollowing duplicates were found: ${duplicates.join()}`, this.self);
  }
  // Returns the index of the radio-button dependent on the DOM-Structure
  getRadioButtonsInsertIndex(element) {
    var _a;
    const parentElementBelowRadioButtonGroup = (_a = this.getRadioButtonHolderBeforeSelf(element)) !== null && _a !== void 0 ? _a : this.self;
    // We need to find the correct order of the radio-buttons to be able to focus them correctly when pressing the arrow keys.
    return this.radioButtons
      .map((radioButton) => this.getRadioButtonHolderBeforeSelf(radioButton))
      .findIndex((radioOwner) => parentElementBelowRadioButtonGroup.compareDocumentPosition(radioOwner) & Node.DOCUMENT_POSITION_FOLLOWING);
  }
  shouldHandleKeyboardEvent(e) {
    return (!this.disabled &&
      ["ArrowDown", "ArrowUp", "ArrowLeft", "ArrowRight"].includes(e.code));
  }
  handleKeyboardArrows(e) {
    e.preventDefault();
    const enabledRadioButtons = this.radioButtons.filter((radioButton) => !radioButton.disabled);
    if (enabledRadioButtons.length === 0) {
      return;
    }
    const currentValueIndex = enabledRadioButtons.findIndex((radioButton) => radioButton.value === this.value);
    const nextRadioButtonIndex = (e.code === "ArrowDown" || e.code === "ArrowRight"
      ? currentValueIndex + 1
      : currentValueIndex - 1 + enabledRadioButtons.length) %
      enabledRadioButtons.length;
    const newSelectedRadioButton = enabledRadioButtons[nextRadioButtonIndex];
    this.select(newSelectedRadioButton.value).then();
    newSelectedRadioButton.focusControl().then();
  }
  getRadioButtonHolderBeforeSelf(element) {
    var _a, _b;
    let parent = element;
    let before = null;
    let radioOwner = null;
    while (parent != null && parent !== this.self) {
      before = parent;
      // If we find a radio-button or radioOwner we update the radioOwner to reference it
      if (miscUtil.tagOf(before) === "dx-radio-button" ||
        "getRadioElement" in before) {
        radioOwner = before;
      }
      parent = (_a = parent.parentElement) !== null && _a !== void 0 ? _a : (_b = parent.getRootNode()) === null || _b === void 0 ? void 0 : _b.host;
    }
    return radioOwner !== null && radioOwner !== void 0 ? radioOwner : before;
  }
  updateCheckedStates() {
    this.radioButtons.forEach((radioButton) => {
      radioButton.internalSetChecked(radioButton.value === this.value).then();
    });
  }
  emitValueChange() {
    if (this.shouldEmitValueChange) {
      this.valueChange.emit(this.value);
    }
    this.shouldEmitValueChange = false;
  }
  injectStates() {
    this.radioButtons.forEach((radioButton) => {
      var _a;
      radioButton.setAttribute("required", (_a = this.required) === null || _a === void 0 ? void 0 : _a.toString());
    });
  }
  getSelectedRadioButton() {
    return this.radioButtons.find((radioButton) => {
      return radioButton.value === this.value;
    });
  }
  render() {
    var _a, _b;
    if (this.readonly) {
      return (index.h(baseElements.ReadonlyTextElement, { text: (_b = (_a = this.getSelectedRadioButton()) === null || _a === void 0 ? void 0 : _a.label) !== null && _b !== void 0 ? _b : "" }));
    }
    return (index.h(index.Host, null, index.h("dx-form-wrapper", { id: elementIdHandling.ElementIdGenerator.createId(this.self, `form-wrapper`), label: this.label, required: this.required, kisynced: this.kisynced, errormessage: this.errormessage, ref: (ref) => {
        if (ref) {
          index.forceUpdate(ref);
        }
      } }, index.h("slot", null), index.h("slot", { name: "error-message", slot: "error-message" }))));
  }
  get self() { return index.getElement(this); }
  static get watchers() { return {
    "disabled": ["onDisabledChange"],
    "value": ["valueChanged"]
  }; }
};
DxRadioButtonGroup.style = dxRadioButtonGroupCss;

exports.dx_number_paginator = DxNumberPaginator;
exports.dx_number_picker = DxNumberPicker;
exports.dx_radio_button_group = DxRadioButtonGroup;
