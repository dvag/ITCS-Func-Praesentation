'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const index = require('./index-2f41386b.js');
const assert = require('./assert-d8ea75c6.js');
const elementIdHandling = require('./element-id-handling-89898a1c.js');
const baseElements = require('./base-elements-0dbfd791.js');
const slotObserver = require('./slot-observer-2e83212e.js');
const value = require('./value-1f8d9874.js');
const errorPopup = require('./error-popup-9c9bd96e.js');
require('./value-store-f683b26f.js');
require('./query-util-8642f149.js');

const dsRadioButtonCss = ":host{display:flex;align-items:baseline;width:fit-content;width:-moz-fit-content;outline:none;position:relative;top:0;left:0}:host:host([hidden]){display:none !important}:host .radio-input{position:absolute;cursor:pointer;left:0;top:0;width:100%;height:100%;opacity:0;margin:0;padding:0}:host .dot-baseline-container{display:flex;align-items:center}:host .dot-baseline-container .dot-container{border:1px solid #a7893d;border-radius:50%;height:16px;width:16px;position:relative;box-sizing:border-box;background-color:white;pointer-events:none;flex:0 0 16px}:host .dot-baseline-container .dot-container.margin-right{margin-right:8px}:host .dot-baseline-container .dot-container.checked{border-width:5px}:host .dot-baseline-container .dot-container .dot-focus-border{width:16px;height:16px;left:-1px;top:-1px;position:absolute;border:0 solid #a7893d;border-radius:50%;box-sizing:border-box}:host(:hover),:host(.force-hover){cursor:pointer}:host(:hover) .dot-container,:host(.force-hover) .dot-container{border-color:#957b36}:host(.has-focus) .dot-container .dot-focus-border{border-width:1px;border-color:#4c4c4c}:host(.has-focus) .dot-container.checked .dot-focus-border{left:-5px;top:-5px}:host(.disabled){cursor:default;pointer-events:none;--ds-text-color:#c1c1c1}:host(.disabled) .dot-container{border-color:#e3dac4}";

const DsRadioButton = class {
  constructor(hostRef) {
    index.registerInstance(this, hostRef);
    /**
     * Disables the ability to interact with this component.
     *
     * @value false: User can interact with this component.
     * @value true: User cannot interact with this component.
     *
     * @example modes
     */
    this.disabled = false;
    /**
     * Sets the error state on the group.
     *
     * @value true: An error exists.
     * @value false: No error exists.
     */
    this.error = false;
    this.checked = false;
    this.hasFocus = false;
  }
  /**
   * @internal
   */
  async internalSetChecked(checked) {
    this.checked = checked;
  }
  /**
   * Sets the focus on this component.
   * @example focus
   */
  async focusControl() {
    this.inputElement.focus();
  }
  componentWillLoad() {
    elementIdHandling.verifyElementId(this.self);
  }
  get showLabel() {
    var _a;
    return ((_a = this.label) === null || _a === void 0 ? void 0 : _a.length) > 0;
  }
  select() {
    if (!this.disabled) {
      const radioButtonGroup = this.group();
      radioButtonGroup.select(this.value).then();
    }
  }
  group() {
    const radioButtonGroup = this.self.closest("ds-radio-button-group");
    assert.assert(radioButtonGroup != null, () => "<ds-radio-button> has to be within a <ds-radio-button-group>.", this.self);
    return radioButtonGroup;
  }
  render() {
    const radioButtonGroup = this.group();
    const groupId = radioButtonGroup.getAttribute("radiogroupid");
    return (index.h(index.Host, { class: {
        disabled: this.disabled,
        "force-hover": this.mouseOver,
        "has-focus": this.hasFocus,
      } }, index.h("div", { class: "dot-baseline-container" }, index.h(baseElements.BaselineElement, null), index.h("div", { class: {
        "dot-container": true,
        "margin-right": this.showLabel,
        checked: this.checked,
      } }, index.h("div", { class: {
        "dot-focus-border": true,
      } }))), index.h("input", { id: elementIdHandling.ElementIdGenerator.createId(this.self, "control"), ref: (el) => (this.inputElement = el), name: `form-ds-radio-button-group-${groupId}`, type: "radio", onMouseEnter: () => (this.mouseOver = true), onMouseLeave: () => (this.mouseOver = false), onFocus: () => (this.hasFocus = true), onBlur: () => (this.hasFocus = false), onChange: () => this.select(), disabled: this.disabled, class: {
        "radio-input": true,
        "event-delegate-receiver": true,
      }, checked: this.checked }), this.renderLabel()));
  }
  renderLabel() {
    if (this.showLabel) {
      return (index.h("ds-text", { id: elementIdHandling.ElementIdGenerator.createId(this.self, "label"), screensize: "small" }, this.label));
    }
  }
  get self() { return index.getElement(this); }
};
DsRadioButton.style = dsRadioButtonCss;

const dsRadioButtonGroupCss = ":host{display:block;position:relative;--ds-show-error-hint:none;--dx-popup-offset-left:0px}:host:host([hidden]){display:none !important}:host:host(.required){--ds-show-required-hint:block}:host:host(.required) ds-required-hint{display:flex;padding-left:16px;justify-content:flex-end}:host:host(.required):host(.requirement-fulfilled){--ds-required-hint-fulfilled:true}:host:host(.required) .container{display:flex;flex-direction:column;width:max-content}";

const DsRadioButtonGroup = class {
  constructor(hostRef) {
    index.registerInstance(this, hostRef);
    this.valueChange = index.createEvent(this, "valueChange", 7);
    this.shouldEmitValueChange = false;
    this.radioButtons = [];
    this.inputFocused = false;
    /**
     * @internal
     */
    this.radiogroupid = `${++radioGroupCounter}`;
    /**
     * Defines if the group is in a read-only state.
     * The label of the current selected radio button will be displayed.
     *
     * @value false: The component is displayed normally.
     * @value true: The current selected option is displayed as text. If no option is selected no text will be displayed.
     * @example readonly
     */
    this.readonly = false;
    /**
     * Defines if the radio button group is a required form element.
     * @value false: It is not required to select an option.
     * @value true: To fulfill the requirement one option has to be selected.
     * @example required
     */
    this.required = false;
    /**
     * Sets the error state on the group.
     *
     * @value true: An error exists.
     * @value false: No error exists.
     * @example error
     */
    this.error = false;
    /**
     * Disables the ability to interact with this component.
     * Every option inside will also be set to `disabled`.
     *
     * @value false: User can select an option.
     * @value true: User cannot select an option.
     *
     * @example disabled
     */
    this.disabled = false;
  }
  onErrorMessageChange() {
    if (this.isConnectedToBorderedFormGroup()) {
      this.borderedFormGroup.errormessage = this.errormessage;
    }
  }
  onDisabledChange() {
    this.radioButtons.forEach((radioButton) => {
      if (this.disabled) {
        radioButton.classList.add("disabled");
      }
      else if (!radioButton.disabled) {
        radioButton.classList.remove("disabled");
      }
    });
  }
  valueChanged(newValue, oldValue) {
    if (newValue === oldValue) {
      return;
    }
    this.updateCheckedStates();
    this.emitValueChange();
    this.handleRequirement();
  }
  onKeyUp(e) {
    if (!this.disabled &&
      (e.code === "ArrowDown" ||
        e.code === "ArrowUp" ||
        e.code === "ArrowLeft" ||
        e.code === "ArrowRight") &&
      this.radioButtons.includes(e.target)) {
      e.preventDefault();
      const enabledRadioButtons = this.radioButtons.filter((radioButton) => !radioButton.disabled);
      if (enabledRadioButtons.length === 0) {
        return;
      }
      const currentValueIndex = enabledRadioButtons.findIndex((radioButton) => radioButton.value === this.value);
      const nextRadioButtonIndex = (e.code === "ArrowDown" || e.code === "ArrowRight"
        ? currentValueIndex + 1
        : currentValueIndex - 1 + enabledRadioButtons.length) %
        enabledRadioButtons.length;
      const newSelectedRadioButton = enabledRadioButtons[nextRadioButtonIndex];
      this.select(newSelectedRadioButton.value).then();
      newSelectedRadioButton.focusControl().then();
    }
  }
  onChildFocused() {
    this.inputFocused = true;
  }
  onChildBlurred() {
    this.inputFocused = false;
  }
  /**
   * Sets the focus on the radio group.
   *
   * If an option is selected it will be focused.
   * If no option is selected the first option will be focused.
   * @example focus
   */
  async focusControl() {
    var _a;
    if (this.radioButtons.length === 0) {
      return;
    }
    const radioButton = (_a = this.getSelectedRadioButton()) !== null && _a !== void 0 ? _a : this.radioButtons[0];
    radioButton.focusControl().then();
  }
  /**
   * @internal
   */
  async select(value) {
    this.shouldEmitValueChange = true;
    this.value = value;
  }
  connectedCallback() {
    this.init();
  }
  componentDidLoad() {
    this.init();
  }
  disconnectedCallback() {
    var _a;
    (_a = this.slotObserver) === null || _a === void 0 ? void 0 : _a.disconnect();
  }
  updateCheckedStates() {
    this.radioButtons.forEach((radioButton) => {
      radioButton.internalSetChecked(radioButton.value === this.value).then();
    });
  }
  emitValueChange() {
    if (this.shouldEmitValueChange) {
      this.valueChange.emit(this.value);
    }
    this.shouldEmitValueChange = false;
  }
  hasError() {
    var _a;
    return this.error || ((_a = this.errormessage) === null || _a === void 0 ? void 0 : _a.length) > 0;
  }
  injectStates() {
    this.radioButtons.forEach((radioButton) => {
      radioButton.setAttribute("required", this.required + "");
      radioButton.setAttribute("error", this.hasError() + "");
      radioButton.setAttribute("requirementfulfilled", "" + (this.value != null));
    });
  }
  getSelectedRadioButton() {
    return this.radioButtons.find((radioButton) => {
      return radioButton.value === this.value;
    });
  }
  init() {
    if (this.slotObserver == null) {
      this.slotObserver = new slotObserver.SlotObserver(this.self, "ds-radio-button", async (nodes) => {
        this.radioButtons = nodes;
        this.radioButtons.forEach((radioButton) => {
          if (this.disabled) {
            radioButton.classList.add("disabled");
          }
        });
        this.updateCheckedStates();
        this.injectStates();
        const duplicates = value.findDuplicatedValues(this.radioButtons);
        assert.assert(duplicates.length == 0, () => `There should not be any duplicated values within <ds-radio-button-group> elements!\nFollowing duplicates were found: ${duplicates.join()}`, this.self);
        this.borderedFormGroup = this.self.querySelector("ds-bordered-form-group");
        this.handleRequirement();
        this.handleErrorMessage();
      });
    }
  }
  handleRequirement() {
    if (this.isConnectedToBorderedFormGroup()) {
      this.borderedFormGroup.requirementfulfilled = this.value != null;
    }
  }
  handleErrorMessage() {
    if (this.isConnectedToBorderedFormGroup()) {
      this.borderedFormGroup.errormessage = this.errormessage;
    }
  }
  isConnectedToBorderedFormGroup() {
    return this.borderedFormGroup != null;
  }
  renderErrorPopup() {
    if (this.errormessage && !this.isConnectedToBorderedFormGroup()) {
      return (index.h(errorPopup.ErrorPopup, { text: this.errormessage, show: this.inputFocused }));
    }
  }
  componentShouldUpdate(_, __, propName) {
    if (["required", "error", "errormessage", "disabled", "value"].includes(propName)) {
      this.injectStates();
    }
  }
  render() {
    var _a, _b;
    if (this.readonly) {
      return (index.h(baseElements.ReadonlyTextElement, { text: (_b = (_a = this.getSelectedRadioButton()) === null || _a === void 0 ? void 0 : _a.label) !== null && _b !== void 0 ? _b : "" }));
    }
    return (index.h(index.Host, { class: {
        required: this.required,
        "requirement-fulfilled": !!this.value,
      } }, index.h("div", { class: { container: !this.isConnectedToBorderedFormGroup() } }, index.h("slot", null), this.renderErrorPopup(), index.h("ds-required-hint", { required: this.required && !this.isConnectedToBorderedFormGroup(), fulfilled: !!this.value }))));
  }
  get self() { return index.getElement(this); }
  static get watchers() { return {
    "errormessage": ["onErrorMessageChange"],
    "disabled": ["onDisabledChange"],
    "value": ["valueChanged"]
  }; }
};
let radioGroupCounter = 0;
DsRadioButtonGroup.style = dsRadioButtonGroupCss;

exports.ds_radio_button = DsRadioButton;
exports.ds_radio_button_group = DsRadioButtonGroup;
