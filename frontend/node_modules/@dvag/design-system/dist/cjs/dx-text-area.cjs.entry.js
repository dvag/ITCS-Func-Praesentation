'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const index = require('./index-2f41386b.js');
const assert = require('./assert-d8ea75c6.js');
const elementIdHandling = require('./element-id-handling-89898a1c.js');
const error = require('./error-e6134abb.js');
const baseElements = require('./base-elements-f50ffdf3.js');
const inputContainer = require('./input-container-97007eba.js');
require('./value-store-f683b26f.js');
require('./misc-util-63b423bd.js');

const dxTextAreaCss = ":host{min-width:0;width:100%;display:block}:host:host([hidden]){display:none !important}:host:host(.disabled){pointer-events:none}:host:host(.disabled:not(.nested-form-element)){opacity:0.4}:host label{display:block}:host label .container{position:relative;top:0;left:0;display:flex;height:48px;padding:10px 16px 10px 16px;box-sizing:border-box;border:1px solid #d6d6d6;border-bottom:var(--dx-container-border-bottom, 1px solid #d6d6d6);background-color:#ffffff;align-items:center;--dx-icon-color:#337a96;flex:1;width:100%;display:block;height:auto;padding:0}:host label .container.error{border-color:#9d2235;background-color:#f5e9eb}:host label .container.error input,:host label .container.error textarea{background:transparent}:host label .container.active{border-color:#004763;--dx-text-color:#004763;--dx-icon-color:#004763}:host label .container textarea{resize:none;outline:none;scrollbar-width:none;overflow:auto;-ms-overflow-style:none;border:none;margin:12px 16px;flex-grow:1;font-size:16px;font-weight:normal;letter-spacing:0.02px;line-height:22px;padding:0;background-color:#ffffff;font-family:DVAG-Type;font-size:16px;line-height:24px;letter-spacing:0.02px;color:#2b2b2b;color:#2b2b2b}@media (min-width: 1280px){:host label .container textarea{font-size:18px;line-height:28px}}:host label .container textarea::placeholder{color:#ababab}:host label .container textarea::-webkit-scrollbar{display:none}:host label .bottom-info-container{display:flex}:host label .bottom-info-container.one-item{justify-content:flex-end}@media (min-width: 0px){:host label .bottom-info-container.two-items{flex-direction:column-reverse}}@media (min-width: 476px){:host label .bottom-info-container.two-items{flex-direction:row;justify-content:space-between}}:host label .remaining-letters{display:block;flex-shrink:0;margin-top:8px;padding-right:8px;text-align:right}:host label .remaining-letters .remaining-text{display:block}dx-text{white-space:pre-line;word-break:break-word}";

const DxTextArea = class {
  constructor(hostRef) {
    index.registerInstance(this, hostRef);
    this.valueChange = index.createEvent(this, "valueChange", 7);
    this.valueComplete = index.createEvent(this, "valueComplete", 7);
    this.inputFocused = false;
    this.internalValue = "";
    /**
     * Number of lines shown simultaneously.
     * @value number: Number of lines.
     * @example lines
     */
    this.lines = 4;
    /**
     * Placeholder for this text area.
     * @value string: The placeholder text.
     *
     * @example placeholder
     */
    this.placeholder = "Bitte geben Sie hier Ihren Text ein ...";
    /**
     * Text of the textarea.
     * @important
     * @value string: Content of the textarea.
     * @example value
     */
    this.value = "";
    /**
     * Textarea is disabled and cannot be used anymore.
     * Label and border are grey.
     * @value true: Textarea is disabled
     * @value false: Textarea is not disabled
     * @example disabled
     */
    this.disabled = false;
    /**
     * Textarea is in read-only mode.
     * Content of the textare is displayed in a simple way.
     * @value false: Formfield
     * @value true: Shows the content only as text.
     * @example readonly
     */
    this.readonly = false;
    /**
     * Marks the textarea as mandatory.
     * @value false: Not mandatory (Default).
     * @value true: mandatory field.
     * @example required
     * @example required-maxlength
     */
    this.required = false;
    /**
     * Indicates that the form is synced with the KI.
     * @value true: Synchronized.
     * @value false: Not synchronized.
     * @example kisynced
     */
    this.kisynced = false;
  }
  valueChanged() {
    this.obtainValueChangesFromOutside();
  }
  /**
   * Sets the focus to the textarea.
   */
  async focusControl() {
    this.inputElement.focus();
  }
  componentWillLoad() {
    elementIdHandling.verifyElementId(this.self);
    this.obtainValueChangesFromOutside(true);
  }
  onForceUpdateOnChange(e) {
    e.detail(this.self);
  }
  obtainValueChangesFromOutside(force = false) {
    if (force || this.value !== this.internalValue) {
      this.internalValue = this.value;
      this.lastEmittedChangeValue = this.value;
      this.lastEmittedCompleteValue = this.value;
    }
  }
  onInputFocused() {
    this.inputFocused = true;
  }
  onInputBlurred() {
    this.inputFocused = false;
    this.emitValueChange();
    this.emitValueComplete();
  }
  onInputKeyUp(event) {
    this.internalValue = event.target.value;
    this.emitValueChange();
  }
  emitValueChange() {
    this.value = this.internalValue;
    if (this.lastEmittedChangeValue !== this.value) {
      this.valueChange.emit(this.value);
      this.lastEmittedChangeValue = this.value;
    }
  }
  emitValueComplete() {
    if (this.lastEmittedCompleteValue !== this.value) {
      this.valueComplete.emit(this.value);
      this.lastEmittedCompleteValue = this.value;
    }
  }
  render() {
    if (this.readonly) {
      return index.h(baseElements.ReadonlyTextElement, { text: this.value, label: this.label });
    }
    return (index.h(index.Host, { class: { disabled: this.disabled } }, this.renderInput()));
  }
  renderInput() {
    assert.assert(this.maxlength == null || this.maxlength > 0, () => `<dx-text-area> 'maxlength' should not be smaller than 1. `);
    assert.assert(this.maxlength == null || this.maxlength > this.value.length, () => `<dx-text-area> 'value' should not be greater than 'maxlength'`);
    assert.assert(this.lines > 0, () => `<dx-text-area> 'lines' should be greater than 0`);
    return (index.h("label", null, index.h(inputContainer.LabeledInputContainer, { containerProperties: {
        active: this.inputFocused,
        size: "m",
        title: this.value,
        error: error.hasError(this.self),
      }, labelProperties: {
        disabled: this.disabled,
        label: this.label,
        required: this.required,
        kisynced: this.kisynced,
      }, additionalCssStyles: {
        width: "100%",
      } }, index.h("ds-scroll-container", { style: { height: `${MARGIN_PX + this.lines * LINE_PX}px` }, scrollbarspace: 8, scrollbarborderradius: 0 }, index.h("textarea", { id: elementIdHandling.ElementIdGenerator.createId(this.self, "control"), onKeyUp: (event) => this.onInputKeyUp(event), onFocus: () => this.onInputFocused(), onBlur: () => this.onInputBlurred(), ref: (el) => (this.inputElement = el), placeholder: this.placeholder, value: this.internalValue, maxLength: this.maxlength > 0 ? this.maxlength : undefined, disabled: this.disabled }))), index.h("div", { class: {
        "bottom-info-container": true,
        "one-item": this.maxlength > 0 && !this.errormessage,
        "two-items": this.maxlength > 0 && !!this.errormessage,
      } }, index.h(error.ErrorMessage, { self: this.self, message: this.errormessage }), this.renderRemainingLetters())));
  }
  renderRemainingLetters() {
    if (this.maxlength > 0) {
      const remainingLetters = this.maxlength - this.internalValue.length;
      return (index.h("div", { class: "remaining-letters" }, index.h("dx-text", { class: "remaining-text", type: "its" }, remainingLetters, " Zeichen verbleibend")));
    }
  }
  get self() { return index.getElement(this); }
  static get watchers() { return {
    "value": ["valueChanged"]
  }; }
};
const MARGIN_PX = 12 + 12;
const LINE_PX = 22;
DxTextArea.style = dxTextAreaCss;

exports.dx_text_area = DxTextArea;
