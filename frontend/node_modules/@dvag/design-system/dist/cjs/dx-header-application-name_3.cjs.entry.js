'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const index = require('./index-2f41386b.js');
const elementIdHandling = require('./element-id-handling-89898a1c.js');
const slotObserver = require('./slot-observer-2e83212e.js');
const miscUtil = require('./misc-util-63b423bd.js');
const renderUtil = require('./render-util-6b278c0d.js');
const assert = require('./assert-d8ea75c6.js');
const headerMenu_util = require('./header-menu.util-2740ba3a.js');
const sizes_util = require('./sizes.util-a4bacea6.js');
require('./value-store-f683b26f.js');
require('./query-util-8642f149.js');

const dxHeaderApplicationNameCss = ":host{display:block;width:100%;height:100%;min-width:176px;max-width:640px;position:relative}:host:host([hidden]){display:none !important}:host .hidden-text{display:block;position:absolute;top:-10000px;width:100%;visibility:hidden;pointer-events:none}:host .app-name-container{cursor:pointer;width:max-content;max-width:100%;height:100%;display:flex;align-items:center}:host .app-name-container .displayed-text{display:-webkit-box;-webkit-line-clamp:2;-webkit-box-orient:vertical;overflow:hidden;--dx-text-color:var(--dx-header-text-icon-theme-color, #2b2b2b)}";

const DxHeaderApplicationName = class {
  constructor(hostRef) {
    index.registerInstance(this, hostRef);
    this.interaction = index.createEvent(this, "interaction", 7);
    this.currentType = "Paragraph-Standard";
  }
  connectedCallback() {
    this.resizeObserver = new ResizeObserver((entries) => {
      const currentHeightOfHiddenText = entries[0].contentRect.height;
      // We want to check whether the hidden text has at least two lines of text. Therefore we factor the
      // PARAGRAPH_STANDARD_LINE_HEIGHT by 1.5 as a bias to get a middle height between one line and two lines of text.
      const biasScale = 1.5;
      if (currentHeightOfHiddenText >
        PARAGRAPH_STANDARD_LINE_HEIGHT * biasScale) {
        this.currentType = INFO_TEXT_SMALL;
      }
      else {
        this.currentType = PARAGRAPH_STANDARD;
      }
    });
  }
  disconnectedCallback() {
    var _a;
    (_a = this.resizeObserver) === null || _a === void 0 ? void 0 : _a.disconnect();
  }
  render() {
    return (index.h(index.Host, null, index.h("div", { class: "app-name-container", role: "button", id: elementIdHandling.ElementIdGenerator.createId(this.self, "control"), onClick: () => this.interaction.emit() }, index.h("dx-text", { class: {
        "displayed-text": true,
      }, type: this.currentType }, this.appname)), index.h("dx-text", { type: "ps", class: {
        "hidden-text": true,
      }, ref: (ref) => this.resizeObserver.observe(ref) }, this.appname)));
  }
  get self() { return index.getElement(this); }
};
const PARAGRAPH_STANDARD_LINE_HEIGHT = 24;
const PARAGRAPH_STANDARD = "Paragraph-Standard";
const INFO_TEXT_SMALL = "Infotext-Small";
DxHeaderApplicationName.style = dxHeaderApplicationNameCss;

const dxHeaderMenuBarCss = ":host{display:block;min-width:48px;max-height:100%}:host:host([hidden]){display:none !important}:host ::slotted(dx-header-menu-item),:host ::slotted(dx-header-app-favorites),:host ::slotted(dx-header-user),:host ::slotted(dx-header-navigation){z-index:1}:host dx-header-menu-item,:host dx-header-app-favorites,:host dx-header-user,:host dx-header-navigation{z-index:1}:host .menu-bar{width:100%;position:relative;display:flex;justify-content:flex-end}:host .menu-bar .header-navigation{z-index:1}";

const DxHeaderMenuBar = class {
  constructor(hostRef) {
    index.registerInstance(this, hostRef);
    this.sidebarOpenChange = index.createEvent(this, "sidebarOpenChange", 7);
    this.navigationInSlot = false;
    this.showSidebar = false;
  }
  onShowSidebarChanged() {
    const sidebarOpenChangeEvent = new CustomEvent(this.showSidebar ? "sidebarOpen" : "sidebarClose", {
      detail: {
        showNavigationItem: this.navigationValueToShowInNavigationMenu,
      },
    });
    this.navigationValueToShowInNavigationMenu = null;
    this.menuItems.forEach((menuItem) => {
      menuItem.internalactive && (menuItem.internalactive = this.showSidebar);
      menuItem.dispatchEvent(sidebarOpenChangeEvent);
    });
    if (this.showSidebar) {
      this.showChildrenOnSidebarOpen();
    }
    else {
      this.updateChildren(this.lastPossibleAvailableSpace).then();
    }
    this.sidebarOpenChange.emit(this.showSidebar);
  }
  connectedCallback() {
    this.menuItemsObserver = new slotObserver.SlotObserver(this.self, "*", () => {
      this.menuItems = this.getAllSlottedMenuItemElements();
      this.handleSlottedNavigationItem();
    });
  }
  disconnectedCallback() {
    var _a;
    (_a = this.menuItemsObserver) === null || _a === void 0 ? void 0 : _a.disconnect();
  }
  async componentWillRender() {
    var _a;
    const renderPromises = (_a = this.menuItems) === null || _a === void 0 ? void 0 : _a.map((menuItem) => {
      var _a, _b;
      return ((_b = (_a = menuItem.renderSidebarContent) === null || _a === void 0 ? void 0 : _a.call(menuItem)) !== null && _b !== void 0 ? _b : (index.h("slot", { name: menuItem.connectedslot })));
    });
    if (renderPromises == null) {
      this.sidebarContentOutputs = null;
      return;
    }
    this.sidebarContentOutputs = (await Promise.all(renderPromises)).map((output, index$1) => {
      var _a;
      return (index.h("dx-content-switcher-item", { value: (_a = this.menuItems[index$1].connectedslot) !== null && _a !== void 0 ? _a : index$1 }, output));
    });
  }
  onForceSidebarContentUpdate() {
    index.forceUpdate(this);
  }
  handleOpenSidebar(e) {
    this.showSidebar = e.detail;
  }
  onMenuInteraction(e) {
    if (e.target === this.self) {
      // The navigation element triggered the menuInteraction event
      return;
    }
    const interactedMenuEntry = e.target;
    if (headerMenu_util.isMenuItem(interactedMenuEntry)) {
      const interactedMenuItem = interactedMenuEntry;
      const currentlyActive = interactedMenuItem.internalactive;
      this.menuItems.forEach((menuItem) => {
        menuItem.internalactive =
          this.menuItemHasSidebarContent(menuItem) &&
            menuItem === interactedMenuItem &&
            !currentlyActive;
      });
      if (interactedMenuItem.internalactive) {
        this.contentSwitcher
          .showValue(interactedMenuItem.connectedslot, this.showSidebar)
          .then();
      }
      this.showSidebar = interactedMenuItem.internalactive;
    }
    else if (headerMenu_util.isMenuLink(e.target)) {
      const interactedMenuLink = e.target;
      if (this.menuLinkHasNavigationElement(interactedMenuLink)) {
        this.navigationValueToShowInNavigationMenu =
          interactedMenuLink.connectednavigationvalue;
        this.navigationMenuItem.internalactive = true;
        this.contentSwitcher
          .showValue(this.navigationMenuItem.connectedslot, this.showSidebar)
          .then();
        this.showSidebar = true;
      }
    }
  }
  showChildrenOnSidebarOpen() {
    this.getGroupedHeaderMenuEntries().forEach((element) => {
      element.internalopen || (element.internalopen = headerMenu_util.isMenuItem(element));
    });
    this.navigationMenuItem.internalnotification = false;
  }
  /**
   * @internal
   */
  async updateChildren(possibleAvailableSpace) {
    this.lastPossibleAvailableSpace = Math.floor(possibleAvailableSpace);
    const sortedMenuEntries = this.getGroupedHeaderMenuEntries()
      .sort((first, second) => (second.priority || Number.POSITIVE_INFINITY) -
      (first.priority || Number.POSITIVE_INFINITY))
      .reverse();
    if (sortedMenuEntries.length === 0) {
      return;
    }
    let accumulatedWidth = 0;
    let showNotificationInNavigation = false;
    let navigationNotificationsTheme = null;
    const updateNavigationProperties = (menuitem) => {
      navigationNotificationsTheme = calculateTheme(menuitem, navigationNotificationsTheme);
      showNotificationInNavigation || (showNotificationInNavigation = menuItemHasNotifications(menuitem));
    };
    const slottedContent = miscUtil.getSlottedContent(this.self);
    for (const sortedMenuEntry of sortedMenuEntries) {
      const defaultWidth = await sortedMenuEntry.getDefaultWidth();
      accumulatedWidth += defaultWidth;
      const spacerToTheRight = this.getSpacerToTheRight(sortedMenuEntry, slottedContent);
      accumulatedWidth += sizes_util.getSpacerWidth(spacerToTheRight);
      const enoughSpaceLeft = accumulatedWidth <= this.lastPossibleAvailableSpace;
      sortedMenuEntry.internalopen =
        enoughSpaceLeft || (this.showSidebar && headerMenu_util.isMenuItem(sortedMenuEntry));
      this.updateSpacerVisibility(spacerToTheRight, enoughSpaceLeft);
      if (!showNotificationInNavigation && !sortedMenuEntry.internalopen) {
        if (isHeaderMenuGroup(sortedMenuEntry)) {
          const menuItems = await sortedMenuEntry.getInnerMenuItems();
          menuItems.forEach((menuItem) => {
            updateNavigationProperties(menuItem);
          });
        }
        else if (headerMenu_util.isMenuItem(sortedMenuEntry)) {
          updateNavigationProperties(sortedMenuEntry);
        }
      }
    }
    if (this.navigationMenuItem) {
      this.navigationMenuItem.internalnotification =
        showNotificationInNavigation;
      this.navigationMenuItem.internalnotificationstheme =
        navigationNotificationsTheme;
    }
  }
  updateSpacerVisibility(spacerToTheRight, enoughSpaceLeft) {
    if (spacerToTheRight) {
      spacerToTheRight.style.transition =
        "width var(--dx-header-hide-animation-duration) ease-in-out";
      spacerToTheRight.style.width = enoughSpaceLeft
        ? sizes_util.getSpacerWidth(spacerToTheRight) + "px"
        : "0";
    }
  }
  getSpacerToTheRight(sortedMenuElement, slottedContent) {
    const menuItemIndex = slottedContent.indexOf(sortedMenuElement);
    if (menuItemIndex >= 0 && slottedContent.length > menuItemIndex + 1) {
      const elementToTheRight = slottedContent[menuItemIndex + 1];
      return miscUtil.tagOf(elementToTheRight) === "dx-spacer"
        ? elementToTheRight
        : null;
    }
    return null;
  }
  getAllSlottedMenuItemElements() {
    return miscUtil.getSlottedContent(this.self)
      .filter((node) => isValidHeaderComponentTag(node.tagName))
      .map((menuItem, index) => {
      var _a;
      if (headerMenu_util.isMenuItem(menuItem)) {
        (_a = menuItem.connectedslot) !== null && _a !== void 0 ? _a : (menuItem.connectedslot = index.toString());
        return menuItem;
      }
      if (headerMenu_util.isMenuGroup(menuItem)) {
        return miscUtil.getSlottedContent(menuItem);
      }
    })
      .filter((element) => !!element)
      .flat();
  }
  handleSlottedNavigationItem() {
    const navigationMenuItem = this.menuItems.find((menuItem) => miscUtil.tagOf(menuItem) === "dx-header-navigation");
    this.navigationInSlot = navigationMenuItem != null;
    // If there already is a navigation defined we want to reorder the menuItems array.
    if (this.navigationInSlot) {
      this.navigationMenuItem = navigationMenuItem;
      assert.assert(this.menuItems.indexOf(this.navigationMenuItem) ===
        this.menuItems.length - 1, () => "The <dx-header-navigation> has to be the last menu item integrated into the <dx-header> element. This has to be ensured because of the tab order and accessibility reasons.", this.navigationMenuItem);
    }
    else if (this.navigationMenuItem != null) {
      this.menuItems.push(this.navigationMenuItem);
    }
  }
  menuItemHasSidebarContent(menuItem) {
    var _a;
    return (menuItem.renderSidebarContent != null ||
      (((_a = menuItem.connectedslot) === null || _a === void 0 ? void 0 : _a.length) > 0 &&
        renderUtil.isSlotDefined(this.self, menuItem.connectedslot)));
  }
  menuLinkHasNavigationElement(menuItem) {
    var _a;
    return (((_a = menuItem.connectednavigationvalue) === null || _a === void 0 ? void 0 : _a.length) > 0 &&
      menuItem.label &&
      miscUtil.getSlottedContent(this.navigationMenuItem).some((element) => element.value === menuItem.connectednavigationvalue));
  }
  getGroupedHeaderMenuEntries() {
    return miscUtil.getSlottedContent(this.self)
      .filter((element) => {
      return isValidHeaderComponentTag(element.tagName);
    })
      .concat(this.navigationInSlot || this.menuItems.length === 0
      ? []
      : this.menuItems[this.menuItems.length - 1]);
  }
  renderHeaderNavigation() {
    var _a, _b;
    if (this.navigationInSlot || ((_b = (_a = this.menuItems) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0) == 0) {
      return;
    }
    return (index.h("dx-header-navigation", { id: elementIdHandling.ElementIdGenerator.createId(this.self, "navigation"), onMenuInteraction: (e) => this.onMenuInteraction(e), class: { "header-navigation": true }, ref: (ref) => requestAnimationFrame(() => {
        this.navigationMenuItem = ref;
        this.navigationMenuItem.connectedslot = "dx-internal-navigation";
        if (!this.menuItems.includes(this.navigationMenuItem)) {
          this.menuItems.push(this.navigationMenuItem);
        }
      }) }));
  }
  render() {
    return [
      index.h("div", { class: "menu-bar" }, index.h("slot", null), this.renderHeaderNavigation()),
      index.h("dx-sidebar", { open: this.showSidebar, onOpenChange: (e) => (this.showSidebar = e.detail) }, index.h("dx-content-switcher", { ref: (ref) => (this.contentSwitcher = ref) }, this.sidebarContentOutputs)),
    ];
  }
  get self() { return index.getElement(this); }
  static get watchers() { return {
    "showSidebar": ["onShowSidebarChanged"]
  }; }
};
function calculateTheme(item, theme) {
  var _a;
  if (theme !== "system" && menuItemHasNotifications(item)) {
    return (_a = item.notificationstheme) !== null && _a !== void 0 ? _a : theme;
  }
  return theme;
}
function isHeaderMenuGroup(element) {
  return element.tagName.toLowerCase() === "dx-header-menu-group";
}
function isValidHeaderComponentTag(tagName) {
  return tagName.toLowerCase().startsWith("dx-header-");
}
function menuItemHasNotifications(menuItem) {
  return (menuItem.notification ||
    menuItem.notifications === "no-number" ||
    menuItem.notifications >= 1);
}
DxHeaderMenuBar.style = dxHeaderMenuBarCss;

const dxLogoCss = ":host{display:inline-block;height:56px;line-height:0}:host:host([hidden]){display:none !important}";

const DxLogo = class {
  constructor(hostRef) {
    index.registerInstance(this, hostRef);
    /**
     * Provides the logo in different styles.
     *
     * @value bildmarke: DVAG-Logo banner image.
     * @value wortmarke: DVAG-Logo with word mark.
     * @example logo
     */
    this.type = "bildmarke";
  }
  render() {
    // https://stackoverflow.com/questions/33471880/dynamic-tag-name-in-react-jsx
    const Logo = `dx-logo-${this.type}`;
    return (index.h(index.Host, null, index.h(Logo, null)));
  }
  get self() { return index.getElement(this); }
};
DxLogo.style = dxLogoCss;

exports.dx_header_application_name = DxHeaderApplicationName;
exports.dx_header_menu_bar = DxHeaderMenuBar;
exports.dx_logo = DxLogo;
