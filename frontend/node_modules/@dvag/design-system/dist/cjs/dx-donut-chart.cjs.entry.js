'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const index = require('./index-2f41386b.js');
const slotObserver = require('./slot-observer-2e83212e.js');
const queryUtil = require('./query-util-8642f149.js');
const mathUtil = require('./math-util-a514efc6.js');
const colorPalette = require('./color-palette-ed0f6557.js');
const assert = require('./assert-d8ea75c6.js');
const debounce = require('./debounce-0d323abe.js');
const breakpointAware = require('./breakpoint-aware-cc9d0ee6.js');
const preciseCssSetter = require('./precise-css-setter-3049fed6.js');
const renderUtil = require('./render-util-6b278c0d.js');

const dxDonutChartCss = ":host{display:block;width:100%}:host:host([hidden]){display:none !important}.donut-container{display:grid;aspect-ratio:1;position:relative}.content-container{display:flex;justify-content:center;align-items:center;position:absolute;top:25%;left:25%;width:50%;height:50%;margin:auto}.label-svg{position:absolute;top:0;left:0;width:100%;height:100%}.label-line{stroke:#575757;opacity:0}.sub-label,.label-svg,.segment-label{white-space:nowrap;--dx-text-color:#575757}@media (min-width: 0px) and (min-width: 0px){.sub-label,.label-svg,.segment-label{font-size:12px;--dx-text-font-size:12px;line-height:16px;--dx-text-line-height:16px}}@media (min-width: 0px) and (min-width: 1280px){.sub-label,.label-svg,.segment-label{font-size:14px;--dx-text-font-size:14px;line-height:20px;--dx-text-line-height:20px}}@media (min-width: 1024px) and (min-width: 0px){.sub-label,.label-svg,.segment-label{font-size:20px;--dx-text-font-size:20px;line-height:28px;--dx-text-line-height:28px}}@media (min-width: 1024px) and (min-width: 1280px){.sub-label,.label-svg,.segment-label{font-size:22px;--dx-text-font-size:22px;line-height:32px;--dx-text-line-height:32px}}@media (min-width: 1280px) and (min-width: 0px){.sub-label,.label-svg,.segment-label{font-size:22px;--dx-text-font-size:22px;line-height:32px;--dx-text-line-height:32px}}@media (min-width: 1280px) and (min-width: 1280px){.sub-label,.label-svg,.segment-label{font-size:26px;--dx-text-font-size:26px;line-height:36px;--dx-text-line-height:36px}}.segment{transition:stroke, stroke-width;transition-duration:300ms;transition-timing-function:ease-in-out}.text{font-family:DVAG-Type, sans-serif;fill:#575757}.segment-label,.label-line{transition:opacity 150ms ease-in-out;opacity:0}.segment-label.can-be-visible.visible,.label-line.can-be-visible.visible{opacity:1}.overlay{position:absolute;display:flex;justify-content:center;align-items:center;width:100%;height:100%;top:0;left:0}.overlay .inner-labels{display:flex;flex-direction:column;justify-content:center;align-items:center;width:50%;height:50%;top:25%;left:25%;text-align:center}.overlay .label{--dx-text-color:#2b2b2b}@media (min-width: 0px) and (min-width: 0px){.overlay .label{font-size:16px;--dx-text-font-size:16px;line-height:24px;--dx-text-line-height:24px}}@media (min-width: 0px) and (min-width: 1280px){.overlay .label{font-size:18px;--dx-text-font-size:18px;line-height:28px;--dx-text-line-height:28px}}@media (min-width: 1024px) and (min-width: 0px){.overlay .label{font-size:30px;--dx-text-font-size:30px;line-height:40px;--dx-text-line-height:40px}}@media (min-width: 1024px) and (min-width: 1280px){.overlay .label{font-size:38px;--dx-text-font-size:38px;line-height:48px;--dx-text-line-height:48px}}@media (min-width: 1280px) and (min-width: 0px){.overlay .label{font-size:34px;--dx-text-font-size:34px;line-height:44px;--dx-text-line-height:44px}}@media (min-width: 1280px) and (min-width: 1280px){.overlay .label{font-size:46px;--dx-text-font-size:46px;line-height:56px;--dx-text-line-height:56px}}.overlay .label+.sub-label{margin-top:8px}.overlay .segment-label{position:absolute;transform:translate(-50%, -50%);display:flex;align-items:center}@media (min-width: 0px){.overlay .segment-label{--dx-icon-attr-size:16px}}@media (min-width: 1024px){.overlay .segment-label{--dx-icon-attr-size:24px}}@media (min-width: 1280px){.overlay .segment-label{--dx-icon-attr-size:32px}}.overlay .segment-label dx-icon{margin-right:8px}";

const DxDonutChart = class {
  constructor(hostRef) {
    index.registerInstance(this, hostRef);
    this.segmentSelect = index.createEvent(this, "segmentSelect", 7);
    // 15.915 is a value which enables us to easily compute with understandable factors for svg parameters.
    this.donutRadius = 15.915;
    // Choose a viewBox big enough to minimize the overflow of the segment labels.
    this.viewBoxSize = this.donutRadius * 3;
    this.virtualScaledSegmentWidth = 25 * 1.25; // 1.25 is the segment scale when active
    this.labelPositioningFactor = 1.75;
    this.debounce = new debounce.Debounce(200);
    this.mouseMoveHandler = (mouseEvent) => {
      this.handleMouseMove(mouseEvent);
    };
    this.chartInput = [];
    this.internalSelected = null;
    /**
     * The index of the selected segment.
     *
     * @value number: An index between 0 and (n - 1), whereas n = number of segments.
     *
     * @example selected
     */
    this.selected = null;
    /**
     * The color scheme which is used to color the segments
     *
     * @value blue: All segments are displayed in a predefined blue color
     * @value gray: All segments are displayed in a predefined gray color
     * @value signal: The segments can be displayed in the three different signal colors (success, warning, error).
     * @value custom: The color of segments can be set to any color in the color palette.
     *
     * @example color-scheme
     * @example signal
     */
    this.colorscheme = "custom";
    /**
     * Defines whether to show the outer labels of the segments or not.
     *
     * @value true: The label of every segment is displayed.
     * @value false: No segment labels are visible.
     *
     * @example show-segment-labels
     */
    this.showsegmentlabels = false;
  }
  onShowSegmentLabelsChanged() {
    if (this.showsegmentlabels) {
      // The startUpdateCalculation function has to be called after the next render to ensure that every element is available.
      renderUtil.onNextFrame(() => this.startUpdateCalculation());
    }
  }
  connectedCallback() {
    this.breakpointAware = new breakpointAware.BreakpointAware(() => null, true);
  }
  disconnectedCallback() {
    var _a, _b, _c;
    (_a = this.debounce) === null || _a === void 0 ? void 0 : _a.reset();
    (_b = this.breakpointAware) === null || _b === void 0 ? void 0 : _b.disconnect();
    (_c = this.slotObserver) === null || _c === void 0 ? void 0 : _c.disconnect();
  }
  onWindowResizeChange() {
    this.startUpdateCalculation();
  }
  async update() {
    this.startUpdateCalculation().then(() => {
      index.forceUpdate(this);
    });
  }
  async startUpdateCalculation() {
    return new Promise((resolve) => {
      index.readTask(() => {
        const invisibleElementsWhileCalculating = this.self.shadowRoot.querySelectorAll(".segment-label, .label-line");
        const setVisibility = (visible) => {
          index.writeTask(() => {
            invisibleElementsWhileCalculating === null || invisibleElementsWhileCalculating === void 0 ? void 0 : invisibleElementsWhileCalculating.forEach((segmentLabel) => {
              if (visible) {
                segmentLabel.classList.add("visible");
              }
              else {
                segmentLabel.classList.remove("visible");
              }
            });
          });
        };
        setVisibility(false);
        this.debounce.run(async () => {
          await this.updatePositions();
          setVisibility(true);
          resolve();
        });
      });
    });
  }
  async updatePositions() {
    if (!this.showsegmentlabels || this.chartInput.length === 0) {
      return;
    }
    const createData = this.generateDonutCreateData();
    return new Promise((resolve) => {
      index.readTask(() => {
        const labelLines = Array.from(this.self.shadowRoot.querySelectorAll(".label-line"));
        const segmentLabels = Array.from(this.self.shadowRoot.querySelectorAll(".segment-label"));
        let fractionOfLastSegment = createData.segments[createData.segments.length - 1].input.value /
          createData.sum;
        let count = 0;
        let lastDistance = 0;
        const selfWidth = this.self.offsetWidth;
        const breakpointFactor = this.breakpointAware.mq1 ? 2 : 1;
        const updatePositionsInfo = createData.segments.map((segment) => {
          const fractionOfCurrentSegment = segment.input.value / createData.sum;
          const { distance, offset } = computeDistanceAndOffsetBetweenSegments(segment, lastDistance, fractionOfCurrentSegment, fractionOfLastSegment, breakpointFactor, 1 + (window.innerWidth / selfWidth) * 0.5);
          fractionOfLastSegment = fractionOfCurrentSegment;
          lastDistance = offset === 0 ? 0 : distance;
          return {
            segment,
            correspondingLabelLine: labelLines[count++],
            offset: offset,
          };
        });
        const writeQueue = normalizeOffset(updatePositionsInfo).map((data, index) => {
          const { segment, correspondingLabelLine, offset } = data;
          const direction = this.getSegmentMiddleDirectionFromOrigin(segment, createData.sum, offset);
          const directionLineStart = this.getSegmentMiddleDirectionFromOrigin(segment, createData.sum);
          const origin = new mathUtil.Point(this.viewBoxSize * 0.5);
          const scaledViewBoxSize = this.viewBoxSize * this.labelPositioningFactor;
          const location = origin.plus(direction.scale(scaledViewBoxSize * 0.53));
          const locationLineStart = origin.plus(directionLineStart.scale(scaledViewBoxSize * 0.485));
          const lineDirection = location.minus(locationLineStart);
          const locationLineEnd = locationLineStart.plus(lineDirection.scale(0.9));
          const directionFromLineStartToEnd = mathUtil.normalize(lineDirection);
          const locationToOriginDirection = origin.minus(location);
          const percentageX = 50 - locationToOriginDirection.x;
          const percentageY = 50 + locationToOriginDirection.y;
          const locationLineStartToOriginDirection = origin.minus(locationLineStart);
          const locationLineEndToOriginDirection = origin.minus(locationLineEnd);
          const percentageXLineStart = 50 - locationLineStartToOriginDirection.x;
          const percentageYLineStart = 50 + locationLineStartToOriginDirection.y;
          const percentageXLineEnd = 50 - locationLineEndToOriginDirection.x;
          const percentageYLineEnd = 50 + locationLineEndToOriginDirection.y;
          return () => {
            if (correspondingLabelLine != null) {
              new preciseCssSetter.PreciseCssSetter(correspondingLabelLine)
                .set("can-be-visible", segment.input.value / createData.sum < 0.1 ||
                Math.abs(offset) > BIAS)
                .execute();
              correspondingLabelLine.setAttribute("x1", `${percentageXLineStart}%`);
              correspondingLabelLine.setAttribute("y1", `${percentageYLineStart}%`);
              correspondingLabelLine.setAttribute("x2", `${percentageXLineEnd}%`);
              correspondingLabelLine.setAttribute("y2", `${percentageYLineEnd}%`);
            }
            segmentLabels[index].style.setProperty("top", `${percentageY}%`);
            segmentLabels[index].style.setProperty("left", `${percentageX}%`);
            const angleInRadians = mathUtil.directionToRadians(directionFromLineStartToEnd);
            const translationFactorX = Math.sin(angleInRadians);
            const translationFactorY = Math.cos(angleInRadians);
            const originPercentage = 50;
            segmentLabels[index].style.setProperty("transform", `translate(${originPercentage * (translationFactorX - 1)}%, ${-originPercentage * (translationFactorY + 1)}%)`);
          };
        });
        index.writeTask(() => {
          writeQueue.forEach((writeFunction) => writeFunction());
          resolve();
        });
      });
    });
  }
  componentDidLoad() {
    this.slotObserver =
      slotObserver.createMetaComponentsSlotObserver(this.self, queryUtil.notHidden("dx-chart-sample"), async (nodes) => {
        await this.collectSamplesFromChildren(nodes);
        requestAnimationFrame(() => {
          this.startUpdateCalculation();
        });
      });
  }
  async collectSamplesFromChildren(nodes) {
    this.chartInput = await Promise.all(nodes.map((node) => node.toChartSample()));
    assert.assert(this.chartInput.length >= 2 && this.chartInput.length <= 8, () => "A donut chart should contain 2 to 8 samples!", this.self);
  }
  getHitAngle(mouseX, mouseY) {
    const selfBoundingClientRect = this.self.getBoundingClientRect();
    const relativeOrigin = new mathUtil.Point(selfBoundingClientRect.width * 0.5, selfBoundingClientRect.height * 0.5);
    const clientOrigin = relativeOrigin.plus(mathUtil.toPoint(selfBoundingClientRect));
    const mousePosition = new mathUtil.Point(mouseX, mouseY);
    const scale = this.getScaledOuterDiameter / selfBoundingClientRect.width;
    const direction = mousePosition.minus(clientOrigin).scale(scale);
    const lengthSquared = direction.lengthSquared;
    const scaledRadiusOuter = this.getScaledOuterRadius();
    const scaledRadiusInner = scaledRadiusOuter - this.virtualScaledSegmentWidth * 2;
    const minRadiusSquared = scaledRadiusInner * scaledRadiusInner;
    const maxRadiusSquared = scaledRadiusOuter * scaledRadiusOuter;
    // Check if the mouse is between the segments
    if (lengthSquared >= minRadiusSquared &&
      lengthSquared <= maxRadiusSquared) {
      let angle = (Math.acos(direction.x / Math.sqrt(lengthSquared)) * 180) / mathUtil.PI;
      if (mousePosition.y < clientOrigin.y) {
        angle = 360 - angle;
      }
      const angleOffset = 90;
      return (angle + angleOffset + 360) % 360;
    }
    return null;
  }
  getSegmentIndexOnCoordinate(x, y) {
    const angle = this.getHitAngle(x, y);
    return this.getSelectIndexWithAngle(angle);
  }
  handleMouseMove(e) {
    const angle = this.getHitAngle(e.clientX, e.clientY);
    if (angle != null) {
      this.selectSegmentByAngle(angle);
    }
    else {
      this.selectSegment(null);
    }
  }
  getSelectIndexWithAngle(angle) {
    const valueSum = this.chartInput
      .map((input) => input.value)
      .reduce((previous, current) => previous + current, 0);
    let currentValueSum = 0;
    return this.chartInput.findIndex((sample) => {
      const from = currentValueSum;
      currentValueSum += sample.value;
      const to = currentValueSum;
      const fromAngle = (from / valueSum) * 360;
      const toAngle = (to / valueSum) * 360;
      return angle >= fromAngle && angle <= toAngle;
    });
  }
  selectSegmentByAngle(angle) {
    const index = this.getSelectIndexWithAngle(angle);
    if (index === -1) {
      return;
    }
    this.selectSegment(index);
  }
  selectSegment(index) {
    if (this.internalSelected !== index) {
      this.internalSelected = index;
      this.segmentSelect.emit(index);
    }
  }
  // Generates a data structure which is used to compute the offsets of all segments dependent on their position on the chart.
  generateDonutCreateData() {
    return this.chartInput.reduce((acc, input, i) => {
      const offset = i == 0
        ? 0
        : acc.segments[i - 1].offset + acc.segments[i - 1].input.value;
      return {
        segments: [
          ...acc.segments,
          {
            input,
            offset,
          },
        ],
        sum: acc.sum + input.value,
      };
    }, {
      segments: [],
      sum: 0,
    });
  }
  get getScaledOuterDiameter() {
    return this.getScaledOuterRadius() * 2;
  }
  getScaledOuterRadius() {
    const radius = 100;
    return radius + this.virtualScaledSegmentWidth * 0.5;
  }
  getSegmentMiddleDirectionFromOrigin(data, sumOfAllSegments, offset = 0) {
    const from = data.offset;
    const end = data.offset + data.input.value;
    const mean = (from + end) * 0.5 + offset;
    const middleAngle = (mean / sumOfAllSegments) * 360;
    return mathUtil.angleToDirection(middleAngle);
  }
  getSegmentEndDirectionFromOrigin(data, sumOfAllSegments) {
    const end = data.offset + data.input.value;
    const endAngle = (end / sumOfAllSegments) * 360;
    return mathUtil.angleToDirection(endAngle);
  }
  getColor(segment, selected) {
    const getColorPaletteName = () => {
      var _a;
      switch (this.colorscheme) {
        case "blue":
          return selected ? "blue-100" : "blue-60";
        case "gray":
          return selected ? "gray-66" : "gray-33";
        case "signal":
          const color = segment.input.color;
          if (["green", "orange", "red", "success", "warning", "error"].includes(color)) {
            const palette = {
              success: "green",
              warning: "orange",
              error: "red",
            };
            const paletteColor = (_a = palette[color]) !== null && _a !== void 0 ? _a : color;
            return selected ? `${paletteColor}-100` : `${paletteColor}-60`;
          }
          return selected ? "red-100" : "red-60";
        case "custom":
          return selected ? segment.input.selectedcolor : segment.input.color;
      }
    };
    return new colorPalette.ColorPalette(true).getColorCode(getColorPaletteName());
  }
  handlePointerEnter(e) {
    if (e.pointerType !== "mouse") {
      return;
    }
    window.addEventListener("mousemove", this.mouseMoveHandler);
  }
  handlePointerLeave(e) {
    if (e.pointerType !== "mouse") {
      return;
    }
    this.selectSegment(null);
    window.removeEventListener("mousemove", this.mouseMoveHandler);
  }
  handlePointerUp(e) {
    if (e.pointerType === "mouse") {
      return;
    }
    const selectedIndexOnCoordinate = this.getSegmentIndexOnCoordinate(e.clientX, e.clientY);
    const selectIndex = this.internalSelected === selectedIndexOnCoordinate
      ? null
      : selectedIndexOnCoordinate;
    this.selectSegment(selectIndex);
  }
  renderLineFromDirectionVector(origin, directionVector) {
    var _a;
    return (index.h("line", { x1: origin.x, y1: origin.y, x2: origin.x + directionVector.x, y2: origin.y + directionVector.y, "stroke-width": (_a = window.offsetValue) !== null && _a !== void 0 ? _a : 1, stroke: "black" }));
  }
  renderCircleSegment(data, sumOfAllSegments, selected) {
    var _a, _b;
    const value = (data.input.value * 100) / sumOfAllSegments;
    const dashArray = `${value} ${100 - value}`;
    const offset = (data.offset * 100) / sumOfAllSegments;
    const dashOffset = 25 - offset;
    return (index.h("circle", { class: "segment", cx: this.viewBoxSize * 0.5, cy: this.viewBoxSize * 0.5, r: "15.915", fill: "transparent", "stroke-dasharray": dashArray, "stroke-dashoffset": dashOffset, "stroke-width": selected
        ? (_a = window.selectedStrokeWidthValue) !== null && _a !== void 0 ? _a : "6.25"
        : (_b = window.strokeWidthValue) !== null && _b !== void 0 ? _b : "5", stroke: this.getColor(data, selected), mask: "url(#segment-offset)" }));
  }
  renderSegmentMask(createData) {
    const segments = createData.segments;
    return (index.h("mask", { id: "segment-offset" }, index.h("rect", { width: "100%", height: "100%", fill: "white" }), segments.map((segment) => {
      const directionToEnd = this.getSegmentEndDirectionFromOrigin(segment, createData.sum);
      const donutDiameter = this.donutRadius * 2;
      return this.renderLineFromDirectionVector(new mathUtil.Point(this.viewBoxSize * 0.5), new mathUtil.Point(directionToEnd.x * donutDiameter, directionToEnd.y * -donutDiameter));
    })));
  }
  renderLabelLine() {
    if (!this.showsegmentlabels) {
      return;
    }
    return index.h("line", { class: "label-line" });
  }
  renderCircleSegments(createData) {
    return [
      index.h("svg", { viewBox: `0 0 ${this.viewBoxSize} ${this.viewBoxSize}` }, index.h("defs", null, this.renderSegmentMask(createData)), createData.segments.map((segment, i) => this.renderCircleSegment(segment, createData.sum, (this.internalSelected == null && i === this.selected) ||
        i === this.internalSelected))),
      index.h("svg", { class: "label-svg" }, createData.segments.map(() => this.renderLabelLine())),
    ];
  }
  renderSegmentLabels(createData) {
    if (!this.showsegmentlabels) {
      return;
    }
    return createData.segments.map((segment) => {
      return (index.h("div", { class: "segment-label can-be-visible" }, segment.input.icon && (index.h("dx-icon", { color: "paragraph", icon: segment.input.icon })), index.h("dx-text", { color: "paragraph" }, segment.input.label)));
    });
  }
  renderLabels(createData) {
    var _a, _b;
    return (index.h("div", { class: "overlay" }, index.h("div", { class: "inner-labels" }, ((_a = this.label) === null || _a === void 0 ? void 0 : _a.length) > 0 ? (index.h("dx-text", { class: "label" }, this.label)) : null, ((_b = this.sublabel) === null || _b === void 0 ? void 0 : _b.length) > 0 ? (index.h("dx-text", { class: "sub-label" }, this.sublabel)) : null), this.renderSegmentLabels(createData)));
  }
  render() {
    const createData = this.generateDonutCreateData();
    return (index.h(index.Host, { style: {
        "user-select": "none",
      }, onContextMenu: () => false, onPointerEnter: (e) => this.handlePointerEnter(e), onPointerLeave: (e) => this.handlePointerLeave(e), onPointerUp: (e) => this.handlePointerUp(e) }, index.h("div", { class: "donut-container" }, this.renderCircleSegments(createData), this.renderLabels(createData))));
  }
  get self() { return index.getElement(this); }
  static get watchers() { return {
    "showsegmentlabels": ["onShowSegmentLabelsChanged"]
  }; }
};
function normalizeOffset(hasOffsetArray) {
  let offset = 0;
  let offsetOfLastIndexWasZero = hasOffsetArray[hasOffsetArray.length - 1].offset === 0;
  const isZero = (num) => Math.abs(num) < BIAS;
  return hasOffsetArray.map((hasOffset, index) => {
    var _a, _b;
    const offsetIsZero = isZero(hasOffset.offset);
    if (offsetOfLastIndexWasZero || offsetIsZero) {
      const rest = hasOffsetArray.slice(index + 1);
      const indexOfNextZero = rest.findIndex((value) => isZero(value.offset));
      const restIndex = indexOfNextZero === -1 ? rest.length : indexOfNextZero;
      offset = (_b = (_a = rest[restIndex - 1]) === null || _a === void 0 ? void 0 : _a.offset) !== null && _b !== void 0 ? _b : 0;
    }
    offsetOfLastIndexWasZero = offsetIsZero;
    return Object.assign(Object.assign({}, hasOffset), { offset: hasOffset.offset - offset * 0.5 });
  });
}
function getFactor(num, exp) {
  return Math.pow(1.01 - num, exp);
}
function computeDistanceAndOffsetBetweenSegments(segment, lastDistance, fractionOfCurrentSegment, fractionOfLastSegment, breakpointFactor, viewportFactor) {
  const currentDistance = breakpointFactor *
    computeDistanceBetweenSegments(segment.input.icon ? 1.3333 : 0.75, fractionOfCurrentSegment, fractionOfLastSegment);
  const distanceFactor = getFactor(fractionOfCurrentSegment, 10) * 2;
  const distance = lastDistance * (fractionOfCurrentSegment >= 0.1 ? distanceFactor : 1) +
    currentDistance;
  const offset = fractionOfLastSegment < 0.1 || lastDistance > 0
    ? distance * viewportFactor
    : 0;
  return { distance, offset };
}
function computeDistanceBetweenSegments(differenceFactor, fractionOfCurrentSegment, fractionOfLastSegment) {
  const factorCurrentSegment = getFactor(fractionOfCurrentSegment, 20);
  const factorLastSegment = getFactor(fractionOfLastSegment, 20);
  const differenceBetweenFractions = Math.abs(fractionOfCurrentSegment - fractionOfLastSegment);
  const differenceComplement = 1 - differenceBetweenFractions;
  return Math.pow(differenceComplement * factorCurrentSegment * factorLastSegment, Math.min(4 / differenceFactor + differenceBetweenFractions * 100, 10));
}
const BIAS = 0.0001;
DxDonutChart.style = dxDonutChartCss;

exports.dx_donut_chart = DxDonutChart;
