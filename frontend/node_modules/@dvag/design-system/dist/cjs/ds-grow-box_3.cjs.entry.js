'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const index = require('./index-2f41386b.js');

const dsGrowBoxCss = ":host{display:block;overflow:hidden;transition:height 400ms ease-in-out}:host:host([hidden]){display:none !important}:host:host(.animate-on-init){height:0}:host:host(.slide-content){display:flex;flex-direction:column-reverse}:host:host(:not(.content-is-visible)){visibility:hidden !important}";

const DsGrowBox = class {
  constructor(hostRef) {
    index.registerInstance(this, hostRef);
    this.growboxGrowStart = index.createEvent(this, "growboxGrowStart", 7);
    this.growStart = index.createEvent(this, "growStart", 7);
    this.contentVisibilityChange = index.createEvent(this, "contentVisibilityChange", 7);
    this.lastScrollHeight = null;
    this.isInTransition = false;
    this.childGrowboxIsGrowing = false;
    /**
     * Gibt an, ob die Box offen oder geschlossen sein soll. Wenn dieser Wert geändert wird, animiert die Box automatisch
     * auf die entsprechende Höhe.
     *
     * @value true: Die Box animiert seine Höhe auf die Höhe seiner Kind-Elemente.
     * @value false: Die Box animiert seine Höhe auf den Wert 0.
     *
     * @example open
     */
    this.open = true;
    /**
     * Gibt an, ob die Kind-Elemente mitgeschoben werden, wenn sich die Box öffnet oder schließt.
     *
     * @value true: Die Kind-Elemente werden nach oben bzw. unten geschoben, wenn sich der `open`-State der Box verändert.
     * @value false: Die Kind-Elemente bleiben immer an Ort und Stelle.
     *
     * @example slide-content
     */
    this.slidecontent = true;
    /**
     * Gibt an, ob nach dem Initialisieren der Box bereits animiert werden soll.
     *
     * @value true: Sofern das `open`-Attribute den Wert `true` hat, animiert die Box auf seine berechnete Höhe.
     * @value false: Beim Initialisieren der Box wird keine Animation stattfinden.
     *
     * @example animate-on-init
     */
    this.animateoninit = true;
  }
  onContentVisibilityChange(event) {
    if (event.target === this.self) {
      this.contentIsVisible = event.detail;
    }
    else {
      /// stop events contentVisiblityChange events from child growboxes
      event.stopPropagation();
      event.stopImmediatePropagation();
    }
  }
  onChildGrowboxGrowStart(event) {
    // only listen to child growboxes
    if (event.target !== this.self) {
      this.checkHeight();
      if (!this.isInTransition) {
        this.childGrowboxIsGrowing = true;
        // we need to suppress any 'slide content' effect while a child is animating, because it looks strange
        clearTimeout(this.suppressSlideContentTimeoutHandle);
        this.suppressSlideContentTimeoutHandle = setTimeout(() => (this.childGrowboxIsGrowing = false), event.detail + 200);
      }
    }
  }
  componentWillLoad() {
    this.contentIsVisible = this.open;
  }
  handleTransitionStart() {
    this.isInTransition = true;
  }
  handleTransitionEnd(event) {
    this.isInTransition = false;
    if (event.target === this.self && !this.open) {
      this.contentVisibilityChange.emit(false);
    }
  }
  contentElementCreated(contentElement) {
    var _a;
    if (this.contentElement === contentElement) {
      this.checkHeight();
      return;
    }
    this.contentElement = contentElement;
    (_a = this.resizeObserver) === null || _a === void 0 ? void 0 : _a.disconnect();
    this.resizeObserver = new ResizeObserver(() => {
      // Fix for DS-703: ResizeObserver loop limit exceeded error is thrown in chrome-headless mode of angular tests
      requestAnimationFrame(() => {
        this.checkHeight();
      });
    });
    this.resizeObserver.observe(this.contentElement);
  }
  // Checks the required height of the slotted element and initiates a transition
  checkHeight() {
    var _a;
    const scrollHeight = this.getHeightOfContent();
    if (this.lastScrollHeight === null ||
      this.lastScrollHeight !== scrollHeight) {
      const deltaPixel = Math.abs(scrollHeight - ((_a = this.lastScrollHeight) !== null && _a !== void 0 ? _a : 0));
      const duration = Math.min(Math.max(150, Math.round(deltaPixel * 1.5)), 600);
      this.self.style.transitionDuration = this.childGrowboxIsGrowing
        ? "0ms"
        : `${duration}ms`;
      this.self.style.height = `${scrollHeight}px`;
      this.growboxGrowStart.emit(duration);
      if (this.lastScrollHeight === 0 && scrollHeight !== 0) {
        this.contentVisibilityChange.emit(true);
      }
      this.lastScrollHeight = scrollHeight;
    }
  }
  getHeightOfContent() {
    var _a, _b;
    if (!this.open) {
      return 0;
    }
    return (_b = (_a = this.contentElement) === null || _a === void 0 ? void 0 : _a.scrollHeight) !== null && _b !== void 0 ? _b : 0;
  }
  render() {
    return (index.h(index.Host, { class: {
        "animate-on-init": this.animateoninit,
        "slide-content": this.slidecontent && !this.childGrowboxIsGrowing,
        "content-is-visible": this.contentIsVisible,
      }, onTransitionStart: () => this.handleTransitionStart(), onTransitionEnd: (event) => this.handleTransitionEnd(event) }, index.h("div", { ref: (el) => this.contentElementCreated(el) }, index.h("slot", null))));
  }
  get self() { return index.getElement(this); }
};
DsGrowBox.style = dsGrowBoxCss;

const kiSyncIcon = () => (index.h("svg", { width: "32px", height: "16px", viewBox: "0 0 32 16", version: "1.1" },
  index.h("title", null, "Sync"),
  index.h("g", { id: "Eingabefelder", stroke: "none", "stroke-width": "1", fill: "none", "fill-rule": "evenodd" },
    index.h("g", { id: "Input", transform: "translate(-925.000000, -1689.000000)", fill: "#C1C1C1" },
      index.h("g", { id: "Input-mit-Icon", transform: "translate(174.000000, 1357.000000)" },
        index.h("g", { id: "Input/Default", transform: "translate(509.000000, 332.000000)" },
          index.h("g", { id: "Sync", transform: "translate(242.000000, 0.000000)" },
            index.h("path", { d: "M2.816,13 L2.816,10.12 L4.04,8.908 L6.848,13 L8.72,13 L5.06,7.852 L8.48,4.432 L6.632,4.432 L2.816,8.332 L2.816,4.432 L1.316,4.432 L1.316,13 L2.816,13 Z M11.056,13 L11.056,4.432 L9.556,4.432 L9.556,13 L11.056,13 Z", id: "KI", "fill-rule": "nonzero" }),
            index.h("g", { id: "Group", transform: "translate(16.000000, 0.000000)" },
              index.h("g", { id: "16px/Sortieren", transform: "translate(8.000000, 8.000000) rotate(90.000000) translate(-8.000000, -8.000000) " },
                index.h("path", { d: "M11.95,0.922000032 C12.3642136,0.922000032 12.7,1.25778645 12.7,1.672 L12.7,1.672 L12.7,12.518 L13.748,11.47 C13.8886661,11.3292437 14.0795044,11.2501601 14.2785,11.2501601 C14.4774956,11.2501601 14.6683339,11.3292437 14.809,11.47 C14.9496955,11.6104953 15.0287543,11.801168 15.0287543,12 C15.0287543,12.198832 14.9496955,12.3895047 14.809,12.53 L14.809,12.53 L12.48,14.858 C12.3396356,14.9989416 12.1489138,15.0781705 11.95,15.0781705 C11.7510862,15.0781705 11.5603644,14.9989416 11.42,14.858 L11.42,14.858 L9.092,12.53 C8.81664114,12.2344902 8.82476612,11.7739903 9.1103782,11.4883782 C9.39599028,11.2027661 9.85649025,11.1946411 10.152,11.47 L10.152,11.47 L11.2,12.518 L11.2,1.672 C11.2,1.25778645 11.5357864,0.922000032 11.95,0.922000032 Z M4.05,0.92224569 C4.24883198,0.92224569 4.43950471,1.00130447 4.58,1.142 L4.58,1.142 L6.908,3.47 C7.18335886,3.76550975 7.17523388,4.22600972 6.8896218,4.5116218 C6.60400972,4.79723388 6.14350975,4.80535886 5.848,4.53 L5.848,4.53 L4.8,3.482 L4.8,14.328 C4.8,14.7422136 4.46421356,15.078 4.05,15.078 C3.63578644,15.078 3.3,14.7422136 3.3,14.328 L3.3,14.328 L3.3,3.482 L2.252,4.53 C1.95785035,4.81437105 1.49006646,4.8105282 1.20062843,4.52136296 C0.911190394,4.23219772 0.906906443,3.76441767 1.191,3.47 L1.191,3.47 L3.52,1.142 C3.66049529,1.00130447 3.85116802,0.92224569 4.05,0.92224569 Z", id: "Combined-Shape" }))))))))));

const dsInputLabelCss = ":host{display:none;padding:0 0 6px 8px;--ds-text-font-size:12px;--ds-text-letter-spacing:0.02px;--ds-text-font-weight:500;--ds-text-line-height:16px;color:#666666;overflow:hidden;white-space:nowrap;text-overflow:ellipsis}:host:host([hidden]){display:none !important}:host .disabled{color:#c1c1c1}:host .label-icon-container{margin-right:8px;display:flex;justify-content:space-between}:host .label-icon-container ds-icon{margin-left:8px}:host .label-icon-container ds-text{overflow:hidden;text-overflow:ellipsis}:host .label-icon-container.with-icon{align-items:center}:host .label-icon-container.ki-synced svg{flex-shrink:0;margin-left:8px}:host .label-icon-container.align-right{justify-content:flex-end;margin-right:0}:host .label-icon-container.align-right .non-clickable-container{flex:0}:host .label-icon-container .non-clickable-container{flex:1}:host(.visible){display:block}";

const DsInputLabel = class {
  constructor(hostRef) {
    index.registerInstance(this, hostRef);
    /**
     * If the label should be in an disabled state.
     */
    this.disabled = false;
    /**
     * Aligns the label to the right. USed for ds-date-input
     */
    this.alignRight = false;
  }
  render() {
    var _a;
    return (index.h(index.Host, { class: { visible: ((_a = this.label) === null || _a === void 0 ? void 0 : _a.length) > 0 || this.kisynced } }, index.h("div", { class: { "label-icon-container": true, "ki-synced": this.kisynced, "align-right": this.alignRight } }, index.h("ds-text", { class: { disabled: this.disabled } }, this.label), index.h("div", { class: "non-clickable-container", onClick: (e) => {
        e.preventDefault();
      } }), this.renderSyncIcon())));
  }
  renderSyncIcon() {
    if (this.kisynced) {
      return kiSyncIcon();
    }
    return null;
  }
};
DsInputLabel.style = dsInputLabelCss;

const dsRequiredHintCss = ":host{display:var(--ds-show-required-hint, block)}:host:host([hidden]){display:none !important}:host .animation-container .hint-container{display:flex;width:100%;box-sizing:border-box;flex-direction:column-reverse;align-items:flex-end;justify-content:end;padding-right:8px;padding-top:4px;opacity:1;transition:opacity 150ms ease-in-out}:host .animation-container .hint-container .hint{display:flex;align-items:center}:host .animation-container .hint-container .hint ds-icon{margin-right:5px}:host .animation-container .hint-container.fulfilled{opacity:0}";

const DsRequiredHint = class {
  constructor(hostRef) {
    index.registerInstance(this, hostRef);
    this.fulfilled = false;
  }
  render() {
    if (!this.required) {
      return;
    }
    return (index.h(index.Host, null, index.h("ds-grow-box", { open: !this.fulfilled, animateoninit: false, class: "animation-container" }, index.h("div", { class: {
        "hint-container": true,
        fulfilled: this.fulfilled,
      } }, index.h("div", { class: "hint" }, index.h("ds-icon", { icon: "achtung-circle", size: 16, color: "gelb-1" }), index.h("ds-text", { type: "itk" }, "Pflichtfeld"))))));
  }
};
DsRequiredHint.style = dsRequiredHintCss;

exports.ds_grow_box = DsGrowBox;
exports.ds_input_label = DsInputLabel;
exports.ds_required_hint = DsRequiredHint;
