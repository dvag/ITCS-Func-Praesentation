'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const index = require('./index-2f41386b.js');
const assert = require('./assert-d8ea75c6.js');
const compareObjects = require('./compare-objects-1e161956.js');
const elementIdHandling = require('./element-id-handling-89898a1c.js');
const error = require('./error-e6134abb.js');
const miscUtil = require('./misc-util-63b423bd.js');
const queryUtil = require('./query-util-8642f149.js');
const renderUtil = require('./render-util-6b278c0d.js');
const slotObserver = require('./slot-observer-2e83212e.js');
const value = require('./value-1f8d9874.js');
const baseElements = require('./base-elements-f50ffdf3.js');
const inputContainer = require('./input-container-97007eba.js');
const mathUtil = require('./math-util-a514efc6.js');
const event_util = require('./event.util-7f75b6a8.js');
require('./value-store-f683b26f.js');

const dxDropdownCss = ":host{min-width:0;-webkit-tap-highlight-color:transparent;display:block;min-width:0}:host:host([hidden]){display:none !important}:host:host(.disabled){pointer-events:none}:host:host(.disabled:not(.nested-form-element)){opacity:0.4}:host .input{outline:none;cursor:pointer}:host .input.disabled{cursor:default;pointer-events:none}:host .input dx-list-item[type=default]{cursor:default}:host .input .container.size-s{position:relative;top:0;left:0;display:flex;height:40px;padding:8px 16px 8px 16px;--dx-info-button-offset-y:0px;box-sizing:border-box;border:1px solid #d6d6d6;border-bottom:var(--dx-container-border-bottom, 1px solid #d6d6d6);background-color:#ffffff;align-items:center;--dx-icon-color:#337a96}:host .input .container.size-s.error{border-color:#9d2235;background-color:#f5e9eb}:host .input .container.size-s.error input,:host .input .container.size-s.error textarea{background:transparent}:host .input .container.size-s.active{border-color:#004763;--dx-text-color:#004763;--dx-icon-color:#004763}:host .input .container.size-m{position:relative;top:0;left:0;display:flex;height:48px;padding:10px 16px 10px 16px;box-sizing:border-box;border:1px solid #d6d6d6;border-bottom:var(--dx-container-border-bottom, 1px solid #d6d6d6);background-color:#ffffff;align-items:center;--dx-icon-color:#337a96}:host .input .container.size-m.error{border-color:#9d2235;background-color:#f5e9eb}:host .input .container.size-m.error input,:host .input .container.size-m.error textarea{background:transparent}:host .input .container.size-m.active{border-color:#004763;--dx-text-color:#004763;--dx-icon-color:#004763}:host .input .container select{position:absolute;width:100%;left:0;top:0;pointer-events:none;opacity:0}:host .input .container .current-value{flex:1;overflow:hidden;user-select:none;--dx-text-font-weight:var(--dx-dropdown-selected-font-weight, 500)}:host .input .container .current-value .item{display:flex;align-items:center;--dx-text-color:#2b2b2b;--dx-icon-color:#337a96}:host .input .container .current-value .item dx-icon{margin-right:16px;flex-shrink:0}:host .input .container .current-value .item dx-text{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}:host .input .container .current-value .item.is-placeholder{--dx-text-color:#337a96}:host .input .container .current-value .item .label.align-right{margin-left:auto}:host .input .container.active .current-value .item{--dx-text-color:#004763}:host .input .container .open-list-button{margin-left:16px;width:24px;height:24px;pointer-events:none}:host .input .respect-label-height{--dx-overlay-offset:-24}@media (min-width: 1280px){:host .input .respect-label-height{--dx-overlay-offset:-28}}:host .else-option-input-container{margin-top:16px}:host .else-option-button{width:100%;pointer-events:all}";

const DxDropdown = class {
  constructor(hostRef) {
    index.registerInstance(this, hostRef);
    this.valueChange = index.createEvent(this, "valueChange", 7);
    this.valueComplete = index.createEvent(this, "valueComplete", 7);
    this.lastEmittedChangeValue = null;
    this.lastEmittedCompleteValue = null;
    this.preventReFocus = false;
    this.selectScanningEnabled = true;
    this.options = [];
    this.inputFocused = false;
    this.listOpen = false;
    this.internalValue = null;
    /**
     * The size of the dropdown.
     *
     * @value s: A small dropdown is displayed.
     * @value m: A medium sized dropdown is displayed.
     */
    this.size = "m";
    /**
     * Whether the selection is readonly or editable.
     * If true the value of this component will be visualized as a normal text.
     * @value false: Input is editable.
     * @value true: Input is read-only.
     *
     * @example readonly
     */
    this.readonly = false;
    /**
     * Marks this input field as a required form element.
     * @value false: Not required
     * @value true: It is necessary to select an option to fulfill the requirement.
     * @example required
     */
    this.required = false;
    /**
     * Indicates that the form is synced with the KI.
     * @value true: Synchronized.
     * @value false: Not synchronized.
     * @example kisynced
     */
    this.kisynced = false;
    /**
     * Placeholder text which is displayed when no option is currently selected.
     * @value string: Placeholder text
     * @example placeholder
     */
    this.placeholder = "Bitte ausw√§hlen ...";
    /**
     * The current value of this element. It represents the `value` property of the current selected `<dx-dropdown-option>` or null.
     * Other by selecting an option with the mouse or keyboard, it is possible to set this property programmatically.
     *
     * @important
     * @value string: The string value of the selected option.
     * @value object: The value of the selected option in case it's a complex type.
     * @value null: No option selected.
     * @example value
     */
    this.value = null;
    /**
     * Defines the text alignment.
     * @value left: Text is left aligned.
     * @value right: Text is right aligned.
     * @example text-align
     */
    this.textalign = "left";
    /**
     * Defines the position of the dropdown list.
     * @value top: The list is displayed at the top of the input field.
     * @value bottom: The list is displayed at the bottom of the input field.
     * @example popup-position
     */
    this.popupposition = "bottom";
    /**
     * Whether it is possible to select an option which is not present in the current option list.
     *
     * @value false: The user can only select an option in the list.
     * @value true: The user is able to set a value which is not present in the option list by editing a text field under
     * the selection input field.
     * @example elseoption
     */
    this.elseoption = false;
    /**
     * The label of the button which activates the `elseoption` input field. The `elseoption` property has to be `true`.
     * @value string: Button label
     * @example elseoption
     */
    this.elseoptionbuttonlabel = "Sonstige Eingabe";
    /**
     * The label of the text input field which represents the `elseoption`. The `elseoption` property has to be `true`.
     * @value string: Text input label.
     * @example elseoption
     */
    this.elseoptioninputlabel = "Sonstige Eingabe";
    /**
     * Determines if the else-option input field is visible to the user. This property automatically changes
     * on user interaction or providing a value that doesn't match any dropdown options.
     * @value false: Else-option input field is not displayed.
     * @value true: Else-option input field is displayed.
     * @example elseoption-selected
     */
    this.elseoptionselected = false;
    /**
     * Defines whether the dropdown is enabled or not.
     * @value true: Dropdown is not editable.
     * @value false: Dropdown is editable.
     * @example disabled
     */
    this.disabled = false;
  }
  valueChanged() {
    this.obtainValueChangesFromOutside();
  }
  componentWillLoad() {
    elementIdHandling.verifyElementId(this.self);
    this.obtainValueChangesFromOutside(true);
    this.internalPopupPosition = this.popupposition;
  }
  connectedCallback() {
    this.optionsObserver =
      slotObserver.createMetaComponentsSlotObserver(this.self, "dx-dropdown-option", async (nodes) => {
        await this.collectOptions(nodes);
        this.findSelectedOption();
        const duplicates = value.findDuplicatedValues(this.options.filter((option) => !option.isSeparator));
        assert.assert(duplicates.length == 0, () => `It is not allowed for multiple 'dx-dropdown-option' elements to share the same value!\nFollowing duplicated value were found: ${duplicates.join()}`, this.self);
      });
  }
  disconnectedCallback() {
    var _a;
    (_a = this.optionsObserver) === null || _a === void 0 ? void 0 : _a.disconnect();
  }
  onForceUpdateOnChange(e) {
    e.detail(this.self);
  }
  /**
   * Sets the focus on this element.
   *
   * @example focus
   */
  async focusControl() {
    this.inputElement.focus();
  }
  /**
   * If the value changed from outside we need to check what option to use.
   * Possible cases can be:
   * - Setting value attribute
   * - Set of possible <dx-dropdown-option> changed
   * - Native <select> supervise detected a value change
   */
  findSelectedOption() {
    if (this.self.querySelectorAll(queryUtil.notHidden("dx-dropdown-option")).length !==
      this.options.length) {
      return; // can't decide now, cause not all option nodes are initialized
    }
    const optionMatchingValue = this.options.find((option) => option.value === this.value);
    if (!this.elseoptionselected && optionMatchingValue != null) {
      // Is there an option matching the value and our internal selectedOption is unset or set to a different option?
      if (this.selectedOption == null ||
        !compareObjects.compareObjectsEqual(optionMatchingValue, this.selectedOption)) {
        this.selectedOption = optionMatchingValue;
      }
    }
    else if (this.elseoption && this.internalValue !== null) {
      // Is elseoption enabled and therefore we don't need to match an option and use the value as elseoption value?
      this.elseoptionselected = true;
      this.selectedOption = null;
    }
    else {
      // We couldn't figure out an existing option => no option set
      this.selectedOption = null;
      this.elseoptionselected = false;
    }
  }
  async collectOptions(nodes) {
    const previousOptions = this.options;
    this.options = await Promise.all(nodes.map((node) => {
      return node.toOption();
    }));
    if (this.options.length > 0 && previousOptions.length > 0) {
      this.findSelectedOption();
    }
  }
  // Always keep internalValue in sync with nativeSelect value. Otherwise there could be a race condition where a selection fails.
  updateInternalValue(newValue) {
    this.internalValue = newValue;
    if (this.nativeSelect) {
      index.writeTask(() => {
        this.nativeSelect.value = JSON.stringify(this.internalValue);
      });
    }
  }
  obtainValueChangesFromOutside(force = false) {
    this.sanitizeValue();
    if (force || this.value !== this.internalValue) {
      this.updateInternalValue(this.value);
      this.lastEmittedChangeValue = this.value;
      this.lastEmittedCompleteValue = this.value;
      this.findSelectedOption();
    }
  }
  sanitizeValue() {
    if (this.value === undefined || this.value === NULL_STRING) {
      this.value = null;
    }
  }
  onInputFocused() {
    this.inputFocused = true;
  }
  onInputBlurred() {
    renderUtil.onNextFrame(() => {
      if (this.preventReFocus || !miscUtil.isActiveElement(this.self)) {
        this.inputFocused = false;
        this.setOpenListStatus(false);
        this.emitValueChange();
        this.emitValueComplete();
      }
      else {
        this.inputElement.focus();
      }
      this.preventReFocus = false;
    });
  }
  toggleList() {
    this.setOpenListStatus(!this.listOpen);
  }
  onInputKeyUp(event) {
    if (["Enter", "Escape"].includes(event.code)) {
      this.setOpenListStatus(false);
      this.emitValueComplete();
    }
  }
  /**
   * Delegates keyboard events to the underlying list element.
   * The list element itself cannot receive keyboard events because it has a tabIndex of -1.
   */
  onInputKeyDown(event) {
    const listFlyoutElement = this.self.shadowRoot.querySelector("dx-list-flyout");
    if (event.target === listFlyoutElement) {
      return;
    }
    if (["ArrowDown", "ArrowUp", "Space"].includes(event.code)) {
      event.preventDefault();
    }
    if (this.listOpen) {
      listFlyoutElement === null || listFlyoutElement === void 0 ? void 0 : listFlyoutElement.dispatchEvent(new event.constructor(event.type, event));
    }
    else if (["ArrowDown", "ArrowUp", "Space"].includes(event.code)) {
      this.setOpenListStatus(true);
    }
  }
  onInputClicked() {
    if (!this.disabled) {
      this.toggleList();
    }
  }
  setOpenListStatus(isOpen) {
    this.listOpen = isOpen;
    if (this.listOpen) {
      this.inputElement.focus();
    }
  }
  /**
   * Used by the hidden native <select> to react to changes.
   */
  selectOptionsByValue(text) {
    if (text === NULL_STRING || text === "") {
      if (this.internalValue !== null) {
        this.selectedOption = null;
        this.updateInternalValue(null);
        this.emitValueChange();
      }
    }
    else {
      const optionWithValueMatchingText = this.options.find((option) => JSON.stringify(option.value) === text);
      if (optionWithValueMatchingText != null) {
        this.selectedOption = optionWithValueMatchingText;
        this.updateInternalValue(this.selectedOption.value);
        this.elseoptionselected = false;
        this.emitValueChange();
      }
      else {
        this.updateInternalValue(this.internalValue);
      }
    }
  }
  requestElseOption() {
    this.elseoptionselected = true;
    this.selectedOption = null;
    this.updateInternalValue("");
    renderUtil.onNextFrame(() => {
      var _a;
      (_a = this.elseOptionInput) === null || _a === void 0 ? void 0 : _a.focusControl();
    });
  }
  selectValueFromElseOption(value) {
    this.updateInternalValue(value);
    this.emitValueChange();
  }
  emitValueChange() {
    this.value = this.internalValue;
    if (this.lastEmittedChangeValue !== this.value) {
      this.valueChange.emit(this.value);
      this.lastEmittedChangeValue = this.value;
    }
  }
  emitValueComplete() {
    if (this.lastEmittedCompleteValue !== this.value) {
      this.valueComplete.emit(this.value);
      this.lastEmittedCompleteValue = this.value;
    }
  }
  selectOption(option) {
    this.selectedOption = option;
    this.elseoptionselected = false;
    this.updateInternalValue(this.selectedOption.value);
    this.emitValueChange();
  }
  superviseSelectElement(el) {
    index.readTask(() => {
      this.nativeSelect = el;
      // When the value of the select changes we want to run the code below
      miscUtil.hookToUpdateProperty(el, "value", () => {
        var _a;
        const areAllOptionsScanned = () => el.querySelectorAll("option").length >= this.options.length + 1;
        if (!this.elseoptionselected &&
          this.selectScanningEnabled &&
          !this.readonly &&
          JSON.stringify((_a = this.internalValue) !== null && _a !== void 0 ? _a : "null") !== el.value &&
          areAllOptionsScanned()) {
          this.selectOptionsByValue(el.value);
        }
      });
    });
  }
  onItemSelectionChanged(e) {
    const option = this.options.find((option) => { var _a, _b; return option.value === ((_b = (_a = e.detail) === null || _a === void 0 ? void 0 : _a.selectedItems) === null || _b === void 0 ? void 0 : _b[0]); });
    this.selectOption(option);
  }
  onPopupPositionChanged(e) {
    this.internalPopupPosition = e.detail;
  }
  isChevronRotated() {
    // If list is open rotate chevron icon
    let rotated = this.listOpen;
    // If popupposition is at the top, invert current rotation
    if (this.internalPopupPosition === "top") {
      rotated = !rotated;
    }
    return rotated;
  }
  format(str) {
    var _a, _b;
    return (_b = (_a = this.formatter) === null || _a === void 0 ? void 0 : _a.call(this, str)) !== null && _b !== void 0 ? _b : str;
  }
  renderErrorMessage() {
    if (this.elseoptionselected) {
      return;
    }
    return (index.h(error.ErrorMessage, { self: this.self, message: this.errormessage, custom: {
        onFocus: () => {
          this.preventReFocus = true;
        },
        onBlur: () => {
          this.preventReFocus = false;
        },
      } }));
  }
  render() {
    var _a, _b, _c, _d;
    if (this.readonly) {
      return (index.h(baseElements.ReadonlyTextElement, { text: (_b = (_a = this.selectedOption) === null || _a === void 0 ? void 0 : _a.label) !== null && _b !== void 0 ? _b : "", label: this.label }));
    }
    return (index.h(index.Host, { class: {
        disabled: this.disabled,
      } }, " ", index.h("div", { class: {
        input: true,
        "size-s": this.size === "s",
        "size-m": this.size === "m",
      }, ref: (el) => (this.inputElement = el), id: elementIdHandling.ElementIdGenerator.createId(this.self, "user-interaction"), tabIndex: this.disabled ? -1 : 0, onKeyDown: (event) => this.onInputKeyDown(event), onKeyUp: (event) => this.onInputKeyUp(event), onFocus: () => this.onInputFocused(), onBlur: () => this.onInputBlurred(), onClick: () => this.onInputClicked() }, index.h("dx-list-flyout", { open: this.listOpen, position: this.popupposition, direction: this.textalign === "left" ? "right" : "left", itemsvisible: 5.5, size: "m", selectionmode: "single", class: {
        "respect-label-height": ((_c = this.label) === null || _c === void 0 ? void 0 : _c.length) > 0,
      } }, index.h(inputContainer.LabeledInputContainer, { slot: "base", containerProperties: {
        active: this.inputFocused,
        size: this.size,
        error: error.hasError(this.self),
        title: (_d = this.selectedOption) === null || _d === void 0 ? void 0 : _d.label,
      }, labelProperties: {
        label: this.label,
        disabled: this.disabled,
        required: this.required,
        kisynced: this.kisynced,
      } }, this.renderNativeSelect(), this.renderCurrentValue(), this.renderOpenListButton()), this.renderItemList())), this.renderErrorMessage(), this.renderElseOptionInput()));
  }
  renderNativeSelect() {
    // The native select can be used for test automation tools to
    // change and read values from the select box.
    let nativeOptions = [
      { label: "-", value: NULL_STRING, icon: null, selected: true },
      ...this.options,
    ];
    if (this.elseoptionselected) {
      nativeOptions = [
        {
          label: this.elseoptionbuttonlabel,
          value: "$$$ELSEOPTION$$$",
          icon: null,
          selected: true,
        },
        ...nativeOptions,
      ];
    }
    return (index.h("select", { id: elementIdHandling.ElementIdGenerator.createId(this.self, "control"), ref: (el) => {
        this.superviseSelectElement(el);
      }, tabIndex: -1, onChange: (e) => {
        const value = e.target.value;
        this.selectOptionsByValue(value);
      } }, nativeOptions.map((option) => {
      return (index.h("option", { selected: option.value === this.internalValue ||
          (this.internalValue === null && option.value === NULL_STRING), value: JSON.stringify(option.value) }, option.label));
    })));
  }
  renderOpenListButton() {
    return (index.h("div", { id: elementIdHandling.ElementIdGenerator.createId(this.self, "open-list-button"), class: {
        "open-list-button": true,
      } }, index.h("dx-chevron", { directiontop: this.isChevronRotated(), active: this.inputFocused })));
  }
  renderItemList() {
    return [
      ...this.options.map((option, index$1) => {
        return (index.h("dx-list-item", { id: elementIdHandling.ElementIdGenerator.createId(this.self, `list-item-${index$1}`), type: option.isSeparator ? "default" : "selectable", value: option.value, label: option.label, icon: option.icon, textalign: this.textalign, selected: this.selectedOption === option }));
      }),
      this.renderElseOptionButton(),
    ];
  }
  renderElseOptionButton() {
    if (!this.elseoption || this.elseoptionselected) {
      return;
    }
    return (index.h("dx-button", { class: "else-option-button", id: elementIdHandling.ElementIdGenerator.createId(this.self, "else-option-button"), slot: "below", onClick: () => this.requestElseOption(), type: "primary-m", label: this.elseoptionbuttonlabel, stretch: true }));
  }
  renderOption(option, interactive = true, isPlaceholder = false, format = false) {
    var _a;
    return (index.h("div", { id: !isPlaceholder
        ? elementIdHandling.ElementIdGenerator.createId(this.self, `item-list-value-${option.value}`)
        : undefined, class: {
        item: true,
        "is-placeholder": isPlaceholder,
        right: this.textalign == "right",
        selected: option.value == ((_a = this.selectedOption) === null || _a === void 0 ? void 0 : _a.value),
        disabled: this.disabled === true,
      }, onClick: () => {
        if (interactive) {
          this.selectOption(option);
          this.inputElement.blur();
        }
      } }, option.icon != null ? index.h("dx-icon", { size: 24, icon: option.icon }) : null, index.h("dx-text", { key: option.label, class: { label: true, "align-right": this.textalign === "right" } }, format ? this.format(option.label) : option.label)));
  }
  renderCurrentValue() {
    const className = "current-value";
    if (this.elseoptionselected) {
      return (index.h("div", { class: className }, this.renderOption({
        label: this.elseoptionbuttonlabel,
        value: "",
        icon: null,
        selected: false,
      }, false)));
    }
    if (this.selectedOption != null) {
      return (index.h("div", { class: className }, this.renderOption(this.selectedOption, false, false, true)));
    }
    return (index.h("div", { class: className }, this.renderOption({
      label: this.placeholder,
      icon: this.icon,
      value: "",
      selected: false,
    }, false, true)));
  }
  renderElseOptionInput() {
    if (!this.elseoptionselected) {
      return;
    }
    return (index.h("div", { class: "else-option-input-container" }, index.h("dx-text-input", { class: "nested-form-element", ref: (ref) => {
        this.elseOptionInput = ref;
        if (ref != null) {
          index.forceUpdate(ref);
        }
      }, id: elementIdHandling.ElementIdGenerator.createId(this.self, "else-option-input"), label: this.elseoptioninputlabel, value: this.internalValue, disabled: this.disabled, required: this.required, errormessage: this.errormessage, onFocus: () => {
        this.selectScanningEnabled = false;
        this.preventReFocus = true;
      }, onBlur: () => {
        this.selectScanningEnabled = true;
        this.preventReFocus = false;
      }, onValueChange: (event) => {
        this.selectValueFromElseOption(event.detail);
        event.stopPropagation();
      } }, index.h("slot", { name: "error-message", slot: "error-message" }))));
  }
  get self() { return index.getElement(this); }
  static get watchers() { return {
    "value": ["valueChanged"]
  }; }
};
const NULL_STRING = "null";
DxDropdown.style = dxDropdownCss;

const DxDropdownOption = class {
  constructor(hostRef) {
    index.registerInstance(this, hostRef);
  }
  /**
   * @internal
   * Extracts this element's properties into a complex javascript object.
   */
  async toOption() {
    var _a;
    assert.assert(typeof this.value !== "number", () => `<dx-dropdown-option> Property 'value' must not be of type 'number'.`);
    return {
      icon: this.icon,
      value: (_a = this.value) !== null && _a !== void 0 ? _a : this.label,
      label: this.label,
      selected: this.selected,
      isSeparator: this.isseparator,
    };
  }
};

const dxNumberPaginatorPageButtonCss = ":host{display:inline-flex;flex-direction:column;text-align:center;width:40px;height:40px}:host:host([hidden]){display:none !important}:host dx-list-flyout{width:100px}:host .button{width:var(--dx-button-width, fit-content);width:var(--dx-button-width, -moz-fit-content);cursor:pointer;display:inline-flex;justify-content:center;align-items:center;box-sizing:border-box;white-space:nowrap;user-select:none;-webkit-user-select:none;border:none;margin:0;background-color:transparent;transition:background-color 150ms ease-in-out, border-color 150ms ease-in-out;background-color:rgba(0, 88, 124, 0);border-color:#337a96;--dx-text-color:#337a96;--dx-icon-color:#337a96;width:40px;height:40px;--dx-text-color:#808080}:host .button[disabled]{cursor:unset}@media not all and (pointer: coarse){:host .button:hover{background-color:rgba(0, 88, 124, 0.1);border-color:#00587c;--dx-text-color:#00587c;--dx-icon-color:#00587c}}:host .button:active{background-color:rgba(0, 88, 124, 0.2);border-color:#004763;--dx-text-color:#004763;--dx-icon-color:#004763}:host .button.active{--dx-text-color:#004763;--dx-text-font-weight:bold}";

const DxNumberPaginatorPageButton = class {
  constructor(hostRef) {
    index.registerInstance(this, hostRef);
    this.pageChange = index.createEvent(this, "pageChange", 7);
    this.pageSelect = index.createEvent(this, "pageSelect", 7);
    this.listOpen = false;
  }
  onStateChanged(newState, oldState) {
    if ((isGapPayload(newState) && isGapPayload(oldState)) ||
      (isPagePayload(newState) && isPagePayload(oldState))) {
      return;
    }
    this.previousState = oldState;
    this.listOpen = this.listOpen && isGapPayload(newState);
  }
  onBlur() {
    this.listOpen = false;
  }
  onItemSelectionChanged(e) {
    e.stopPropagation();
    const listItem = e
      .composedPath()
      .find((target) => target.tagName.toLowerCase() === "dx-list-item");
    if (listItem != null) {
      this.pageChange.emit(parseInt(listItem.value.toString()));
    }
  }
  handleClick() {
    this.listOpen = isGapPayload(this.state) && !this.listOpen;
    if (isPagePayload(this.state)) {
      this.pageSelect.emit(this.state.page);
    }
  }
  renderSelectableListItem(value) {
    return (index.h("dx-list-item", { id: elementIdHandling.ElementIdGenerator.createId(this.self, `list-item-${value}`), type: "selectable", value: value.toString(), label: value.toString(), textalign: "left", selected: false }));
  }
  renderListItems(gapState) {
    return miscUtil.createNumberArray(gapState.from, gapState.to).map((value) => {
      return (index.h("dx-list-item", { id: elementIdHandling.ElementIdGenerator.createId(this.self, `list-item-${value}`), type: "selectable", value: value.toString(), label: value.toString(), textalign: "left", selected: false }));
    });
  }
  renderListItemGap() {
    return (index.h("dx-list-item", { id: elementIdHandling.ElementIdGenerator.createId(this.self, `page-gap`), type: "default", label: "..." }));
  }
  renderListItemsWithGap(gapState) {
    const range = 25;
    const firstFrom = gapState.from;
    const firstTo = gapState.from + range;
    const secondFrom = gapState.to - range;
    const secondTo = gapState.to;
    const createListItem = this.renderSelectableListItem.bind(this);
    return miscUtil.createNumberArray(firstFrom, firstTo)
      .map(createListItem)
      .concat(this.renderListItemGap())
      .concat(miscUtil.createNumberArray(secondFrom, secondTo).map(createListItem));
  }
  renderListFlyout(isGap) {
    var _a;
    if (!isGap) {
      return;
    }
    const gapState = (isGap ? this.state : (_a = this.previousState) !== null && _a !== void 0 ? _a : { from: 1, to: 1 });
    const range = gapState.to - gapState.from + 1;
    const displayedRange = mathUtil.clamp(range, 1, 50);
    const hasGap = displayedRange !== range;
    return (index.h("dx-list-flyout", { open: this.listOpen, position: "bottom", direction: "right", itemsvisible: 3.5, size: "m", selectionmode: null }, hasGap
      ? this.renderListItemsWithGap(gapState)
      : this.renderListItems(gapState)));
  }
  render() {
    const isGap = isGapPayload(this.state);
    return (index.h(index.Host, null, index.h("button", { id: elementIdHandling.ElementIdGenerator.createId(this.self, `control`), type: "text", class: { button: true, active: this.state.active }, onClick: () => this.handleClick() }, index.h("dx-text", null, isGap ? "..." : this.state.page)), this.renderListFlyout(isGap)));
  }
  get self() { return index.getElement(this); }
  static get watchers() { return {
    "state": ["onStateChanged"]
  }; }
};
function isGapPayload(info) {
  return "from" in info && "to" in info;
}
function isPagePayload(info) {
  return "page" in info && "active" in info;
}
DxNumberPaginatorPageButton.style = dxNumberPaginatorPageButtonCss;

const dxTextInputCss = ":host{min-width:0;display:block}:host:host([hidden]){display:none !important}:host:host(.disabled){pointer-events:none}:host:host(.disabled:not(.nested-form-element)){opacity:0.4}:host label{display:block}:host label .container.size-s{position:relative;top:0;left:0;display:flex;height:40px;padding:8px 16px 8px 16px;--dx-info-button-offset-y:0px;box-sizing:border-box;border:1px solid #d6d6d6;border-bottom:var(--dx-container-border-bottom, 1px solid #d6d6d6);background-color:#ffffff;align-items:center;--dx-icon-color:#337a96}:host label .container.size-s.error{border-color:#9d2235;background-color:#f5e9eb}:host label .container.size-s.error input,:host label .container.size-s.error textarea{background:transparent}:host label .container.size-s.active{border-color:#004763;--dx-text-color:#004763;--dx-icon-color:#004763}:host label .container.size-m{position:relative;top:0;left:0;display:flex;height:48px;padding:10px 16px 10px 16px;box-sizing:border-box;border:1px solid #d6d6d6;border-bottom:var(--dx-container-border-bottom, 1px solid #d6d6d6);background-color:#ffffff;align-items:center;--dx-icon-color:#337a96}:host label .container.size-m.error{border-color:#9d2235;background-color:#f5e9eb}:host label .container.size-m.error input,:host label .container.size-m.error textarea{background:transparent}:host label .container.size-m.active{border-color:#004763;--dx-text-color:#004763;--dx-icon-color:#004763}:host label .container input{height:24px;border:none;outline:none;font-family:DVAG-Type;font-size:16px;line-height:24px;letter-spacing:0.02px;color:#2b2b2b;width:1px;flex-grow:1;padding:0}@media (min-width: 1280px){:host label .container input{font-size:18px;line-height:28px}}:host label .container input::placeholder{color:#ababab;opacity:1}:host label .container input:disabled{background-color:#ffffff}:host label .respect-label-height{--dx-overlay-offset:-24}@media (min-width: 1280px){:host label .respect-label-height{--dx-overlay-offset:-28}}";

const DxTextInput = class {
  constructor(hostRef) {
    index.registerInstance(this, hostRef);
    this.valueChange = index.createEvent(this, "valueChange", 7);
    this.valueComplete = index.createEvent(this, "valueComplete", 7);
    this.autocomplete = index.createEvent(this, "autocomplete", 7);
    this.selectAutocomplete = index.createEvent(this, "selectAutocomplete", 7);
    this.enterPress = index.createEvent(this, "enterPress", 7);
    this.preventReFocus = false;
    this.inputFocused = false;
    this.internalValue = "";
    /**
     * Defines the size of this input.
     *
     * @value m: medium size text-input
     * @value s: small sized input. Should only be used in special cases.
     */
    this.size = "m";
    /**
     * The value of this input.
     * @important
     * @value string: Value of this input.
     * @example value
     */
    this.value = "";
    /**
     * Displays an icon when the input is not active or empty.
     * @value string: the name of the icon.
     * @example icon
     */
    this.icon = undefined;
    /**
     * Placeholder for this input field.
     * @value string: The placeholder.
     */
    this.placeholder = "Bitte eingeben ...";
    /**
     * Defines if the input field is enabled or not.
     * @value true: Input ist disabled
     * @value false: Input is not disabled
     * @example disabled
     */
    this.disabled = false;
    /**
     * Input field is in readonly mode.
     * The value of this input is display in an simplified manner.
     * The input field is not interactable.
     * @value false: input is not editable.
     * @value true: input is read-only.
     * @example readonly
     */
    this.readonly = false;
    /**
     * Indicates that the form is synced with the KI.
     * @value true: Synchronized.
     * @value false: Not synchronized.
     * @example kisynced
     */
    this.kisynced = false;
  }
  valueChanged() {
    this.obtainValueChangesFromOutside();
  }
  onItemSelectionChanged(e) {
    const option = this.autocompleteValues.find((option) => { var _a, _b; return option.value === ((_b = (_a = e.detail) === null || _a === void 0 ? void 0 : _a.selectedItems) === null || _b === void 0 ? void 0 : _b[0]); });
    this.selectOption(option);
  }
  /**
   * Focuses this input field.
   * @example focus
   */
  async focusControl() {
    this.inputElement.focus();
  }
  componentWillLoad() {
    elementIdHandling.verifyElementId(this.self);
    this.obtainValueChangesFromOutside(true);
  }
  onForceUpdateOnChange(e) {
    e.detail(this.self);
  }
  obtainValueChangesFromOutside(force = false) {
    if (force || this.value !== this.internalValue) {
      this.internalValue = this.value;
      this.lastEmittedChangeValue = this.value;
      this.lastEmittedCompleteValue = this.value;
      this.emitAutocompleteEvent();
    }
  }
  onInputFocused() {
    this.inputFocused = true;
    this.emitAutocompleteEvent();
  }
  onInputBlurred() {
    renderUtil.onNextFrame(() => {
      if (this.preventReFocus || !miscUtil.isActiveElement(this.self)) {
        this.inputFocused = false;
        this.autocompleteValues = null;
        this.emitValueChange();
        this.emitValueComplete();
      }
    });
  }
  onListFlyoutClicked(event) {
    const clickedOnListItem = event_util.extractPath(event).some((el) => { var _a; return ((_a = el.tagName) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === "dx-list-item"; });
    if (clickedOnListItem) {
      this.autocompleteValues = null;
      this.emitValueComplete();
    }
  }
  clearInput() {
    this.inputElement.value = "";
    this.internalValue = "";
    this.emitValueChange();
  }
  onInputKeyDown(event) {
    var _a;
    if (event.key == "Enter") {
      if (((_a = this.autocompleteValues) === null || _a === void 0 ? void 0 : _a.length) > 0 && this.selectedOption) {
        this.selectAutocompleteValue(this.selectedOption);
      }
      this.inputElement.blur();
      this.enterPress.emit();
    }
    const listFlyoutElement = this.self.shadowRoot.querySelector("dx-list-flyout");
    if (event.target === listFlyoutElement) {
      return;
    }
    if (listFlyoutElement === null || listFlyoutElement === void 0 ? void 0 : listFlyoutElement.open) {
      listFlyoutElement === null || listFlyoutElement === void 0 ? void 0 : listFlyoutElement.dispatchEvent(new event.constructor(event.type, event));
    }
  }
  onInputInput() {
    this.internalValue = this.inputElement.value;
    this.emitAutocompleteEvent();
    this.emitValueChange();
  }
  selectOption(option) {
    this.selectedOption = option;
    this.internalValue = option.value;
    this.emitValueChange();
  }
  selectAutocompleteValue(value) {
    this.internalValue = value.value;
    this.autocompleteValues = null;
    this.emitValueChange();
    this.emitValueComplete();
    this.selectAutocomplete.emit(value.data);
  }
  emitAutocompleteEvent() {
    this.autocomplete.emit({
      value: this.internalValue,
      provideValues: (values) => {
        this.autocompleteValues = values;
      },
    });
  }
  emitValueChange() {
    const valueCandidate = this.internalValue;
    if (this.lastEmittedChangeValue !== valueCandidate) {
      this.value = valueCandidate;
      this.valueChange.emit(this.value);
      this.lastEmittedChangeValue = this.value;
    }
  }
  emitValueComplete() {
    if (this.lastEmittedCompleteValue !== this.value) {
      this.valueComplete.emit(this.value);
      this.lastEmittedCompleteValue = this.value;
    }
  }
  render() {
    if (this.readonly) {
      return index.h(baseElements.ReadonlyTextElement, { text: this.value, label: this.label });
    }
    return (index.h(index.Host, { class: { disabled: this.disabled } }, this.renderInput(), index.h(error.ErrorMessage, { self: this.self, message: this.errormessage, custom: {
        onFocus: () => {
          this.preventReFocus = true;
        },
        onBlur: () => {
          this.preventReFocus = false;
        },
      } })));
  }
  renderInput() {
    return (index.h("label", null, index.h(inputContainer.LabeledInputContainer, { containerProperties: {
        active: this.inputFocused,
        size: this.size,
        title: this.value,
        error: error.hasError(this.self),
      }, labelProperties: {
        disabled: this.disabled,
        label: this.label,
        required: this.required,
        kisynced: this.kisynced,
      } }, index.h("input", { id: elementIdHandling.ElementIdGenerator.createId(this.self, "control"), ref: (el) => (this.inputElement = el), onInput: () => this.onInputInput(), onKeyDown: (event) => this.onInputKeyDown(event), onFocus: () => this.onInputFocused(), onBlur: () => this.onInputBlurred(), type: "text", placeholder: this.placeholder, value: this.internalValue, maxLength: this.limitlength, disabled: this.disabled }), this.renderIconOrClearButton()), this.renderAutocompleteValues()));
  }
  renderAutocompleteValues() {
    var _a, _b;
    const isOpen = this.inputFocused &&
      this.autocompleteValues != null &&
      this.autocompleteValues.length > 0;
    return (index.h("dx-list-flyout", { open: isOpen, position: "bottom", direction: "right", itemsvisible: 5.5, size: "m", selectionmode: "single", onClick: (event) => this.onListFlyoutClicked(event), class: {
        "respect-label-height": ((_a = this.label) === null || _a === void 0 ? void 0 : _a.length) > 0,
      } }, index.h("div", { slot: "base" }), (_b = this.autocompleteValues) === null || _b === void 0 ? void 0 :
      _b.map((value) => {
        return (index.h("dx-list-item", { value: value.value, label: value.label, type: "selectable", selected: this.selectedOption === value, onClick: () => this.selectAutocompleteValue(value) }));
      })));
  }
  renderIconOrClearButton() {
    var _a;
    const isClearButtonVisible = this.internalValue !== "" && this.inputFocused;
    if (isClearButtonVisible) {
      return (index.h("dx-clear-button", { onClearInput: () => this.clearInput(), id: elementIdHandling.ElementIdGenerator.createId(this.self, "clear-button") }));
    }
    else {
      if (((_a = this.icon) === null || _a === void 0 ? void 0 : _a.length) > 0) {
        return (index.h("dx-icon", { size: 24, icon: this.icon, color: "default", class: "display-icon" }));
      }
      else {
        return index.h("div", { class: "display-icon" }, "\u00A0");
      }
    }
  }
  get self() { return index.getElement(this); }
  static get watchers() { return {
    "value": ["valueChanged"]
  }; }
};
DxTextInput.style = dxTextInputCss;

exports.dx_dropdown = DxDropdown;
exports.dx_dropdown_option = DxDropdownOption;
exports.dx_number_paginator_page_button = DxNumberPaginatorPageButton;
exports.dx_text_input = DxTextInput;
