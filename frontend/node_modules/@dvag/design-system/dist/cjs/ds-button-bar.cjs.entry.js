'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const index = require('./index-2f41386b.js');
const slotObserver = require('./slot-observer-2e83212e.js');
const renderUtil = require('./render-util-6b278c0d.js');
require('./query-util-8642f149.js');

const dsButtonBarCss = ":host{display:flex}:host:host([hidden]){display:none !important}:host:host(.direction-row){flex-direction:row}:host:host(.direction-row) ::slotted(*:not(:last-child)){margin-right:16px}:host:host(.direction-column){flex-direction:column;align-items:flex-start}:host:host(.direction-column) ::slotted(*:not(:last-child)){margin-bottom:16px}";

const DsButtonBar = class {
  constructor(hostRef) {
    index.registerInstance(this, hostRef);
    this.nodes = [];
    /**
     * Specifies the direction in which the buttons get arranged.
     *
     * @value row: Buttons get layouted from left to right.
     * @value column: Buttons get layouted from top to bottom.
     * @value auto: Button get layouted automatically.
     * @example column
     * @example row
     */
    this.direction = "row";
  }
  onDirectionChange() {
    if (this.direction !== "auto") {
      this.internalDirection = this.direction;
    }
  }
  onResize() {
    this.calculateDirection();
  }
  connectedCallback() {
    this.slotObserver = new slotObserver.SlotObserver(this.self, ":scope > *", (nodes) => {
      renderUtil.onNextFrame(() => {
        renderUtil.onNextFrame(() => {
          applyStyleWidth(nodes, maxWidth(nodes));
          configureDsButtonElementsForStretchedBehavior(nodes);
          this.nodes = nodes;
        });
      });
    });
  }
  componentWillLoad() {
    this.internalDirection =
      this.direction !== "auto" ? this.direction : "column";
  }
  componentDidLoad() {
    this.calculateDirection();
  }
  disconnectedCallback() {
    var _a;
    (_a = this.slotObserver) === null || _a === void 0 ? void 0 : _a.disconnect();
  }
  calculateDirection() {
    if (this.direction === "auto") {
      requestAnimationFrame(() => {
        if (this.checkOverflow()) {
          this.internalDirection = "column";
        }
        else {
          const nodesWidthTotal = this.nodes.reduceRight((prev, curr) => prev + curr.offsetWidth, 0);
          // test if nodes could be displayed in row-direction. This should prevent flickering
          if (nodesWidthTotal <= this.self.getBoundingClientRect().width) {
            this.internalDirection = "row";
          }
        }
      });
    }
  }
  checkOverflow() {
    const curOverflow = this.self.style.overflow;
    if (!curOverflow || curOverflow === "visible") {
      const isOverflowing = this.self.clientWidth < this.self.scrollWidth ||
        this.self.clientHeight < this.self.scrollHeight;
      this.self.style.overflow = curOverflow;
      return isOverflowing;
    }
  }
  render() {
    return (index.h(index.Host, { class: {
        "direction-row": this.internalDirection === "row",
        "direction-column": this.internalDirection === "column",
      } }, index.h("slot", null)));
  }
  get self() { return index.getElement(this); }
  static get watchers() { return {
    "direction": ["onDirectionChange"]
  }; }
};
function applyStyleWidth(nodes, width) {
  nodes.forEach((el) => (el.style.width = `${width}px`));
}
function configureDsButtonElementsForStretchedBehavior(nodes) {
  nodes
    .filter((el) => el.tagName.toLowerCase() === "ds-button")
    .forEach((el) => (el.stretch = true));
}
function maxWidth(nodes) {
  return nodes.reduce((curr, next) => Math.max(curr, next.offsetWidth), 0);
}
DsButtonBar.style = dsButtonBarCss;

exports.ds_button_bar = DsButtonBar;
