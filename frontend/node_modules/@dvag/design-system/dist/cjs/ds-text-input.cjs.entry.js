'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const index = require('./index-2f41386b.js');
const elementIdHandling = require('./element-id-handling-89898a1c.js');
const baseElements = require('./base-elements-0dbfd791.js');
const platform_util = require('./platform.util-5ed8c7b0.js');
const inputContainer = require('./input-container-9bf53d94.js');
const errorPopup = require('./error-popup-9c9bd96e.js');
const renderUtil = require('./render-util-6b278c0d.js');
require('./value-store-f683b26f.js');

/**
 * Converts a raw value into masked value.
 * See unit tests for examples.
 *
 * @param mask pattern with `0` (numeric) and `X` (alphanumeric) as placeholders
 * @param value value that should be masked
 */
function rawToMaskedValue(mask, value) {
  if ((mask === null || mask === void 0 ? void 0 : mask.length) > 0) {
    // only do something if mask defined
    let index = 0; // tracks position in raw value string
    let result = ""; // will contain the mask value we are building here
    let lastValidLength = 0; // last string length of result without any errors on applying placeholders
    if ((value === null || value === void 0 ? void 0 : value.length) > 0) {
      for (const char of mask.split("")) {
        // iterate over pattern
        if (MASK_CHARS.includes(char)) {
          // char in pattern is placeholder
          if (value.length === index) {
            // stop iteration when there are no more raw value to process
            break;
          }
          const valueToInsert = value[index++]; // obtain raw value char and increase index counter
          if (char === MASK_CHAR_NUMERIC && !NUM_CHAR.test(valueToInsert)) {
            // found non-numeric on numeric placeholder
            return result.substring(0, lastValidLength); // resolve error case by returning the latest working string
          }
          result += valueToInsert; // take value char
          lastValidLength = result.length;
        }
        else {
          // char in pattern is not placeholder
          result += char; // just take char
          // TODO: Felix review. Do this because the mask char should be valid
          lastValidLength = result.length;
        }
      }
    }
    return result;
  }
  return value;
}
/**
 * Converts a masked value into a raw value.
 * See unit tests for examples.
 *
 * @param mask pattern with `0` (numeric) and `X` (alphanumeric) as placeholders
 * @param masked value in masked form
 */
function maskedToRawValue(mask, masked) {
  if ((mask === null || mask === void 0 ? void 0 : mask.length) > 0) {
    // only do something if mask defined
    return mask
      .split("")
      .map((char, index) => {
      var _a;
      // iterate over pattern
      return MASK_CHARS.includes(char) ? (_a = masked[index]) !== null && _a !== void 0 ? _a : "" : ""; // only take chars from masked input on positions where pattern has placeholders
    })
      .join("");
  }
  return masked;
}
const MASK_CHAR_ALPHANUMERIC = "X";
const MASK_CHAR_NUMERIC = "0";
const MASK_CHARS = [MASK_CHAR_ALPHANUMERIC, MASK_CHAR_NUMERIC];
const NUM_CHAR = /\d/;

const dsTextInputCss = ":host{display:block}:host:host([hidden]){display:none !important}:host:host([label]:not([label=\"\"])){--ds-info-button-offset-y:24px}:host label{display:block}:host label .container{position:relative;top:0;left:0;display:flex;height:38px;border-radius:4px;border:1px solid #c1c1c1;background-color:#ffffff;box-sizing:border-box;align-items:center}:host label .container.required-outline{border-color:#e8b50e}:host label .container.requirement-fulfilled{border-color:#c1c1c1}:host label .container.red-outline{border-color:#be1413}:host label .container.disabled-outline{border-color:#ebebeb}:host label .container.active{border-color:#4c4c4c}:host label .container input{height:22px;margin:8px 0 8px 8px;border:none;outline:none;font-family:\"Helvetica Neue\", \"Helvetica Neue LT W01\";font-size:16px;line-height:24px;letter-spacing:0.02px;color:#4c4c4c;width:1px;flex-grow:1}:host label .container input::placeholder{color:#c1c1c1}:host label .container input:disabled{background-color:#ffffff;color:#c1c1c1}:host label .container .clear-button{visibility:hidden}:host label .container .clear-button.visible{visibility:visible}:host label .autocomplete-popup{min-width:max-content;max-height:215px;border-radius:4px;box-shadow:0 4px 12px 0 rgba(0, 0, 0, 0.32);background-color:#ffffff;overflow-y:auto}:host label .autocomplete-popup .autocomplete-item{user-select:none;-webkit-user-select:none;padding:0 10px;text-align:left;height:39px;display:flex;align-items:center;box-sizing:border-box;border-bottom:1px solid #dedede}:host label .autocomplete-popup .autocomplete-item:hover{background-color:#f5f5f5;cursor:pointer}:host label .autocomplete-popup .autocomplete-item.active{background-color:#ebebeb}:host label .autocomplete-popup .autocomplete-item:last-child{border-bottom:none}";

const DsTextInput = class {
  constructor(hostRef) {
    index.registerInstance(this, hostRef);
    this.valueChange = index.createEvent(this, "valueChange", 7);
    this.valueComplete = index.createEvent(this, "valueComplete", 7);
    this.autocomplete = index.createEvent(this, "autocomplete", 7);
    this.selectAutocomplete = index.createEvent(this, "selectAutocomplete", 7);
    this.preventAutocomplete = false;
    this.inputFocused = false;
    this.internalValue = "";
    this.currentFocusedIndex = 0;
    /**
     * Indicates that the form is synced with the KI.
     * @value true: Synchronized.
     * @value false: Not synchronized.
     * @example kisynced
     */
    this.kisynced = false;
    /**
     * Input has a red outline.
     * @value true: red outlined.
     * @value false: gray outlined.
     * @example error
     */
    this.error = false;
    /**
     * The value of this input.
     * @important
     * @value string: value of this input.
     * @example value
     */
    this.value = "";
    /**
     * Placeholder for this input field.
     * @value string: The placeholder.
     */
    this.placeholder = "Bitte eingeben ...";
    /**
     * Defines if the input field is enabled or not.
     * @value true: Input ist disabled
     * @value false: Input is not disabled
     * @example disabled
     */
    this.disabled = false;
    /**
     * Input field is in readonly mode.
     * The value of this input is displaey in an simplified manner.
     * The input field is not interactable.
     * @value false: input is not editable.
     * @value true: input is read-only.
     * @example readonly
     */
    this.readonly = false;
    /**
     * Input is marked as required. And the user needs to fulfill the input's requirements.
     * @value true: Input field is required and draws a yellow outline and displays an icon beneath the input.
     * @value false: Input field is not required.
     * @example required
     */
    this.required = false;
  }
  valueChanged() {
    this.obtainValueChangesFromOutside();
  }
  /**
   * Focuses this input field.
   * @example focus
   */
  async focusControl() {
    this.inputElement.focus();
  }
  componentWillLoad() {
    elementIdHandling.verifyElementId(this.self);
    this.obtainValueChangesFromOutside(true);
  }
  obtainValueChangesFromOutside(force = false) {
    const maskedValue = rawToMaskedValue(this.mask, this.value);
    if (force ||
      (this.value !== this.internalValue && maskedValue !== this.internalValue)) {
      this.internalValue = maskedValue;
      this.lastEmittedChangeValue = this.value;
      this.lastEmittedCompleteValue = this.value;
      this.emitAutocompleteEvent();
    }
  }
  onInputFocused() {
    this.inputFocused = true;
    this.emitAutocompleteEvent();
  }
  onInputBlurred() {
    this.inputFocused = false;
    this.autocompleteValues = null;
    this.emitValueChange();
    this.emitValueComplete();
  }
  clearInput() {
    this.inputElement.value = "";
    this.internalValue = "";
    this.emitValueChange();
  }
  onInputKeyDown(event) {
    if (this.shouldShowAutocompleteValues() &&
      (event.key === "ArrowUp" || event.key === "ArrowDown")) {
      event.preventDefault();
    }
  }
  shouldShowAutocompleteValues() {
    var _a;
    const autocompleteValuesAreAvailable = ((_a = this.autocompleteValues) === null || _a === void 0 ? void 0 : _a.length) > 0;
    return this.inputFocused && autocompleteValuesAreAvailable;
  }
  onInputKeyUp(event) {
    var _a, _b, _c, _d;
    if (event.key == "Enter") {
      if (((_a = this.autocompleteValues) === null || _a === void 0 ? void 0 : _a.length) > 0) {
        this.selectAutocompleteValue(this.autocompleteValues[this.currentFocusedIndex]);
      }
      this.inputElement.blur();
    }
    //TODO home taste abfangen
    if (((_b = this.mask) === null || _b === void 0 ? void 0 : _b.length) > 0 && ((_c = event.key) === null || _c === void 0 ? void 0 : _c.includes("Arrow"))) {
      this.moveTextCursorToEnd();
    }
    if (((_d = this.autocompleteValues) === null || _d === void 0 ? void 0 : _d.length) > 0) {
      this.updateCurrentFocusedIndexAndScrollIntoView(event);
    }
  }
  updateCurrentFocusedIndexAndScrollIntoView(event) {
    if (event.key === "ArrowDown") {
      this.currentFocusedIndex =
        (this.currentFocusedIndex + 1) % this.autocompleteValues.length;
      this.scrollIntoView(this.currentFocusedIndex);
    }
    else if (event.key === "ArrowUp") {
      this.currentFocusedIndex =
        (this.currentFocusedIndex + this.autocompleteValues.length - 1) %
          this.autocompleteValues.length;
      this.scrollIntoView(this.currentFocusedIndex);
    }
  }
  scrollIntoView(selectedIndex) {
    renderUtil.onNextFrame(() => {
      if (selectedIndex > -1) {
        const autocompletePopup = this.self.shadowRoot.querySelector(".autocomplete-popup");
        if (autocompletePopup == null) {
          return;
        }
        const items = Array.from(this.self.shadowRoot.querySelectorAll(".autocomplete-item"));
        const listHeight = autocompletePopup.offsetHeight;
        const itemHeight = items[0].offsetHeight;
        autocompletePopup.scrollTop =
          itemHeight * selectedIndex - listHeight / 2 + itemHeight / 2;
      }
    });
  }
  onInputClicked() {
    var _a;
    if (((_a = this.mask) === null || _a === void 0 ? void 0 : _a.length) > 0) {
      this.moveTextCursorToEnd();
    }
  }
  moveTextCursorToEnd() {
    this.inputElement.setSelectionRange(this.internalValue.length, this.internalValue.length);
  }
  onInputInput(e) {
    var _a;
    if (((_a = this.mask) === null || _a === void 0 ? void 0 : _a.length) > 0) {
      this.handleMaskedInput(e);
    }
    else {
      this.internalValue = this.inputElement.value;
    }
    this.emitAutocompleteEvent();
    this.emitValueChange();
  }
  selectAutocompleteValue(value) {
    this.internalValue = value.value;
    this.autocompleteValues = null;
    this.emitValueChange();
    this.selectAutocomplete.emit(value.data);
  }
  emitAutocompleteEvent() {
    if (this.preventAutocomplete) {
      return;
    }
    this.autocomplete.emit({
      value: maskedToRawValue(this.mask, this.internalValue),
      provideValues: (values) => {
        this.autocompleteValues = values;
        this.currentFocusedIndex = 0;
      },
    });
  }
  emitValueChange() {
    const valueCandidate = maskedToRawValue(this.mask, this.internalValue);
    if (this.lastEmittedChangeValue !== valueCandidate) {
      this.value = valueCandidate;
      this.valueChange.emit(this.value);
      this.lastEmittedChangeValue = this.value;
    }
  }
  emitValueComplete() {
    if (this.lastEmittedCompleteValue !== this.value) {
      this.valueComplete.emit(this.value);
      this.lastEmittedCompleteValue = this.value;
    }
  }
  handleMaskedInput(event) {
    const previousValue = this.internalValue;
    const nextValue = this.inputElement.value;
    const newChar = event.data;
    let result;
    if (event.inputType === "insertFromPaste") {
      // copy/paste
      if (nextValue.length === this.mask.length) {
        result = nextValue; // paste masked
      }
      else {
        result = rawToMaskedValue(this.mask, nextValue); // paste raw values
      }
    }
    else if (previousValue.length < nextValue.length) {
      // add char
      const currentValue = newChar == undefined ? nextValue : previousValue;
      const rawNewValue = maskedToRawValue(this.mask, currentValue) + (newChar !== null && newChar !== void 0 ? newChar : "");
      result = rawToMaskedValue(this.mask, rawNewValue);
    }
    else if (event.inputType === "deleteContentBackward") {
      // delete
      let rawNewValue = maskedToRawValue(this.mask, previousValue);
      rawNewValue = rawNewValue.substring(0, rawNewValue.length - 1);
      result = rawToMaskedValue(this.mask, rawNewValue);
    }
    else {
      // anything else
      result = rawToMaskedValue(this.mask, maskedToRawValue(this.mask, nextValue));
    }
    this.inputElement.value = result;
    this.internalValue = result;
    this.moveTextCursorToEnd();
  }
  render() {
    if (this.readonly) {
      return (index.h(baseElements.ReadonlyTextElement, { text: this.value, label: this.label, kisynced: this.kisynced }));
    }
    return index.h(index.Host, null, this.renderInput());
  }
  renderInput() {
    var _a, _b, _c, _d;
    const isErrorOutline = ((_a = this.errormessage) === null || _a === void 0 ? void 0 : _a.length) > 0 || this.error;
    return (index.h("label", null, index.h("ds-input-label", { disabled: this.disabled, kisynced: this.kisynced, label: this.label }), index.h("dx-overlay", { position: "bottom", offsety: 4, disabled: !this.shouldShowAutocompleteValues() }, index.h(inputContainer.InputContainer, { active: this.inputFocused, error: isErrorOutline, required: this.required, requirementFulfilled: ((_b = this.value) === null || _b === void 0 ? void 0 : _b.length) > 0, disabled: this.disabled, title: this.value }, index.h("input", { id: elementIdHandling.ElementIdGenerator.createId(this.self, "control"), ref: (el) => (this.inputElement = el), onInput: (event) => this.onInputInput(event), onKeyUp: (event) => this.onInputKeyUp(event), onKeyDown: (event) => this.onInputKeyDown(event), onFocus: () => this.onInputFocused(), onBlur: () => this.onInputBlurred(), onClick: () => this.onInputClicked(), type: "text", placeholder: this.placeholder, value: this.internalValue, maxLength: ((_c = this.mask) === null || _c === void 0 ? void 0 : _c.length) || this.limitlength, disabled: this.disabled }), this.renderClearButton(), index.h(errorPopup.ErrorPopup, { text: this.errormessage, show: this.inputFocused })), this.renderAutocompleteValues()), index.h("ds-required-hint", { required: this.required, fulfilled: ((_d = this.value) === null || _d === void 0 ? void 0 : _d.length) > 0 })));
  }
  renderAutocompleteValues() {
    if (!this.shouldShowAutocompleteValues()) {
      return;
    }
    return (index.h("div", { slot: "overlay", class: "autocomplete-popup" }, this.autocompleteValues.map((value, index$1) => {
      return (index.h("div", { onPointerDown: () => {
          // because autocomplete list is attached to input's focus state
          // it's too late to wait for a click's mouseup part.
          if (!platform_util.isIos()) {
            this.selectAutocompleteValue(value);
          }
        }, onClick: () => {
          // we can't use pointerdown at ios because of scrolling behavior
          if (platform_util.isIos()) {
            this.selectAutocompleteValue(value);
            // prevent autocomplete event firing for a short amount of time
            this.preventAutocomplete = true;
            setTimeout(() => (this.preventAutocomplete = false), 200);
          }
        }, class: {
          "autocomplete-item": true,
          active: this.currentFocusedIndex === index$1,
        } }, index.h("ds-text", null, value.label)));
    })));
  }
  renderClearButton() {
    const isClearButtonVisible = this.internalValue !== "" && this.inputFocused;
    return (index.h("ds-function-icon-button", { id: elementIdHandling.ElementIdGenerator.createId(this.self, "clear-button"), unfocusable: true, class: {
        "clear-button": true,
        visible: isClearButtonVisible,
      }, onPointerDown: () => this.clearInput() }, index.h("ds-icon", { icon: "schliessen-input", size: 16 })));
  }
  get self() { return index.getElement(this); }
  static get watchers() { return {
    "value": ["valueChanged"]
  }; }
};
DsTextInput.style = dsTextInputCss;

exports.ds_text_input = DsTextInput;
