'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const index = require('./index-2f41386b.js');
const renderUtil = require('./render-util-6b278c0d.js');
const elementIdHandling = require('./element-id-handling-89898a1c.js');
const miscUtil = require('./misc-util-63b423bd.js');
const table_util = require('./table.util-f374fdbd.js');
const breakpointAware = require('./breakpoint-aware-cc9d0ee6.js');
require('./value-store-f683b26f.js');

const dxTableRowCss = ":host{border-bottom:var(--dx-table-row-border-bottom, 1px solid #d6d6d6);width:var(--dx-table-row-width, 100%);display:none}:host:host([hidden]){display:none !important}:host:host(.visible){display:flex}:host .collapsable-button-container{width:var(--dx-table-collapsable-spacing-left, 64px);flex:0 0 var(--dx-table-collapsable-spacing-left, 64px);display:flex;justify-content:center}:host .collapsable-button-container .collapsable-button{width:var(--dx-button-width, fit-content);width:var(--dx-button-width, -moz-fit-content);cursor:pointer;display:inline-flex;justify-content:center;align-items:center;box-sizing:border-box;white-space:nowrap;user-select:none;-webkit-user-select:none;border:none;margin:0;background-color:transparent;transition:background-color 150ms ease-in-out, border-color 150ms ease-in-out;outline-offset:2px;margin-top:8px;width:48px;height:48px}:host .collapsable-button-container .collapsable-button[disabled]{cursor:unset}:host .collapsable-button-container .collapsable-button.icon-right{flex-direction:row-reverse}:host .collapsable-button-container .collapsable-button:focus-visible{outline:2px solid #004763}:host .table-row-container{box-sizing:border-box;width:var(--dx-table-row-width, 100%);overflow-x:var(--dx-table-row-overflow, hidden)}:host .table-row-container .table-row{min-height:64px;display:flex;position:relative}:host .table-row-container .table-row:host(.selected){background-color:#f7f7f7}:host .table-row-container .table-row.selected{background-color:#f7f7f7}:host .table-row-container .table-row.has-content{cursor:pointer}:host .table-row-container .content-container{display:flex;box-sizing:border-box;background:white;z-index:1;flex:1}:host .table-row-container .content-container .sticky-space{display:none;position:sticky;background-color:white;left:0;flex:0 0 var(--dx-table-sticky-columns-width, 0);border-right:1px solid #d6d6d6;z-index:1}:host .table-row-container .content-container .sticky-space.visible{display:block}:host .table-row-container .content-container .content{padding:0 8px 32px 8px;flex:1}:host .sticky{position:sticky;left:0;background:white;z-index:1;display:flex;width:max-content;flex:0 0 0}:host .sticky.visible{flex-basis:unset;border-right:1px solid #d6d6d6}:host .sticky .selection-cell{display:var(--dx-table-selection-display, none);min-width:56px;max-width:56px}:host .sticky .expand-cell{display:var(--dx-table-expand-display, none);min-width:64px;max-width:64px}";

const DxTableRow = class {
  constructor(hostRef) {
    index.registerInstance(this, hostRef);
    this.rowSelected = index.createEvent(this, "rowSelected", 7);
    this.tableScrollChanged = (e) => {
      this.tableScrollable = e.detail;
    };
    this.expansionChangedHandler = (e) => {
      this.showExpandColumn = e.detail;
    };
    this.selectionChangedHandler = (e) => {
      this.showSelectionColumn = e.detail.enabled;
      this.selectionMode = e.detail.mode;
    };
    this.open = false;
    this.showExpandColumn = false;
    this.showSelectionColumn = false;
    this.tableScrollable = false;
    this.selectionMode = "multi";
    this.mediaQueryAllowsStickyness = false;
    /**
     * @internal
     */
    this.visible = true;
  }
  onRowSelected() {
    this.rowSelected.emit(this.selected);
  }
  connectedCallback() {
    this.breakpointAware = new breakpointAware.BreakpointAware(() => this.updateMediaQueryStickyness(), true);
    this.table = miscUtil.findUpperElement(this.self, "dx-table");
    this.table.addEventListener("expansionChanged", this.expansionChangedHandler);
    this.table.addEventListener("selectionStateChanged", this.selectionChangedHandler);
    this.table.addEventListener("internalScrollChanged", this.tableScrollChanged);
    this.tableScrollable = this.table.internalScrollable;
    this.showSelectionColumn = this.table.selectionenabled;
    this.selectionMode = this.table.selectionmode;
    this.showExpandColumn = table_util.containsExpandableRows(this.table);
    this.updateMediaQueryStickyness();
  }
  disconnectedCallback() {
    this.table.removeEventListener("expansionChanged", this.expansionChangedHandler);
    this.table.removeEventListener("internalScrollChanged", this.tableScrollChanged);
    this.table.removeEventListener("selectionStateChanged", this.selectionChangedHandler);
    this.breakpointAware.disconnect();
  }
  showStickyContainer() {
    return table_util.showStickyContainer(this.tableScrollable, this.showExpandColumn, this.showSelectionColumn, this.mediaQueryAllowsStickyness, () => renderUtil.isSlotDefined(this.self, "sticky"));
  }
  updateMediaQueryStickyness() {
    this.mediaQueryAllowsStickyness = this.breakpointAware.getEffectiveValue({
      mq1: false,
      mq3: true,
    });
  }
  handleGrowBoxStateChanged(e) {
    // We have to listen to the grow-box state changed event because the overflow hidden style of the simple-grow-box
    // disabled the sticky ability of the sticky-space. That's why we update the left position of the sticky-space
    // while the content is animating.
    const stickySpace = this.self.shadowRoot.querySelector(".sticky-space");
    if (stickySpace == null) {
      return;
    }
    const getLeft = () => {
      return new Promise((resolve) => {
        var _a;
        if (e.detail === "closing" || e.detail === "opening") {
          const closestScrollElement = miscUtil.findClosestScrollElement(this.self);
          // We cannot use readTask here because the style doesn't update fast enough.
          resolve((_a = closestScrollElement === null || closestScrollElement === void 0 ? void 0 : closestScrollElement.scrollLeft) !== null && _a !== void 0 ? _a : 0);
          return;
        }
        resolve(0);
      });
    };
    getLeft().then((left) => {
      index.writeTask(() => {
        stickySpace.style.left = left + "px";
      });
    });
  }
  renderStickyColumn(mode) {
    const isInStickyContainer = this.tableScrollable && this.mediaQueryAllowsStickyness;
    if (mode === "sticky" && !isInStickyContainer) {
      return null;
    }
    if (mode === "default" && isInStickyContainer) {
      return null;
    }
    return (index.h("slot", { name: "sticky", onSlotchange: () => {
        index.forceUpdate(this.self);
      } }));
  }
  renderStickyColumns(containsContent, stickyEnabled) {
    return (index.h("div", { class: { sticky: true, visible: stickyEnabled } }, index.h("div", { class: {
        "collapsable-button-container": true,
        "expand-cell": true,
      } }, containsContent ? (index.h("button", { class: {
        "collapsable-button": true,
      } }, index.h("dx-chevron", { directiontop: this.open }))) : null), index.h("dx-table-cell", { type: "html", class: "selection-cell" }, this.renderSelectionInput()), this.renderStickyColumn("sticky")));
  }
  renderSelectionInput() {
    if (this.selectionMode === "single") {
      if (this.rowid != null) {
        return (index.h("dx-radio-button", { id: elementIdHandling.ElementIdGenerator.createId(this.self, "selection"), groupid: "table-selection-group", disabled: !this.visible, onClick: (e) => e.stopPropagation(), value: this.rowid, onInternalCheckedChange: (e) => {
            this.selected = e.detail;
          } }));
      }
    }
    return (index.h("dx-checkbox", { id: elementIdHandling.ElementIdGenerator.createId(this.self, "selection"), onClick: (e) => e.stopPropagation(), onCheckedChange: (e) => {
        this.selected = e.detail;
      }, checked: this.selected }));
  }
  render() {
    const containsContent = renderUtil.isSlotDefined(this.self, "content");
    const stickyEnabled = this.showStickyContainer();
    return (index.h(index.Host, { class: {
        visible: this.visible,
      }, role: "row" }, index.h("div", { class: {
        "table-row-container": true,
      } }, index.h("div", { class: {
        "table-row": true,
        "has-content": containsContent,
      }, onClick: () => {
        this.open = !this.open;
      } }, this.renderStickyColumns(containsContent, stickyEnabled), this.renderStickyColumn("default"), index.h("slot", null)), containsContent ? (index.h("dx-simple-grow-box", { open: this.open, onGrowBoxStateChange: (e) => {
        this.handleGrowBoxStateChanged(e);
      } }, index.h("div", { class: "content-container" }, index.h("div", { class: {
        "sticky-space": true,
        visible: stickyEnabled,
      } }), index.h("div", { class: "content" }, index.h("slot", { name: "content" }))))) : null)));
  }
  get self() { return index.getElement(this); }
  static get watchers() { return {
    "selected": ["onRowSelected"]
  }; }
};
DxTableRow.style = dxTableRowCss;

exports.dx_table_row = DxTableRow;
