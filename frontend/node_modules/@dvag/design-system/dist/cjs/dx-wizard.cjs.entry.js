'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const index = require('./index-2f41386b.js');
const slotObserver = require('./slot-observer-2e83212e.js');
const renderUtil = require('./render-util-6b278c0d.js');
const breakpointAware = require('./breakpoint-aware-cc9d0ee6.js');
const pageIndexType = require('./page-index-type-1fc5150f.js');
const mathUtil = require('./math-util-a514efc6.js');
const wizard_util = require('./wizard.util-6e67973d.js');
const assert = require('./assert-d8ea75c6.js');
const elementIdHandling = require('./element-id-handling-89898a1c.js');
const gridModels = require('./grid-models-cbbf414b.js');
const miscUtil = require('./misc-util-63b423bd.js');
require('./query-util-8642f149.js');
require('./value-store-f683b26f.js');

const dxWizardCss = ":host{display:block;--dx-content-switcher-transition-duration:750ms;--dx-wizard-step-flex:calc(2 - 1 / (8.75 - var(--dx-wizard-step-count)))}:host:host([hidden]){display:none !important}:host .wizard-steps-container .wizard-steps{display:flex}:host .wizard-steps-container .wizard-steps .wizard-step.is-first-step,:host .wizard-steps-container .wizard-steps .wizard-step.is-last-step{--dx-wizard-step-flex:1}:host .wizard-steps-container .context-container{width:var(--dx-button-width, fit-content);width:var(--dx-button-width, -moz-fit-content);cursor:pointer;display:inline-flex;justify-content:center;align-items:center;box-sizing:border-box;white-space:nowrap;user-select:none;-webkit-user-select:none;border:none;margin:0;background-color:transparent;transition:background-color 150ms ease-in-out, border-color 150ms ease-in-out;outline-offset:2px;display:flex;margin-top:12px;width:100%;padding:0}:host .wizard-steps-container .context-container[disabled]{cursor:unset}:host .wizard-steps-container .context-container.icon-right{flex-direction:row-reverse}:host .wizard-steps-container .context-container:focus-visible{outline:2px solid #004763}:host .wizard-steps-container .context-container .current-step-container{text-align:left;flex:1;margin-right:8px}:host .wizard-steps-container .context-container .current-step-container .steps-counter{margin-bottom:4px}:host .wizard-steps-container .context-container .current-step-container .current-step-label{white-space:break-spaces}:host .wizard-steps-container .context-container .context-menu-button{flex:0 0 40px}:host .gap-container{flex:var(--dx-wizard-step-flex);display:none}:host .gap-container.visible{display:flex}:host .gap-container .gap{display:flex;flex:1;align-items:center}:host .gap-container .gap .horizontal-line{background-color:#d6d6d6;flex:1}:host .gap-container .gap .circle{width:3px;height:3px;flex-grow:0;flex-shrink:0;border-radius:50%;background-color:#808080}:host .gap-container .gap .blue{background-color:#337a96}:host(.orientation-vertical) .wizard-steps{flex-direction:column;height:max-content}@media (min-width: 0px){:host(.orientation-vertical) .wizard-steps{font-size:14px;--dx-text-font-size:14px;line-height:20px;--dx-text-line-height:20px}}@media (min-width: 1280px){:host(.orientation-vertical) .wizard-steps{font-size:16px;--dx-text-font-size:16px;line-height:24px;--dx-text-line-height:24px}}:host(.orientation-vertical) .gap-container{display:none}@media (min-width: 0px){:host(.orientation-horizontal) .wizard-steps{font-size:12px;--dx-text-font-size:12px;line-height:16px;--dx-text-line-height:16px}}@media (min-width: 1280px){:host(.orientation-horizontal) .wizard-steps{font-size:14px;--dx-text-font-size:14px;line-height:20px;--dx-text-line-height:20px}}:host(.orientation-horizontal) .gap-container{flex-direction:row}:host(.orientation-horizontal) .gap-container .gap .horizontal-line{height:2px}:host(.orientation-horizontal) .gap-container .gap .horizontal-line.left{margin-right:4px}:host(.orientation-horizontal) .gap-container .gap .horizontal-line.right{margin-left:4px}:host(.orientation-horizontal) .gap-container .gap .circle.center{margin:0 2px}@media (min-width: 476px){:host(.expanded-layout-at-mq2) .wizard-steps{--dx-wizard-step-flex:1}:host(.expanded-layout-at-mq2) .wizard-steps .context-container{display:none}}@media (min-width: 760px){:host(.expanded-layout-at-mq3) .wizard-steps{--dx-wizard-step-flex:1}:host(.expanded-layout-at-mq3) .wizard-steps .context-container{display:none}}@media (min-width: 1024px){:host(.expanded-layout-at-mq4) .wizard-steps{--dx-wizard-step-flex:1}:host(.expanded-layout-at-mq4) .wizard-steps .context-container{display:none}}";

const DxWizard = class {
  constructor(hostRef) {
    index.registerInstance(this, hostRef);
    this.currentStepChange = index.createEvent(this, "currentStepChange", 7);
    this.stepsAreVisible = true;
    /**
     * Defines from which breakpoint the expanded large screen layout of the component is displayed.
     *
     * @value auto: The expanded layout starts at mq2 for the `horizontal` layout and mq3 for the `vertical` layout.
     * @value mq3: The expanded layout starts at mq3 or bigger.
     * @value mq4: The expanded layout starts at mq4 or bigger.
     *
     * @example expanded-layout-at
     */
    this.expandedlayoutat = "auto";
    /**
     * Defines the orientation of the wizard's expanded view.
     * The default orientation of the mobile view (dependent on `expandedlayoutat` property) is always `horizontal`.
     *
     * @value horizontal: All wizards will be displayed from left to right as long as there are six steps at most. If there are more than six steps the `vertical` view will be displayed instead.
     * @value vertical: All steps are displayed from top to bottom. Only the mobile view displays a horizontal setup.
     *
     * @example orientation
     * @example orientation-invalid
     */
    this.orientation = "horizontal";
  }
  onOrientationChanged() {
    this.updateInternalOrientation();
  }
  onValueChanged(_, oldValue) {
    var _a;
    const wizardStepIndex = this.steps.findIndex((step) => step.value === this.currentstep);
    const wizardStep = this.steps[wizardStepIndex];
    const previousStep = this.steps[wizardStepIndex - 1];
    // Check if the previous step is finished. If wizardStepIndex is zero we want the attribute to be true.
    const previousStepIsFinished = (previousStep !== null && previousStep !== void 0 ? previousStep : { finished: true })
      .finished;
    if (wizardStep != null && previousStepIsFinished) {
      (_a = this.contentSwitcher) === null || _a === void 0 ? void 0 : _a.showValue(this.currentstep, true);
      this.editWizardStep(wizardStep);
      this.currentStepChange.emit(this.currentstep);
    }
    else {
      if (wizardStep) {
        console.warn("You cannot navigate to a step when the previous steps aren't finished yet.", this.self);
      }
      else {
        console.error(`There is no step which defines the value property with the value '${this.currentstep}'\nPossible values are [${this.steps
          .map((step) => `"${step.value}"`)
          .join(", ")}]`, this.self);
      }
      this.currentstep = oldValue;
    }
    this.buildPageIndexTypes();
  }
  connectedCallback() {
    var _a;
    this.initializeBreakpointAware();
    this.initializeSlotObserver();
    elementIdHandling.verifyElementId(this.self);
    assert.assert(((_a = this.headline) === null || _a === void 0 ? void 0 : _a.length) > 0, () => "It is mandatory to define the headline property. Please set it's value to the current page's headline.", this.self);
  }
  disconnectedCallback() {
    this.slotObserver.disconnect();
    this.breakpointAware.disconnect();
  }
  onWizardStepFinishedChange(e) {
    var _a;
    const oldStepStates = this.steps.map((step) => step.state);
    const wizardStep = e.target;
    const extendedWizardStep = this.getExtendedWizardStep(wizardStep.value);
    if (extendedWizardStep != null) {
      const finished = e.detail;
      if (finished) {
        extendedWizardStep.finished = true;
        extendedWizardStep.state = "finished";
        const index = this.steps.indexOf(extendedWizardStep);
        const nextStep = this.steps[index + 1];
        if (nextStep) {
          nextStep.state = "edit";
          this.currentstep = nextStep.value;
        }
      }
      else if (extendedWizardStep.state === "finished") {
        extendedWizardStep.finished = false;
        extendedWizardStep.state = "visited";
      }
      else if (extendedWizardStep.state === "edit") {
        extendedWizardStep.finished = false;
      }
    }
    this.buildWizardStepStates();
    const newStep = (_a = this.getCurrentEditedStep()) === null || _a === void 0 ? void 0 : _a.value;
    if (newStep !== this.currentstep) {
      this.currentstep = newStep;
    }
    else {
      // We want to forceUpdate if the step states changed.
      // If newStep was already !== this.currentstep the render would trigger anyway and we don't need to compare the arrays.
      const newStepStates = this.steps.map((step) => step.state);
      if (!miscUtil.sameArrayInOrder(oldStepStates, newStepStates)) {
        index.forceUpdate(this.self);
      }
    }
  }
  initializeBreakpointAware() {
    this.breakpointAware = new breakpointAware.BreakpointAware(() => {
      this.updateInternalOrientation();
      if (!this.isMobileView()) {
        this.modal.visible = false;
      }
      index.forceUpdate(this);
    }, true);
  }
  initializeSlotObserver() {
    let initialized = false;
    this.slotObserver = new slotObserver.SlotObserver(this.self, ":scope > dx-wizard-step", async (steps) => {
      var _a, _b;
      await this.collectWizardSteps(steps);
      this.updateInternalOrientation();
      if (!initialized) {
        this.buildWizardStepStates();
        initialized = true;
        // We don't want to set the property if it is already defined from outside.
        this.currentstep || (this.currentstep = (_a = this.getCurrentEditedStep()) === null || _a === void 0 ? void 0 : _a.value);
      }
      else {
        this.currentstep = (_b = this.getCurrentEditedStep()) === null || _b === void 0 ? void 0 : _b.value;
      }
      this.buildPageIndexTypes();
    });
  }
  getCurrentEditedStep() {
    var _a;
    return (_a = this.steps.find((step) => step.state === "edit")) !== null && _a !== void 0 ? _a : this.steps[0];
  }
  getExpandedViewOrientation() {
    var _a;
    if (this.orientation === "vertical" || ((_a = this.steps) === null || _a === void 0 ? void 0 : _a.length) > 6) {
      return "vertical";
    }
    return "horizontal";
  }
  buildWizardStepStates() {
    let indexOfLastFinished = this.steps.findIndex((step) => !step.finished) - 1;
    const lastIndex = this.steps.length - 1;
    indexOfLastFinished =
      indexOfLastFinished < -1 ? lastIndex : indexOfLastFinished;
    const currentEditedIndex = mathUtil.clamp(this.steps.indexOf(this.getExtendedWizardStep(this.currentstep)), 0, indexOfLastFinished + 1);
    const lastIsFinished = indexOfLastFinished === lastIndex;
    this.steps.forEach((step, index) => {
      const isLastAndFinished = index === lastIndex && lastIsFinished;
      const isCurrentEditedAndFinished = index === currentEditedIndex &&
        step.finished &&
        currentEditedIndex <= indexOfLastFinished;
      if (index === currentEditedIndex &&
        currentEditedIndex <= indexOfLastFinished + 1) {
        step.state = "edit";
      }
      else if (currentEditedIndex === -1 &&
        (index === indexOfLastFinished + 1 || isLastAndFinished)) {
        step.state = "edit";
      }
      else if (index <= indexOfLastFinished) {
        step.state = "finished";
      }
      else if (index - 1 === indexOfLastFinished) {
        step.state = "visited";
      }
      else {
        step.state = "unvisited";
      }
      step.finished =
        step.state === "finished" ||
          isLastAndFinished ||
          isCurrentEditedAndFinished;
      if (step.metaStepComponent.finished !== step.finished) {
        step.metaStepComponent.finished = step.finished;
      }
    });
  }
  buildPageIndexTypes() {
    var _a, _b, _c, _d;
    const currentPage = ((_b = (_a = this.steps) === null || _a === void 0 ? void 0 : _a.indexOf(this.getCurrentEditedStep())) !== null && _b !== void 0 ? _b : 0) + 1;
    this.pageIndexTypes = pageIndexType.generatePageIndexTypes(currentPage, (_d = (_c = this.steps) === null || _c === void 0 ? void 0 : _c.length) !== null && _d !== void 0 ? _d : 0, MAX_VISIBLE_STEPS);
  }
  setInternalOrientation(orientation) {
    if (this.internalOrientation === orientation) {
      return;
    }
    this.internalOrientation = orientation;
    this.buildPageIndexTypes();
  }
  getExtendedWizardStep(value) {
    var _a;
    return (_a = this.steps) === null || _a === void 0 ? void 0 : _a.find((step) => step.value === value);
  }
  onWizardStepInteraction(e) {
    const wizardStep = e.target;
    const extendedWizardStep = this.getExtendedWizardStep(wizardStep.value);
    if (extendedWizardStep != null) {
      this.editWizardStep(extendedWizardStep);
      extendedWizardStep.interact();
      this.modal.visible = false;
    }
  }
  editWizardStep(wizardStep) {
    const currentEditedStep = this.getCurrentEditedStep();
    if (currentEditedStep != null) {
      currentEditedStep.state = currentEditedStep.finished
        ? "finished"
        : "visited";
    }
    this.currentstep = wizardStep.value;
    wizardStep.state = "edit";
  }
  async collectWizardSteps(steps) {
    var _a;
    const collectedSteps = await Promise.all(steps.map((step) => step.toWizardStep()));
    this.steps = collectedSteps.map((collectedStep) => {
      var _a, _b;
      return Object.assign(Object.assign({}, collectedStep), { state: (_b = (_a = this.getExtendedWizardStep(collectedStep.value)) === null || _a === void 0 ? void 0 : _a.state) !== null && _b !== void 0 ? _b : "unvisited" });
    });
    assert.assert(((_a = this.steps) === null || _a === void 0 ? void 0 : _a.length) > 1, () => "A <dx-wizard> component must have at least 2 different steps!", this.self);
  }
  updateInternalOrientation() {
    if (this.getExpandedViewOrientation() === "vertical") {
      this.setInternalOrientation(this.isMobileView() ? "horizontal" : "vertical");
    }
    else {
      this.setInternalOrientation("horizontal");
    }
  }
  isMobileViewForBreakpoint(breakpoint) {
    switch (breakpoint) {
      case gridModels.GridBreakpoint.MQ1:
        return true;
      case gridModels.GridBreakpoint.MQ2:
        return (this.getExpandedViewOrientation() === "vertical" ||
          this.expandedlayoutat === "mq3" ||
          this.expandedlayoutat === "mq4");
      case gridModels.GridBreakpoint.MQ3:
        return this.expandedlayoutat === "mq4";
      default:
        return false;
    }
  }
  isMobileView() {
    return this.breakpointAware.getEffectiveValue({
      mq1: this.isMobileViewForBreakpoint(gridModels.GridBreakpoint.MQ1),
      mq2: this.isMobileViewForBreakpoint(gridModels.GridBreakpoint.MQ2),
      mq3: this.isMobileViewForBreakpoint(gridModels.GridBreakpoint.MQ3),
      mq4: this.isMobileViewForBreakpoint(gridModels.GridBreakpoint.MQ4),
      mq5: this.isMobileViewForBreakpoint(gridModels.GridBreakpoint.MQ5)
    });
  }
  renderStepDisplayText() {
    var _a, _b;
    const currentStep = this.steps.findIndex((step) => step.value === this.currentstep) + 1;
    const maxSteps = (_b = (_a = this.steps) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0;
    return (index.h("dx-text", { type: "its", color: "headline" }, "Schritt ", currentStep, " von ", maxSteps));
  }
  renderCurrentStepLabel() {
    var _a;
    return (index.h("dx-text", { class: "current-step-label", color: "headline", type: "ps-bold" }, (_a = this.getCurrentEditedStep()) === null || _a === void 0 ? void 0 : _a.label));
  }
  renderGap(isVisible, leftLineIsBlue, rightLineIsBlue) {
    return (index.h("div", { class: { "gap-container": true, visible: isVisible } }, index.h("div", { class: "gap" }, index.h("div", { class: {
        "horizontal-line": true,
        left: true,
        blue: leftLineIsBlue,
      } }), index.h("div", { class: { circle: true, blue: leftLineIsBlue || rightLineIsBlue } }), index.h("div", { class: {
        circle: true,
        center: true,
        blue: leftLineIsBlue || rightLineIsBlue,
      } }), index.h("div", { class: { circle: true, blue: leftLineIsBlue || rightLineIsBlue } }), index.h("div", { class: {
        "horizontal-line": true,
        right: true,
        blue: rightLineIsBlue,
      } }))));
  }
  renderFirstGap(isVisible) {
    // Normally the first gap has always left and right blue lines because it wouldn't be visible otherwise
    const isFirstStepFinished = this.steps[0].finished;
    return this.renderGap(isVisible, isFirstStepFinished, isFirstStepFinished);
  }
  renderLastGap(isVisible) {
    const isPreviousStepFinished = isVisible &&
      this.steps[this.pageIndexTypes[this.pageIndexTypes.length - 3] - 1].finished;
    const isPenultimateFinished = isVisible && this.steps[this.steps.length - 2].finished;
    return this.renderGap(isVisible, isPreviousStepFinished, isPenultimateFinished);
  }
  getLastVisitedStepIndex() {
    for (let i = this.steps.length - 1; i >= 0; --i) {
      const step = this.steps[i];
      if (["visited", "edit", "finished"].includes(step.state)) {
        return i;
      }
    }
    return -1;
  }
  renderWizardStep(wizardStepRenderPayload) {
    const { extendedWizardStep, orientation, index: index$1, indexOfLastVisitedStep, visible, useExtendedView, } = wizardStepRenderPayload;
    return (index.h("dx-internal-wizard-step", { id: elementIdHandling.ElementIdGenerator.createId(extendedWizardStep.metaStepComponent, "internal"), class: "wizard-step", state: extendedWizardStep.state, finished: extendedWizardStep.finished, label: extendedWizardStep.label, value: extendedWizardStep.value, orientation: orientation, neighborIsInteractive: index$1 < indexOfLastVisitedStep, isFirstStep: index$1 === 0, isLastStep: index$1 === this.steps.length - 1, onInteraction: (e) => this.onWizardStepInteraction(e), key: index$1, hidden: !visible, isExtendedView: useExtendedView }));
  }
  renderWizardSteps(wizardStepsConfig) {
    var _a, _b, _c, _d, _e;
    const orientation = (_a = wizardStepsConfig === null || wizardStepsConfig === void 0 ? void 0 : wizardStepsConfig.overrideOrientation) !== null && _a !== void 0 ? _a : this.internalOrientation;
    const indexOfLastVisitedStep = this.getLastVisitedStepIndex();
    const isHorizontalOrientation = orientation === "horizontal";
    const hasFirstGap = isHorizontalOrientation && ((_b = this.pageIndexTypes) === null || _b === void 0 ? void 0 : _b[1]) === pageIndexType.GAP;
    const hasLastGap = isHorizontalOrientation &&
      ((_c = this.pageIndexTypes) === null || _c === void 0 ? void 0 : _c[((_d = this.pageIndexTypes) === null || _d === void 0 ? void 0 : _d.length) - 2]) === pageIndexType.GAP;
    const isExtendedView = (_e = wizardStepsConfig === null || wizardStepsConfig === void 0 ? void 0 : wizardStepsConfig.overrideUseExtendedView) !== null && _e !== void 0 ? _e : !this.isMobileView();
    return [
      this.renderWizardStep({
        extendedWizardStep: this.steps[0],
        orientation: orientation,
        index: 0,
        indexOfLastVisitedStep,
        visible: true,
        useExtendedView: isExtendedView,
      }),
      this.renderFirstGap(hasFirstGap),
      this.steps.map((step, index) => {
        if (index === 0 || index === this.steps.length - 1) {
          return null;
        }
        return this.renderWizardStep({
          extendedWizardStep: step,
          orientation: orientation,
          index,
          indexOfLastVisitedStep,
          visible: !isHorizontalOrientation || this.pageIndexTypes.includes(index + 1),
          useExtendedView: isExtendedView,
        });
      }),
      this.renderLastGap(hasLastGap),
      this.renderWizardStep({
        extendedWizardStep: this.steps[this.steps.length - 1],
        orientation: orientation,
        index: this.steps.length - 1,
        indexOfLastVisitedStep,
        visible: true,
        useExtendedView: isExtendedView,
      }),
    ];
  }
  getConnectedContentSlots() {
    const slots = renderUtil.getDefinedSlots(this.self).filter((slot) => !["", wizard_util.CONTENT_SLOT_NAME].includes(slot));
    // Get all slots which have a corresponding step and find their index.
    const slotToStepIndices = slots
      .map((slot) => {
      return {
        slot,
        stepIndex: this.steps.findIndex((step) => step.value === slot),
      };
    })
      .filter((slotToStepIndex) => slotToStepIndex.stepIndex !== -1);
    // Sort the slots by the step order and map them back to their slot name.
    return slotToStepIndices
      .sort((first, second) => first.stepIndex - second.stepIndex)
      .map((slotToStepIndex) => slotToStepIndex.slot);
  }
  renderContextContainer() {
    if (!this.isMobileView()) {
      return index.h("div", null);
    }
    return (index.h("button", { id: elementIdHandling.ElementIdGenerator.createId(this.self, "context-control"), class: "context-container", onClick: () => {
        this.modal.visible = true;
      } }, index.h("div", { class: "current-step-container" }, index.h("div", { class: "steps-counter" }, this.renderStepDisplayText()), index.h("div", null, this.renderCurrentStepLabel())), index.h("dx-button", { type: "text", icon: "ueberlauf-menue", id: elementIdHandling.ElementIdGenerator.createId(this.self, "context-button") })));
  }
  renderContent() {
    const connectedSlots = this.getConnectedContentSlots();
    if (connectedSlots.length === 0) {
      // Just display the content slot and let the user handle the view.
      return (index.h("div", { class: "content-slot" }, index.h("slot", { name: wizard_util.CONTENT_SLOT_NAME })));
    }
    return (index.h("dx-content-switcher", { key: "content-switcher", value: this.currentstep, ref: (contentSwitcher) => {
        var _a;
        if (this.contentSwitcher !== contentSwitcher) {
          this.contentSwitcher = contentSwitcher;
          if (this.currentstep != null) {
            (_a = this.contentSwitcher) === null || _a === void 0 ? void 0 : _a.showValue(this.currentstep, false);
          }
        }
      } }, connectedSlots.map((slot) => (index.h("dx-content-switcher-item", { value: slot }, index.h("slot", { name: slot }))))));
  }
  renderView() {
    const content = [
      index.h("div", { class: {
          "wizard-steps-container": true,
        } }, index.h("div", { class: { "wizard-steps": true, visible: this.stepsAreVisible } }, this.renderWizardSteps()), this.renderContextContainer()),
      this.renderContent(),
    ];
    const useVerticalGridParameters = this.getExpandedViewOrientation() === "vertical";
    // Returns the columns dependent on whether to use a vertical, horizontal or mobile view
    const getGridParams = (columns, useMobileView) => {
      if (useMobileView) {
        return undefined;
      }
      return useVerticalGridParameters ? `${columns}-${12 - columns}` : "12/*";
    };
    return (index.h("dx-grid", { key: "grid", rowgap: "32", mq1: "12/*", mq2: getGridParams(4, this.isMobileViewForBreakpoint(gridModels.GridBreakpoint.MQ2)), mq3: getGridParams(4, this.isMobileViewForBreakpoint(gridModels.GridBreakpoint.MQ3)), mq4: getGridParams(3, this.isMobileViewForBreakpoint(gridModels.GridBreakpoint.MQ4)), mq5: getGridParams(3, this.isMobileViewForBreakpoint(gridModels.GridBreakpoint.MQ5)) }, content));
  }
  render() {
    var _a, _b;
    if (this.steps == null) {
      return;
    }
    const orientationIsHorizontal = this.internalOrientation === "horizontal";
    return (index.h(index.Host, { style: {
        "--dx-wizard-step-count": Math.min((_b = (_a = this.steps) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0, MAX_VISIBLE_STEPS).toString(),
      }, class: {
        "expanded-layout-at-mq2": !this.isMobileViewForBreakpoint(gridModels.GridBreakpoint.MQ2),
        "expanded-layout-at-mq3": !this.isMobileViewForBreakpoint(gridModels.GridBreakpoint.MQ3),
        "expanded-layout-at-mq4": !this.isMobileViewForBreakpoint(gridModels.GridBreakpoint.MQ4),
        "orientation-horizontal": orientationIsHorizontal,
        "orientation-vertical": !orientationIsHorizontal,
      } }, this.renderView(), index.h("dx-modal", { id: elementIdHandling.ElementIdGenerator.createId(this.self, "steps-modal"), width: "internal-site-navigation-menu", height: "internal-site-navigation-menu", label: this.headline, class: "modal", ref: (modal) => (this.modal = modal) }, index.h("div", { slot: "content" }, this.renderWizardSteps({
      overrideOrientation: "vertical",
      overrideUseExtendedView: true,
    })))));
  }
  get self() { return index.getElement(this); }
  static get watchers() { return {
    "orientation": ["onOrientationChanged"],
    "currentstep": ["onValueChanged"]
  }; }
};
const MAX_VISIBLE_STEPS = 7;
DxWizard.style = dxWizardCss;

exports.dx_wizard = DxWizard;
