'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const index = require('./index-2f41386b.js');
const elementIdHandling = require('./element-id-handling-89898a1c.js');
const baseElements = require('./base-elements-f50ffdf3.js');
const newKiSnycIcon = require('./new-ki-snyc-icon-665f6e39.js');
const slotObserver = require('./slot-observer-2e83212e.js');
const preciseCssSetter = require('./precise-css-setter-3049fed6.js');
const mathUtil = require('./math-util-a514efc6.js');
const breakpointAware = require('./breakpoint-aware-cc9d0ee6.js');
const async = require('./async-da958283.js');
const miscUtil = require('./misc-util-63b423bd.js');
const assert = require('./assert-d8ea75c6.js');
const renderUtil = require('./render-util-6b278c0d.js');
const dragController = require('./drag-controller-fb679cde.js');
const sizes_util = require('./sizes.util-a4bacea6.js');
require('./value-store-f683b26f.js');
require('./query-util-8642f149.js');

const dxCheckboxCss = ":host{display:block;width:fit-content;width:-moz-fit-content}:host:host([hidden]){display:none !important}:host .checkbox-label-container{--dx-text-color:#2b2b2b;min-height:40px;position:relative;display:flex;box-sizing:border-box;align-items:baseline;padding:8px 0}@media (min-width: 1280px){:host .checkbox-label-container{padding:6px 0}}:host .checkbox-label-container .baseline-container{display:flex;align-items:center}:host .checkbox-label-container .baseline-container .checkbox{width:24px;height:24px;box-sizing:border-box}:host .checkbox-label-container .baseline-container .checkbox:not(.read-only){border:1px solid #337a96;transition:background-color 150ms ease-in-out}:host .checkbox-label-container .baseline-container .checkbox:not(.read-only) dx-icon{position:relative;top:-1px;left:-1px}:host .checkbox-label-container .baseline-container .baseline-text{width:0}:host .checkbox-label-container .label-and-icon-container{display:flex;align-items:center}:host .checkbox-label-container .label-and-icon-container .ki-sync-icon-container.two-icons-present{margin-left:4px}:host .checkbox-label-container .label-text.margin-right{margin-right:4px}:host .checkbox-label-container .required-icon{flex-shrink:0;vertical-align:sub}@media (min-width: 1280px){:host .checkbox-label-container .required-icon{vertical-align:text-top}}:host .checkbox-label-container.contains-label .checkbox{margin-right:16px}:host .native-input-container{position:relative}:host .native-input-container .native-input{position:absolute;cursor:pointer;left:0;top:0;width:100%;height:100%;opacity:0;margin:0;padding:0;z-index:1}:host .native-input-container .native-input:disabled{pointer-events:none;cursor:default}:host .native-input-container .native-input:disabled+.checkbox-label-container{opacity:0.4}:host .native-input-container .native-input:checked+.checkbox-label-container .checkbox{background-color:#004763;border-color:#004763;--dx-icon-color:#ffffff}@media not all and (pointer: coarse){:host .native-input-container .native-input:checked:hover+.checkbox-label-container .checkbox{background-color:#196989;border-color:#196989}}:host .native-input-container .native-input:checked:active+.checkbox-label-container .checkbox{background-color:#4c8aa3;border-color:#4c8aa3}:host .native-input-container .native-input:not(:checked)+.checkbox-label-container .checkbox{background-color:white;border:1px solid #337a96;--dx-icon-color:transparent}@media not all and (pointer: coarse){:host .native-input-container .native-input:not(:checked):hover+.checkbox-label-container .checkbox{background-color:#e5eef2;border-color:#00587c}}:host .native-input-container .native-input:not(:checked):active+.checkbox-label-container .checkbox{background-color:#ccdee5;border-color:#004763}:host .native-input-container .native-input:focus-visible+.checkbox-label-container{outline-offset:2px;outline:2px solid #004763}";

const DxCheckBox = class {
  constructor(hostRef) {
    index.registerInstance(this, hostRef);
    this.checkedChange = index.createEvent(this, "checkedChange", 7);
    /**
     * Disables the ability to interact with this component.
     *
     * @value false: User can interact with this component.
     * @value true: User cannot interact with this component.
     *
     * @example disabled
     */
    this.disabled = false;
    /**
     * Defines if the checkbox is in a read-only state.
     * If the `checked` property is false, the component will not be rendered.
     * @value false: The checkbox is displayed normally.
     * @value true: A success icon and the label are displayed next to each other.
     * @example readonly
     */
    this.readonly = false;
    /**
     * Defines if the checkbox is a required form element.
     * @value false: It is not required to set the checkbox`s `checked` state to true.
     * @value true: The checkbox's `checked` state has to be true to fulfill the requirement.
     * @example required
     */
    this.required = false;
    /**
     * Indicates that the form is synced with the KI.
     * @value true: Synchronized.
     * @value false: Not synchronized.
     * @example kisynced
     */
    this.kisynced = false;
    /**
     * Defines whether the checkbox is checked or not.
     * @value false: Checkbox is unchecked.
     * @value true: Checkbox is checked.
     *
     * @example checked
     */
    this.checked = false;
  }
  /**
   * Sets the focus on this component.
   * @example focus
   */
  async focusControl() {
    var _a;
    (_a = this.inputElement) === null || _a === void 0 ? void 0 : _a.focus();
  }
  componentWillLoad() {
    elementIdHandling.verifyElementId(this.self);
  }
  check(checked) {
    if (!this.disabled) {
      this.checked = checked;
      this.checkedChange.emit(this.checked);
    }
  }
  toggle(e) {
    if (e.code === "Enter") {
      this.check(!this.checked);
    }
  }
  onForceUpdateOnChange(e) {
    e.stopPropagation();
    e.detail(this);
  }
  renderIcon(icon, color) {
    return index.h("dx-icon", { size: 24, icon: icon, color: color });
  }
  renderCheckboxLabelContainerIcon(type) {
    switch (type) {
      case "interactive":
        return this.renderIcon("check");
      case "readonly":
        return this.renderIcon("check", "headline");
    }
  }
  renderRequiredIcon() {
    if (!this.required || !this.label) {
      return;
    }
    return (index.h("dx-icon", { class: "required-icon", icon: "state-required", size: 16 }));
  }
  renderKiSyncIcon() {
    if (!this.kisynced) {
      return;
    }
    return (index.h("div", { class: {
        "ki-sync-icon-container": true,
        "two-icons-present": this.required && this.kisynced,
      } }, index.h(newKiSnycIcon.NewKiSyncIcon, null)));
  }
  renderCheckboxLabelContainer(containerType) {
    var _a;
    return (index.h("div", { class: {
        "checkbox-label-container": true,
        "contains-label": ((_a = this.label) === null || _a === void 0 ? void 0 : _a.length) > 0,
        interactable: containerType === "interactive",
      } }, index.h("div", { class: "baseline-container" }, index.h(baseElements.BaselineElement, null), index.h("div", { class: {
        checkbox: true,
        "read-only": containerType === "readonly",
        checked: this.checked,
      } }, this.renderCheckboxLabelContainerIcon(containerType))), index.h("div", { class: "label-and-icon-container" }, index.h("dx-text", { class: {
        "label-text": true,
        "margin-right": this.required || this.kisynced,
      } }, this.label), this.renderRequiredIcon(), this.renderKiSyncIcon())));
  }
  renderReadOnly() {
    if (!this.checked) {
      return;
    }
    return index.h(index.Host, null, this.renderCheckboxLabelContainer("readonly"));
  }
  render() {
    if (this.readonly) {
      return this.renderReadOnly();
    }
    const nativeInputId = elementIdHandling.ElementIdGenerator.createId(this.self, "control");
    return (index.h(index.Host, null, index.h("dx-form-wrapper", { id: elementIdHandling.ElementIdGenerator.createId(this.self, "error-message"), errormessage: this.errormessage, ref: (ref) => {
        if (ref) {
          index.forceUpdate(ref);
        }
      } }, index.h("div", { class: "native-input-container" }, index.h("input", { id: nativeInputId, type: "checkbox", class: "native-input", disabled: this.disabled, checked: this.checked, ref: (ref) => (this.inputElement = ref), onChange: (e) => {
        this.check(e.target.checked);
      } }), this.renderCheckboxLabelContainer("interactive")), index.h("slot", { name: "error-message", slot: "error-message" }))));
  }
  get self() { return index.getElement(this); }
};
DxCheckBox.style = dxCheckboxCss;

const dxFlyoutCss = ":host{display:block;--dx-simple-grow-box-border-top-width:1px;--dx-simple-grow-box-border-right-width:1px;--dx-simple-grow-box-border-bottom-width:1px;--dx-simple-grow-box-border-left-width:1px;--dx-simple-grow-box-border-color:#d6d6d6}:host:host([hidden]){display:none !important}:host .flyout-grow-box{min-width:var(--dx-flyout-simple-grow-box-min-width, unset);width:var(--dx-flyout-simple-grow-box-width, unset)}";

const DxFlyout = class {
  constructor(hostRef) {
    index.registerInstance(this, hostRef);
    this.open = false;
    this.position = "bottom";
    this.direction = "right";
    this.offsety = 0;
    this.hideoverlay = false;
    this.disableOverlay = false;
  }
  onOpenChanged() {
    if (this.open) {
      this.disableOverlay = false;
    }
  }
  connectedCallback() {
    this.disableOverlay = !this.open;
  }
  updateAlignment() {
    this.internalAlignment = {
      alignTop: this.position === "top",
      alignRight: this.direction === "left",
    };
  }
  componentWillRender() {
    this.updateAlignment();
  }
  renderPopupContent() {
    if (this.hideoverlay) {
      return;
    }
    return (index.h("dx-simple-grow-box", { slot: "overlay", class: "flyout-grow-box", tabIndex: -1, open: this.open, animationmode: this.internalAlignment.alignTop ? "bottom-to-top" : "top-to-bottom", onGrowBoxStateChange: (e) => {
        this.disableOverlay = e.detail === "closed";
      }, reservespaceonopen: true }, index.h("slot", { name: "overlay" })));
  }
  render() {
    return (index.h(index.Host, null, index.h("dx-overlay", { position: this.position, anchorposition: this.direction === "left" ? "right" : "left", offsety: this.offsety, popupinteractable: this.open, disabled: this.disableOverlay }, index.h("slot", null), this.renderPopupContent()), " "));
  }
  get self() { return index.getElement(this); }
  static get watchers() { return {
    "open": ["onOpenChanged"]
  }; }
};
DxFlyout.style = dxFlyoutCss;

const dxListCss = ":host{display:block;width:100%;--dx-simple-grow-box-border-top-width:0px;--dx-simple-grow-box-border-right-width:1px;--dx-simple-grow-box-border-bottom-width:1px;--dx-simple-grow-box-border-left-width:1px;--dx-simple-grow-box-border-color:#d6d6d6}:host:host([hidden]){display:none !important}:host:host(.content){min-width:max-content}:host .list-container{display:flex;flex-direction:column;pointer-events:all;background-color:white}:host ::slotted(dx-list-item:last-child){--dx-list-item-border-bottom:none}";

const DxList = class {
  constructor(hostRef) {
    index.registerInstance(this, hostRef);
    /**
     * The default size of the underlying `dx-list-item` elements.
     * @value m: default sized list
     * @value l: large sized list
     * @example size
     */
    this.size = "m";
    /**
     * Indicates whether the list is keeping its width according to the biggest child or keeping the parent's width and wrap the inner labels of the `dx-list-item` elements.
     *
     * @value parent: The list does not overflow the parent width. The labels of the underlying `dx-list-item` elements wrap themselves.
     * @value content: The biggest `dx-list-item` element purports the width of the list.
     */
    this.width = "parent";
    /**
     * Defines whether the content of the child `<dx-list-item>` elements display their content next to or below the label.
     *
     * @value true: The content of the child `<dx-list-item>` elements is displayed below their label.
     * @value false: The content of the child `<dx-list-item>` elements is displayed next to their label.
     */
    this.contentbelow = false;
  }
  connectedCallback() {
    this.slotObserver = new slotObserver.SlotObserver(this.self, "*", () => {
      this.updateChildren();
    });
  }
  componentWillRender() {
    this.updateChildren();
  }
  disconnectedCallback() {
    this.slotObserver.disconnect();
  }
  updateChildren() {
    // Ignore list-items which already are in another dx-list
    const listItems = this.self.querySelectorAll("dx-list-item:not(dx-list:not(:scope) > dx-list-item)");
    listItems.forEach((listItem, index) => {
      listItem.internalcontentbelow = this.contentbelow;
      listItem.internalsize = this.size;
      if (index + 1 === listItems.length) {
        listItem.style.setProperty("--dx-list-item-border-bottom", "none");
      }
      else {
        listItem.style.removeProperty("--dx-list-item-border-bottom");
      }
    });
  }
  render() {
    return (index.h(index.Host, { class: {
        content: this.width === "content",
      } }, index.h("div", { class: {
        "list-container": true,
      } }, index.h("slot", null))));
  }
  get self() { return index.getElement(this); }
};
DxList.style = dxListCss;

const dxListFlyoutCss = ":host{--dx-list-item-background-color-active:#ccdee5;--dx-list-item-select-indicator-color:#004763;--dx-list-item-text-color-selected:#004763;--dx-list-item-background-color-selected:#e5eef2;--dx-list-item-background-color-hover:#e5eef2;display:block;--dx-simple-grow-box-border-top-width:1px;--dx-simple-grow-box-border-right-width:1px;--dx-simple-grow-box-border-bottom-width:1px;--dx-simple-grow-box-border-left-width:1px;--dx-list-item-outline:none;--dx-simple-grow-box-border-color:#d6d6d6}:host:host([hidden]){display:none !important}:host .scroll-container{width:100%;overflow-y:auto;pointer-events:all}";

const DxListFlyout = class {
  constructor(hostRef) {
    index.registerInstance(this, hostRef);
    this.itemSelectionChange = index.createEvent(this, "itemSelectionChange", 7);
    this.positionChange = index.createEvent(this, "positionChange", 7);
    this.scrollHandle = () => this.updateScrollContainerMaxHeight();
    this.currentHighlightedItem = -1;
    this.listItems = [];
    this.defaultSlottedElements = [];
    this.open = false;
    this.position = "bottom";
    this.direction = "right";
    this.preventSpaceSelection = false;
    this.preventArrowSelection = false;
    this.size = "m";
    this.selectionmode = "single";
    this.stopclickpropagationonpopup = false;
    this.defaulthighlightfirst = false;
    this.focusable = true;
    /**
     * Automatically clears the current selected item when the list closes.
     */
    this.clearselectiononclose = false;
    /**
     * Whether a list item should be selected when focused with the keyboard or not.
     */
    this.selectonhighlight = true;
    // Only trigger render, when number changes.
    this.numberOfListItems = 0;
    this.internalPosition = "bottom";
    this.maxheight = null;
  }
  onMaxSelectionsChanged() {
    this.updateListItemsDisabledState();
  }
  componentWillLoad() {
    this.internalPosition = this.position;
  }
  connectedCallback() {
    this.breakpointAware = new breakpointAware.BreakpointAware(() => index.forceUpdate(this), true);
    this.mutationObserver = this.createMutationObserver();
    this.mutationObserver.observe(this.self, {
      childList: true,
      subtree: true,
      attributes: true,
    });
    this.updateUpperScrollContainer();
    // In case of hydration the upper scroll container is not always available on startup (e.g. dx-modal scrollable content)
    setTimeout(() => {
      this.updateUpperScrollContainer();
    }, 1000);
  }
  createMutationObserver() {
    const onFocus = (e) => this.handleListItemFocus(e);
    // We want to prevent the mouse down event on all list items to prevent the focus on mousedown because the focus
    // event triggers the list flyout container to scroll to the corresponding list item.
    const onMouseDown = (e) => {
      e.preventDefault();
      const element = e.target;
      if (miscUtil.tagOf(element) === "dx-list-item") {
        element.classList.add("force-active");
      }
    };
    return new MutationObserver(() => {
      var _a;
      this.defaultSlottedElements = miscUtil.getSlottedContent(this.self).filter((element) => !element.slot);
      this.listItems = this.getListItems();
      this.numberOfListItems = this.listItems.length;
      this.listItems.forEach((listItem) => {
        listItem.removeEventListener("focus", onFocus);
        listItem.addEventListener("focus", onFocus);
        listItem.removeEventListener("mousedown", onMouseDown);
        listItem.addEventListener("mousedown", onMouseDown);
      });
      if (this.selectionmode === "single") {
        const selectedNodes = this.listItems.filter((node) => node.selected);
        if (selectedNodes.length > 1) {
          console.error("There can only be one selected item at a time. Please set 'selectionmode' to \"multi\".\n", this.self);
        }
      }
      if (!this.open && this.clearselectiononclose) {
        this.clearSelection();
      }
      this.updateListItemsDisabledState();
      if (this.defaulthighlightfirst &&
        ((_a = this.listItems) === null || _a === void 0 ? void 0 : _a.length) > 0 &&
        this.currentHighlightedItem === -1) {
        this.highlightItem(0);
      }
    });
  }
  getListItems() {
    return this.defaultSlottedElements
      .map((element) => {
      if (miscUtil.tagOf(element) === "dx-list-item") {
        return new Array(element);
      }
      else {
        return Array.from(element.querySelectorAll("dx-list-item"));
      }
    })
      .flat();
  }
  disconnectedCallback() {
    var _a, _b;
    (_a = this.mutationObserver) === null || _a === void 0 ? void 0 : _a.disconnect();
    this.removeScrollEventListener();
    this.upperScrollContainer.removeEventListener("scroll", this.scrollHandle);
    (_b = this.breakpointAware) === null || _b === void 0 ? void 0 : _b.disconnect();
  }
  /**
   * Workaround for Firefox Bug:
   * https://bugzilla.mozilla.org/show_bug.cgi?id=771241
   *
   * Because of the preventDefault used in mousedown for every listItem the CSS :active state is not applied for the list items.
   */
  onWindowMouseUp() {
    var _a;
    (_a = this.listItems) === null || _a === void 0 ? void 0 : _a.forEach((listItem) => {
      listItem.classList.remove("force-active");
    });
  }
  updateUpperScrollContainer() {
    index.readTask(() => {
      this.upperScrollContainer = miscUtil.findClosestScrollElement(this.self);
      this.addScrollEventListener();
    });
  }
  addScrollEventListener() {
    // We have to listen to the window scroll when the upperScrollContainer equals the
    // documentElement, because it does not fire the scroll event.
    if (this.upperScrollContainer === document.documentElement) {
      window.addEventListener("scroll", this.scrollHandle);
    }
    else {
      this.upperScrollContainer.addEventListener("scroll", this.scrollHandle);
    }
  }
  removeScrollEventListener() {
    if (this.upperScrollContainer === document.documentElement) {
      window.removeEventListener("scroll", this.scrollHandle);
    }
    else {
      this.upperScrollContainer.removeEventListener("scroll", this.scrollHandle);
    }
  }
  handleListItemFocus(e) {
    const index = this.listItems.indexOf(e.target);
    this.highlightItem(index);
  }
  updateScrollContainerMaxHeight() {
    if (this.scrollContainer == null) {
      return;
    }
    index.writeTask(async () => {
      this.scrollContainer.style.maxHeight =
        (await this.getScrollContainerHeight()) + "px";
    });
  }
  getMinListHeight() {
    const numberOfListItems = this.self.querySelectorAll("dx-list-item").length || 1;
    const itemHeight = this.size === "m" ? ITEM_HEIGHT_PX_M : ITEM_HEIGHT_PX_L;
    const visibleItems = Math.min(numberOfListItems, this.itemsvisible || Infinity);
    return visibleItems * itemHeight - BORDER_PX;
  }
  async computeHeightToViewportEnd() {
    return new Promise((resolve) => {
      index.readTask(() => {
        var _a, _b;
        let position = this.position;
        let height;
        const belowHeight = (_b = (_a = this.self.shadowRoot.querySelector(".below-container")) === null || _a === void 0 ? void 0 : _a.offsetHeight) !== null && _b !== void 0 ? _b : 0;
        const offsetToViewport = 24;
        const upperScrollContainerBoundingClientRect = this.upperScrollContainer.getBoundingClientRect();
        const getHeightBottom = () => {
          var _a, _b;
          const relativeValue = this.upperScrollContainer === document.documentElement
            ? this.upperScrollContainer.clientHeight
            : upperScrollContainerBoundingClientRect.bottom;
          const selfPositionY = relativeValue - ((_b = (_a = this.self) === null || _a === void 0 ? void 0 : _a.getBoundingClientRect()) === null || _b === void 0 ? void 0 : _b.bottom);
          return (selfPositionY -
            offsetToViewport -
            belowHeight -
            this.getOffsetY("bottom"));
        };
        const getHeightTop = () => {
          var _a, _b;
          const relativeValue = this.upperScrollContainer === document.documentElement
            ? 0
            : upperScrollContainerBoundingClientRect.top;
          const selfPositionY = ((_b = (_a = this.self) === null || _a === void 0 ? void 0 : _a.getBoundingClientRect()) === null || _b === void 0 ? void 0 : _b.top) - relativeValue;
          return (selfPositionY -
            offsetToViewport -
            belowHeight -
            this.getOffsetY("top"));
        };
        if (position === "bottom") {
          height = getHeightBottom();
          if (height < this.getMinListHeight()) {
            const topHeight = getHeightTop();
            if (topHeight > height) {
              height = topHeight;
              position = "top";
            }
          }
        }
        else if (position === "top") {
          height = getHeightTop();
          if (height < this.getMinListHeight()) {
            const bottomHeight = getHeightBottom();
            if (bottomHeight > height) {
              height = bottomHeight;
              position = "bottom";
            }
          }
        }
        if (position !== this.internalPosition) {
          this.internalPosition = position;
          this.positionChange.emit(this.internalPosition);
        }
        resolve(height);
      });
    });
  }
  async getScrollContainerHeight() {
    const maxHeight = this.maxheight == null || isNaN(this.maxheight)
      ? Infinity
      : this.maxheight;
    return Math.min(maxHeight, await this.computeHeightToViewportEnd());
  }
  getExplicitSelectionKeys() {
    const keyCodes = ["Enter"];
    if (!this.preventArrowSelection) {
      keyCodes.push("ArrowRight", "ArrowLeft");
    }
    if (!this.preventSpaceSelection) {
      keyCodes.push("ArrowRight", "ArrowLeft");
    }
    return keyCodes;
  }
  handleSelectionInput(keyCode) {
    if (this.getExplicitSelectionKeys().includes(keyCode)) {
      if (this.currentHighlightedItem >= 0) {
        this.selectItem(this.currentHighlightedItem, "explicit");
      }
    }
  }
  onWindowResize() {
    this.updateScrollContainerMaxHeight();
  }
  onWindowScroll() {
    this.updateScrollContainerMaxHeight();
  }
  onListItemInteraction(e) {
    if (this.selectionmode == null) {
      return;
    }
    e.stopPropagation();
    this.selectItem(this.listItems.indexOf(e.target), "explicit");
  }
  focusItem(itemIndex) {
    if (this.scrollContainer == null) {
      return;
    }
    if (itemIndex > -1) {
      index.readTask(() => {
        const listHeight = this.scrollContainer.offsetHeight;
        let count = 0;
        const itemIndexWithinSlot = this.defaultSlottedElements.findIndex((element) => {
          if (miscUtil.tagOf(element) === "dx-list-item") {
            return count++ === itemIndex;
          }
          return false;
        });
        const arrayBeforeScrollToItem = itemIndexWithinSlot < 0
          ? []
          : this.defaultSlottedElements.slice(0, itemIndexWithinSlot);
        const heightBeforeScrollToItem = arrayBeforeScrollToItem.reduce((acc, element) => acc + element.offsetHeight, 0);
        const listItem = this.listItems[itemIndex];
        if (this.focusable) {
          async.unawaited(listItem.focusControl());
        }
        this.scrollContainer.scrollTo({
          top: heightBeforeScrollToItem +
            listItem.offsetHeight / 2 -
            listHeight / 2,
          behavior: "smooth",
        });
      });
    }
    else {
      this.scrollContainer.scrollTop = 0;
    }
  }
  onGrowBoxStateChanged(e) {
    const clearSelectionBecauseClosed = this.clearselectiononclose && e.detail === "closed";
    // If there is always only one selection we want to check if the list is closed and the selection should be cleared.
    // If not we highlight the current selected item.
    if (!clearSelectionBecauseClosed && this.selectionmode === "single") {
      this.highlightItem(this.listItems.findIndex((node) => node.selected));
      return;
    }
    // Otherwise we clear the highlight and the selection (only if clearselectiononclose is true)
    this.clearHighlighting();
    if (this.clearselectiononclose) {
      this.clearSelection();
    }
  }
  onKeyDown(e) {
    //Prevents the whole page from scrolling
    if ([
      "ArrowDown",
      "ArrowUp",
      "Space",
      "ArrowRight",
      "ArrowLeft",
      "Enter",
    ].includes(e.key)) {
      e.preventDefault();
    }
    this.handleUpDownNavigation(e.key);
    this.handleSelectionInput(e.key);
  }
  emitSelectionChange(reason) {
    this.itemSelectionChange.emit({
      selectedItems: this.listItems
        .filter((listItem) => listItem.selected)
        .map((listItem) => listItem.value),
      reason,
    });
  }
  clearSelection() {
    index.writeTask(() => {
      var _a;
      (_a = this.listItems) === null || _a === void 0 ? void 0 : _a.forEach((listItem) => {
        if (listItem.selected) {
          listItem.setAttribute("selected", "false");
        }
      });
    });
  }
  selectItem(itemIndex, reason) {
    const element = this.listItems[itemIndex];
    if (element == null) {
      return;
    }
    index.writeTask(() => {
      if (this.selectionmode === "single") {
        this.listItems.forEach((listItem) => {
          listItem.setAttribute("selected", (listItem === element).toString());
        });
      }
      else if (this.selectionmode === "multi") {
        element.setAttribute("selected", (!element.selected).toString());
      }
      this.emitSelectionChange(reason);
    });
    this.highlightItem(itemIndex);
    this.updateListItemsDisabledState();
  }
  updateListItemsDisabledState() {
    index.writeTask(() => {
      if (this.maxselections == null) {
        this.listItems.forEach((listItem) => {
          listItem.disabled = false;
        });
      }
      else {
        const currentSelections = this.listItems.filter((listItem) => listItem.selected).length;
        this.listItems
          .filter((listItem) => !listItem.selected)
          .forEach((listItem) => {
          listItem.disabled = currentSelections >= this.maxselections;
        });
      }
    });
  }
  handleUpDownNavigation(keyCode) {
    if (keyCode === "ArrowUp" || keyCode === "ArrowDown") {
      const listItems = this.listItems;
      const step = keyCode.includes("Down") ? 1 : -1;
      const nextOrPreviousIndex = mathUtil.clamp(this.currentHighlightedItem + step, -1, listItems.length);
      const nextHighlightedIndex = (nextOrPreviousIndex + listItems.length) % listItems.length;
      if (this.selectionmode === "single" && this.selectonhighlight) {
        this.selectItem(nextHighlightedIndex, "implicit");
      }
      else {
        this.highlightItem(nextHighlightedIndex);
      }
    }
  }
  highlightItem(itemIndex) {
    this.currentHighlightedItem = itemIndex;
    this.setHighlightStyles(itemIndex);
    this.focusItem(itemIndex);
  }
  setHighlightStyles(itemIndex) {
    index.writeTask(() => {
      this.listItems.forEach((item, index) => {
        const isHighlighted = itemIndex === index;
        new preciseCssSetter.PreciseCssSetter(item).set("highlighted", isHighlighted).execute();
      });
    });
  }
  clearHighlighting() {
    this.highlightItem(-1);
  }
  getOffsetY(position) {
    if ((position !== null && position !== void 0 ? position : this.internalPosition) === "top") {
      const offset = parseInt(getComputedStyle(this.self).getPropertyValue("--dx-overlay-offset"));
      return isNaN(offset) ? 0 : offset;
    }
    return 0;
  }
  componentWillRender() {
    this.updateUpperScrollContainer();
  }
  render() {
    return (index.h(index.Host, { tabIndex: -1 }, index.h("dx-flyout", { open: this.open, position: this.internalPosition, direction: this.direction, offsety: this.getOffsetY() }, index.h("slot", { name: "base" }), index.h("div", { slot: "overlay", class: {
        "scroll-container": true,
      }, ref: (ref) => {
        this.scrollContainer = ref;
        this.updateScrollContainerMaxHeight();
      }, onClick: (e) => {
        if (this.stopclickpropagationonpopup) {
          e.stopPropagation();
        }
      } }, index.h("dx-list", { class: { "list-container": true }, tabIndex: -1, size: this.size, width: "parent" }, index.h("slot", null))), index.h("div", { slot: "overlay", class: "below-container" }, index.h("slot", { name: "below" })))));
  }
  get self() { return index.getElement(this); }
  static get watchers() { return {
    "maxselections": ["onMaxSelectionsChanged"]
  }; }
};
const BORDER_PX = 1;
const ITEM_HEIGHT_PX_M = 48;
const ITEM_HEIGHT_PX_L = 64;
DxListFlyout.style = dxListFlyoutCss;

const dxListItemCss = ":host .left-container{display:flex;height:40px;align-items:center;min-width:var(--dx-list-mock-icon-container-width, 0)}:host .left-container .icon-drawer{flex-shrink:0}:host .left-container .icon-drawer .type-container{padding-right:16px}:host .left-container .icon-drawer .type-container .interactable-element{pointer-events:none;--dx-disabled-form-opacity:1;--dx-focus-outline-offset:0}:host .label-content-container{padding:4px 16px 3px 16px}:host(.size-medium) .content-below{padding-bottom:3px}:host(.size-medium) .labels{padding:8px 0}@media (min-width: 1280px){:host(.size-medium) .labels{padding:6px 0}}:host(.size-large) .left-container{padding-top:8px}:host(.size-large) .right-container{padding:8px 0}:host(.size-large) .content-below{padding-top:16px;padding-bottom:11px}:host(.size-large) .labels{padding:16px 0}@media (min-width: 1280px){:host(.size-large) .labels{padding:14px 0}}:host(.content-below) .labels{padding-bottom:0}:host(.content-below):host(.size-large) .content-container{padding-bottom:8px}:host{display:block;position:relative}:host:host([hidden]){display:none !important}:host:host(.highlighted) .label-content-container{background-color:var(--dx-list-item-background-color-active, #ccdee5)}:host .item{width:var(--dx-button-width, fit-content);width:var(--dx-button-width, -moz-fit-content);cursor:pointer;display:inline-flex;justify-content:center;align-items:center;box-sizing:border-box;white-space:nowrap;user-select:none;-webkit-user-select:none;border:none;margin:0;background-color:transparent;transition:background-color 150ms ease-in-out, border-color 150ms ease-in-out;position:absolute;top:0;left:0;width:100%;height:100%;z-index:1;background:transparent;display:block;padding-left:0;padding-top:0}:host .item[disabled]{cursor:unset}:host .item.disabled{opacity:0.4;pointer-events:none}@media not all and (pointer: coarse){:host .item:not(.type-default):hover+.label-content-container{background-color:var(--dx-list-item-background-color-hover, #e5eef2);--dx-text-color:var(\n      --dx-list-item-text-color-hover,\n      #00587c\n    );--dx-icon-color:var(\n      --dx-list-item-icon-color-hover,\n      #00587c\n    )}:host .item:not(.type-default):hover+.label-content-container .action-indicator{--dx-icon-color:#337a96}}:host .item:not(.type-default):active+.label-content-container{background-color:var(--dx-list-item-background-color-active, #ccdee5);--dx-text-color:var(--dx-list-item-text-color-active, #004763);--dx-icon-color:var(--dx-list-item-icon-color-active, #004763)}:host .item:not(.type-default):active+.label-content-container .action-indicator{--dx-icon-color:#337a96}:host .item:not(.type-default):focus-visible{outline:var(--dx-list-item-outline, 2px solid #004763);outline-offset:2px}:host .item:not(.type-default)+.label-content-container .action-indicator-container{pointer-events:all;cursor:pointer;z-index:0}:host .item.type-default{pointer-events:none}@media not all and (pointer: coarse){:host .item.type-clickable:hover+.label-content-container{background-color:var(--dx-list-item-background-color-hover, rgba(0, 0, 0, 0.03));--dx-text-color:var(\n      --dx-list-item-text-color-hover,\n      #2b2b2b\n    );--dx-icon-color:var(\n      --dx-list-item-icon-color-hover,\n      #00587c\n    )}:host .item.type-clickable:hover+.label-content-container .action-indicator{--dx-icon-color:#337a96}}:host .item.type-clickable:active+.label-content-container{background-color:rgba(0, 0, 0, 0.07)}@media not all and (pointer: coarse){:host .item.type-selectable:hover+.label-content-container{background-color:var(--dx-list-item-background-color-hover, rgba(0, 0, 0, 0.03));--dx-text-color:var(\n      --dx-list-item-text-color-hover,\n      #2b2b2b\n    );--dx-icon-color:var(\n      --dx-list-item-icon-color-hover,\n      #00587c\n    )}:host .item.type-selectable:hover+.label-content-container .action-indicator{--dx-icon-color:#337a96}}:host .item.type-selectable:active+.label-content-container{background-color:rgba(0, 0, 0, 0.07)}:host .item.type-selectable.selected+.label-content-container{background-color:var(--dx-list-item-background-color-selected, rgba(0, 0, 0, 0.03));--dx-text-color:var(\n    --dx-list-item-text-color-selected,\n    #2b2b2b\n  );--dx-icon-color:var(\n    --dx-list-item-icon-color-selected,\n    #337a96\n  )}:host .item.type-selectable.selected+.label-content-container .action-indicator{--dx-icon-color:#ffffff}:host .item.type-selectable.selected .select-indicator{background-color:var(--dx-list-item-select-indicator-color, #c8aa22)}:host .item.type-selectable.selected:active+.label-content-container{background-color:var(--dx-list-item-background-color-selected, rgba(0, 0, 0, 0.07))}:host .item .select-indicator{width:4px;height:100%}:host:host(.force-active:not(.type-default)) .item+.label-content-container{background-color:var(--dx-list-item-background-color-active, #ccdee5);--dx-text-color:var(--dx-list-item-text-color-active, #004763);--dx-icon-color:var(--dx-list-item-icon-color-active, #004763)}:host:host(.force-active:not(.type-default)) .item+.label-content-container .action-indicator{--dx-icon-color:#337a96}:host .label-content-container{background-color:var(--dx-list-item-background-color-default, #ffffff);border-bottom:var(--dx-list-item-border-bottom, 1px solid #d6d6d6);--dx-text-color:var(\n    --dx-list-item-text-color-default,\n    #2b2b2b\n  );--dx-icon-color:var(--dx-list-item-icon-color-default, #337a96)}:host .label-content-container.dragging{box-shadow:4px 4px 0px rgba(0, 0, 0, 0.03);border:1px solid #d6d6d6}:host .label-content-container.disabled{opacity:0.4}:host .label-content-container .default-container{display:flex}:host .label-content-container .default-container .action-indicator{--dx-icon-color:#337a96}:host .label-content-container .default-container .icon-container{display:flex}:host .label-content-container .default-container .left-container.margin-right{margin-right:16px}:host .label-content-container .default-container .labels{position:relative;flex:1;text-align:left;white-space:pre-line}:host .label-content-container .default-container .labels.right-align-text{text-align:right}:host .label-content-container .default-container .labels .label{display:block}:host .label-content-container .default-container .labels .sub-label{margin-top:4px}:host .label-content-container .default-container .pre-label{margin-bottom:4px}:host .label-content-container .default-container .right-container{display:flex;min-height:40px}:host .label-content-container .default-container .right-container .action-indicator-container{display:flex;height:40px;align-self:center}:host .label-content-container .default-container .right-container .action-indicator-container.margin-sides-small{margin-left:8px;margin-right:0}:host .label-content-container .default-container .right-container .action-indicator-container.margin-sides-large{margin-left:24px;margin-right:8px}:host .label-content-container .default-container .right-container .action-indicator-container .action-indicator-wrapper{align-self:center}:host .label-content-container .default-container .right-container .action-indicator-container .action-indicator-wrapper .navigate-action-indicator{display:flex}:host .label-content-container .content-container{pointer-events:all;display:flex;justify-content:flex-end;width:max-content}:host .label-content-container .content-container:not(.full-width){margin-left:16px}:host .label-content-container .content-container.full-width{width:100%}:host .label-content-container .content-container.margin-right{margin-right:16px}:host .label-content-container .content-container .content{z-index:1;height:max-content}:host .sub-items-container{padding-left:16px}";

const DxListItem = class {
  constructor(hostRef) {
    index.registerInstance(this, hostRef);
    this.listItemInteraction = index.createEvent(this, "listItemInteraction", 7);
    this.dragBegin = index.createEvent(this, "dragBegin", 7);
    this.dragUpdate = index.createEvent(this, "dragUpdate", 7);
    this.dragFinish = index.createEvent(this, "dragFinish", 7);
    /**
     * @internal
     * Defines whether the content is shown below or next to the label
     */
    this.internalcontentbelow = false;
    /**
     * @internal
     */
    this.internaldraggable = false;
    /**
     * @internal
     */
    this.internaldragging = false;
    /**
     * The type of the item.
     *
     * @value default: The item will be displayed with an optional icon and a label.
     * @value selectable: The item is displayed like the default and can be selected.
     * @value checkbox: The item displays a checkbox instead of an icon. The selection can be toggled by clicking the item.
     *
     * @example type
     */
    this.type = "default";
    /**
     * The size of this item.
     * @internal
     */
    this.internalsize = "m";
    /**
     * @internal
     */
    this.internalanimation = false;
    /**
     * Defines whether the item is disabled or not.
     *
     * @value true: The item is displayed in a gray tone and can't be interacted with
     * @value false: The item is displayed normally.
     *
     * @exmaple disabled
     */
    this.disabled = false;
    /**
     * The current selection state of this item.
     *
     * @value true: The item is selected. This state will be visualized according to the `type`.
     * @value false: The item is not selected.
     *
     * @example selected
     */
    this.selected = false;
    /**
     * Defines the text alignment.
     * @value left: Text is left aligned.
     * @value right: Text is right aligned.
     * @example text-align
     */
    this.textalign = "left";
  }
  onIconChanged(newIcon, oldIcon) {
    this.internalIcon = newIcon || oldIcon || this.internalIcon;
  }
  onSelectedChange() {
    var _a;
    if (this.selected) {
      (_a = this.queryForRadioElement()) === null || _a === void 0 ? void 0 : _a.internalSelect();
    }
  }
  onCheckedChange(e) {
    this.selected = e.detail;
  }
  componentWillLoad() {
    this.internalIcon = this.icon;
    elementIdHandling.verifyElementId(this.self);
  }
  onInteraction(e) {
    if (e.target === this.self) {
      if (this.type === "clickable") {
        return;
      }
      this.selected = !this.selected || this.type === "radio";
    }
  }
  async getRadioElement() {
    return this.queryForRadioElement();
  }
  async focusControl() {
    this.self.shadowRoot.querySelector(".item").focus({
      preventScroll: true,
    });
  }
  queryForRadioElement() {
    return this.self.shadowRoot.querySelector("dx-radio-button");
  }
  getActiveElementSwapperSlot() {
    if (this.internaldraggable) {
      return "first";
    }
    if (isValidActionIndicatorValue(this.actionindicator)) {
      return "second";
    }
    return "none";
  }
  renderLabels() {
    if (!this.label && !this.sublabel && !this.prelabel) {
      return null;
    }
    assert.assert(!!this.label, () => "You have to define the 'label' property when defining the 'sublabel'!", this.self);
    const renderLabel = (label, type, labelType) => (label === null || label === void 0 ? void 0 : label.length) > 0 ? (index.h("dx-text", { type: type, class: {
        label: true,
        "sub-label": labelType === "sub-label",
        "pre-label": labelType === "pre-label",
      } }, label)) : null;
    return (index.h("div", { class: { labels: true, "right-align-text": this.textalign === "right" } }, renderLabel(this.prelabel, "its", "pre-label"), renderLabel(this.label, "ps", "default"), renderLabel(this.sublabel, "its", "sub-label")));
  }
  renderIcon() {
    return (index.h("div", { class: "icon-container" }, index.h("dx-icon", { icon: this.internalIcon, size: 24 })));
  }
  renderCheckbox() {
    return (index.h("dx-checkbox", { id: elementIdHandling.ElementIdGenerator.createId(this.self, "checkbox"), class: "interactable-element", checked: this.selected, tabIndex: -1 }));
  }
  renderRadioButton() {
    var _a;
    return (index.h("div", { class: "interactable-element" }, index.h("dx-radio-button", { id: elementIdHandling.ElementIdGenerator.createId(this.self, "radio-button"), value: (_a = this.value) === null || _a === void 0 ? void 0 : _a.toString(), disabled: this.disabled })));
  }
  renderSortHandle() {
    return (index.h("dx-sort-handle", { id: elementIdHandling.ElementIdGenerator.createId(this.self, "sort-handle"), internaldragging: this.internaldragging, internaldraggable: this.internaldraggable, onDragBegin: (e) => this.dragBegin.emit(e.detail), onDragUpdate: (e) => this.dragUpdate.emit(e.detail), onDragFinish: (e) => this.dragFinish.emit(e.detail) }));
  }
  renderAnimatableActionIndicator() {
    return (index.h("dx-horizontal-grow-box", { open: this.internaldraggable ||
        isValidActionIndicatorValue(this.actionindicator), class: {
        "action-indicator-container": true,
      } }, index.h("dx-spacer", { mq1: "8h" }), index.h("dx-element-swapper", { class: "action-indicator-wrapper", active: this.getActiveElementSwapperSlot() }, index.h("div", { slot: "first" }, this.renderSortHandle()), index.h("div", { slot: "second", class: "navigate-action-indicator" }, index.h("dx-spacer", { mq1: "8h" }), index.h("dx-icon", { icon: "chevron-rechts", size: 16, class: "action-indicator" })))));
  }
  renderActionIndicator() {
    if (!this.internaldraggable &&
      !isValidActionIndicatorValue(this.actionindicator)) {
      return;
    }
    return (index.h("div", { class: {
        "action-indicator-container": true,
        "margin-sides-small": this.internaldraggable,
        "margin-sides-large": !this.internaldraggable,
      }, key: "1" }, index.h("div", { class: "action-indicator-wrapper" }, index.h("div", { class: "navigate-action-indicator" }, this.internaldraggable ? (this.renderSortHandle()) : (index.h("dx-icon", { icon: "chevron-rechts", size: 16, class: "action-indicator" }))))));
  }
  renderLeftSide() {
    var _a;
    const typeToRenderFunction = {
      default: this.renderIcon.bind(this),
      selectable: this.renderIcon.bind(this),
      checkbox: this.renderCheckbox.bind(this),
      radio: this.renderRadioButton.bind(this),
      clickable: this.renderIcon.bind(this),
    };
    const open = ((_a = this.icon) === null || _a === void 0 ? void 0 : _a.length) > 0 ||
      this.type === "checkbox" ||
      this.type === "radio";
    const IconDrawerTag = this.internalanimation
      ? "dx-horizontal-grow-box"
      : "div";
    if (open || this.internalanimation) {
      return (index.h("div", { class: { "left-container": true } }, index.h(IconDrawerTag, { open: open, animationmode: "open-from-left", class: {
          "icon-drawer": true,
        } }, index.h("div", { class: "type-container" }, typeToRenderFunction[this.type]()))));
    }
  }
  renderRightSide() {
    return (index.h("div", { class: "right-container" }, this.internalcontentbelow ? null : this.renderContent(), this.internalanimation
      ? this.renderAnimatableActionIndicator()
      : this.renderActionIndicator()));
  }
  renderBelowContent() {
    if (!this.internalcontentbelow) {
      return;
    }
    return this.renderContent();
  }
  renderContent() {
    const isContentDefined = renderUtil.isSlotDefined(this.self, "content");
    if (isContentDefined) {
      return (index.h("div", { class: {
          "content-container": true,
          "full-width": this.internalcontentbelow,
        }, key: "content-container" }, index.h("div", { class: "content" }, index.h("slot", { name: "content" }))));
    }
  }
  render() {
    const contentSlotDefined = renderUtil.isSlotDefined(this.self, "content");
    const useContentBelow = contentSlotDefined && this.internalcontentbelow;
    return (index.h(index.Host, { class: {
        "size-medium": this.internalsize === "m",
        "size-large": this.internalsize === "l",
        "content-right": !useContentBelow,
        "content-below": useContentBelow,
      } }, index.h("button", { id: elementIdHandling.ElementIdGenerator.createId(this.self, "control"), class: {
        item: true,
        "type-checkbox": this.type === "checkbox",
        "type-selectable": this.type === "selectable",
        "type-default": this.type === "default",
        "type-clickable": this.type === "clickable",
        "type-navigatable": this.actionindicator === "navigate",
        selected: this.selected,
        disabled: this.disabled,
      }, onClick: () => this.listItemInteraction.emit(), disabled: this.disabled || this.type === "default" }, index.h("div", { class: "select-indicator" })), index.h("div", { class: {
        "label-content-container": true,
        dragging: this.internaldragging,
        disabled: this.disabled,
      } }, index.h("div", { class: "default-container" }, this.renderLeftSide(), this.renderLabels(), this.renderRightSide()), this.renderBelowContent()), index.h("div", { class: "sub-items-container" }, index.h("slot", null))));
  }
  get self() { return index.getElement(this); }
  static get watchers() { return {
    "icon": ["onIconChanged"],
    "selected": ["onSelectedChange"]
  }; }
};
const ACTION_INDICATOR_VALUES = ["navigate"];
function isValidActionIndicatorValue(actionIndicatorType) {
  return ACTION_INDICATOR_VALUES.includes(actionIndicatorType);
}
DxListItem.style = dxListItemCss;

const dxRadioButtonCss = ":host{min-height:40px;display:flex;align-items:center;width:fit-content;width:-moz-fit-content;outline:none;position:relative;top:0;left:0}:host:host([hidden]){display:none !important}:host .radio-label-container{--dx-text-color:#2b2b2b;position:relative;display:flex;flex-direction:row-reverse;justify-content:flex-end;box-sizing:border-box;align-items:baseline}:host .radio-label-container .baseline-container{display:flex}:host .radio-label-container .baseline-container .dot-container{border:1px solid #337a96;transition:border-width 150ms ease-in-out;border-radius:50%;height:24px;width:24px;position:relative;box-sizing:border-box;background-color:#ffffff;pointer-events:none;flex:0 0 24px}:host .radio-label-container .baseline-container .baseline-text{width:0}:host .radio-label-container.contains-label .baseline-container .dot-container{margin-right:16px}:host .native-input{position:absolute;cursor:pointer;left:0;top:0;width:100%;height:100%;opacity:0;margin:0;padding:0;z-index:1}:host .native-input:disabled{pointer-events:none;cursor:default}:host .native-input:disabled+.radio-label-container{opacity:0.4}:host .native-input:checked+.radio-label-container .dot-container{border-color:#004763;border-width:8px}@media not all and (pointer: coarse){:host .native-input:checked:hover+.radio-label-container .dot-container{border-color:#196989}}:host .native-input:checked:active+.radio-label-container .dot-container{border-color:#4c8aa3}:host .native-input:not(:checked)+.radio-label-container .dot-container{border-width:1px}@media not all and (pointer: coarse){:host .native-input:not(:checked):hover+.radio-label-container .dot-container{border-color:#00587c;background-color:#e5eef2}}:host .native-input:not(:checked):active+.radio-label-container .dot-container{border-color:#004763;background-color:#ccdee5}:host .native-input:focus-visible+.radio-label-container{outline-offset:2px;outline:2px solid #004763}";

const DxRadioButton = class {
  constructor(hostRef) {
    index.registerInstance(this, hostRef);
    this.internalCheckedChange = index.createEvent(this, "internalCheckedChange", 7);
    /**
     * Disables the ability to interact with this component.
     *
     * @value false: User can interact with this component.
     * @value true: User cannot interact with this component.
     *
     * @example modes
     */
    this.disabled = false;
    /**
     * The group id of the parent radio button group. If not defined the first radio-button-group which is found will be elected as the owner of this radio-button
     * @internal
     */
    this.groupid = null;
  }
  /**
   * @internal
   */
  async internalSetChecked(checked) {
    this.inputElement.checked = checked;
    this.internalCheckedChange.emit(checked);
  }
  /**
   * @internal
   */
  async internalSelect() {
    this.select();
  }
  /**
   * Sets the focus on this component.
   * @example focus
   */
  async focusControl() {
    this.inputElement.focus();
  }
  /**
   * @internal
   */
  async forceUpdate() {
    index.forceUpdate(this);
  }
  connectedCallback() {
    var _a;
    (_a = this.group()) === null || _a === void 0 ? void 0 : _a.connectRadioButton(this.self);
  }
  disconnectedCallback() {
    var _a;
    (_a = this.group()) === null || _a === void 0 ? void 0 : _a.disconnectRadioButton(this.self);
  }
  componentWillLoad() {
    elementIdHandling.verifyElementId(this.self);
  }
  containsLabel() {
    var _a;
    return ((_a = this.label) === null || _a === void 0 ? void 0 : _a.length) > 0;
  }
  select() {
    if (!this.disabled) {
      const radioButtonGroup = this.group();
      radioButtonGroup.select(this.value).then();
    }
  }
  group() {
    const radioButtonGroup = miscUtil.findUpperElementByPredicate(this.self, (elem) => {
      const isRadioGroup = miscUtil.tagOf(elem) === "dx-radio-button-group";
      if (isRadioGroup) {
        return (elem.radiogroupid ===
          this.groupid ||
          (elem.radiogroupid == null &&
            this.groupid == null));
      }
      return false;
    });
    assert.assert(radioButtonGroup != null, () => "<dx-radio-button> has to be within a <dx-radio-button-group>.", this.self);
    return radioButtonGroup;
  }
  render() {
    const radioButtonGroup = this.group();
    const groupId = radioButtonGroup.getAttribute("radiogroupid");
    const disabled = this.disabled || radioButtonGroup.disabled;
    return (index.h(index.Host, { class: {
        disabled: disabled,
      } }, index.h("div", null, index.h("input", { id: elementIdHandling.ElementIdGenerator.createId(this.self, "control"), ref: (el) => (this.inputElement = el), name: groupId ? `form-dx-radio-button-group-${groupId}` : undefined, type: "radio", onChange: () => this.select(), disabled: disabled, class: {
        "native-input": true,
        "event-delegate-receiver": true,
      }, tabIndex: disabled ? -1 : 1 }), index.h("div", { class: {
        "radio-label-container": true,
        "contains-label": this.containsLabel(),
      } }, index.h("dx-text", null, this.label), index.h("div", { class: "baseline-container" }, index.h("dx-text", { class: "baseline-text" }, "\u00A0"), index.h("div", { class: {
        "dot-container": true,
      } }))))));
  }
  get self() { return index.getElement(this); }
};
DxRadioButton.style = dxRadioButtonCss;

const dxSortHandleCss = ":host{display:block}:host:host([hidden]){display:none !important}:host .sort-handle{width:var(--dx-button-width, fit-content);width:var(--dx-button-width, -moz-fit-content);cursor:pointer;display:inline-flex;justify-content:center;align-items:center;box-sizing:border-box;white-space:nowrap;user-select:none;-webkit-user-select:none;border:none;margin:0;background-color:transparent;transition:background-color 150ms ease-in-out, border-color 150ms ease-in-out;width:40px;height:40px;pointer-events:none}:host .sort-handle[disabled]{cursor:unset}:host .sort-handle.draggable{cursor:move;pointer-events:all}";

const DxSortHandle = class {
  constructor(hostRef) {
    index.registerInstance(this, hostRef);
    this.dragBegin = index.createEvent(this, "dragBegin", 7);
    this.dragFinish = index.createEvent(this, "dragFinish", 7);
    this.dragUpdate = index.createEvent(this, "dragUpdate", 7);
  }
  componentWillLoad() {
    this.dragController = new dragController.DragController((startX, startY) => this.dragBegin.emit(new mathUtil.Point(startX, startY)), (event) => this.dragUpdate.emit(mathUtil.toPoint(event)), () => undefined, () => this.dragFinish.emit());
  }
  render() {
    return (index.h("button", { id: elementIdHandling.ElementIdGenerator.createId(this.self, "control"), class: { "sort-handle": true, draggable: this.internaldraggable }, type: "text", color: "default", onTouchStart: (e) => this.dragController.onTouchStart(e), onPointerDown: (e) => this.dragController.onPointerDown(e) }, index.h("dx-icon", { icon: "move", size: 24, color: "border" })));
  }
  get self() { return index.getElement(this); }
};
DxSortHandle.style = dxSortHandleCss;

const dxSpacerCss = ":host{display:block;flex-shrink:1;flex-grow:0}:host:host([hidden]){display:none !important}";

const DxSpacer = class {
  constructor(hostRef) {
    index.registerInstance(this, hostRef);
  }
  connectedCallback() {
    var _a, _b, _c;
    // Do not initialize breakpointAware when mq1 is the only valid option
    if (sizes_util.isPossibleSize(this.mq1) &&
      !sizes_util.isPossibleSize((_c = (_b = (_a = this.mq2) !== null && _a !== void 0 ? _a : this.mq3) !== null && _b !== void 0 ? _b : this.mq4) !== null && _c !== void 0 ? _c : this.mq5)) {
      return;
    }
    this.breakpointAware = new breakpointAware.BreakpointAware(() => index.forceUpdate(this), true);
  }
  disconnectedCallback() {
    var _a;
    (_a = this.breakpointAware) === null || _a === void 0 ? void 0 : _a.disconnect();
  }
  componentWillRender() {
    this.checkValue(this.mq1);
    this.checkValue(this.mq2);
    this.checkValue(this.mq3);
    this.checkValue(this.mq4);
    this.checkValue(this.mq5);
  }
  checkValue(size) {
    if (size == null) {
      return;
    }
    sizes_util.assertIsPossibleSize(size);
  }
  getCurrentBreakpointValue() {
    var _a, _b, _c;
    return (_c = ((_b = (_a = this.breakpointAware) === null || _a === void 0 ? void 0 : _a.getEffectiveValue({
      mq1: this.mq1,
      mq2: this.mq2,
      mq3: this.mq3,
      mq4: this.mq4,
      mq5: this.mq5,
    })) !== null && _b !== void 0 ? _b : this.mq1)) === null || _c === void 0 ? void 0 : _c.toString();
  }
  render() {
    const breakpointValue = this.getCurrentBreakpointValue();
    const isHorizontal = breakpointValue.includes("h");
    const isVertical = breakpointValue.includes("v");
    const isSquare = !(isVertical || isHorizontal);
    const cssSize = `${parseInt(breakpointValue)}px`;
    return (index.h(index.Host, null, index.h("div", { style: {
        width: isHorizontal || isSquare ? cssSize : "0",
        height: isVertical || isSquare ? cssSize : "0",
      } })));
  }
  get self() { return index.getElement(this); }
};
DxSpacer.style = dxSpacerCss;

exports.dx_checkbox = DxCheckBox;
exports.dx_flyout = DxFlyout;
exports.dx_list = DxList;
exports.dx_list_flyout = DxListFlyout;
exports.dx_list_item = DxListItem;
exports.dx_radio_button = DxRadioButton;
exports.dx_sort_handle = DxSortHandle;
exports.dx_spacer = DxSpacer;
