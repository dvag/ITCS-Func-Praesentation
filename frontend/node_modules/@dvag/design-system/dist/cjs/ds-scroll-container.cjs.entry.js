'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const index = require('./index-2f41386b.js');
const mathUtil = require('./math-util-a514efc6.js');
const slotObserver = require('./slot-observer-2e83212e.js');
const renderUtil = require('./render-util-6b278c0d.js');
const miscUtil = require('./misc-util-63b423bd.js');
require('./query-util-8642f149.js');

const dsScrollContainerCss = ":host{display:flex;scrollbar-width:none;-ms-overflow-style:none;position:relative;width:100%}:host:host([hidden]){display:none !important}::slotted(*){overflow:scroll;scrollbar-width:none;-ms-overflow-style:none}::slotted(:first-child::-webkit-scrollbar){display:none}.scroll-container{display:flex;flex-grow:1;overflow:scroll;scrollbar-width:none;-ms-overflow-style:none}.glue{width:0px;height:0px;position:sticky}::-webkit-scrollbar{display:none}.scrollbar-container{position:absolute;display:none;cursor:pointer;z-index:105}.scrollbar-container .scrollbar{background-color:#dedede}.scrollbar-container .scrollbar.active{background-color:#c1c1c1 !important}.scrollbar-container:hover .scrollbar{background-color:#c1c1c1 !important}.scrollbar-container.visible{display:block}";

const DsScrollContainer = class {
  constructor(hostRef) {
    index.registerInstance(this, hostRef);
    this.scrollVerticalActive = index.createEvent(this, "scrollVerticalActive", 7);
    this.scrollHorizontalActive = index.createEvent(this, "scrollHorizontalActive", 7);
    this.initialYPositionOnScrollBar = 0;
    this.updateScrollParameterEvents = ["scroll", "resize", "move"];
    this.updateHandler = () => this.update();
    this.verticalMouseMoveHandler = (e) => this.handleVerticalScrollBarMouseMove(e);
    this.horizontalMouseMoveHandler = (e) => this.handleHorizontalScrollBarMouseMove(e);
    this.mouseUpHandler = () => this.handleScrollBarMouseUp();
    this.currentDraggingBar = null;
    this.collisionTop = 0;
    this.collisionBottom = 0;
    this.horizontalThumbWidth = 0;
    this.verticalThumbHeight = 0;
    this.verticalThumbTop = 0;
    this.horizontalThumbLeft = 0;
    this.top = 0;
    this.left = 0;
    this.height = 0;
    this.width = 0;
    // Thumb Options
    this.thumbwidth = 4;
    this.thumbmargin = 0;
    this.thumbcolor = "#dedede";
    this.thumbopacity = 1;
    this.minthumbsize = 16;
    // Scrollbar Options
    this.scrollbarspace = 0;
    this.scrollbaroffset = 0;
    this.scrollbarwidth = 0;
    this.scrollbarmargin = 0;
    this.verticalscrollbarposition = "right";
    this.horizontalscrollbarposition = "bottom";
    this.scrollbarcolorfactor = 0.5;
    this.scrollbarborderradius = 7;
    this.scrollbaropacity = 0.5;
  }
  onDraggingBarChanged(newVal, oldVal) {
    if (newVal === "vertical") {
      this.scrollVerticalActive.emit(true);
    }
    else if (newVal === "horizontal") {
      this.scrollHorizontalActive.emit(true);
    }
    else {
      const event = oldVal === "vertical"
        ? this.scrollVerticalActive
        : this.scrollHorizontalActive;
      event.emit(false);
    }
  }
  connectedCallback() {
    this.slotObserver = new slotObserver.SlotObserver(this.self, "*", (nodes) => {
      this.init(nodes[0]);
    });
  }
  disconnectedCallback() {
    var _a;
    (_a = this.slotObserver) === null || _a === void 0 ? void 0 : _a.disconnect();
  }
  handleScrollBarMouseUp() {
    this.currentDraggingBar = null;
    window.removeEventListener("mouseup", this.mouseUpHandler);
    window.removeEventListener("mousemove", this.verticalMouseMoveHandler);
    window.removeEventListener("mousemove", this.horizontalMouseMoveHandler);
  }
  update() {
    if (this.scrollContainer === undefined) {
      return;
    }
    this.scrollContainerBoundings =
      this.scrollContainer.getBoundingClientRect();
    this.updateVertical();
    this.updateHorizontal();
  }
  updateVertical() {
    const offsetHeight = this.scrollContainer.offsetHeight;
    const scrollHeight = this.scrollContainer.scrollHeight;
    const isScrollableVertical = scrollHeight > offsetHeight;
    if (isScrollableVertical) {
      this.verticalThumbHeight = Math.max(this.minthumbsize, offsetHeight * (offsetHeight / scrollHeight));
      const heightDifference = scrollHeight - offsetHeight;
      const scrollPercentage = this.scrollContainer.scrollTop / heightDifference;
      const minScrollTop = this.thumbmargin;
      const maxScrollTop = this.verticalScrollContainerHeight -
        this.verticalThumbHeight -
        this.thumbmargin;
      this.verticalThumbTop =
        minScrollTop + (maxScrollTop - minScrollTop) * scrollPercentage;
    }
    else {
      this.verticalThumbTop = 0;
      this.verticalThumbHeight = 0;
    }
  }
  updateHorizontal() {
    const offsetWidth = this.scrollContainer.offsetWidth;
    const scrollWidth = this.scrollContainer.scrollWidth;
    const isScrollableHorizontal = scrollWidth > offsetWidth;
    if (isScrollableHorizontal) {
      this.horizontalThumbWidth = Math.max(this.minthumbsize, offsetWidth * (offsetWidth / scrollWidth));
      const widthDifference = scrollWidth - offsetWidth;
      const scrollPercentage = this.scrollContainer.scrollLeft / widthDifference;
      const minScrollLeft = this.thumbmargin;
      const maxScrollLeft = this.horizontalScrollContainerWidth -
        this.horizontalThumbWidth -
        this.thumbmargin;
      this.horizontalThumbLeft =
        minScrollLeft + (maxScrollLeft - minScrollLeft) * scrollPercentage;
    }
    else {
      this.horizontalThumbLeft = 0;
      this.horizontalThumbWidth = 0;
    }
  }
  get scrollBarWidth() {
    return Math.max(this.scrollbarwidth, this.thumbwidth + this.thumbmargin * 2);
  }
  init(container) {
    var _a;
    this.updateScrollParameterEvents.forEach((eventType) => {
      var _a;
      (_a = this.scrollContainer) === null || _a === void 0 ? void 0 : _a.removeEventListener(eventType, this.updateHandler);
      container === null || container === void 0 ? void 0 : container.addEventListener(eventType, this.updateHandler);
      window.removeEventListener(eventType, this.updateHandler);
      window.addEventListener(eventType, this.updateHandler);
    });
    this.scrollContainer = container;
    this.scrollContainerBoundings =
      (_a = this.scrollContainer) === null || _a === void 0 ? void 0 : _a.getBoundingClientRect();
    // We wait 10 frames to be sure that the scrollContainer loaded properly. It should be enough to wait 3
    // frames, but this value could differ on slower systems.
    miscUtil.waitAnimationFrames(10).then(this.updateHandler);
  }
  get verticalScrollContainerHeight() {
    return (this.self.offsetHeight -
      this.scrollbarmargin * 2 -
      this.getTargetMargin("Top") * 2);
  }
  get horizontalScrollContainerWidth() {
    return (this.self.offsetWidth -
      this.scrollbarmargin * 2 -
      this.getTargetMargin("Left") * 2);
  }
  getTargetMargin(direction) {
    if (this.scrollContainer !== undefined) {
      const marginStyleName = "margin" + direction;
      const scrollContainerStyle = getComputedStyle(this.scrollContainer);
      const scrollContainerMargin = scrollContainerStyle[marginStyleName] ||
        scrollContainerStyle.margin;
      return parseInt(scrollContainerMargin);
    }
    return 0;
  }
  get verticalScrollContainerY() {
    return (this.scrollbarmargin +
      this.getTargetMargin("Top") +
      (this.horizontalscrollbarposition === "top"
        ? this.actualScrollbarSpace
        : 0));
  }
  get horizontalScrollContainerX() {
    return (this.scrollbarmargin +
      this.getTargetMargin("Left") +
      (this.verticalscrollbarposition === "left"
        ? this.actualScrollbarSpace
        : 0));
  }
  scrollContainerBegin(axis) {
    const coord = this.scrollContainerBoundings[axis];
    const offset = window[`page${axis.toUpperCase()}Offset`];
    return coord + this.scrollbarmargin + offset;
  }
  toLocal(coord, axis) {
    return (coord +
      window[`page${axis.toUpperCase()}Offset`] -
      this.scrollContainerBegin(axis));
  }
  handleVerticalScrollBarMouseDown(e) {
    e.preventDefault();
    this.scrollContainerBoundings =
      this.scrollContainer.getBoundingClientRect();
    const localMouseY = this.toLocal(e.y, "y");
    const scrollBarTopPx = this.verticalThumbTop;
    this.initialYPositionOnScrollBar = localMouseY - scrollBarTopPx;
    const scrollBarBeginY = scrollBarTopPx;
    const scrollBarEndY = scrollBarBeginY + this.verticalThumbHeight;
    const mouseOverScrollBar = mathUtil.clamp(localMouseY, scrollBarBeginY, scrollBarEndY) == localMouseY;
    if (!mouseOverScrollBar) {
      this.initialYPositionOnScrollBar = this.verticalThumbHeight * 0.5;
      this.scrollContainer.scrollTop = this.getScrollPositionY(e.y);
    }
    this.currentDraggingBar = "vertical";
    window.addEventListener("mousemove", this.verticalMouseMoveHandler);
    window.addEventListener("mouseup", this.mouseUpHandler);
  }
  handleHorizontalScrollBarMouseDown(e) {
    e.preventDefault();
    const localMouseX = this.toLocal(e.x, "x");
    this.initialYPositionOnScrollBar = localMouseX - this.horizontalThumbLeft;
    const scrollBarBeginX = this.horizontalThumbLeft;
    const scrollBarEndX = scrollBarBeginX + this.horizontalThumbWidth;
    const mouseOverScrollBar = mathUtil.clamp(localMouseX, scrollBarBeginX, scrollBarEndX) == localMouseX;
    if (!mouseOverScrollBar) {
      this.initialYPositionOnScrollBar = this.horizontalThumbWidth * 0.5;
      this.scrollContainer.scrollLeft = this.getScrollPositionX(e.x);
    }
    this.currentDraggingBar = "horizontal";
    window.addEventListener("mousemove", this.horizontalMouseMoveHandler);
    window.addEventListener("mouseup", this.mouseUpHandler);
  }
  handleVerticalScrollBarMouseMove(e) {
    if (this.currentDraggingBar &&
      this.visibleVertical &&
      this.scrollContainer !== undefined) {
      e.stopPropagation();
      this.scrollContainer.scrollTop = this.getScrollPositionY(e.y);
    }
  }
  handleHorizontalScrollBarMouseMove(e) {
    if (this.currentDraggingBar &&
      this.visibleHorizontal &&
      this.scrollContainer !== undefined) {
      e.stopPropagation();
      this.scrollContainer.scrollLeft = this.getScrollPositionX(e.x);
    }
  }
  get visibleVertical() {
    return this.verticalThumbHeight > 0;
  }
  get visibleHorizontal() {
    return this.horizontalThumbWidth > 0;
  }
  getScrollPositionY(mouseY) {
    const max = this.verticalScrollContainerHeight - this.verticalThumbHeight;
    const mouseOnTop = this.toLocal(mouseY, "y") - this.initialYPositionOnScrollBar;
    const yWithinTarget = mathUtil.clamp(mouseOnTop, 0, this.verticalScrollContainerHeight);
    const result = (yWithinTarget / max) *
      (this.scrollContainer.scrollHeight - this.scrollContainer.offsetHeight);
    return result;
  }
  getScrollPositionX(mouseX) {
    const max = this.horizontalScrollContainerWidth - this.horizontalThumbWidth;
    const mouseOnLeft = this.toLocal(mouseX, "x") - this.initialYPositionOnScrollBar;
    const xWithinTarget = mathUtil.clamp(mouseOnLeft, 0, this.horizontalScrollContainerWidth);
    const result = (xWithinTarget / max) *
      (this.scrollContainer.scrollWidth - this.scrollContainer.offsetWidth);
    return result;
  }
  render() {
    return (index.h(index.Host, null, index.h("slot", null), this.renderScrollBars()));
  }
  get actualScrollbarSpace() {
    return this.scrollbarspace;
  }
  createVerticalScrollBar(middle, offset, color, borderRadius) {
    if (this.visibleVertical) {
      const verticalScrollBarPosition = {};
      verticalScrollBarPosition[this.verticalscrollbarposition] =
        middle + this.scrollbaroffset + "px";
      return (index.h("div", { class: {
          "scrollbar-container": true,
          visible: this.visibleVertical,
        }, onMouseDown: (e) => this.handleVerticalScrollBarMouseDown(e), style: Object.assign(Object.assign({}, verticalScrollBarPosition), { top: this.verticalScrollContainerY + "px", height: this.verticalScrollContainerHeight + "px", width: this.scrollBarWidth + "px", "background-color": color, "border-radius": borderRadius }) }, index.h("div", { style: {
          top: this.verticalThumbTop + "px",
          left: offset,
          width: this.thumbwidth + "px",
          height: this.verticalThumbHeight + "px",
          "background-color": this.thumbcolor,
          position: "absolute",
          "border-radius": borderRadius,
          opacity: this.thumbopacity.toString(),
        }, class: {
          scrollbar: true,
          active: this.currentDraggingBar === "vertical",
        } })));
    }
  }
  createHorizontalScrollBar(middle, color, borderRadius) {
    if (this.visibleHorizontal) {
      const horizontalScrollBarPosition = {};
      horizontalScrollBarPosition[this.horizontalscrollbarposition] =
        -middle - this.scrollbaroffset + "px";
      return (index.h("div", { class: {
          "scrollbar-container": true,
          visible: this.visibleHorizontal,
        }, onMouseDown: (e) => this.handleHorizontalScrollBarMouseDown(e), style: Object.assign(Object.assign({}, horizontalScrollBarPosition), { left: this.horizontalScrollContainerX + "px", width: this.horizontalScrollContainerWidth + "px", height: this.scrollBarWidth + "px", "background-color": color, "border-radius": borderRadius }) }, index.h("div", { style: {
          left: this.horizontalThumbLeft + "px",
          height: this.thumbwidth + "px",
          width: this.horizontalThumbWidth + "px",
          "background-color": this.thumbcolor,
          position: "absolute",
          "border-radius": borderRadius,
          opacity: this.thumbopacity.toString(),
        }, class: {
          scrollbar: true,
          active: this.currentDraggingBar === "horizontal",
        } })));
    }
    return null;
  }
  renderScrollBars() {
    if (!(this.visibleVertical || this.visibleHorizontal))
      return null;
    const scrollBarContainerColor = renderUtil.lighten(this.thumbcolor, this.scrollbarcolorfactor) +
      renderUtil.toHex(this.scrollbaropacity * 255);
    const borderRadius = this.scrollbarborderradius + "px";
    const containerMiddle = (1 - this.thumbwidth / this.scrollBarWidth) * 50 + "%";
    const scrollbarMiddle = this.actualScrollbarSpace * 0.5 - this.scrollBarWidth * 0.5;
    return [
      this.createVerticalScrollBar(scrollbarMiddle, containerMiddle, scrollBarContainerColor, borderRadius),
      this.createHorizontalScrollBar(scrollbarMiddle, scrollBarContainerColor, borderRadius),
    ];
  }
  get self() { return index.getElement(this); }
  static get watchers() { return {
    "currentDraggingBar": ["onDraggingBarChanged"]
  }; }
};
DsScrollContainer.style = dsScrollContainerCss;

exports.ds_scroll_container = DsScrollContainer;
