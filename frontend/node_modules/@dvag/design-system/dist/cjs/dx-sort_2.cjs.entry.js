'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const index = require('./index-2f41386b.js');
const mathUtil = require('./math-util-a514efc6.js');
const miscUtil = require('./misc-util-63b423bd.js');
const slotObserver = require('./slot-observer-2e83212e.js');
require('./query-util-8642f149.js');

const dxSortCss = ":host{display:block;position:relative}:host:host([hidden]){display:none !important}";

const DxSort = class {
  constructor(hostRef) {
    index.registerInstance(this, hostRef);
    this.sort = index.createEvent(this, "sort", 7);
    this.automaticScrollIntervalHandler = null;
    this.autoScrollActive = false;
    this.currentDraggingSortItem = null;
    /**
     * Whether the sorting is enabled or not.
     *
     * @example sortable
     */
    this.sortable = true;
    this.dragging = false;
  }
  onSortableChanged() {
    this.sortItems.forEach((item) => {
      item.internaldraggable = this.sortable;
    });
  }
  getNearestItem(mousePosition) {
    return this.sortItems.reduce((closest, current) => {
      const currentBoundingClientRect = current.getBoundingClientRect();
      const offset = mousePosition.y -
        currentBoundingClientRect.top -
        currentBoundingClientRect.height;
      if (offset < 0 && offset > closest.offset) {
        return { offset: offset, element: current };
      }
      else {
        return closest;
      }
    }, { offset: Number.NEGATIVE_INFINITY, element: null }).element;
  }
  stopAutomaticScrolling() {
    clearInterval(this.automaticScrollIntervalHandler);
    //Testwise defer
    setTimeout(() => {
      this.autoScrollActive = false;
    }, 200);
  }
  automaticScroll(direction, lastMousePositionY, yDistance) {
    clearInterval(this.automaticScrollIntervalHandler);
    let scrollSpeed = yDistance * 0.1;
    this.automaticScrollIntervalHandler = setInterval(() => {
      // The amount of speed increase every frame
      const scrollSpeedIncrement = 0.01;
      scrollSpeed = Math.max(1, scrollSpeed + scrollSpeedIncrement);
      if (direction === "down") {
        this.contentDiv.scrollTop = this.contentDiv.scrollTop + scrollSpeed;
      }
      else if (direction === "up") {
        this.contentDiv.scrollTop = this.contentDiv.scrollTop - scrollSpeed;
      }
      this.updateSlotsOrder(new mathUtil.Point(0, lastMousePositionY));
    }, 0);
    this.autoScrollActive = true;
  }
  onMouseWheel(e) {
    if (!this.dragging) {
      return;
    }
    this.contentDiv.scrollTop = this.contentDiv.scrollTop + e.deltaY;
    this.updateSlotsOrder(mathUtil.toPoint(e));
  }
  onDraggingStart(e) {
    this.dragging = true;
    this.currentDraggingSortItem = e.target;
  }
  onDragging(e) {
    this.dragging = true;
    if (!this.autoScrollActive) {
      this.updateSlotsOrder(e.detail);
    }
    this.updateAutomaticScrolling(e);
  }
  onDraggingEnd() {
    this.dragging = false;
    this.stopAutomaticScrolling();
    this.currentDraggingSortItem = null;
    const toValue = (sortItem) => sortItem.value;
    const originalArray = [...this.sortItems];
    const sortedArray = [...this.sortItems].sort((a, b) => parseFloat(a.slot) - parseFloat(b.slot));
    this.sort.emit({
      originalArray: originalArray.map(toValue),
      sortedArray: sortedArray.map(toValue),
    });
  }
  connectedCallback() {
    // Prevent race conditions by waiting 500ms before getting the contentDiv
    setTimeout(() => {
      this.contentDiv = miscUtil.findClosestScrollElement(this.self);
    }, 500);
    this.slotObserver = new slotObserver.SlotObserver(this.self, "dx-sort-item", (nodes) => {
      if (this.dragging || miscUtil.sameArrayInOrder(this.sortItems, nodes)) {
        return;
      }
      nodes.forEach((item, index) => {
        item.slot = index.toString();
        item.internaldraggable = this.sortable;
      });
      this.sortItems = nodes;
    });
  }
  disconnectedCallback() {
    var _a;
    (_a = this.slotObserver) === null || _a === void 0 ? void 0 : _a.disconnect();
  }
  updateAutomaticScrolling(e) {
    const scrollBoundsOffset = 32;
    const topBorder = this.contentDiv.getBoundingClientRect().y + scrollBoundsOffset;
    const bottomBorder = this.contentDiv.offsetHeight +
      this.contentDiv.getBoundingClientRect().y -
      scrollBoundsOffset;
    const sortItemIntersectsTopBorder = e.detail.y < topBorder;
    const sortItemIntersectsBottomBorder = e.detail.y > bottomBorder;
    if (!(sortItemIntersectsTopBorder || sortItemIntersectsBottomBorder)) {
      // Mouse is not intersecting with either the top or bottom border
      this.stopAutomaticScrolling();
      return;
    }
    const fullyScrolledTop = () => this.contentDiv.scrollTop === 0;
    if (sortItemIntersectsTopBorder && fullyScrolledTop()) {
      this.stopAutomaticScrolling();
      return;
    }
    const fullyScrolledBottom = () => this.contentDiv.scrollHeight - this.contentDiv.scrollTop ===
      this.contentDiv.clientHeight;
    if (sortItemIntersectsBottomBorder && fullyScrolledBottom()) {
      this.stopAutomaticScrolling();
      return;
    }
    if (sortItemIntersectsTopBorder) {
      const yDistance = topBorder - e.detail.y;
      this.automaticScroll("up", e.detail.y, yDistance);
    }
    else {
      const yDistance = e.detail.y - bottomBorder;
      this.automaticScroll("down", e.detail.y, yDistance);
    }
  }
  /**
   * Pushes all sortItems away to reserve space for the current dragging sort item.
   *
   * @param reservedSlotIndex: The new slot for the current dragging sort item.
   */
  pushAwaySortItems(reservedSlotIndex) {
    const currentSortItemSlotIndex = parseFloat(this.currentDraggingSortItem.slot);
    this.sortItems
      .filter((sortItem) => sortItem !== this.currentDraggingSortItem)
      .forEach((sortItem) => {
      const sortItemSlotIndex = parseFloat(sortItem.slot);
      // Moves a sortItem to the top or bottom dependent on it being within the drag path and
      // the current sortItem moves to the top or bottom
      if (sortItemSlotIndex > currentSortItemSlotIndex &&
        sortItemSlotIndex <= reservedSlotIndex) {
        sortItem.slot = (sortItemSlotIndex - 1).toString();
      }
      else if (sortItemSlotIndex < currentSortItemSlotIndex &&
        sortItemSlotIndex >= reservedSlotIndex) {
        sortItem.slot = (sortItemSlotIndex + 1).toString();
      }
    });
    this.currentDraggingSortItem.slot = reservedSlotIndex.toString();
    const map = {};
    this.sortItems.forEach((sortItem) => {
      if (map[sortItem.slot]) {
        console.error(sortItem.slot, "is already filled", map[sortItem.slot]);
      }
      if (!map[sortItem.slot]) {
        map[sortItem.slot] = [];
      }
      map[sortItem.slot].push(sortItem);
    });
  }
  updateSlotsOrder(currentDraggingPosition) {
    const nearestItem = this.getNearestItem(currentDraggingPosition);
    if (nearestItem != null) {
      const newSlot = parseFloat(nearestItem.slot);
      this.pushAwaySortItems(newSlot);
    }
  }
  render() {
    var _a, _b;
    return (index.h(index.Host, null, (_b = (_a = this.sortItems) === null || _a === void 0 ? void 0 : _a.map((_, index$1) => (index.h("slot", { name: index$1.toString() })))) !== null && _b !== void 0 ? _b : index.h("slot", null)));
  }
  get self() { return index.getElement(this); }
  static get watchers() { return {
    "sortable": ["onSortableChanged"]
  }; }
};
DxSort.style = dxSortCss;

function isDraggable(obj) {
  return "internaldraggable" in obj && "internaldragging" in obj;
}

const dxSortItemCss = ":host{display:block;user-select:none}:host:host([hidden]){display:none !important}:host:host(.dragging){background-color:#f7f7f7}:host:host(.dragging) .slot-container{position:fixed;top:0;left:0;z-index:1020;background:#ffffff}:host .slot-container{position:relative}";

const DxSortItem = class {
  constructor(hostRef) {
    index.registerInstance(this, hostRef);
    this.dragging = index.createEvent(this, "dragging", 7);
    this.draggingStart = index.createEvent(this, "draggingStart", 7);
    this.draggingEnd = index.createEvent(this, "draggingEnd", 7);
  }
  onDragElementChanged() {
    var _a;
    (_a = this.draggableElements) === null || _a === void 0 ? void 0 : _a.forEach((draggableNode) => {
      draggableNode.internaldragging = this.dragElement != null;
    });
  }
  onSortableChange() {
    var _a;
    (_a = this.draggableElements) === null || _a === void 0 ? void 0 : _a.forEach((draggableNode) => {
      draggableNode.internaldraggable = this.internaldraggable;
    });
  }
  connectedCallback() {
    this.slotObserver = new slotObserver.SlotObserver(this.self, "*", (nodes) => {
      this.draggableElements = nodes.filter((node) => isDraggable(node));
      this.draggableElements.forEach((draggableNode) => {
        draggableNode.internaldraggable = this.internaldraggable;
        draggableNode.internaldragging = this.dragElement != null;
      });
    });
  }
  disconnectedCallback() {
    var _a;
    (_a = this.slotObserver) === null || _a === void 0 ? void 0 : _a.disconnect();
  }
  onDragBegan(e) {
    var _a, _b;
    if (this.isCurrentlyDragging()) {
      return;
    }
    this.draggingStart.emit();
    this.dragElement = this.self.shadowRoot.querySelector(".slot-container");
    this.draggableElements.forEach((draggableElement) => (draggableElement.internaldragging = true));
    this.dragElementRect = this.dragElement.getBoundingClientRect();
    const selfBoundingClientRect = this.self.getBoundingClientRect();
    const offsetParentBoundingClientRect = (_b = (_a = miscUtil.findUpperElementByPredicate(this.self, (element) => getComputedStyle(element).transform !== "none")) === null || _a === void 0 ? void 0 : _a.getBoundingClientRect()) !== null && _b !== void 0 ? _b : { x: 0, y: 0 };
    const floatingOffset = new mathUtil.Point(2);
    this.startDragOffset = mathUtil.toPoint(selfBoundingClientRect)
      .minus(e.detail)
      .minus(offsetParentBoundingClientRect)
      .minus(floatingOffset);
    this.updateDragElementPosition(e.detail);
  }
  onDragFinished() {
    if (!this.isCurrentlyDragging()) {
      return;
    }
    this.dragElement.style.transform = "translate3d(0,0,0)";
    this.dragElement = null;
    this.draggableElements.forEach((draggableElement) => (draggableElement.internaldragging = false));
    this.dragElementRect = null;
    this.startDragOffset = null;
    this.draggingEnd.emit();
  }
  onWindowMouseMove(e) {
    if (!this.isCurrentlyDragging()) {
      return;
    }
    this.updateDragElementPosition(e.detail);
  }
  isCurrentlyDragging() {
    return this.internaldraggable && this.dragElement != null;
  }
  updateDragElementPosition(position) {
    this.dragElement.style.setProperty("transform", `translate3d(${position.x + this.startDragOffset.x}px, ${position.y + this.startDragOffset.y}px, 0)`);
    this.dragging.emit(position.copy());
  }
  renderPlaceholder() {
    var _a;
    if (this.isCurrentlyDragging()) {
      return (index.h("div", { style: {
          width: `${this.dragElementRect.width}px`,
          height: `${(_a = this.dragElementRect) === null || _a === void 0 ? void 0 : _a.height}px`,
        } }));
    }
  }
  renderSlot(width, height) {
    return (index.h("div", { class: {
        "slot-container": true,
      }, style: {
        width: width != null && !isNaN(width) ? `${width}px` : "100%",
        height: height != null && !isNaN(height) ? `${height}px` : "unset",
      } }, index.h("slot", null)));
  }
  renderContent() {
    var _a, _b;
    if (!this.internaldraggable) {
      return this.renderSlot();
    }
    return [
      this.renderSlot((_a = this.dragElementRect) === null || _a === void 0 ? void 0 : _a.width, (_b = this.dragElementRect) === null || _b === void 0 ? void 0 : _b.height),
      this.renderPlaceholder(),
    ];
  }
  render() {
    return (index.h(index.Host, { class: { dragging: this.isCurrentlyDragging() } }, this.renderContent()));
  }
  get self() { return index.getElement(this); }
  static get watchers() { return {
    "dragElement": ["onDragElementChanged"],
    "internaldraggable": ["onSortableChange"]
  }; }
};
DxSortItem.style = dxSortItemCss;

exports.dx_sort = DxSort;
exports.dx_sort_item = DxSortItem;
