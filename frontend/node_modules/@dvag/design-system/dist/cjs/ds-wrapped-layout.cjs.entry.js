'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const index = require('./index-2f41386b.js');
const slotObserver = require('./slot-observer-2e83212e.js');
const breakpointAware = require('./breakpoint-aware-cc9d0ee6.js');
const renderUtil = require('./render-util-6b278c0d.js');
require('./query-util-8642f149.js');

const dsWrappedLayoutCss = ":host{display:flex;flex-wrap:wrap}:host:host([hidden]){display:none !important}:host ::slotted(*){box-sizing:border-box}:host:host(.align-left){justify-content:flex-start}:host:host(.align-center){justify-content:center}:host:host(.align-right){justify-content:flex-end}";

const DsWrappedLayout = class {
  constructor(hostRef) {
    index.registerInstance(this, hostRef);
    /**
     * Legt die Größe der Elemente fest.
     *
     * Je kleiner die Elementgröße festgelegt wird, desto mehr
     * Elemente werden in einer Reihe angezeigt.
     * @value xs: Sehr klein
     * @value s: Klein
     * @value m: Normal
     * @value l: Groß
     * @value xl: Sehr groß
     * @example sizes
     */
    this.size = "m";
    /**
     * Ausrichtung von Elementen, wenn eine Reihe auf Grund der
     * Anzahl an Elementen nicht vervollständigt werden kann.
     * @value left: Linksbündig
     * @value center: Zentriert
     * @value right: Rechtsbündig
     * @example align-left
     * @example align-center
     * @example align-right
     */
    this.align = "center";
  }
  onWindowResize() {
    this.layout();
  }
  connectedCallback() {
    this.breakpointAware = new breakpointAware.BreakpointAware(() => {
      // noop
    });
    this.slotObserver = new slotObserver.SlotObserver(this.self, "*", () => {
      this.layout();
    });
  }
  disconnectedCallback() {
    var _a, _b;
    (_a = this.slotObserver) === null || _a === void 0 ? void 0 : _a.disconnect();
    (_b = this.breakpointAware) === null || _b === void 0 ? void 0 : _b.disconnect();
  }
  componentDidRender() {
    renderUtil.onNextFrame(() => this.layout());
  }
  layout() {
    const slot = this.self.shadowRoot.querySelector("slot");
    if (slot == null) {
      return;
    }
    const nodes = Array.from(slot.assignedElements()).filter((node) => getComputedStyle(node).display !== "none");
    const availableWidth = this.self.getBoundingClientRect().width;
    const refWidth = this.referenceSize();
    const gapSize = this.gapSize();
    // Compute elements per row
    let elementsPerRow = Math.floor(availableWidth / refWidth + 0.25); // tolerate that element can be 25% smaller.
    elementsPerRow = Math.max(1, elementsPerRow);
    // Gaps between two elements
    const gaps = elementsPerRow - 1;
    // Effective elements with
    const elementWidth = (availableWidth - gaps * gapSize) / elementsPerRow;
    // Apply on all nodes
    nodes.forEach((node, index) => {
      const isFirstInRow = index % elementsPerRow === 0;
      const isInFirstRow = index < elementsPerRow;
      node.style.margin = "0"; // reset margin
      if (!isFirstInRow) {
        node.style.marginLeft = `${gapSize}px`;
      }
      if (!isInFirstRow) {
        node.style.marginTop = `${gapSize}px`;
      }
      node.style.width = `${elementWidth}px`;
    });
  }
  referenceSize() {
    if (this.size === "xs") {
      return 100;
    }
    if (this.size === "s") {
      return 200;
    }
    if (this.size === "m") {
      return 300;
    }
    if (this.size === "l") {
      return 400;
    }
    if (this.size === "xl") {
      return 500;
    }
  }
  gapSize() {
    if (this.breakpointAware.xl) {
      return 32;
    }
    if (this.breakpointAware.lg || this.breakpointAware.md) {
      return 24;
    }
    return 16;
  }
  render() {
    return (index.h(index.Host, { class: {
        "align-left": this.align === "left",
        "align-center": this.align === "center",
        "align-right": this.align === "right",
      } }, index.h("slot", null)));
  }
  get self() { return index.getElement(this); }
};
DsWrappedLayout.style = dsWrappedLayoutCss;

exports.ds_wrapped_layout = DsWrappedLayout;
