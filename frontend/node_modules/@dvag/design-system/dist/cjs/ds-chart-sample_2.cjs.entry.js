'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const index = require('./index-2f41386b.js');
const assert = require('./assert-d8ea75c6.js');
const slotObserver = require('./slot-observer-2e83212e.js');
const mathUtil = require('./math-util-a514efc6.js');
require('./query-util-8642f149.js');

const DsChartSample = class {
  constructor(hostRef) {
    index.registerInstance(this, hostRef);
    this.valueChange = index.createEvent(this, "valueChange", 7);
  }
  onValueChange(newValue, oldValue) {
    if (newValue !== oldValue) {
      this.valueChange.emit(this.value);
    }
  }
  /**
   * Maps the component into a JS object.
   */
  async toChartSample() {
    assert.assertPropertyNotEmpty("ds-chart-sample", "color", this.color, "Every chart sample must have a unique color.");
    const exposedValue = Math.max(this.value, 0) || 0;
    return {
      label: this.label,
      value: exposedValue,
      formattedValue: this.formattedValue || exposedValue.toString(),
      color: this.color,
    };
  }
  componentShouldUpdate() {
    if (isNaN(this.value)) {
      return false;
    }
  }
  static get watchers() { return {
    "value": ["onValueChange"]
  }; }
};

const dsDonutChartCss = ":host{display:block;position:relative}:host:host([hidden]){display:none !important}.center{display:flex;justify-content:center;align-items:center;position:absolute;transform:translateX(-50%) translateY(-50%)}";

const DsDonutChart = class {
  constructor(hostRef) {
    index.registerInstance(this, hostRef);
    this.segmentSelect = index.createEvent(this, "segmentSelect", 7);
    this.mouseMoveHandler = (mouseEvent) => {
      this.handleMouseMove(mouseEvent);
    };
    this.chartInput = [];
    this.selected = null;
    /**
     * The radius of the donut.
     *
     * @value Number:
     */
    this.radius = 50;
    /**
     * Specifies the width of the donut's segments.
     *
     * @value number: The width of a segment.
     */
    this.segmentwidth = 10;
    /**
     * The distance between all segments.
     *
     * @value number: The distance in pixels.
     */
    this.offset = 5;
    /**
     * Specifies the scale factor of selected segments.
     *
     * @value number: The scaling factor of the selected segment.
     */
    this.scale = 1.5;
    /**
     * The starting angle of the first segment.
     *
     * @value number: An angle between 0 and 360.
     * e.g.:
     * First segment starts...
     * - 0: from the top (12 o'clock)
     * - 90: from the right (3 o'clock)
     * - 180: from the bottom (6 o'clock)
     * - 270: from the left (9 o'clock)
     */
    this.startangle = 0;
  }
  connectedCallback() {
    this.slotObserver =
      slotObserver.createMetaComponentsSlotObserver(this.self, "ds-chart-sample", (nodes) => this.collectSamplesFromChildren(nodes));
  }
  disconnectedCallback() {
    var _a;
    (_a = this.slotObserver) === null || _a === void 0 ? void 0 : _a.disconnect();
  }
  async collectSamplesFromChildren(nodes) {
    this.chartInput = await Promise.all(nodes.map((node) => node.toChartSample()));
  }
  getHitAngle(mouseX, mouseY) {
    const elementPosition = this.self.getBoundingClientRect();
    const relativeOrigin = this.circleOrigin;
    const clientOrigin = {
      x: relativeOrigin.x + elementPosition.x,
      y: relativeOrigin.y + elementPosition.y,
    };
    const mousePosition = { x: mouseX, y: mouseY };
    const direction = {
      x: mousePosition.x - clientOrigin.x,
      y: mousePosition.y - clientOrigin.y,
    };
    const lengthSquared = direction.x * direction.x + direction.y * direction.y;
    const scaledRadiusOuter = this.getScaledOuterRadius();
    const scaledRadiusInner = scaledRadiusOuter - this.segmentwidth * this.scale * 2;
    const minRadiusSquared = scaledRadiusInner * scaledRadiusInner;
    const maxRadiusSquared = scaledRadiusOuter * scaledRadiusOuter;
    // Check if the mouse is between the segments
    if (lengthSquared >= minRadiusSquared &&
      lengthSquared <= maxRadiusSquared) {
      let angle = (Math.acos(direction.x /
        Math.sqrt(direction.x * direction.x + direction.y * direction.y)) *
        180) /
        mathUtil.PI;
      if (mousePosition.y < clientOrigin.y) {
        angle = 360 - angle;
      }
      const angleOffset = this.startangle - 90;
      return (angle - angleOffset + 360) % 360;
    }
    return null;
  }
  handleMouseMove(e) {
    const angle = this.getHitAngle(e.clientX, e.clientY);
    if (angle != null) {
      this.selectSegmentByAngle(angle);
    }
    else {
      this.selectSegment(null);
    }
  }
  selectSegmentByAngle(angle) {
    const max = this.chartInput
      .map((input) => input.value)
      .reduce((previous, current) => previous + current, 0);
    let count = 0;
    const index = this.chartInput.findIndex((sample) => {
      const from = count;
      count += sample.value;
      const to = count;
      const fromAngle = (from / max) * 360;
      const toAngle = (to / max) * 360;
      return angle >= fromAngle && angle <= toAngle;
    });
    if (index !== -1) {
      this.selectSegment(index);
      return true;
    }
    return false;
  }
  selectSegment(index) {
    if (this.selected !== index) {
      this.selected = index;
      this.segmentSelect.emit(index);
    }
  }
  addWindowHandler() {
    window.addEventListener("mousemove", this.mouseMoveHandler);
  }
  removeWindowHandler() {
    window.removeEventListener("mousemove", this.mouseMoveHandler);
  }
  getCircleSegmentPoints(circleOrigin, radius, percentage, offset, width) {
    const points = [];
    const angleOffset = -90 + this.startangle;
    const fromAngle = offset * 3.6 + angleOffset;
    const toAngle = (offset + percentage) * 3.6 + angleOffset;
    const radiusOuter = radius + width * 0.5;
    const radiusInner = radiusOuter - width;
    let last = 0;
    for (let angle = fromAngle; angle < toAngle; angle += 5) {
      if (angle > toAngle) {
        angle = toAngle;
      }
      const circlePoint = mathUtil.getPointOnCircle(radiusOuter, angle);
      points.push(circlePoint);
      last = angle;
    }
    if (toAngle - last > 0) {
      const circlePoint = mathUtil.getPointOnCircle(radiusOuter, toAngle);
      points.push(circlePoint);
    }
    for (let i = points.length - 1; i >= 0; --i) {
      const widthDirection = {
        x: radiusInner * (points[i].x / radiusOuter),
        y: radiusInner * (points[i].y / radiusOuter),
      };
      points.push(widthDirection);
    }
    return points
      .map((point) => {
      point.x += circleOrigin.x;
      point.y += circleOrigin.y;
      return point.x + "," + point.y;
    })
      .join(" ");
  }
  generateDonutCreateData() {
    return this.chartInput.reduce((acc, input, i) => {
      const offset = i == 0
        ? 0
        : acc.segments[i - 1].offset + acc.segments[i - 1].input.value;
      return {
        segments: [
          ...acc.segments,
          {
            input,
            offset,
          },
        ],
        sum: acc.sum + input.value,
      };
    }, {
      segments: [],
      sum: 0,
    });
  }
  get maxSize() {
    return this.getScaledOuterRadius() * 2;
  }
  get circleOrigin() {
    return {
      x: this.maxSize * 0.5,
      y: this.maxSize * 0.5,
    };
  }
  getScaledOuterRadius() {
    const addedSegmentWidth = this.segmentwidth * this.scale;
    return this.radius + addedSegmentWidth * 0.5;
  }
  render() {
    if (this.chartInput == null)
      return (index.h(index.Host, null, index.h("slot", { name: "content" })));
    const halfSize = this.maxSize * 0.5;
    const minSize = (this.getScaledOuterRadius() - this.segmentwidth * this.scale) * 2;
    return (index.h(index.Host, { onMouseEnter: () => {
        this.addWindowHandler();
      }, onMouseLeave: () => {
        this.removeWindowHandler();
        this.selectSegment(null);
      } }, this.renderDonutChart(), index.h("div", { class: "center", style: {
        top: halfSize + "px",
        left: halfSize + "px",
        width: minSize + "px",
        height: minSize + "px",
      } }, index.h("slot", { name: "content" })), index.h("slot", null)));
  }
  renderDonutChart() {
    const createData = this.generateDonutCreateData();
    const svgSize = this.maxSize + "px";
    return (index.h("svg", { style: { width: svgSize, height: svgSize } }, this.renderSegments(createData)));
  }
  renderSegment(circleOrigin, radius, percentage, offset, width, color, strokeWidth) {
    if (percentage <= 0) {
      return;
    }
    return (index.h("polygon", { class: "segment", points: this.getCircleSegmentPoints(circleOrigin, radius, percentage, offset, width), style: {
        fill: color,
        stroke: "white",
        strokeWidth: strokeWidth,
      } }));
  }
  renderSegments(createData) {
    if (createData.sum === 0) {
      return null;
    }
    const circleOrigin = this.circleOrigin;
    const segments = createData.segments
      .map((segmentInfo, index) => {
      if (index != this.selected) {
        const percentage = (100 * segmentInfo.input.value) / createData.sum;
        const offsetPercentage = (100 * segmentInfo.offset) / createData.sum;
        return this.renderSegment(circleOrigin, this.radius, percentage, offsetPercentage, this.segmentwidth + this.offset, segmentInfo.input.color, `${this.offset}`);
      }
      return undefined;
    })
      .filter((item) => item !== undefined);
    // Always draw the selected segement last (z-index doesn't work for svgs)
    if (this.selected != null) {
      const segmentInfo = createData.segments[this.selected];
      const percentage = (100 * segmentInfo.input.value) / createData.sum;
      const offsetPercentage = (100 * segmentInfo.offset) / createData.sum;
      const scaledSegmentWidth = this.segmentwidth * this.scale + this.offset;
      segments.push(this.renderSegment(circleOrigin, this.radius, percentage, offsetPercentage, scaledSegmentWidth, segmentInfo.input.color, `${this.offset}`));
    }
    return segments;
  }
  get self() { return index.getElement(this); }
};
DsDonutChart.style = dsDonutChartCss;

exports.ds_chart_sample = DsChartSample;
exports.ds_donut_chart = DsDonutChart;
