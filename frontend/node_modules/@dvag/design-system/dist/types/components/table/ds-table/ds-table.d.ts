import { ComponentInterface, EventEmitter } from "../../../stencil-public-runtime";
import { SortState } from "../table-common-types";
/**
 * A table for visualizing data in columns and rows.
 *
 * It has the ability to sort and paginate it's content out of the box.
 * This feature can be disabled, if you want to realize data sorting and pagination manually.
 *
 * @name Table
 * @path /
 * @icon table
 * @stable
 *
 * @slot - Definition of the table data (rows) and data structure (columns) by using specialized sub-component (e.g.: `ds-table-header`, `ds-table-row`, etc.).
 * @slot title - This slot contains the title of the card, if a card layout is configured in the `view` attribute.
 */
export declare class DsTable implements ComponentInterface {
  private headerItemObserver;
  private rowObserver;
  private headerItemElements;
  private rowElements;
  private settings;
  private currentSortSettings;
  private tableResizeObserver;
  private sortDebounce;
  private rowDebounce;
  private selectionGroup;
  private touchMoveDetected;
  private scrollHintFadedOutHandler;
  private scrollHandler;
  self: HTMLDsTableElement;
  currentPage: number;
  sortState: SortState;
  selectedRowKeys: string[];
  showLeftGradient: boolean;
  showRightGradient: boolean;
  showScrollHint: boolean;
  scrollHintNecessary: boolean;
  internalScrollable: boolean;
  scrollContainer: HTMLDivElement;
  /**
   * Defines the style of this table.
   *
   * @value default: Default table
   * @value paginated-card: Table within a card with pagination.
   * @value paginated-card-shadow: Table within a shadowed card with pagination.
   *
   * @example paginator
   */
  view: "default" | "paginated-card" | "paginated-card-shadow";
  /**
   * Defines the options for the page size that a user can pick from.
   * It only has an effect if the `view` attribute supports pagination.
   *
   * @value string: Comma seperated list of numbers (e.g: [25,50,100]).
   *
   * @example paginator
   */
  pagesizes: string;
  /**
   * The initially selected option for the page size.
   * It only has an effect if the `view` attribute supports pagination.
   *
   * @value number: Number of rows per page.
   *
   * @example paginator
   */
  pagesize: number;
  /**
   * Defines the column that is used for initially sorting the table.
   *
   * @value string: The `columnId` or `label` of the column.
   *
   * @example initial-sort
   */
  initialsort?: string;
  /**
   * Specifies the initial sort direction.
   *
   * @value asc: Ascending order.
   * @value desc: Descending order.
   *
   * @example initial-sort
   */
  initialsortdirection: "asc" | "desc";
  /**
   * Specifies whether the table is self-managed or remote-controlled.
   *
   * @value managed: The table is responsible for sorting and pagination.
   * @value remote: The table relies on an external implementation for creating rows, sorting and pagination using the `tableStateChanged` event.
   *
   * @example remote
   * @example remote-complex
   */
  mode: "managed" | "remote";
  /**
   * **Warning: This feature is highly experimental.**
   *
   * Enables the selection of rows.
   * A `key` for every row has to be specified.
   *
   * @value true: The selection-group will be opened.
   * @value false: The selection-group will be closed.
   *
   * @example selection
   */
  selectionenabled: boolean;
  /**
   * **Warning: This feature is highly experimental.**
   *
   * Specifies if only one or multiple rows can be selected.
   *
   * @value multi: Multiple rows can be selected.
   * @value single: One row can be selected at a time.
   *
   * @example selection-mode
   */
  selectionmode: "multi" | "single";
  onSideBarOpenChange(): void;
  /**
   * The data length this table should visualize. In case the table manages itself this attribute should not be set.
   * If the table is remote-controlled this attribute has to be set because the table needs to know the exact amount
   * of data to visualize the **paging** accordingly.
   *
   * @example remote
   * @example remote-complex
   */
  rowcount: number;
  /**
   * Specifies if the table should be scrollable. It is necessary to ensure that every `<ds-header-item>` has the width property set.
   * @value true: Table is scrollable.
   * @value false: Table is not scrollable.
   * @example scrollable
   */
  scrollable: boolean;
  onScrollableChange(): void;
  onTouchStart(): void;
  onTouchmove(): void;
  onTouchEnd(event: TouchEvent): void;
  /**
   * This event will be fired as soon as the table`s state changes (e.g. sorting, paging...)
   *
   * @example table-state-changed
   */
  tableStateChanged: EventEmitter<TableConfig>;
  /**
   * In case a row is selected this event will fire the key of the row.
   *
   * @value string: If the `selectionmode` allows a single selection the event will delegate one selected row key.
   * @value string[]: If the `selectionmode` allows a multi selection the event will delegate all selected row keys.
   * **!!!Experimental feature!!!**
   */
  rowsSelected: EventEmitter<string[]>;
  connectedCallback(): void;
  private initResizeObserver;
  private setScrollable;
  private updateTableScroll;
  private hideScrollHint;
  private controlOpticalHints;
  private isScrollingPossible;
  private calculateScrollHintNecessary;
  private calculateShouldHideScrollHint;
  disconnectedCallback(): void;
  private initialized;
  private invokeSortInputParamsBeforeInit;
  /**
   * @internal
   */
  invokeSort(element: HTMLDsTableHeaderItemElement, reverse: boolean): Promise<void>;
  private internalInvokeSort;
  private reSort;
  private isViewUsingPagination;
  private observeRows;
  private handleRemoteSelection;
  private init;
  private updateVisibility;
  private getCurrentRowsRangeIndices;
  private updateAlternatingRowHighlights;
  private emitTableStateChanged;
  private observeHeaderItems;
  private differentSettings;
  private updateCellSettings;
  private getRows;
  private getFooters;
  private compareColumns;
  private sortRows;
  private checkForDuplicateRowKeys;
  private manipulateDOMRows;
  private handlePaginationPageSizeChanged;
  private handlePaginationPageChanged;
  private handleRadioSelection;
  private handleCheckboxSelection;
  componentDidRender(): void;
  render(): any;
  private renderSelectionGroup;
  private renderCheckboxSelection;
  private renderRadioSelection;
  private renderSidebarFooter;
  private getScrollWidth;
  private renderSidebar;
  private setScrollContainer;
  private renderScrollableTableContent;
  private renderScrollHint;
  private renderTable;
  private renderDefault;
  renderPaginatedCard(shadow: boolean): any;
}
export interface TableConfig {
  page: number;
  pageSize: number;
  fromIndex: number;
  toIndex: number;
  sortState: SortState;
}
