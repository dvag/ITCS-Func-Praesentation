export declare function waitAnimationFrames(frames: number): Promise<void>;
export declare function waitAnimationFrame(): Promise<void>;
/**
 * Returns the lower cased tagName of an HTMLElement
 * @param element The element to get the tag name of or a tagName itself.
 */
export declare function tagOf(element: HTMLElement): string;
/**
 * Use for elements that are rendered inside the Shadow DOM.
 * For everything else use Element.closest<TYPE>(selector).
 */
export declare function findUpperElement<T extends HTMLElement>(of: HTMLElement, tagName: string): T;
/**
 * Use for elements that are rendered inside the Shadow DOM.
 * For everything else use Element.closest<TYPE>(selector).
 */
export declare function findUpperElementByPredicate<T extends HTMLElement>(of: HTMLElement, predicate: (elem: HTMLElement) => boolean, breakCondition?: (elem: HTMLElement) => boolean): T;
/**
 * Returns closest parent scroll element.
 */
export declare function findClosestScrollElement(element: HTMLElement): HTMLElement;
export declare function isActiveElement(element: HTMLElement): boolean;
export declare function getInnerActiveElement(element: HTMLElement): HTMLElement;
/**
 * Use for elements that are rendered inside the Shadow DOM.
 * For everything else use Element.closest<TYPE>(selector).
 */
export declare function isInnerElement(element: HTMLElement, of: HTMLElement): boolean;
export declare function parentElement(el: HTMLElement): HTMLElement;
/**
 * Checks if two arrays contain the same items with the same indices within the array.
 * @param first: First array
 * @param second: Second array
 */
export declare function sameArrayInOrder<T>(first: T[], second: T[]): boolean;
/**
 * Checks if two arrays contain the same items.
 * @param first: First array
 * @param second: Second array
 */
export declare function sameArrayIgnoreOrder<T>(first: T[], second: T[]): boolean;
/**
 * Filters nodes by tag name
 */
export declare function filterElementsByTagPrefix<T extends HTMLElement>(nodes: HTMLElement[], tagName: string): T[];
export declare function getSlottedContent(element: HTMLElement): HTMLElement[];
export declare function getNamedSlottedContent(element: HTMLElement, slot?: string): HTMLElement[];
/**
 * Returns all contents within a slot element recursively. If the provided element is not a slot element it returns
 * the element itself.
 * @param element: The slot element
 */
export declare function getContentFromSlot(element: HTMLElement): HTMLElement | HTMLElement[];
/**
 * Checks whether an element could has overflowing content.
 * @param element: The element which should be checked. Normally this would be an element which has the corresponding styles applied to it (text-overflow, overflow, etc.)
 *
 * @return Whether the element is overflowing.
 */
export declare function isOverflown(element: HTMLElement): boolean;
/**
 * Generates initials for a person's full name.
 * @param fullname The name to generate the initials from. The fullname has to begin with the firstname and has to end with
 * the lastname with all names separated by a space.
 */
export declare function generateInitialsForName(fullname: string): string;
export declare function createNumberArray(from: number, to: number): number[];
export declare type MapOf<T> = {
  [key: string]: T;
};
/**
 * Used for wrapping a primitive type to store a reference
 */
export declare type Ref<T extends number | string | boolean | bigint | symbol> = {
  value: T;
};
export declare function replaceCommaWithDot(value: string): string;
/**
 * Thanks to the never type this function throws a compile error, when the program can reach the function call.
 * @param never
 * Use this in the default case of a switch that swtiches on a enum type, to make it typesafe-ish.
 * @example switch(weekday) {
 *  case Weekday.Sunday:
 * return "Free";
 * default:
 *  throwCompileErrorIfReachable(weekday);
 * }
 *
 */
export declare const throwCompileErrorIfReachable: (never: never) => void;
export declare function hookToUpdateProperty<T, K>(obj: T, prop: keyof T, onSetProperty?: (k: K) => void): void;
