import { ChangeDetectorRef, ElementRef, EventEmitter, NgZone } from '@angular/core';
import { Components } from '@dvag/design-system';
import * as ɵngcc0 from '@angular/core';
export declare interface DsActionList extends Components.DsActionList {
}
export declare class DsActionList {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DsActionList, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DsActionList, "ds-action-list", never, {}, {}, never, ["*"], false>;
}
export declare interface DsActionListItem extends Components.DsActionListItem {
}
export declare class DsActionListItem {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DsActionListItem, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DsActionListItem, "ds-action-list-item", never, {}, {}, never, ["*"], false>;
}
export declare interface DsAlert extends Components.DsAlert {
}
export declare class DsAlert {
    protected z: NgZone;
    /** Fires when the user interacts with one of the alert's buttons. @exqmple button-click*/
    buttonClick: EventEmitter<CustomEvent<string>>;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DsAlert, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DsAlert, "ds-alert", never, { "actionsdirection": "actionsdirection"; "visible": "visible"; }, { "buttonClick": "buttonClick"; }, never, ["*"], false>;
}
export declare interface DsAlertButton extends Components.DsAlertButton {
}
export declare class DsAlertButton {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DsAlertButton, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DsAlertButton, "ds-alert-button", never, { "color": "color"; "confirm": "confirm"; "disabled": "disabled"; "highlight": "highlight"; "label": "label"; "value": "value"; }, {}, never, ["*"], false>;
}
export declare interface DsAnnouncementBar extends Components.DsAnnouncementBar {
}
export declare class DsAnnouncementBar {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DsAnnouncementBar, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DsAnnouncementBar, "ds-announcement-bar", never, {}, {}, never, ["*"], false>;
}
export declare interface DsApp extends Components.DsApp {
}
export declare class DsApp {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DsApp, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DsApp, "ds-app", never, {}, {}, never, ["*"], false>;
}
export declare interface DsBorderedFormGroup extends Components.DsBorderedFormGroup {
}
export declare class DsBorderedFormGroup {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DsBorderedFormGroup, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DsBorderedFormGroup, "ds-bordered-form-group", never, { "direction": "direction"; "size": "size"; }, {}, never, ["*"], false>;
}
export declare interface DsBorderedFormItem extends Components.DsBorderedFormItem {
}
export declare class DsBorderedFormItem {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DsBorderedFormItem, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DsBorderedFormItem, "ds-bordered-form-item", never, {}, {}, never, ["*"], false>;
}
export declare interface DsButton extends Components.DsButton {
}
export declare class DsButton {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DsButton, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DsButton, "ds-button", never, { "disabled": "disabled"; "size": "size"; "stretch": "stretch"; "type": "type"; "unfocusable": "unfocusable"; }, {}, never, ["*"], false>;
}
export declare interface DsButtonBar extends Components.DsButtonBar {
}
export declare class DsButtonBar {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DsButtonBar, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DsButtonBar, "ds-button-bar", never, { "direction": "direction"; }, {}, never, ["*"], false>;
}
export declare interface DsCard extends Components.DsCard {
}
export declare class DsCard {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DsCard, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DsCard, "ds-card", never, { "shadow": "shadow"; }, {}, never, ["*"], false>;
}
export declare interface DsCardCollapsable extends Components.DsCardCollapsable {
}
export declare class DsCardCollapsable {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DsCardCollapsable, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DsCardCollapsable, "ds-card-collapsable", never, { "label": "label"; "open": "open"; "type": "type"; }, {}, never, ["*"], false>;
}
export declare interface DsCardContent extends Components.DsCardContent {
}
export declare class DsCardContent {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DsCardContent, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DsCardContent, "ds-card-content", never, {}, {}, never, ["*"], false>;
}
export declare interface DsCardHeader extends Components.DsCardHeader {
}
export declare class DsCardHeader {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DsCardHeader, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DsCardHeader, "ds-card-header", never, {}, {}, never, ["*"], false>;
}
export declare interface DsCardImageHeader extends Components.DsCardImageHeader {
}
export declare class DsCardImageHeader {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DsCardImageHeader, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DsCardImageHeader, "ds-card-image-header", never, { "url": "url"; }, {}, never, ["*"], false>;
}
export declare interface DsCardTabBar extends Components.DsCardTabBar {
}
export declare class DsCardTabBar {
    protected z: NgZone;
    /** This event will be delegated when the tab switches.
  It contains the `name` of the current `<ds-card-tab-page>`. @example show-change*/
    showChange: EventEmitter<CustomEvent<string>>;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DsCardTabBar, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DsCardTabBar, "ds-card-tab-bar", never, { "show": "show"; }, { "showChange": "showChange"; }, never, ["*"], false>;
}
export declare interface DsCardTabPage extends Components.DsCardTabPage {
}
export declare class DsCardTabPage {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DsCardTabPage, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DsCardTabPage, "ds-card-tab-page", never, { "label": "label"; "name": "name"; }, {}, never, ["*"], false>;
}
export declare interface DsCenteredBoard extends Components.DsCenteredBoard {
}
export declare class DsCenteredBoard {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DsCenteredBoard, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DsCenteredBoard, "ds-centered-board", never, { "columns": "columns"; }, {}, never, ["*"], false>;
}
export declare interface DsCenteredBoardItem extends Components.DsCenteredBoardItem {
}
export declare class DsCenteredBoardItem {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DsCenteredBoardItem, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DsCenteredBoardItem, "ds-centered-board-item", never, {}, {}, never, ["*"], false>;
}
export declare interface DsChartSample extends Components.DsChartSample {
}
export declare class DsChartSample {
    protected z: NgZone;
    /** Triggers when value of the sample changes. @value number: Delegates the new value.*/
    valueChange: EventEmitter<CustomEvent<number>>;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DsChartSample, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DsChartSample, "ds-chart-sample", never, { "color": "color"; "formattedValue": "formattedValue"; "label": "label"; "value": "value"; }, { "valueChange": "valueChange"; }, never, ["*"], false>;
}
export declare interface DsCheckbox extends Components.DsCheckbox {
}
export declare class DsCheckbox {
    protected z: NgZone;
    /** Indicates that an error exist within the checkbox. Colors the border in red. @example check-event*/
    checkedChange: EventEmitter<CustomEvent<boolean>>;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DsCheckbox, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DsCheckbox, "ds-checkbox", never, { "checked": "checked"; "disabled": "disabled"; "error": "error"; "errormessage": "errormessage"; "label": "label"; "readonly": "readonly"; "required": "required"; }, { "checkedChange": "checkedChange"; }, never, ["*"], false>;
}
export declare interface DsColumn extends Components.DsColumn {
}
export declare class DsColumn {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DsColumn, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DsColumn, "ds-column", never, { "align": "align"; }, {}, never, ["*"], false>;
}
import { DateError as IDsDateInputDateError } from '@dvag/design-system/dist/types/components/form/inputs/date/date';
export declare interface DsDateInput extends Components.DsDateInput {
}
export declare class DsDateInput {
    protected z: NgZone;
    /** Delegates the current value while the user is editing the input. @example change-events*/
    valueChange: EventEmitter<CustomEvent<string>>;
    /** Delegates the final value when the user submits the result by pressing 'Enter' or unfocusing this component. @example change-events*/
    valueComplete: EventEmitter<CustomEvent<string>>;
    /** Delegates the final value when the user submits the result by pressing 'Enter' or unfocusing this component. @example change-events*/
    errorFound: EventEmitter<CustomEvent<IDsDateInputDateError>>;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DsDateInput, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DsDateInput, "ds-date-input", never, { "disabled": "disabled"; "error": "error"; "errormessage": "errormessage"; "kisynced": "kisynced"; "label": "label"; "max": "max"; "min": "min"; "mode": "mode"; "readonly": "readonly"; "required": "required"; "value": "value"; }, { "valueChange": "valueChange"; "valueComplete": "valueComplete"; "errorFound": "errorFound"; }, never, ["*"], false>;
}
export declare interface DsDateRange extends Components.DsDateRange {
}
export declare class DsDateRange {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DsDateRange, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DsDateRange, "ds-date-range", never, { "max": "max"; "min": "min"; "mode": "mode"; "value": "value"; }, {}, never, ["*"], false>;
}
export declare interface DsDonutChart extends Components.DsDonutChart {
}
export declare class DsDonutChart {
    protected z: NgZone;
    /** Triggers when a segment is clicked. It delegates the index of the selected segment. @value number: The index of the selected segment.*/
    segmentSelect: EventEmitter<CustomEvent<number>>;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DsDonutChart, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DsDonutChart, "ds-donut-chart", never, { "offset": "offset"; "radius": "radius"; "scale": "scale"; "segmentwidth": "segmentwidth"; "startangle": "startangle"; }, { "segmentSelect": "segmentSelect"; }, never, ["*"], false>;
}
import { StringOrObject as IDsDropdownStringOrObject } from '@dvag/design-system/dist/types/components/form/ds-dropdown/ds-dropdown';
export declare interface DsDropdown extends Components.DsDropdown {
}
export declare class DsDropdown {
    protected z: NgZone;
    /** Delegates the current selection or text input (`elseoption`) while the user is still editing. @example complex*/
    valueChange: EventEmitter<CustomEvent<IDsDropdownStringOrObject>>;
    /** Delegates the final selection or text input (`elseoption`).
  The event is fired when the dropdown loses focus or pushing the 'Enter' key. @example complex*/
    valueComplete: EventEmitter<CustomEvent<IDsDropdownStringOrObject>>;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DsDropdown, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DsDropdown, "ds-dropdown", never, { "disabled": "disabled"; "elseoption": "elseoption"; "elseoptionbuttonlabel": "elseoptionbuttonlabel"; "elseoptioninputlabel": "elseoptioninputlabel"; "elseoptionselected": "elseoptionselected"; "error": "error"; "errormessage": "errormessage"; "icon": "icon"; "kisynced": "kisynced"; "label": "label"; "placeholder": "placeholder"; "popupposition": "popupposition"; "readonly": "readonly"; "required": "required"; "textalign": "textalign"; "value": "value"; }, { "valueChange": "valueChange"; "valueComplete": "valueComplete"; }, never, ["*"], false>;
}
export declare interface DsDropdownOption extends Components.DsDropdownOption {
}
export declare class DsDropdownOption {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DsDropdownOption, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DsDropdownOption, "ds-dropdown-option", never, { "icon": "icon"; "label": "label"; "secondarylabel": "secondarylabel"; "tertiarylabel": "tertiarylabel"; "value": "value"; }, {}, never, ["*"], false>;
}
export declare interface DsFmErgebnisuebersicht extends Components.DsFmErgebnisuebersicht {
}
export declare class DsFmErgebnisuebersicht {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DsFmErgebnisuebersicht, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DsFmErgebnisuebersicht, "ds-fm-ergebnisuebersicht", never, { "donutcenterlabel": "donutcenterlabel"; "donutlabel": "donutlabel"; "donutsublabel": "donutsublabel"; "donutvisible": "donutvisible"; "firstcolumn": "firstcolumn"; "firstcolumninfo": "firstcolumninfo"; "firstcontributionlabel": "firstcontributionlabel"; "firstcontributionsublabel": "firstcontributionsublabel"; "secondcolumn": "secondcolumn"; "secondcolumninfo": "secondcolumninfo"; "secondcontributionlabel": "secondcontributionlabel"; "secondcontributionsublabel": "secondcontributionsublabel"; }, {}, never, ["*"], false>;
}
export declare interface DsFmErgebnisuebersichtItem extends Components.DsFmErgebnisuebersichtItem {
}
export declare class DsFmErgebnisuebersichtItem {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DsFmErgebnisuebersichtItem, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DsFmErgebnisuebersichtItem, "ds-fm-ergebnisuebersicht-item", never, { "firstcolumninfo": "firstcolumninfo"; "firstcolumnvalue": "firstcolumnvalue"; "label": "label"; "secondcolumninfo": "secondcolumninfo"; "secondcolumnvalue": "secondcolumnvalue"; "sublabel": "sublabel"; }, {}, never, ["*"], false>;
}
export declare interface DsFmErgebnisuebersichtTable extends Components.DsFmErgebnisuebersichtTable {
}
export declare class DsFmErgebnisuebersichtTable {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DsFmErgebnisuebersichtTable, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DsFmErgebnisuebersichtTable, "ds-fm-ergebnisuebersicht-table", never, { "label": "label"; }, {}, never, ["*"], false>;
}
export declare interface DsFooter extends Components.DsFooter {
}
export declare class DsFooter {
    protected z: NgZone;
    /** This event is fired when the user clicks on an information button. The event holds the information about which button is clicked. @example info-button-event*/
    infoButtonClicked: EventEmitter<CustomEvent<string>>;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DsFooter, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DsFooter, "ds-footer", never, { "companyinfo": "companyinfo"; "showimprint": "showimprint"; "showtermsofuse": "showtermsofuse"; }, { "infoButtonClicked": "infoButtonClicked"; }, never, ["*"], false>;
}
export declare interface DsFormLayout extends Components.DsFormLayout {
}
export declare class DsFormLayout {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DsFormLayout, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DsFormLayout, "ds-form-layout", never, { "size": "size"; }, {}, never, ["*"], false>;
}
export declare interface DsFullscreenSpinner extends Components.DsFullscreenSpinner {
}
export declare class DsFullscreenSpinner {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DsFullscreenSpinner, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DsFullscreenSpinner, "ds-fullscreen-spinner", never, {}, {}, never, ["*"], false>;
}
export declare interface DsFunctionIconButton extends Components.DsFunctionIconButton {
}
export declare class DsFunctionIconButton {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DsFunctionIconButton, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DsFunctionIconButton, "ds-function-icon-button", never, { "disabled": "disabled"; "unfocusable": "unfocusable"; }, {}, never, ["*"], false>;
}
export declare interface DsGrid extends Components.DsGrid {
}
export declare class DsGrid {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DsGrid, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DsGrid, "ds-grid", never, { "base": "base"; "l": "l"; "m": "m"; "s": "s"; "xl": "xl"; }, {}, never, ["*"], false>;
}
export declare interface DsGroupedTextInput extends Components.DsGroupedTextInput {
}
export declare class DsGroupedTextInput {
    protected z: NgZone;
    /** Change of the entered value during the user's input. @example change-events*/
    valueChange: EventEmitter<CustomEvent<string>>;
    /** Confirmation of the entered value by the user. Event is triggered by
  Pressing the Enter key or by leaving the input field. @example change-events*/
    valueComplete: EventEmitter<CustomEvent<string>>;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DsGroupedTextInput, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DsGroupedTextInput, "ds-grouped-text-input", never, { "disabled": "disabled"; "error": "error"; "errormessage": "errormessage"; "label": "label"; "mask": "mask"; "readonly": "readonly"; "required": "required"; "value": "value"; }, { "valueChange": "valueChange"; "valueComplete": "valueComplete"; }, never, ["*"], false>;
}
import { GrowStartEvent as IDsGrowBoxGrowStartEvent } from '@dvag/design-system/dist/types/components/layout/ds-grow-box/ds-grow-box';
export declare interface DsGrowBox extends Components.DsGrowBox {
}
export declare class DsGrowBox {
    protected z: NgZone;
    /** Event kennzeichnet den Abschluss einer Transition. Die Event-Payload (`event.detail`)
  enthält Status-Informationen zur Growbox. */
    growStart: EventEmitter<CustomEvent<IDsGrowBoxGrowStartEvent>>;
    /** Wirft Ergeignis, wenn sich die Sichtbarkeit des Contents ändert.
  Die Event-Payload (`event.detail`) enthält einen boolean, ob der
  Content sichtbar ist. */
    contentVisibilityChange: EventEmitter<CustomEvent<boolean>>;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DsGrowBox, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DsGrowBox, "ds-grow-box", never, { "animateoninit": "animateoninit"; "open": "open"; "slidecontent": "slidecontent"; }, { "growStart": "growStart"; "contentVisibilityChange": "contentVisibilityChange"; }, never, ["*"], false>;
}
export declare interface DsHeader extends Components.DsHeader {
}
export declare class DsHeader {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DsHeader, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DsHeader, "ds-header", never, { "brand": "brand"; "fullscreen": "fullscreen"; }, {}, never, ["*"], false>;
}
export declare interface DsHeaderAction extends Components.DsHeaderAction {
}
export declare class DsHeaderAction {
    protected z: NgZone;
    /** Fired when user interacts with this item.
  
  Event contains the label attribute of the action. */
    interaction: EventEmitter<CustomEvent<string>>;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DsHeaderAction, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DsHeaderAction, "ds-header-action", never, { "highlight": "highlight"; "label": "label"; }, { "interaction": "interaction"; }, never, ["*"], false>;
}
export declare interface DsHeaderActionList extends Components.DsHeaderActionList {
}
export declare class DsHeaderActionList {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DsHeaderActionList, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DsHeaderActionList, "ds-header-action-list", never, { "label": "label"; "open": "open"; }, {}, never, ["*"], false>;
}
export declare interface DsHeaderCustomer extends Components.DsHeaderCustomer {
}
export declare class DsHeaderCustomer {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DsHeaderCustomer, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DsHeaderCustomer, "ds-header-customer", never, { "name": "name"; "typelabel": "typelabel"; }, {}, never, ["*"], false>;
}
export declare interface DsHeaderUser extends Components.DsHeaderUser {
}
export declare class DsHeaderUser {
    protected z: NgZone;
    /** Event wird gefeuert, wenn der Nutzer sich abmelden möchte. */
    signOut: EventEmitter<CustomEvent<void>>;
    /** Fired when the user interacts with the Name of the current user, within the avatar-menu. */
    usernameInteraction: EventEmitter<CustomEvent<void>>;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DsHeaderUser, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DsHeaderUser, "ds-header-user", never, { "imageurl": "imageurl"; "name": "name"; "usernameinteractable": "usernameinteractable"; }, { "signOut": "signOut"; "usernameInteraction": "usernameInteraction"; }, never, ["*"], false>;
}
export declare interface DsHeroImage extends Components.DsHeroImage {
}
export declare class DsHeroImage {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DsHeroImage, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DsHeroImage, "ds-hero-image", never, { "url": "url"; }, {}, never, ["*"], false>;
}
export declare interface DsHr extends Components.DsHr {
}
export declare class DsHr {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DsHr, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DsHr, "ds-hr", never, {}, {}, never, ["*"], false>;
}
export declare interface DsIcon extends Components.DsIcon {
}
export declare class DsIcon {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DsIcon, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DsIcon, "ds-icon", never, { "color": "color"; "icon": "icon"; "size": "size"; }, {}, never, ["*"], false>;
}
export declare interface DsIconButton extends Components.DsIconButton {
}
export declare class DsIconButton {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DsIconButton, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DsIconButton, "ds-icon-button", never, { "align": "align"; "backgroundcolor": "backgroundcolor"; "color": "color"; "disabled": "disabled"; "size": "size"; "unfocusable": "unfocusable"; }, {}, never, ["*"], false>;
}
export declare interface DsInfo extends Components.DsInfo {
}
export declare class DsInfo {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DsInfo, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DsInfo, "ds-info", never, { "hidebutton": "hidebutton"; "popupvisible": "popupvisible"; "size": "size"; }, {}, never, ["*"], false>;
}
export declare interface DsLink extends Components.DsLink {
}
export declare class DsLink {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DsLink, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DsLink, "ds-link", never, { "target": "target"; "url": "url"; }, {}, never, ["*"], false>;
}
export declare interface DsLogo extends Components.DsLogo {
}
export declare class DsLogo {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DsLogo, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DsLogo, "ds-logo", never, { "type": "type"; }, {}, never, ["*"], false>;
}
export declare interface DsModal extends Components.DsModal {
}
export declare class DsModal {
    protected z: NgZone;
    /** Wird gefeuert, wenn der Dialog geöffnet wird. */
    modalOpened: EventEmitter<CustomEvent<void>>;
    /** Wird gefeuert, wenn der Dialog vom Nutzer geschlossen wird. (Schließen-Button/Hintergrund klicken) */
    modalClosed: EventEmitter<CustomEvent<void>>;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DsModal, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DsModal, "ds-modal", never, { "allowbackgroundclose": "allowbackgroundclose"; "contentcolor": "contentcolor"; "label": "label"; "size": "size"; "visible": "visible"; }, { "modalOpened": "modalOpened"; "modalClosed": "modalClosed"; }, never, ["*"], false>;
}
export declare interface DsNavigatedContent extends Components.DsNavigatedContent {
}
export declare class DsNavigatedContent {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DsNavigatedContent, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DsNavigatedContent, "ds-navigated-content", never, {}, {}, never, ["*"], false>;
}
import { NavigatedRoute as IDsNavigatedContentMenuNavigatedRoute } from '@dvag/design-system/dist/types/components/scaffold/navigated-content/ds-navigated-content-menu/ds-navigated-content-menu';
export declare interface DsNavigatedContentMenu extends Components.DsNavigatedContentMenu {
}
export declare class DsNavigatedContentMenu {
    protected z: NgZone;
    /** Is triggered if an user interacts with the menu entries.
  The event detail contains following data structure: `{path: 'toplevel/sublevel', segments: ['toplevel', 'sublevel']}` */
    navigate: EventEmitter<CustomEvent<IDsNavigatedContentMenuNavigatedRoute>>;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DsNavigatedContentMenu, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DsNavigatedContentMenu, "ds-navigated-content-menu", never, { "active": "active"; }, { "navigate": "navigate"; }, never, ["*"], false>;
}
export declare interface DsNavigatedContentMenuItem extends Components.DsNavigatedContentMenuItem {
}
export declare class DsNavigatedContentMenuItem {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DsNavigatedContentMenuItem, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DsNavigatedContentMenuItem, "ds-navigated-content-menu-item", never, { "error": "error"; "label": "label"; "success": "success"; "value": "value"; "warning": "warning"; }, {}, never, ["*"], false>;
}
export declare interface DsNotificationToast extends Components.DsNotificationToast {
}
export declare class DsNotificationToast {
    protected z: NgZone;
    /** Fires when the notification closes automatically or by clicking on the close button. @example close-notification*/
    closeNotification: EventEmitter<CustomEvent<void>>;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DsNotificationToast, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DsNotificationToast, "ds-notification-toast", never, { "closeafter": "closeafter"; "icon": "icon"; "iconcolor": "iconcolor"; "subcontent": "subcontent"; "titlestring": "titlestring"; "visible": "visible"; }, { "closeNotification": "closeNotification"; }, never, ["*"], false>;
}
export declare interface DsNumberInput extends Components.DsNumberInput {
}
export declare class DsNumberInput {
    protected z: NgZone;
    /** Changes of the input value during the input of the user. @example change-events*/
    valueChange: EventEmitter<CustomEvent<number>>;
    /** Confirmation of the input value. Event is triggered, when the user presses return or leaving the input field. @example change-events*/
    valueComplete: EventEmitter<CustomEvent<number>>;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DsNumberInput, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DsNumberInput, "ds-number-input", never, { "disabled": "disabled"; "error": "error"; "errormessage": "errormessage"; "kisynced": "kisynced"; "label": "label"; "limitlength": "limitlength"; "max": "max"; "min": "min"; "placeholder": "placeholder"; "precision": "precision"; "profile": "profile"; "readonly": "readonly"; "required": "required"; "thousandseparator": "thousandseparator"; "uniticon": "uniticon"; "value": "value"; }, { "valueChange": "valueChange"; "valueComplete": "valueComplete"; }, never, ["*"], false>;
}
export declare interface DsPage extends Components.DsPage {
}
export declare class DsPage {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DsPage, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DsPage, "ds-page", never, {}, {}, never, ["*"], false>;
}
export declare interface DsPaginator extends Components.DsPaginator {
}
export declare class DsPaginator {
    protected z: NgZone;
    /** Event wird gefeuert, wenn die Seite, durch Klicken der Pfeile oder der Seitenzahlen, geändert wird.
  Der delegierte Wert, reflektiert das `current`-Attribut. */
    pageChanged: EventEmitter<CustomEvent<number>>;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DsPaginator, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DsPaginator, "ds-paginator", never, { "count": "count"; "current": "current"; "range": "range"; }, { "pageChanged": "pageChanged"; }, never, ["*"], false>;
}
export declare interface DsPlaceholder extends Components.DsPlaceholder {
}
export declare class DsPlaceholder {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DsPlaceholder, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DsPlaceholder, "ds-placeholder", never, { "box": "box"; "card": "card"; }, {}, never, ["*"], false>;
}
export declare interface DsRadioButton extends Components.DsRadioButton {
}
export declare class DsRadioButton {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DsRadioButton, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DsRadioButton, "ds-radio-button", never, { "disabled": "disabled"; "error": "error"; "errormessage": "errormessage"; "label": "label"; "value": "value"; }, {}, never, ["*"], false>;
}
export declare interface DsRadioButtonGroup extends Components.DsRadioButtonGroup {
}
export declare class DsRadioButtonGroup {
    protected z: NgZone;
    /** Delegates the current selected `<ds-radio-button>` element's value.
  This event will not trigger when setting the `value` in JavaScript. @example read-value*/
    valueChange: EventEmitter<CustomEvent<string>>;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DsRadioButtonGroup, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DsRadioButtonGroup, "ds-radio-button-group", never, { "disabled": "disabled"; "error": "error"; "errormessage": "errormessage"; "readonly": "readonly"; "required": "required"; "value": "value"; }, { "valueChange": "valueChange"; }, never, ["*"], false>;
}
import { SearchAutoCompleteHandler as IDsSearchSearchAutoCompleteHandler } from '@dvag/design-system/dist/types/components/form/ds-search/auto-complete-value';
export declare interface DsSearch extends Components.DsSearch {
}
export declare class DsSearch {
    protected z: NgZone;
    /**
  While the user is typing, this event is triggered and returns a controller in the event payload (`event.detail`).
  This controller can be used to send input field values for autocompletion.
  The user entered value can be determined using `event.detail.value`.
  
  The generated search suggestions are passed as an array to the `event.detail.provideValues()`
  method. A search suggestion is an object with the properties:
  
  - `label`: Primary search suggestion text, which will be transferred to the input field when it is accepted
  - `prelabel`: Optional text above the label that describes the search suggestion in more detail.
  - `sublabel`: Optional text under the label that describes the search suggestion in more detail
  - `category`: Optional categorization
  - `data`: Optional field for any data.
  
  A search suggestion object can contain further properties, which can be evaluated with the `searchSelect`
  event. @example example*/
    search: EventEmitter<CustomEvent<IDsSearchSearchAutoCompleteHandler>>;
    /** Fired when the user selects a search suggestion.
  As event payload (`event.detail`) the object is supplied,
  which created the search suggestion. @example example*/
    selectSearch: EventEmitter<CustomEvent<any>>;
    /** Fired when the user changes the search term. */
    valueChange: EventEmitter<CustomEvent<string>>;
    /** Confirmation of the entered value by the user. Event is triggered by
  pressing the Enter key or by leaving the input field. */
    valueComplete: EventEmitter<CustomEvent<string>>;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DsSearch, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DsSearch, "ds-search", never, { "autoscrollintoview": "autoscrollintoview"; "noresultstext": "noresultstext"; "placeholder": "placeholder"; "value": "value"; "visibleentries": "visibleentries"; }, { "search": "search"; "selectSearch": "selectSearch"; "valueChange": "valueChange"; "valueComplete": "valueComplete"; }, never, ["*"], false>;
}
export declare interface DsSlider extends Components.DsSlider {
}
export declare class DsSlider {
    protected z: NgZone;
    /** User made changes. Contains the chosen value. @example value-change*/
    valueChange: EventEmitter<CustomEvent<number>>;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DsSlider, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DsSlider, "ds-slider", never, { "formattedvalue": "formattedvalue"; "label": "label"; "max": "max"; "min": "min"; "readonly": "readonly"; "step": "step"; "value": "value"; }, { "valueChange": "valueChange"; }, never, ["*"], false>;
}
export declare interface DsSpinner extends Components.DsSpinner {
}
export declare class DsSpinner {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DsSpinner, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DsSpinner, "ds-spinner", never, { "size": "size"; "theme": "theme"; }, {}, never, ["*"], false>;
}
import { TableConfig as IDsTableTableConfig } from '@dvag/design-system/dist/types/components/table/ds-table/ds-table';
export declare interface DsTable extends Components.DsTable {
}
export declare class DsTable {
    protected z: NgZone;
    /** This event will be fired as soon as the table`s state changes (e.g. sorting, paging...) @example table-state-changed*/
    tableStateChanged: EventEmitter<CustomEvent<IDsTableTableConfig>>;
    /** In case a row is selected this event will fire the key of the row. @value string: If the `selectionmode` allows a single selection the event will delegate one selected row key.,@value string[]: If the `selectionmode` allows a multi selection the event will delegate all selected row keys.
  **!!!Experimental feature!!!***/
    rowsSelected: EventEmitter<CustomEvent<string[]>>;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DsTable, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DsTable, "ds-table", never, { "initialsort": "initialsort"; "initialsortdirection": "initialsortdirection"; "mode": "mode"; "pagesize": "pagesize"; "pagesizes": "pagesizes"; "rowcount": "rowcount"; "scrollable": "scrollable"; "selectionenabled": "selectionenabled"; "selectionmode": "selectionmode"; "view": "view"; }, { "tableStateChanged": "tableStateChanged"; "rowsSelected": "rowsSelected"; }, never, ["*"], false>;
}
export declare interface DsTableCell extends Components.DsTableCell {
}
export declare class DsTableCell {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DsTableCell, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DsTableCell, "ds-table-cell", never, { "color": "color"; "type": "type"; "value": "value"; }, {}, never, ["*"], false>;
}
export declare interface DsTableFooter extends Components.DsTableFooter {
}
export declare class DsTableFooter {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DsTableFooter, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DsTableFooter, "ds-table-footer", never, {}, {}, never, ["*"], false>;
}
export declare interface DsTableHeader extends Components.DsTableHeader {
}
export declare class DsTableHeader {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DsTableHeader, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DsTableHeader, "ds-table-header", never, {}, {}, never, ["*"], false>;
}
export declare interface DsTableHeaderItem extends Components.DsTableHeaderItem {
}
export declare class DsTableHeaderItem {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DsTableHeaderItem, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DsTableHeaderItem, "ds-table-header-item", never, { "align": "align"; "columnid": "columnid"; "customSort": "customSort"; "label": "label"; "linesize": "linesize"; "maxwidth": "maxwidth"; "minwidth": "minwidth"; "sortable": "sortable"; "sortpriority": "sortpriority"; "type": "type"; }, {}, never, ["*"], false>;
}
export declare interface DsTableRow extends Components.DsTableRow {
}
export declare class DsTableRow {
    protected z: NgZone;
    /** Fired when the selection-status of the row is changed. @value boolean: Row is selected or not.*/
    rowSelected: EventEmitter<CustomEvent<boolean>>;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DsTableRow, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DsTableRow, "ds-table-row", never, { "rowid": "rowid"; "selected": "selected"; }, { "rowSelected": "rowSelected"; }, never, ["*"], false>;
}
export declare interface DsText extends Components.DsText {
}
export declare class DsText {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DsText, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DsText, "ds-text", never, { "color": "color"; "screensize": "screensize"; "type": "type"; }, {}, never, ["*"], false>;
}
export declare interface DsTextArea extends Components.DsTextArea {
}
export declare class DsTextArea {
    protected z: NgZone;
    /** Event is thrown when the user changes the content of the textarea. @example change-events*/
    valueChange: EventEmitter<CustomEvent<string>>;
    /** Event is thrown when the user checks the input. Event is triggered when the user presses Return or
  leaves the textarea. @example change-events*/
    valueComplete: EventEmitter<CustomEvent<string>>;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DsTextArea, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DsTextArea, "ds-text-area", never, { "disabled": "disabled"; "error": "error"; "errormessage": "errormessage"; "label": "label"; "lines": "lines"; "maxlength": "maxlength"; "readonly": "readonly"; "required": "required"; "value": "value"; }, { "valueChange": "valueChange"; "valueComplete": "valueComplete"; }, never, ["*"], false>;
}
export declare interface DsTextButton extends Components.DsTextButton {
}
export declare class DsTextButton {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DsTextButton, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DsTextButton, "ds-text-button", never, { "color": "color"; "disabled": "disabled"; "screensize": "screensize"; "unfocusable": "unfocusable"; }, {}, never, ["*"], false>;
}
import { TextInputAutocompleteController as IDsTextInputTextInputAutocompleteController } from '@dvag/design-system/dist/types/components/form/inputs/ds-text-input/ds-text-input';
export declare interface DsTextInput extends Components.DsTextInput {
}
export declare class DsTextInput {
    protected z: NgZone;
    /** Emits this event when the user changes the value of this input. @example change-events*/
    valueChange: EventEmitter<CustomEvent<string>>;
    /** This Event is emitted when the user accepts the value.
  The user accepts the value by pressing the Enter Key or when the user leave the input. @example change-events*/
    valueComplete: EventEmitter<CustomEvent<string>>;
    /** This event is fired, when the user fills out this input.
  The event paylod contains an controller which can be used to submit autocomplete values. @example autocomplete-plz*/
    autocomplete: EventEmitter<CustomEvent<IDsTextInputTextInputAutocompleteController>>;
    /** This event is fired when the user selects an autocomplete value from the list.
  The event payload contains the `data` of the selected AutoCompleteOption. @example autocomplete-plz-ort*/
    selectAutocomplete: EventEmitter<CustomEvent<any>>;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DsTextInput, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DsTextInput, "ds-text-input", never, { "disabled": "disabled"; "error": "error"; "errormessage": "errormessage"; "kisynced": "kisynced"; "label": "label"; "limitlength": "limitlength"; "mask": "mask"; "placeholder": "placeholder"; "readonly": "readonly"; "required": "required"; "value": "value"; }, { "valueChange": "valueChange"; "valueComplete": "valueComplete"; "autocomplete": "autocomplete"; "selectAutocomplete": "selectAutocomplete"; }, never, ["*"], false>;
}
export declare interface DsTextList extends Components.DsTextList {
}
export declare class DsTextList {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DsTextList, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DsTextList, "ds-text-list", never, { "type": "type"; }, {}, never, ["*"], false>;
}
export declare interface DsUserAvatar extends Components.DsUserAvatar {
}
export declare class DsUserAvatar {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DsUserAvatar, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DsUserAvatar, "ds-user-avatar", never, { "imageurl": "imageurl"; "initials": "initials"; "size": "size"; }, {}, never, ["*"], false>;
}
export declare interface DsWorkflowProgress extends Components.DsWorkflowProgress {
}
export declare class DsWorkflowProgress {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DsWorkflowProgress, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DsWorkflowProgress, "ds-workflow-progress", never, { "progress": "progress"; }, {}, never, ["*"], false>;
}
export declare interface DsWrappedLayout extends Components.DsWrappedLayout {
}
export declare class DsWrappedLayout {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DsWrappedLayout, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DsWrappedLayout, "ds-wrapped-layout", never, { "align": "align"; "size": "size"; }, {}, never, ["*"], false>;
}
export declare interface DsYesNo extends Components.DsYesNo {
}
export declare class DsYesNo {
    protected z: NgZone;
    /** Event contains `"yes"`, when Ja or `"no"` when Nein was selected.
  The user can't unselect the value. @example event*/
    valueChange: EventEmitter<CustomEvent<string>>;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DsYesNo, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DsYesNo, "ds-yes-no", never, { "disabled": "disabled"; "error": "error"; "errormessage": "errormessage"; "readonly": "readonly"; "required": "required"; "size": "size"; "value": "value"; }, { "valueChange": "valueChange"; }, never, ["*"], false>;
}
export declare interface DxAccordion extends Components.DxAccordion {
}
export declare class DxAccordion {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DxAccordion, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DxAccordion, "dx-accordion", never, { "label": "label"; "open": "open"; }, {}, never, ["*"], false>;
}
export declare interface DxAccordionGroup extends Components.DxAccordionGroup {
}
export declare class DxAccordionGroup {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DxAccordionGroup, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DxAccordionGroup, "dx-accordion-group", never, {}, {}, never, ["*"], false>;
}
export declare interface DxAlert extends Components.DxAlert {
}
export declare class DxAlert {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DxAlert, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DxAlert, "dx-alert", never, { "actionsdirection": "actionsdirection"; "content": "content"; "icon": "icon"; "sublabel": "sublabel"; "titlestring": "titlestring"; "type": "type"; "visible": "visible"; }, {}, never, ["*"], false>;
}
export declare interface DxAnnouncementBar extends Components.DxAnnouncementBar {
}
export declare class DxAnnouncementBar {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DxAnnouncementBar, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DxAnnouncementBar, "dx-announcement-bar", never, { "color": "color"; "icon": "icon"; "iconcolor": "iconcolor"; }, {}, never, ["*"], false>;
}
export declare interface DxApp extends Components.DxApp {
}
export declare class DxApp {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DxApp, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DxApp, "dx-app", never, {}, {}, never, ["*"], false>;
}
export declare interface DxBreadcrumb extends Components.DxBreadcrumb {
}
export declare class DxBreadcrumb {
    protected z: NgZone;
    /** Fired when the user interacts with this item. @example navigation*/
    navigateHome: EventEmitter<CustomEvent<void>>;
    /** Fired when the user interacts with a breadcrumb item.
  As event payload (`event.detail`) the value of the interacted item is supplied. @example navigation*/
    navigate: EventEmitter<CustomEvent<string>>;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DxBreadcrumb, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DxBreadcrumb, "dx-breadcrumb", never, {}, { "navigateHome": "navigateHome"; "navigate": "navigate"; }, never, ["*"], false>;
}
export declare interface DxBreadcrumbItem extends Components.DxBreadcrumbItem {
}
export declare class DxBreadcrumbItem {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DxBreadcrumbItem, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DxBreadcrumbItem, "dx-breadcrumb-item", never, { "label": "label"; "value": "value"; }, {}, never, ["*"], false>;
}
export declare interface DxButton extends Components.DxButton {
}
export declare class DxButton {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DxButton, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DxButton, "dx-button", never, { "disabled": "disabled"; "icon": "icon"; "iconposition": "iconposition"; "label": "label"; "loading": "loading"; "stretch": "stretch"; "theme": "theme"; "type": "type"; "unfocusable": "unfocusable"; }, {}, never, ["*"], false>;
}
export declare interface DxCard extends Components.DxCard {
}
export declare class DxCard {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DxCard, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DxCard, "dx-card", never, {}, {}, never, ["*"], false>;
}
export declare interface DxCardCollapsable extends Components.DxCardCollapsable {
}
export declare class DxCardCollapsable {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DxCardCollapsable, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DxCardCollapsable, "dx-card-collapsable", never, { "open": "open"; }, {}, never, ["*"], false>;
}
export declare interface DxCardContent extends Components.DxCardContent {
}
export declare class DxCardContent {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DxCardContent, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DxCardContent, "dx-card-content", never, {}, {}, never, ["*"], false>;
}
export declare interface DxCardHeader extends Components.DxCardHeader {
}
export declare class DxCardHeader {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DxCardHeader, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DxCardHeader, "dx-card-header", never, { "icon": "icon"; "iconcolor": "iconcolor"; "label": "label"; }, {}, never, ["*"], false>;
}
export declare interface DxCardImage extends Components.DxCardImage {
}
export declare class DxCardImage {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DxCardImage, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DxCardImage, "dx-card-image", never, { "coverheightmq1": "coverheightmq1"; "coverheightmq2": "coverheightmq2"; "coverheightmq3": "coverheightmq3"; "coverheightmq4": "coverheightmq4"; "coverheightmq5": "coverheightmq5"; "coverpositionmq1": "coverpositionmq1"; "coverpositionmq2": "coverpositionmq2"; "coverpositionmq3": "coverpositionmq3"; "coverpositionmq4": "coverpositionmq4"; "coverpositionmq5": "coverpositionmq5"; "fit": "fit"; "url": "url"; }, {}, never, ["*"], false>;
}
export declare interface DxChartSample extends Components.DxChartSample {
}
export declare class DxChartSample {
    protected z: NgZone;
    /** Triggers when value of the sample changes. @value number: Delegates the new value.*/
    valueChange: EventEmitter<CustomEvent<number>>;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DxChartSample, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DxChartSample, "dx-chart-sample", never, { "color": "color"; "icon": "icon"; "label": "label"; "selectedcolor": "selectedcolor"; "value": "value"; }, { "valueChange": "valueChange"; }, never, ["*"], false>;
}
export declare interface DxCheckbox extends Components.DxCheckbox {
}
export declare class DxCheckbox {
    protected z: NgZone;
    /** Delegates the current `checked` value of this component when the user interacts with it. @example check-event*/
    checkedChange: EventEmitter<CustomEvent<boolean>>;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DxCheckbox, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DxCheckbox, "dx-checkbox", never, { "checked": "checked"; "disabled": "disabled"; "errormessage": "errormessage"; "kisynced": "kisynced"; "label": "label"; "readonly": "readonly"; "required": "required"; }, { "checkedChange": "checkedChange"; }, never, ["*"], false>;
}
import { ComboboxSearchController as IDxComboboxComboboxSearchController } from '@dvag/design-system/dist/types/new/form/dx-combobox/dx-combobox';
export declare interface DxCombobox extends Components.DxCombobox {
}
export declare class DxCombobox {
    protected z: NgZone;
    /** Emits this event when the user changes the value of this input. @example change-events*/
    valueChange: EventEmitter<CustomEvent<string>>;
    /** This event is emitted when the user accepts the value.
  The user accepts the value by pressing the Enter key or when the user leave the input. @example change-events*/
    valueComplete: EventEmitter<CustomEvent<string>>;
    /** This event is fired, when the user fills out this input.
  The event paylod contains an controller which can be used to submit autocomplete options. @example search,@example select-search-option,@example option-labels,@example option-icons*/
    search: EventEmitter<CustomEvent<IDxComboboxComboboxSearchController>>;
    /** This event is fired when the user selects an autocomplete options from the list.
  The event payload contains the `data` of the selected AutoCompleteOption. @example select-search-option*/
    selectSearchOption: EventEmitter<CustomEvent<any>>;
    /** Trigger when the user presses the "Enter" key while editing the input field. @example enter-press*/
    enterPress: EventEmitter<CustomEvent<void>>;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DxCombobox, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DxCombobox, "dx-combobox", never, { "disabled": "disabled"; "emptysearchtext": "emptysearchtext"; "errormessage": "errormessage"; "kisynced": "kisynced"; "label": "label"; "limitlength": "limitlength"; "loadingtext": "loadingtext"; "maxlistheight": "maxlistheight"; "placeholder": "placeholder"; "presearchconditiontext": "presearchconditiontext"; "presearchlettercount": "presearchlettercount"; "readonly": "readonly"; "required": "required"; "size": "size"; "value": "value"; }, { "valueChange": "valueChange"; "valueComplete": "valueComplete"; "search": "search"; "selectSearchOption": "selectSearchOption"; "enterPress": "enterPress"; }, never, ["*"], false>;
}
export declare interface DxContainer extends Components.DxContainer {
}
export declare class DxContainer {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DxContainer, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DxContainer, "dx-container", never, { "color": "color"; "type": "type"; }, {}, never, ["*"], false>;
}
import { DateError as IDxDateInputDateError } from '@dvag/design-system/dist/types/new/form/date/date';
export declare interface DxDateInput extends Components.DxDateInput {
}
export declare class DxDateInput {
    protected z: NgZone;
    /** Delegates the current value while the user is editing the input. @example change-events*/
    valueChange: EventEmitter<CustomEvent<string>>;
    /** Delegates the final value when the user submits the result by pressing 'Enter' or unfocusing this component. @example change-events*/
    valueComplete: EventEmitter<CustomEvent<string>>;
    /** Delegates an error payload which consists of a message and an error type. @example error-found*/
    errorFound: EventEmitter<CustomEvent<IDxDateInputDateError>>;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DxDateInput, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DxDateInput, "dx-date-input", never, { "disabled": "disabled"; "errormessage": "errormessage"; "kisynced": "kisynced"; "label": "label"; "max": "max"; "min": "min"; "mode": "mode"; "readonly": "readonly"; "required": "required"; "size": "size"; "value": "value"; }, { "valueChange": "valueChange"; "valueComplete": "valueComplete"; "errorFound": "errorFound"; }, never, ["*"], false>;
}
export declare interface DxDateRange extends Components.DxDateRange {
}
export declare class DxDateRange {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DxDateRange, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DxDateRange, "dx-date-range", never, { "max": "max"; "min": "min"; "mode": "mode"; "value": "value"; }, {}, never, ["*"], false>;
}
export declare interface DxDonutChart extends Components.DxDonutChart {
}
export declare class DxDonutChart {
    protected z: NgZone;
    /** Triggers when a segment is clicked. It delegates the index of the selected segment. @value number: The index of the selected segment.,@example segment-select*/
    segmentSelect: EventEmitter<CustomEvent<number>>;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DxDonutChart, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DxDonutChart, "dx-donut-chart", never, { "colorscheme": "colorscheme"; "label": "label"; "selected": "selected"; "showsegmentlabels": "showsegmentlabels"; "sublabel": "sublabel"; }, { "segmentSelect": "segmentSelect"; }, never, ["*"], false>;
}
import { StringOrObject as IDxDropdownStringOrObject } from '@dvag/design-system/dist/types/new/layout/dx-list/list.util';
export declare interface DxDropdown extends Components.DxDropdown {
}
export declare class DxDropdown {
    protected z: NgZone;
    /** Delegates the current selection or text input (`elseoption`) while the user is still editing. @example complex*/
    valueChange: EventEmitter<CustomEvent<IDxDropdownStringOrObject>>;
    /** Delegates the final selection or text input (`elseoption`).
  The event is fired when the dropdown loses focus or pushing the 'Enter' key. @example complex*/
    valueComplete: EventEmitter<CustomEvent<IDxDropdownStringOrObject>>;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DxDropdown, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DxDropdown, "dx-dropdown", never, { "disabled": "disabled"; "elseoption": "elseoption"; "elseoptionbuttonlabel": "elseoptionbuttonlabel"; "elseoptioninputlabel": "elseoptioninputlabel"; "elseoptionselected": "elseoptionselected"; "errormessage": "errormessage"; "icon": "icon"; "kisynced": "kisynced"; "label": "label"; "placeholder": "placeholder"; "popupposition": "popupposition"; "readonly": "readonly"; "required": "required"; "size": "size"; "textalign": "textalign"; "value": "value"; }, { "valueChange": "valueChange"; "valueComplete": "valueComplete"; }, never, ["*"], false>;
}
export declare interface DxDropdownOption extends Components.DxDropdownOption {
}
export declare class DxDropdownOption {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DxDropdownOption, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DxDropdownOption, "dx-dropdown-option", never, { "icon": "icon"; "label": "label"; "selected": "selected"; "value": "value"; }, {}, never, ["*"], false>;
}
export declare interface DxErrorMessage extends Components.DxErrorMessage {
}
export declare class DxErrorMessage {
    protected z: NgZone;
    /**  */
    forceUpdateOnChange: EventEmitter<CustomEvent<(ref: any) => void>>;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DxErrorMessage, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DxErrorMessage, "dx-error-message", never, { "lines": "lines"; }, { "forceUpdateOnChange": "forceUpdateOnChange"; }, never, ["*"], false>;
}
export declare interface DxErrorPage extends Components.DxErrorPage {
}
export declare class DxErrorPage {
    protected z: NgZone;
    /** Fires when the user interacts with the button. @example action*/
    action: EventEmitter<CustomEvent<void>>;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DxErrorPage, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DxErrorPage, "dx-error-page", never, { "actiondescription": "actiondescription"; "actionlabel": "actionlabel"; "description": "description"; "reason": "reason"; }, { "action": "action"; }, never, ["*"], false>;
}
export declare interface DxExpanded extends Components.DxExpanded {
}
export declare class DxExpanded {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DxExpanded, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DxExpanded, "dx-expanded", never, {}, {}, never, ["*"], false>;
}
export declare interface DxFdOutlineBox extends Components.DxFdOutlineBox {
}
export declare class DxFdOutlineBox {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DxFdOutlineBox, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DxFdOutlineBox, "dx-fd-outline-box", never, {}, {}, never, ["*"], false>;
}
export declare interface DxFdSeparator extends Components.DxFdSeparator {
}
export declare class DxFdSeparator {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DxFdSeparator, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DxFdSeparator, "dx-fd-separator", never, { "fromcolor": "fromcolor"; "tocolor": "tocolor"; }, {}, never, ["*"], false>;
}
export declare interface DxFooter extends Components.DxFooter {
}
export declare class DxFooter {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DxFooter, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DxFooter, "dx-footer", never, { "fromcolor": "fromcolor"; }, {}, never, ["*"], false>;
}
export declare interface DxFormWrapper extends Components.DxFormWrapper {
}
export declare class DxFormWrapper {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DxFormWrapper, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DxFormWrapper, "dx-form-wrapper", never, { "errormessage": "errormessage"; "kisynced": "kisynced"; "label": "label"; "required": "required"; }, {}, never, ["*"], false>;
}
export declare interface DxGoldenStage extends Components.DxGoldenStage {
}
export declare class DxGoldenStage {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DxGoldenStage, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DxGoldenStage, "dx-golden-stage", never, { "alignment": "alignment"; "backgroundcolor": "backgroundcolor"; "contentoffsety": "contentoffsety"; "size": "size"; }, {}, never, ["*"], false>;
}
export declare interface DxGrid extends Components.DxGrid {
}
export declare class DxGrid {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DxGrid, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DxGrid, "dx-grid", never, { "base": "base"; "mq1": "mq1"; "mq2": "mq2"; "mq3": "mq3"; "mq4": "mq4"; "mq5": "mq5"; "rowgap": "rowgap"; }, {}, never, ["*"], false>;
}
export declare interface DxHeader extends Components.DxHeader {
}
export declare class DxHeader {
    protected z: NgZone;
    /** An event which is triggered when the user clicks the logo or the application name.
  This event should always be used to show the user the application's home page. */
    navigateHome: EventEmitter<CustomEvent<void>>;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DxHeader, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DxHeader, "dx-header", never, { "appname": "appname"; "brand": "brand"; "logo": "logo"; "showannouncement": "showannouncement"; "theme": "theme"; }, { "navigateHome": "navigateHome"; }, never, ["*"], false>;
}
import { CloseSidebarDetail as IDxHeaderAppFavoritesCloseSidebarDetail } from '@dvag/design-system/dist/types/new/scaffold/dx-header/dx-header-app-favorites/app-favorite';
import { LaunchAppDetail as IDxHeaderAppFavoritesLaunchAppDetail } from '@dvag/design-system/dist/types/new/scaffold/dx-header/dx-header-app-favorites/app-favorite';
export declare interface DxHeaderAppFavorites extends Components.DxHeaderAppFavorites {
}
export declare class DxHeaderAppFavorites {
    protected z: NgZone;
    /** Fired when the navigation's header menu item is interacted with. @example menu-interaction*/
    menuInteraction: EventEmitter<CustomEvent<void>>;
    /** Fires when the user deletes a favorite app. The event delegates the application id of the deleted app. */
    deleteApp: EventEmitter<CustomEvent<string>>;
    /** Fires when the user sorts his favorite apps. The event delegates the application ids dependant on the current sorting. */
    sortApps: EventEmitter<CustomEvent<string[]>>;
    /** Fires when the user clicks on the "Favoriten hinzufügen" button within the sidebar content. */
    addApp: EventEmitter<CustomEvent<IDxHeaderAppFavoritesCloseSidebarDetail>>;
    /** Fires when toggling the edit mode within the sidebar. (e.g. by clicking the "Favoriten bearbeiten" button) @example edit-app-event*/
    editApps: EventEmitter<CustomEvent<boolean>>;
    /** Fires when the user clicks selects an app. The event delegates the application id of the corresponding app. */
    launchApp: EventEmitter<CustomEvent<IDxHeaderAppFavoritesLaunchAppDetail>>;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DxHeaderAppFavorites, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DxHeaderAppFavorites, "dx-header-app-favorites", never, { "notifications": "notifications"; "notificationstheme": "notificationstheme"; "priority": "priority"; }, { "menuInteraction": "menuInteraction"; "deleteApp": "deleteApp"; "sortApps": "sortApps"; "addApp": "addApp"; "editApps": "editApps"; "launchApp": "launchApp"; }, never, ["*"], false>;
}
export declare interface DxHeaderAppFavoritesApp extends Components.DxHeaderAppFavoritesApp {
}
export declare class DxHeaderAppFavoritesApp {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DxHeaderAppFavoritesApp, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DxHeaderAppFavoritesApp, "dx-header-app-favorites-app", never, { "appid": "appid"; "appname": "appname"; "icon": "icon"; }, {}, never, ["*"], false>;
}
export declare interface DxHeaderMenuCustom extends Components.DxHeaderMenuCustom {
}
export declare class DxHeaderMenuCustom {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DxHeaderMenuCustom, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DxHeaderMenuCustom, "dx-header-menu-custom", never, { "priority": "priority"; }, {}, never, ["*"], false>;
}
export declare interface DxHeaderMenuGroup extends Components.DxHeaderMenuGroup {
}
export declare class DxHeaderMenuGroup {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DxHeaderMenuGroup, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DxHeaderMenuGroup, "dx-header-menu-group", never, { "priority": "priority"; }, {}, never, ["*"], false>;
}
export declare interface DxHeaderMenuItem extends Components.DxHeaderMenuItem {
}
export declare class DxHeaderMenuItem {
    protected z: NgZone;
    /** Fired when the header menu item is interacted with. @example menu-interaction*/
    menuInteraction: EventEmitter<CustomEvent<string>>;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DxHeaderMenuItem, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DxHeaderMenuItem, "dx-header-menu-item", never, { "connectedslot": "connectedslot"; "icon": "icon"; "notifications": "notifications"; "notificationstheme": "notificationstheme"; "priority": "priority"; }, { "menuInteraction": "menuInteraction"; }, never, ["*"], false>;
}
export declare interface DxHeaderMenuLink extends Components.DxHeaderMenuLink {
}
export declare class DxHeaderMenuLink {
    protected z: NgZone;
    /** Fired when the header menu item is interacted with. @example menu-interaction*/
    menuInteraction: EventEmitter<CustomEvent<string>>;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DxHeaderMenuLink, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DxHeaderMenuLink, "dx-header-menu-link", never, { "connectednavigationvalue": "connectednavigationvalue"; "label": "label"; "priority": "priority"; "selected": "selected"; }, { "menuInteraction": "menuInteraction"; }, never, ["*"], false>;
}
export declare interface DxHeaderNavigation extends Components.DxHeaderNavigation {
}
export declare class DxHeaderNavigation {
    protected z: NgZone;
    /** Fired when the navigation's header menu item is interacted with. @example menu-interaction*/
    menuInteraction: EventEmitter<CustomEvent<void>>;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DxHeaderNavigation, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DxHeaderNavigation, "dx-header-navigation", never, { "autoclose": "autoclose"; "notification": "notification"; "notificationstheme": "notificationstheme"; }, { "menuInteraction": "menuInteraction"; }, never, ["*"], false>;
}
import { NavigationItemInteractionPayload as IDxHeaderNavigationItemNavigationItemInteractionPayload } from '@dvag/design-system/dist/types/new/scaffold/dx-header/dx-header-navigation/dx-header-navigation-item/dx-header-navigation-item';
export declare interface DxHeaderNavigationItem extends Components.DxHeaderNavigationItem {
}
export declare class DxHeaderNavigationItem {
    protected z: NgZone;
    /** Fired when the user interacts with this item. (e.g. by clicking it)
  It emits a navigation item payload which consists of the corresponding navigation item's `value` and a function which, when called, closes the sidebar. @example interaction*/
    interaction: EventEmitter<CustomEvent<IDxHeaderNavigationItemNavigationItemInteractionPayload>>;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DxHeaderNavigationItem, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DxHeaderNavigationItem, "dx-header-navigation-item", never, { "label": "label"; "size": "size"; "value": "value"; }, { "interaction": "interaction"; }, never, ["*"], false>;
}
export declare interface DxHeaderUser extends Components.DxHeaderUser {
}
export declare class DxHeaderUser {
    protected z: NgZone;
    /** Fired when the sign-out button ("Abmelden") is clicked in the user's sidebar content. @example sidebar-events*/
    signOut: EventEmitter<CustomEvent<void>>;
    /** Fired when the account button ("Benutzerkonto") is clicked in the user's sidebar content. @example sidebar-events*/
    accountInteraction: EventEmitter<CustomEvent<void>>;
    /** Fired when the user's header menu item is interacted with. @example menu-interaction*/
    menuInteraction: EventEmitter<CustomEvent<void>>;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DxHeaderUser, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DxHeaderUser, "dx-header-user", never, { "accountavailable": "accountavailable"; "imageurl": "imageurl"; "name": "name"; "notifications": "notifications"; "notificationstheme": "notificationstheme"; "priority": "priority"; }, { "signOut": "signOut"; "accountInteraction": "accountInteraction"; "menuInteraction": "menuInteraction"; }, never, ["*"], false>;
}
export declare interface DxHeroImage extends Components.DxHeroImage {
}
export declare class DxHeroImage {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DxHeroImage, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DxHeroImage, "dx-hero-image", never, { "mq1": "mq1"; "mq2": "mq2"; "mq3": "mq3"; "mq4": "mq4"; "mq5": "mq5"; }, {}, never, ["*"], false>;
}
export declare interface DxIcon extends Components.DxIcon {
}
export declare class DxIcon {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DxIcon, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DxIcon, "dx-icon", never, { "color": "color"; "icon": "icon"; "size": "size"; }, {}, never, ["*"], false>;
}
export declare interface DxInfo extends Components.DxInfo {
}
export declare class DxInfo {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DxInfo, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DxInfo, "dx-info", never, { "hidebutton": "hidebutton"; "size": "size"; }, {}, never, ["*"], false>;
}
export declare interface DxLegend extends Components.DxLegend {
}
export declare class DxLegend {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DxLegend, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DxLegend, "dx-legend", never, { "kisynchint": "kisynchint"; "requiredhint": "requiredhint"; }, {}, never, ["*"], false>;
}
export declare interface DxLink extends Components.DxLink {
}
export declare class DxLink {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DxLink, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DxLink, "dx-link", never, { "target": "target"; "url": "url"; }, {}, never, ["*"], false>;
}
export declare interface DxList extends Components.DxList {
}
export declare class DxList {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DxList, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DxList, "dx-list", never, { "contentbelow": "contentbelow"; "size": "size"; "width": "width"; }, {}, never, ["*"], false>;
}
export declare interface DxListItem extends Components.DxListItem {
}
export declare class DxListItem {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DxListItem, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DxListItem, "dx-list-item", never, { "actionindicator": "actionindicator"; "disabled": "disabled"; "icon": "icon"; "label": "label"; "selected": "selected"; "sublabel": "sublabel"; "textalign": "textalign"; "type": "type"; "value": "value"; }, {}, never, ["*"], false>;
}
export declare interface DxLogo extends Components.DxLogo {
}
export declare class DxLogo {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DxLogo, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DxLogo, "dx-logo", never, { "type": "type"; }, {}, never, ["*"], false>;
}
export declare interface DxMediaQueryValue extends Components.DxMediaQueryValue {
}
export declare class DxMediaQueryValue {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DxMediaQueryValue, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DxMediaQueryValue, "dx-media-query-value", never, { "mq1": "mq1"; "mq2": "mq2"; "mq3": "mq3"; "mq4": "mq4"; "mq5": "mq5"; "property": "property"; }, {}, never, ["*"], false>;
}
import { ModalClosedPayload as IDxModalModalClosedPayload } from '@dvag/design-system/dist/types/new/modals/dx-modal/dx-modal';
export declare interface DxModal extends Components.DxModal {
}
export declare class DxModal {
    protected z: NgZone;
    /** The Event triggers as soon the dialog opens. */
    modalOpened: EventEmitter<CustomEvent<void>>;
    /** The Event triggers, as soon the user closes the dialog via the close button or through clicking on the background behind the modal.
  It emits an object with meta-data containing the reason the modal was closed and a function to prevent the modal from closing. @example prevent-background-close,@example modal-closed*/
    modalClosed: EventEmitter<CustomEvent<IDxModalModalClosedPayload>>;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DxModal, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DxModal, "dx-modal", never, { "height": "height"; "label": "label"; "visible": "visible"; "width": "width"; }, { "modalOpened": "modalOpened"; "modalClosed": "modalClosed"; }, never, ["*"], false>;
}
export declare interface DxMultiDropdown extends Components.DxMultiDropdown {
}
export declare class DxMultiDropdown {
    protected z: NgZone;
    /** Delegates the current selection while the user is still editing. @example complex*/
    valueChange: EventEmitter<CustomEvent<HTMLDxDropdownOptionElement[]>>;
    /** Delegates the final selection.
  The event is fired when the dropdown loses focus or pushing the 'Enter' key. @example complex*/
    valueComplete: EventEmitter<CustomEvent<HTMLDxDropdownOptionElement[]>>;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DxMultiDropdown, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DxMultiDropdown, "dx-multi-dropdown", never, { "disabled": "disabled"; "errormessage": "errormessage"; "icon": "icon"; "kisynced": "kisynced"; "label": "label"; "placeholder": "placeholder"; "popupposition": "popupposition"; "readonly": "readonly"; "required": "required"; "selectionlabel": "selectionlabel"; "size": "size"; "textalign": "textalign"; }, { "valueChange": "valueChange"; "valueComplete": "valueComplete"; }, never, ["*"], false>;
}
export declare interface DxNotificationBar extends Components.DxNotificationBar {
}
export declare class DxNotificationBar {
    protected z: NgZone;
    /** This event is fired, when the user closes the notification via the close button. @example close-notification*/
    closeNotification: EventEmitter<CustomEvent<void>>;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DxNotificationBar, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DxNotificationBar, "dx-notification-bar", never, { "visible": "visible"; }, { "closeNotification": "closeNotification"; }, never, ["*"], false>;
}
export declare interface DxNotificationToast extends Components.DxNotificationToast {
}
export declare class DxNotificationToast {
    protected z: NgZone;
    /** Fires when the notification closes automatically or by clicking on the close button. @example close-notification*/
    closeNotification: EventEmitter<CustomEvent<void>>;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DxNotificationToast, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DxNotificationToast, "dx-notification-toast", never, { "closeafter": "closeafter"; "icon": "icon"; "iconcolor": "iconcolor"; "subcontent": "subcontent"; "titlestring": "titlestring"; "visible": "visible"; }, { "closeNotification": "closeNotification"; }, never, ["*"], false>;
}
export declare interface DxNumberInput extends Components.DxNumberInput {
}
export declare class DxNumberInput {
    protected z: NgZone;
    /** Changes of the input value during the input of the user. @example change-events*/
    valueChange: EventEmitter<CustomEvent<number>>;
    /** Confirmation of the input value. Event is triggered, when the user presses return or leaving the input field. @example change-events*/
    valueComplete: EventEmitter<CustomEvent<number>>;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DxNumberInput, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DxNumberInput, "dx-number-input", never, { "disabled": "disabled"; "errormessage": "errormessage"; "kisynced": "kisynced"; "label": "label"; "limitlength": "limitlength"; "max": "max"; "min": "min"; "placeholder": "placeholder"; "precision": "precision"; "profile": "profile"; "readonly": "readonly"; "required": "required"; "size": "size"; "step": "step"; "thousandseparator": "thousandseparator"; "unit": "unit"; "value": "value"; }, { "valueChange": "valueChange"; "valueComplete": "valueComplete"; }, never, ["*"], false>;
}
export declare interface DxNumberPaginator extends Components.DxNumberPaginator {
}
export declare class DxNumberPaginator {
    protected z: NgZone;
    /** Triggers when the page changes by interacting with the arrows, the page numbers or the dropdown (MQ1). @example pagechange*/
    pageChanged: EventEmitter<CustomEvent<number>>;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DxNumberPaginator, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DxNumberPaginator, "dx-number-paginator", never, { "count": "count"; "current": "current"; }, { "pageChanged": "pageChanged"; }, never, ["*"], false>;
}
export declare interface DxNumberPicker extends Components.DxNumberPicker {
}
export declare class DxNumberPicker {
    protected z: NgZone;
    /**  */
    valueChange: EventEmitter<CustomEvent<number>>;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DxNumberPicker, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DxNumberPicker, "dx-number-picker", never, { "align": "align"; "value": "value"; "values": "values"; }, { "valueChange": "valueChange"; }, never, ["*"], false>;
}
import { SelectionPayload as IDxOverflowMenuSelectionPayload } from '@dvag/design-system/dist/types/new/scaffold/dx-overflow-menu/dx-overflow-menu';
import { OpenChangePayload as IDxOverflowMenuOpenChangePayload } from '@dvag/design-system/dist/types/new/scaffold/dx-overflow-menu/dx-overflow-menu';
export declare interface DxOverflowMenu extends Components.DxOverflowMenu {
}
export declare class DxOverflowMenu {
    protected z: NgZone;
    /** Fires when the user selects a menu item.
  The event payload consists of a `SelectionPayload` object which contains a `value` property, being either a string, an object.
  When the `selectionmode` equals `multi` the omitted `value` within the `SelectionPayload` is an array of strings and objects. @example selection,@example selection-complex*/
    selection: EventEmitter<CustomEvent<IDxOverflowMenuSelectionPayload>>;
    /** Fires when the list opens.
  The event payload consists of an `OpenChangePayload` object which contains an `isOpen` property. @example list-open-change*/
    listOpenChange: EventEmitter<CustomEvent<IDxOverflowMenuOpenChangePayload>>;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DxOverflowMenu, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DxOverflowMenu, "dx-overflow-menu", never, { "align": "align"; "label": "label"; "maxlabels": "maxlabels"; "maxselections": "maxselections"; "selectionmode": "selectionmode"; }, { "selection": "selection"; "listOpenChange": "listOpenChange"; }, never, ["*"], false>;
}
export declare interface DxOverflowMenuItem extends Components.DxOverflowMenuItem {
}
export declare class DxOverflowMenuItem {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DxOverflowMenuItem, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DxOverflowMenuItem, "dx-overflow-menu-item", never, { "icon": "icon"; "label": "label"; "selected": "selected"; "value": "value"; }, {}, never, ["*"], false>;
}
export declare interface DxPaginator extends Components.DxPaginator {
}
export declare class DxPaginator {
    protected z: NgZone;
    /** Fires when the `current` property changes. */
    pageChanged: EventEmitter<CustomEvent<number>>;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DxPaginator, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DxPaginator, "dx-paginator", never, { "count": "count"; "current": "current"; }, { "pageChanged": "pageChanged"; }, never, ["*"], false>;
}
export declare interface DxPlaceholder extends Components.DxPlaceholder {
}
export declare class DxPlaceholder {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DxPlaceholder, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DxPlaceholder, "dx-placeholder", never, { "box": "box"; "card": "card"; }, {}, never, ["*"], false>;
}
export declare interface DxProcessHeader extends Components.DxProcessHeader {
}
export declare class DxProcessHeader {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DxProcessHeader, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DxProcessHeader, "dx-process-header", never, { "headline": "headline"; }, {}, never, ["*"], false>;
}
export declare interface DxRadioButton extends Components.DxRadioButton {
}
export declare class DxRadioButton {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DxRadioButton, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DxRadioButton, "dx-radio-button", never, { "disabled": "disabled"; "label": "label"; "value": "value"; }, {}, never, ["*"], false>;
}
export declare interface DxRadioButtonGroup extends Components.DxRadioButtonGroup {
}
export declare class DxRadioButtonGroup {
    protected z: NgZone;
    /** Delegates the current selected `<dx-radio-button>` element's value.
  This event will not trigger when setting the `value` in JavaScript. @example read-value*/
    valueChange: EventEmitter<CustomEvent<string>>;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DxRadioButtonGroup, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DxRadioButtonGroup, "dx-radio-button-group", never, { "disabled": "disabled"; "errormessage": "errormessage"; "kisynced": "kisynced"; "label": "label"; "readonly": "readonly"; "required": "required"; "value": "value"; }, { "valueChange": "valueChange"; }, never, ["*"], false>;
}
export declare interface DxRepresentativeInfo extends Components.DxRepresentativeInfo {
}
export declare class DxRepresentativeInfo {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DxRepresentativeInfo, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DxRepresentativeInfo, "dx-representative-info", never, { "name": "name"; "type": "type"; }, {}, never, ["*"], false>;
}
export declare interface DxSidebarContent extends Components.DxSidebarContent {
}
export declare class DxSidebarContent {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DxSidebarContent, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DxSidebarContent, "dx-sidebar-content", never, {}, {}, never, ["*"], false>;
}
export declare interface DxSiteNavigation extends Components.DxSiteNavigation {
}
export declare class DxSiteNavigation {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DxSiteNavigation, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DxSiteNavigation, "dx-site-navigation", never, { "expandedlayoutat": "expandedlayoutat"; }, {}, never, ["*"], false>;
}
import { NavigateEventDetail as IDxSiteNavigationMenuNavigateEventDetail } from '@dvag/design-system/dist/types/new/site-navigation/dx-site-navigation-menu/dx-site-navigation-menu';
export declare interface DxSiteNavigationMenu extends Components.DxSiteNavigationMenu {
}
export declare class DxSiteNavigationMenu {
    protected z: NgZone;
    /** Event is fired when the user interacts with a menu item.
  The event details object contains the following properties:
  - `value`: (string) value of the menu item the user clicked
  - `complete`: (function) needs to be called if not using autonavigation feature. While not completed the menu will not connect to scopes in order to select items by scrolling into the area. */
    navigate: EventEmitter<CustomEvent<IDxSiteNavigationMenuNavigateEventDetail>>;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DxSiteNavigationMenu, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DxSiteNavigationMenu, "dx-site-navigation-menu", never, { "autonavigation": "autonavigation"; "selectedvalue": "selectedvalue"; "titlestring": "titlestring"; }, { "navigate": "navigate"; }, never, ["*"], false>;
}
export declare interface DxSiteNavigationMenuItem extends Components.DxSiteNavigationMenuItem {
}
export declare class DxSiteNavigationMenuItem {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DxSiteNavigationMenuItem, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DxSiteNavigationMenuItem, "dx-site-navigation-menu-item", never, { "label": "label"; "state": "state"; "value": "value"; }, {}, never, ["*"], false>;
}
export declare interface DxSiteNavigationScope extends Components.DxSiteNavigationScope {
}
export declare class DxSiteNavigationScope {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DxSiteNavigationScope, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DxSiteNavigationScope, "dx-site-navigation-scope", never, { "value": "value"; }, {}, never, ["*"], false>;
}
export declare interface DxSlideShow extends Components.DxSlideShow {
}
export declare class DxSlideShow {
    protected z: NgZone;
    /** Delegates the current page when it changes. */
    pageChange: EventEmitter<CustomEvent<number>>;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DxSlideShow, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DxSlideShow, "dx-slide-show", never, { "initialpage": "initialpage"; "mq1amount": "mq1amount"; "mq2amount": "mq2amount"; "mq3amount": "mq3amount"; "mq4amount": "mq4amount"; "mq5amount": "mq5amount"; "spacebetween": "spacebetween"; "viewmode": "viewmode"; }, { "pageChange": "pageChange"; }, never, ["*"], false>;
}
export declare interface DxSlider extends Components.DxSlider {
}
export declare class DxSlider {
    protected z: NgZone;
    /** User made changes. Contains the chosen value. @example value-change*/
    valueChange: EventEmitter<CustomEvent<number>>;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DxSlider, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DxSlider, "dx-slider", never, { "disabled": "disabled"; "formattingpattern": "formattingpattern"; "label": "label"; "max": "max"; "min": "min"; "readonly": "readonly"; "showminmaxlabel": "showminmaxlabel"; "showvaluelabel": "showvaluelabel"; "step": "step"; "value": "value"; }, { "valueChange": "valueChange"; }, never, ["*"], false>;
}
import { SortDetail as IDxSortSortDetail } from '@dvag/design-system/dist/types/new/internal/dx-sort/dx-sort';
export declare interface DxSort extends Components.DxSort {
}
export declare class DxSort {
    protected z: NgZone;
    /** Fires when the children are sorted by the user. By reading the event's detail property you can access the `originalArray` and the `sortedArray`.
  Both arrays consist of the `value` properties provided by the `<dx-sort-item>` elements. @example sort*/
    sort: EventEmitter<CustomEvent<IDxSortSortDetail>>;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DxSort, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DxSort, "dx-sort", never, { "sortable": "sortable"; }, { "sort": "sort"; }, never, ["*"], false>;
}
export declare interface DxSortItem extends Components.DxSortItem {
}
export declare class DxSortItem {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DxSortItem, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DxSortItem, "dx-sort-item", never, { "value": "value"; }, {}, never, ["*"], false>;
}
export declare interface DxSpacer extends Components.DxSpacer {
}
export declare class DxSpacer {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DxSpacer, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DxSpacer, "dx-spacer", never, { "mq1": "mq1"; "mq2": "mq2"; "mq3": "mq3"; "mq4": "mq4"; "mq5": "mq5"; }, {}, never, ["*"], false>;
}
export declare interface DxSpinner extends Components.DxSpinner {
}
export declare class DxSpinner {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DxSpinner, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DxSpinner, "dx-spinner", never, { "size": "size"; "theme": "theme"; }, {}, never, ["*"], false>;
}
export declare interface DxTabBar extends Components.DxTabBar {
}
export declare class DxTabBar {
    protected z: NgZone;
    /** This event fires when the user selects a new tab.
  It contains the `value` of the corresponding `<dx-tab-page>`. @example tab-change*/
    tabChange: EventEmitter<CustomEvent<string>>;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DxTabBar, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DxTabBar, "dx-tab-bar", never, { "selected": "selected"; }, { "tabChange": "tabChange"; }, never, ["*"], false>;
}
export declare interface DxTabPage extends Components.DxTabPage {
}
export declare class DxTabPage {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DxTabPage, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DxTabPage, "dx-tab-page", never, { "label": "label"; "value": "value"; }, {}, never, ["*"], false>;
}
import { TableConfig as IDxTableTableConfig } from '@dvag/design-system/dist/types/new/table/dx-table/dx-table';
import { TableSelection as IDxTableTableSelection } from '@dvag/design-system/dist/types/new/table/table-common-types';
export declare interface DxTable extends Components.DxTable {
}
export declare class DxTable {
    protected z: NgZone;
    /** This event will be fired as soon as the table`s state changes (e.g. sorting, paging...) @example table-state-changed*/
    tableStateChanged: EventEmitter<CustomEvent<IDxTableTableConfig>>;
    /** This event will be fired as soon as the table`s state changes (e.g. sorting, paging...) @example table-state-changed*/
    selectionStateChanged: EventEmitter<CustomEvent<IDxTableTableSelection>>;
    /** This event will be fired as soon as the table`s state changes (e.g. sorting, paging...) @example table-state-changed*/
    expansionChanged: EventEmitter<CustomEvent<boolean>>;
    /** In case a row is selected this event will fire the key of the row. @value string: If the `selectionmode` allows a single selection the event will delegate one selected row key.,@value string[]: If the `selectionmode` allows a multi selection the event will delegate all selected row keys.,@deprecated Please use the `rowSelected` event of the `<dx-table-row>` components to get notified when a new row was selected.*/
    rowsSelected: EventEmitter<CustomEvent<string[]>>;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DxTable, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DxTable, "dx-table", never, { "initialsort": "initialsort"; "initialsortdirection": "initialsortdirection"; "mode": "mode"; "pagesize": "pagesize"; "pagesizes": "pagesizes"; "rowcount": "rowcount"; "scrollable": "scrollable"; "selectionenabled": "selectionenabled"; "selectionmode": "selectionmode"; }, { "tableStateChanged": "tableStateChanged"; "selectionStateChanged": "selectionStateChanged"; "expansionChanged": "expansionChanged"; "rowsSelected": "rowsSelected"; }, never, ["*"], false>;
}
export declare interface DxTableCell extends Components.DxTableCell {
}
export declare class DxTableCell {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DxTableCell, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DxTableCell, "dx-table-cell", never, { "align": "align"; "color": "color"; "type": "type"; "value": "value"; }, {}, never, ["*"], false>;
}
export declare interface DxTableFooter extends Components.DxTableFooter {
}
export declare class DxTableFooter {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DxTableFooter, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DxTableFooter, "dx-table-footer", never, {}, {}, never, ["*"], false>;
}
export declare interface DxTableHeader extends Components.DxTableHeader {
}
export declare class DxTableHeader {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DxTableHeader, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DxTableHeader, "dx-table-header", never, {}, {}, never, ["*"], false>;
}
export declare interface DxTableHeaderItem extends Components.DxTableHeaderItem {
}
export declare class DxTableHeaderItem {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DxTableHeaderItem, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DxTableHeaderItem, "dx-table-header-item", never, { "align": "align"; "columnid": "columnid"; "customSort": "customSort"; "label": "label"; "linesize": "linesize"; "maxwidth": "maxwidth"; "minwidth": "minwidth"; "sortable": "sortable"; "sortpriority": "sortpriority"; "sticky": "sticky"; "type": "type"; }, {}, never, ["*"], false>;
}
export declare interface DxTableRow extends Components.DxTableRow {
}
export declare class DxTableRow {
    protected z: NgZone;
    /** Fired when the selection-status of the row is changed. @value boolean: Row is selected or not.*/
    rowSelected: EventEmitter<CustomEvent<boolean>>;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DxTableRow, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DxTableRow, "dx-table-row", never, { "rowid": "rowid"; "selected": "selected"; }, { "rowSelected": "rowSelected"; }, never, ["*"], false>;
}
export declare interface DxTag extends Components.DxTag {
}
export declare class DxTag {
    protected z: NgZone;
    /** Is fired when the user interacts with the remove button. @example remove-event*/
    remove: EventEmitter<CustomEvent<void>>;
    /** Is fired when the user interacts with a selectable tag. @example select-event*/
    selectChange: EventEmitter<CustomEvent<boolean>>;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DxTag, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DxTag, "dx-tag", never, { "color": "color"; "label": "label"; "removeable": "removeable"; "selectable": "selectable"; "selected": "selected"; "textcolor": "textcolor"; "theme": "theme"; "type": "type"; }, { "remove": "remove"; "selectChange": "selectChange"; }, never, ["*"], false>;
}
export declare interface DxText extends Components.DxText {
}
export declare class DxText {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DxText, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DxText, "dx-text", never, { "color": "color"; "type": "type"; }, {}, never, ["*"], false>;
}
export declare interface DxTextArea extends Components.DxTextArea {
}
export declare class DxTextArea {
    protected z: NgZone;
    /** Event is thrown when the user changes the content of the textarea. @example change-events*/
    valueChange: EventEmitter<CustomEvent<string>>;
    /** Event is thrown when the user checks the input. Event is triggered when the user presses Return or
  leaves the textarea. @example change-events*/
    valueComplete: EventEmitter<CustomEvent<string>>;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DxTextArea, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DxTextArea, "dx-text-area", never, { "disabled": "disabled"; "errormessage": "errormessage"; "kisynced": "kisynced"; "label": "label"; "lines": "lines"; "maxlength": "maxlength"; "placeholder": "placeholder"; "readonly": "readonly"; "required": "required"; "value": "value"; }, { "valueChange": "valueChange"; "valueComplete": "valueComplete"; }, never, ["*"], false>;
}
import { TextInputAutocompleteController as IDxTextInputTextInputAutocompleteController } from '@dvag/design-system/dist/types/new/form/dx-text-input/dx-text-input';
export declare interface DxTextInput extends Components.DxTextInput {
}
export declare class DxTextInput {
    protected z: NgZone;
    /** Emits this event when the user changes the value of this input. @example change-events*/
    valueChange: EventEmitter<CustomEvent<string>>;
    /** This event is emitted when the user accepts the value.
  The user accepts the value by pressing the Enter key or when the user leave the input. @example change-events*/
    valueComplete: EventEmitter<CustomEvent<string>>;
    /** This event is fired, when the user fills out this input.
  The event paylod contains an controller which can be used to submit autocomplete options. @example autocomplete-plz*/
    autocomplete: EventEmitter<CustomEvent<IDxTextInputTextInputAutocompleteController>>;
    /** This event is fired when the user selects an autocomplete options from the list.
  The event payload contains the `data` of the selected AutoCompleteOption. @example autocomplete-plz-ort*/
    selectAutocomplete: EventEmitter<CustomEvent<any>>;
    /** Trigger when the user presses the "Enter" key while editing the input field. @example enter-press*/
    enterPress: EventEmitter<CustomEvent<void>>;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DxTextInput, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DxTextInput, "dx-text-input", never, { "disabled": "disabled"; "errormessage": "errormessage"; "icon": "icon"; "kisynced": "kisynced"; "label": "label"; "limitlength": "limitlength"; "placeholder": "placeholder"; "readonly": "readonly"; "required": "required"; "size": "size"; "value": "value"; }, { "valueChange": "valueChange"; "valueComplete": "valueComplete"; "autocomplete": "autocomplete"; "selectAutocomplete": "selectAutocomplete"; "enterPress": "enterPress"; }, never, ["*"], false>;
}
export declare interface DxTextList extends Components.DxTextList {
}
export declare class DxTextList {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DxTextList, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DxTextList, "dx-text-list", never, { "type": "type"; }, {}, never, ["*"], false>;
}
export declare interface DxToggle extends Components.DxToggle {
}
export declare class DxToggle {
    protected z: NgZone;
    /** Emits this event when the user changes the value of this input. @example checked-change*/
    checkedChange: EventEmitter<CustomEvent<boolean>>;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DxToggle, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DxToggle, "dx-toggle", never, { "checked": "checked"; "disabled": "disabled"; }, { "checkedChange": "checkedChange"; }, never, ["*"], false>;
}
export declare interface DxUserAvatar extends Components.DxUserAvatar {
}
export declare class DxUserAvatar {
    protected z: NgZone;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DxUserAvatar, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DxUserAvatar, "dx-user-avatar", never, { "imageurl": "imageurl"; "initials": "initials"; "size": "size"; }, {}, never, ["*"], false>;
}
export declare interface DxWizard extends Components.DxWizard {
}
export declare class DxWizard {
    protected z: NgZone;
    /** Fires when the `currentstep` property value changes. @example current-step*/
    currentStepChange: EventEmitter<CustomEvent<string>>;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DxWizard, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DxWizard, "dx-wizard", never, { "currentstep": "currentstep"; "expandedlayoutat": "expandedlayoutat"; "headline": "headline"; "orientation": "orientation"; }, { "currentStepChange": "currentStepChange"; }, never, ["*"], false>;
}
export declare interface DxWizardStep extends Components.DxWizardStep {
}
export declare class DxWizardStep {
    protected z: NgZone;
    /** Fires when the user interacts with this step. @example interaction*/
    interaction: EventEmitter<CustomEvent<void>>;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DxWizardStep, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DxWizardStep, "dx-wizard-step", never, { "finished": "finished"; "label": "label"; "value": "value"; }, { "interaction": "interaction"; }, never, ["*"], false>;
}
export declare interface DxYesNo extends Components.DxYesNo {
}
export declare class DxYesNo {
    protected z: NgZone;
    /** Emits this event when the user changes the value of this input. @example value-change*/
    valueChange: EventEmitter<CustomEvent<string>>;
    protected el: HTMLElement;
    constructor(c: ChangeDetectorRef, r: ElementRef, z: NgZone);
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<DxYesNo, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDeclaration<DxYesNo, "dx-yes-no", never, { "disabled": "disabled"; "errormessage": "errormessage"; "size": "size"; "value": "value"; }, { "valueChange": "valueChange"; }, never, ["*"], false>;
}

//# sourceMappingURL=proxies.d.ts.map